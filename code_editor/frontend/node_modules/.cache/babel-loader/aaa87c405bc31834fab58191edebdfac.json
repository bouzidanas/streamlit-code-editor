{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ITERATOR_DONE } from '../io/interfaces';\n/** @ignore */\nconst invalidMessageType = type => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */\nconst nullMessage = type => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */\nconst invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */\nconst invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n/** @ignore */\nexport class MessageReader {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    let r;\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  readMessage(type) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n    return r.value;\n  }\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n    return (/* 1. */buf.byteOffset % 8 === 0 && /* 2. */buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n  readSchema() {\n    let throwIfNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n    return schema;\n  }\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n}\n/** @ignore */\nexport class AsyncMessageReader {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  async next() {\n    let r;\n    if ((r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n    if (r.value === -1 && (r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = await this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  async throw(value) {\n    return await this.source.throw(value);\n  }\n  async return(value) {\n    return await this.source.return(value);\n  }\n  async readMessage(type) {\n    let r;\n    if ((r = await this.next()).done) {\n      return null;\n    }\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n    return r.value;\n  }\n  async readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(await this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n    return (/* 1. */buf.byteOffset % 8 === 0 && /* 2. */buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()\n    );\n  }\n  async readSchema() {\n    let throwIfNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const type = MessageHeader.Schema;\n    const message = await this.readMessage(type);\n    const schema = message && message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n    return schema;\n  }\n  async readMetadataLength() {\n    const buf = await this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n  async readMetadata(metadataLength) {\n    const buf = await this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n}\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n  next() {\n    const {\n      _json\n    } = this;\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n      return {\n        done: false,\n        value: message\n      };\n    }\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch['data']['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column) => [...buffers, ...(column['VALIDITY'] && [column['VALIDITY']] || []), ...(column['TYPE'] && [column['TYPE']] || []), ...(column['OFFSET'] && [column['OFFSET']] || []), ...(column['DATA'] && [column['DATA']] || []), ...flattenDataSources(column['children'])], []);\n    }\n  }\n  readMessage(type) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n    return r.value;\n  }\n  readSchema() {\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n    if (!message || !schema) {\n      throw new Error(nullMessage(type));\n    }\n    return schema;\n  }\n}\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n  MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n/** @ignore */\nexport function checkForMagicArrowString(buffer) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  for (let i = -1, n = MAGIC.length; ++i < n;) {\n    if (MAGIC[i] !== buffer[index + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;","map":{"version":3,"mappings":"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","names":["MessageHeader","flatbuffers","ByteBuffer","Message","isFileHandle","AsyncRandomAccessFile","toUint8Array","ByteStream","AsyncByteStream","ArrowJSON","ITERATOR_DONE","invalidMessageType","type","nullMessage","invalidMessageMetadata","expected","actual","invalidMessageBodyLength","MessageReader","constructor","source","Symbol","iterator","next","r","readMetadataLength","done","value","readMetadata","throw","return","readMessage","headerType","Error","readMessageBody","bodyLength","Uint8Array","buf","read","byteLength","byteOffset","buffer","slice","readSchema","throwIfNull","Schema","message","schema","header","PADDING","bb","len","readInt32","metadataLength","decode","AsyncMessageReader","asyncIterator","JSONMessageReader","_json","_schema","fromJSON","_dictionaryIndex","dictionaries","length","batch","_body","DictionaryBatch","_batchIndex","batches","RecordBatch","_bodyLength","flattenDataSources","xs","reduce","buffers","column","MAGIC_STR","MAGIC","i","charCodeAt","checkForMagicArrowString","index","n","magicLength","magicAndPadding","magicX2AndPadding"],"sources":["ipc/message.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nimport ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array, ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, ReadableSource, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ArrowJSONLike, ITERATOR_DONE, FileHandle } from '../io/interfaces';\n\n/** @ignore */ const invalidMessageType       = (type: MessageHeader) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */ const nullMessage              = (type: MessageHeader) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */ const invalidMessageMetadata   = (expected: number, actual: number) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */ const invalidMessageBodyLength = (expected: number, actual: number) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\n/** @ignore */\nexport class MessageReader implements IterableIterator<Message> {\n    protected source: ByteStream;\n    constructor(source: ByteStream | ArrayBufferViewInput | Iterable<ArrayBufferViewInput>) {\n        this.source = source instanceof ByteStream ? source : new ByteStream(source);\n    }\n    public [Symbol.iterator](): IterableIterator<Message> { return this as IterableIterator<Message>; }\n    public next(): IteratorResult<Message> {\n        let r;\n        if ((r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public throw(value?: any) { return this.source.throw(value); }\n    public return(value?: any) { return this.source.return(value); }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readMessageBody(bodyLength: number): Uint8Array {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected readMetadataLength(): IteratorResult<number> {\n        const buf = this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected readMetadata(metadataLength: number): IteratorResult<Message> {\n        const buf = this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class AsyncMessageReader implements AsyncIterableIterator<Message> {\n    protected source: AsyncByteStream;\n    constructor(source: ReadableSource<Uint8Array>);\n    constructor(source: FileHandle, byteLength?: number);\n    constructor(source: any, byteLength?: number) {\n        this.source = source instanceof AsyncByteStream ? source\n            : isFileHandle(source)\n            ? new AsyncRandomAccessFile(source, byteLength!)\n            : new AsyncByteStream(source);\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<Message> { return this as AsyncIterableIterator<Message>; }\n    public async next(): Promise<IteratorResult<Message>> {\n        let r;\n        if ((r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = await this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public async throw(value?: any) { return await this.source.throw(value); }\n    public async return(value?: any) { return await this.source.return(value); }\n    public async readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = await this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public async readMessageBody(bodyLength: number): Promise<Uint8Array> {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(await this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public async readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = await this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected async readMetadataLength(): Promise<IteratorResult<number>> {\n        const buf = await this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected async readMetadata(metadataLength: number): Promise<IteratorResult<Message>> {\n        const buf = await this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n    private _schema = false;\n    private _json: ArrowJSON;\n    private _body: any[] = [];\n    private _batchIndex = 0;\n    private _dictionaryIndex = 0;\n    constructor(source: ArrowJSON | ArrowJSONLike) {\n        super(new Uint8Array(0));\n        this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n    }\n    public next() {\n        const { _json } = this;\n        if (!this._schema) {\n            this._schema = true;\n            const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n            return { done: false, value: message };\n        }\n        if (this._dictionaryIndex < _json.dictionaries.length) {\n            const batch = _json.dictionaries[this._dictionaryIndex++];\n            this._body = batch['data']['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n            return { done: false, value: message };\n        }\n        if (this._batchIndex < _json.batches.length) {\n            const batch = _json.batches[this._batchIndex++];\n            this._body = batch['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n            return { done: false, value: message };\n        }\n        this._body = [];\n        return ITERATOR_DONE;\n    }\n    public readMessageBody(_bodyLength?: number) {\n        return flattenDataSources(this._body) as any;\n        function flattenDataSources(xs: any[]): any[][] {\n            return (xs || []).reduce<any[][]>((buffers, column: any) => [\n                ...buffers,\n                ...(column['VALIDITY'] && [column['VALIDITY']] || []),\n                ...(column['TYPE'] && [column['TYPE']] || []),\n                ...(column['OFFSET'] && [column['OFFSET']] || []),\n                ...(column['DATA'] && [column['DATA']] || []),\n                ...flattenDataSources(column['children'])\n            ], [] as any[][]);\n        }\n    }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readSchema() {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (!message || !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n}\n\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\n\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n    MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n\n/** @ignore */\nexport function checkForMagicArrowString(buffer: Uint8Array, index = 0) {\n    for (let i = -1, n = MAGIC.length; ++i < n;) {\n        if (MAGIC[i] !== buffer[index + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;\n"]},"metadata":{},"sourceType":"module"}