{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Visitor } from './visitor';\nimport { Schema } from './schema';\nimport { isIterable } from './util/compat';\nimport { Chunked } from './vector/chunked';\nimport { selectFieldArgs } from './util/args';\nimport { DataType, Struct } from './type';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { StructVector } from './vector/index';\nexport class RecordBatch extends StructVector {\n  constructor() {\n    let data;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    let schema = args[0];\n    let children;\n    if (args[1] instanceof Data) {\n      [, data, children] = args;\n    } else {\n      const fields = schema.fields;\n      const [, length, childData] = args;\n      data = Data.Struct(new Struct(fields), 0, length, 0, null, childData);\n    }\n    super(data, children);\n    this._schema = schema;\n  }\n  /** @nocollapse */\n  static from(options) {\n    if (isIterable(options['values'])) {\n      return Table.from(options);\n    }\n    return Table.from(options);\n  }\n  /** @nocollapse */\n  static new() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const [fs, xs] = selectFieldArgs(args);\n    const vs = xs.filter(x => x instanceof Vector);\n    return new RecordBatch(...ensureSameLengthData(new Schema(fs), vs.map(x => x.data)));\n  }\n  clone(data) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._children;\n    return new RecordBatch(this._schema, data, children);\n  }\n  concat() {\n    for (var _len3 = arguments.length, others = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      others[_key3] = arguments[_key3];\n    }\n    const schema = this._schema,\n      chunks = Chunked.flatten(this, ...others);\n    return new Table(schema, chunks.map(_ref => {\n      let {\n        data\n      } = _ref;\n      return new RecordBatch(schema, data);\n    }));\n  }\n  get schema() {\n    return this._schema;\n  }\n  get numCols() {\n    return this._schema.fields.length;\n  }\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\n  }\n  select() {\n    const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());\n    for (var _len4 = arguments.length, columnNames = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      columnNames[_key4] = arguments[_key4];\n    }\n    return this.selectAt(...columnNames.map(columnName => nameToIndex.get(columnName)).filter(x => x > -1));\n  }\n  selectAt() {\n    for (var _len5 = arguments.length, columnIndices = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      columnIndices[_key5] = arguments[_key5];\n    }\n    const schema = this._schema.selectAt(...columnIndices);\n    const childData = columnIndices.map(i => this.data.childData[i]).filter(Boolean);\n    return new RecordBatch(schema, this.length, childData);\n  }\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\n/* tslint:disable:class-name */\nexport class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {\n  constructor(schema) {\n    super(schema, 0, schema.fields.map(f => Data.new(f.type, 0, 0, 0)));\n  }\n}\n/** @ignore */\nclass DictionaryCollector extends Visitor {\n  constructor() {\n    super(...arguments);\n    this.dictionaries = new Map();\n  }\n  static collect(batch) {\n    return new DictionaryCollector().visit(batch.data, new Struct(batch.schema.fields)).dictionaries;\n  }\n  visit(data, type) {\n    if (DataType.isDictionary(type)) {\n      return this.visitDictionary(data, type);\n    } else {\n      data.childData.forEach((child, i) => this.visit(child, type.children[i].type));\n    }\n    return this;\n  }\n  visitDictionary(data, type) {\n    const dictionary = data.dictionary;\n    if (dictionary && dictionary.length > 0) {\n      this.dictionaries.set(type.id, dictionary);\n    }\n    return this;\n  }\n}","map":{"version":3,"names":["Data","Table","Vector","Visitor","Schema","isIterable","Chunked","selectFieldArgs","DataType","Struct","ensureSameLengthData","StructVector","RecordBatch","constructor","data","_len","arguments","length","args","Array","_key","schema","children","fields","childData","_schema","from","options","new","_len2","_key2","fs","xs","vs","filter","x","map","clone","undefined","_children","concat","_len3","others","_key3","chunks","flatten","_ref","numCols","dictionaries","_dictionaries","DictionaryCollector","collect","select","nameToIndex","reduce","m","f","i","set","name","Map","_len4","columnNames","_key4","selectAt","columnName","get","_len5","columnIndices","_key5","Boolean","_InternalEmptyPlaceholderRecordBatch","type","batch","visit","isDictionary","visitDictionary","forEach","child","dictionary","id"],"sources":["recordbatch.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Visitor } from './visitor';\nimport { Schema, Field } from './schema';\nimport { isIterable } from './util/compat';\nimport { Chunked } from './vector/chunked';\nimport { selectFieldArgs } from './util/args';\nimport { DataType, Struct, Dictionary } from './type';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { Clonable, Sliceable, Applicative } from './vector';\nimport { StructVector, VectorBuilderOptions, VectorBuilderOptionsAsync } from './vector/index';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = (Data<T[keyof T]> | Vector<T[keyof T]>)[];\n\nexport interface RecordBatch<T extends { [key: string]: DataType } = any> {\n    concat(...others: Vector<Struct<T>>[]): Table<T>;\n    slice(begin?: number, end?: number): RecordBatch<T>;\n    clone(data: Data<Struct<T>>, children?: Vector[]): RecordBatch<T>;\n}\n\nexport class RecordBatch<T extends { [key: string]: DataType } = any>\n    extends StructVector<T>\n    implements Clonable<RecordBatch<T>>,\n               Sliceable<RecordBatch<T>>,\n               Applicative<Struct<T>, Table<T>> {\n\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull>): Table<T>;\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptionsAsync<Struct<T>, TNull>): Promise<Table<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull> | VectorBuilderOptionsAsync<Struct<T>, TNull>) {\n        if (isIterable<(Struct<T>)['TValue'] | TNull>(options['values'])) {\n            return Table.from(options as VectorBuilderOptions<Struct<T>, TNull>);\n        }\n        return Table.from(options as VectorBuilderOptionsAsync<Struct<T>, TNull>);\n    }\n\n    public static new<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\n    /** @nocollapse */\n    public static new<T extends { [key: string]: DataType } = any>(...args: any[]) {\n        const [fs, xs] = selectFieldArgs<T>(args);\n        const vs = xs.filter((x): x is Vector<T[keyof T]> => x instanceof Vector);\n        return new RecordBatch(...ensureSameLengthData(new Schema<T>(fs), vs.map((x) => x.data)));\n    }\n\n    protected _schema: Schema;\n    protected _dictionaries?: Map<number, Vector>;\n\n    constructor(schema: Schema<T>, length: number, children: (Data | Vector)[]);\n    constructor(schema: Schema<T>, data: Data<Struct<T>>, children?: Vector[]);\n    constructor(...args: any[]) {\n        let data: Data<Struct<T>>;\n        let schema = args[0] as Schema<T>;\n        let children: Vector[] | undefined;\n        if (args[1] instanceof Data) {\n            [, data, children] = (args as [any, Data<Struct<T>>, Vector<T[keyof T]>[]?]);\n        } else {\n            const fields = schema.fields as Field<T[keyof T]>[];\n            const [, length, childData] = args as [any, number, Data<T[keyof T]>[]];\n            data = Data.Struct(new Struct<T>(fields), 0, length, 0, null, childData);\n        }\n        super(data, children);\n        this._schema = schema;\n    }\n\n    public clone(data: Data<Struct<T>>, children = this._children) {\n        return new RecordBatch<T>(this._schema, data, children);\n    }\n\n    public concat(...others: Vector<Struct<T>>[]): Table<T> {\n        const schema = this._schema, chunks = Chunked.flatten(this, ...others);\n        return new Table(schema, chunks.map(({ data }) => new RecordBatch(schema, data)));\n    }\n\n    public get schema() { return this._schema; }\n    public get numCols() { return this._schema.fields.length; }\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        const schema = this._schema.selectAt(...columnIndices);\n        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);\n        return new RecordBatch<{ [key: string]: K }>(schema, this.length, childData);\n    }\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\n/* tslint:disable:class-name */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends { [key: string]: DataType } = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        super(schema, 0, schema.fields.map((f) => Data.new(f.type, 0, 0, 0)));\n    }\n}\n\n/** @ignore */\nclass DictionaryCollector extends Visitor {\n    public dictionaries = new Map<number, Vector>();\n    public static collect<T extends RecordBatch>(batch: T) {\n        return new DictionaryCollector().visit(\n            batch.data, new Struct(batch.schema.fields)\n        ).dictionaries;\n    }\n    public visit(data: Data, type: DataType) {\n        if (DataType.isDictionary(type)) {\n            return this.visitDictionary(data, type);\n        } else {\n            data.childData.forEach((child, i) =>\n                this.visit(child, type.children[i].type));\n        }\n        return this;\n    }\n    public visitDictionary(data: Data, type: Dictionary) {\n        const dictionary = data.dictionary;\n        if (dictionary && dictionary.length > 0) {\n            this.dictionaries.set(type.id, dictionary);\n        }\n        return this;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}