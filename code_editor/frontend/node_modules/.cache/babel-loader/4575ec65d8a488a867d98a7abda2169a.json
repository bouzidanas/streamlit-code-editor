{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Visitor } from '../visitor';\nimport { UnionMode } from '../enum';\nimport { RecordBatch } from '../recordbatch';\nimport { rebaseValueOffsets } from '../util/buffer';\nimport { packBools, truncateBitmap } from '../util/bit';\nimport { selectVectorChildrenArgs } from '../util/args';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message';\nimport { DataType } from '../type';\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n  constructor() {\n    super();\n    this._byteLength = 0;\n    this._nodes = [];\n    this._buffers = [];\n    this._bufferRegions = [];\n  }\n  /** @nocollapse */\n  static assemble() {\n    const assembler = new VectorAssembler();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const vectorChildren = selectVectorChildrenArgs(RecordBatch, args);\n    const [assembleResult = assembler] = assembler.visitMany(vectorChildren);\n    return assembleResult;\n  }\n  visit(vector) {\n    if (!DataType.isDictionary(vector.type)) {\n      const {\n        data,\n        length,\n        nullCount\n      } = vector;\n      if (length > 2147483647) {\n        /* istanbul ignore next */\n        throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n      }\n      if (!DataType.isNull(vector.type)) {\n        addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) // placeholder validity buffer\n        : truncateBitmap(data.offset, length, data.nullBitmap));\n      }\n      this.nodes.push(new FieldNode(length, nullCount));\n    }\n    return super.visit(vector);\n  }\n  visitNull(_nullV) {\n    return this;\n  }\n  visitDictionary(vector) {\n    // Assemble the indices here, Dictionary assembled separately.\n    return this.visit(vector.indices);\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get bufferRegions() {\n    return this._bufferRegions;\n  }\n}\n/** @ignore */\nfunction addBuffer(values) {\n  const byteLength = values.byteLength + 7 & ~7; // Round up to a multiple of 8\n  this.buffers.push(values);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\n/** @ignore */\nfunction assembleUnion(vector) {\n  const {\n    type,\n    length,\n    typeIds,\n    valueOffsets\n  } = vector;\n  // All Union Vectors have a typeIds buffer\n  addBuffer.call(this, typeIds);\n  // If this is a Sparse Union, treat it like all other Nested types\n  if (type.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, vector);\n  } else if (type.mode === UnionMode.Dense) {\n    // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n    if (vector.offset <= 0) {\n      // If the Vector hasn't been sliced, write the existing valueOffsets\n      addBuffer.call(this, valueOffsets);\n      // We can treat this like all other Nested types\n      return assembleNestedVector.call(this, vector);\n    } else {\n      // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n      // each child vector, we need to \"rebase\" the valueOffsets for each child\n      // Union typeIds are not necessary 0-indexed\n      const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\n      const childLengths = new Int32Array(maxChildTypeId + 1);\n      // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n      const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      const shiftedOffsets = new Int32Array(length);\n      // If we have a non-zero offset, then the value offsets do not start at\n      // zero. We must a) create a new offsets array with shifted offsets and\n      // b) slice the values array accordingly\n      const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n      for (let typeId, shift, index = -1; ++index < length;) {\n        if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n        shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n        ++childLengths[typeId];\n      }\n      addBuffer.call(this, shiftedOffsets);\n      // Slice and visit children accordingly\n      for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n        if (child = vector.getChildAt(childIndex)) {\n          const typeId = type.typeIds[childIndex];\n          const childLength = Math.min(length, childLengths[typeId]);\n          this.visit(child.slice(childOffsets[typeId], childLength));\n        }\n      }\n    }\n  }\n  return this;\n}\n/** @ignore */\nfunction assembleBoolVector(vector) {\n  // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n  let values;\n  if (vector.nullCount >= vector.length) {\n    // If all values are null, just insert a placeholder empty data buffer (fastest path)\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values = vector.values) instanceof Uint8Array) {\n    // If values is already a Uint8Array, slice the bitmap (fast path)\n    return addBuffer.call(this, truncateBitmap(vector.offset, vector.length, values));\n  }\n  // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n  // values as bools and re-pack them into a Uint8Array. This code isn't\n  // reachable unless you're trying to manipulate the Data internals,\n  // we we're only doing this for safety.\n  /* istanbul ignore next */\n  return addBuffer.call(this, packBools(vector));\n}\n/** @ignore */\nfunction assembleFlatVector(vector) {\n  return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));\n}\n/** @ignore */\nfunction assembleFlatListVector(vector) {\n  const {\n    length,\n    values,\n    valueOffsets\n  } = vector;\n  const firstOffset = valueOffsets[0];\n  const lastOffset = valueOffsets[length];\n  const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\n  // Push in the order FlatList types read their buffers\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n  addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n  return this;\n}\n/** @ignore */\nfunction assembleListVector(vector) {\n  const {\n    length,\n    valueOffsets\n  } = vector;\n  // If we have valueOffsets (MapVector, ListVector), push that buffer first\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n  }\n  // Then insert the List's values child\n  return this.visit(vector.getChildAt(0));\n}\n/** @ignore */\nfunction assembleNestedVector(vector) {\n  return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;","map":{"version":3,"mappings":"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","names":["Visitor","UnionMode","RecordBatch","rebaseValueOffsets","packBools","truncateBitmap","selectVectorChildrenArgs","BufferRegion","FieldNode","DataType","VectorAssembler","constructor","assemble","assembler","args","vectorChildren","assembleResult","visitMany","visit","vector","isDictionary","type","data","length","nullCount","RangeError","isNull","addBuffer","call","Uint8Array","offset","nullBitmap","nodes","push","visitNull","_nullV","visitDictionary","indices","_nodes","buffers","_buffers","byteLength","_byteLength","bufferRegions","_bufferRegions","values","assembleUnion","typeIds","valueOffsets","mode","Sparse","assembleNestedVector","Dense","maxChildTypeId","reduce","x","y","Math","max","childLengths","Int32Array","childOffsets","fill","shiftedOffsets","unshiftedOffsets","typeId","shift","index","child","childIndex","numChildren","children","getChildAt","childLength","min","slice","assembleBoolVector","assembleFlatVector","subarray","stride","assembleFlatListVector","firstOffset","lastOffset","assembleListVector","map","_","i","filter","Boolean","prototype","visitBool","visitInt","visitFloat","visitUtf8","visitBinary","visitFixedSizeBinary","visitDate","visitTimestamp","visitTime","visitDecimal","visitList","visitStruct","visitUnion","visitInterval","visitFixedSizeList","visitMap"],"sources":["visitor/vectorassembler.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Vector } from '../vector';\nimport { Visitor } from '../visitor';\nimport { Type, UnionMode } from '../enum';\nimport { RecordBatch } from '../recordbatch';\nimport { VectorType as V } from '../interfaces';\nimport { rebaseValueOffsets } from '../util/buffer';\nimport { packBools, truncateBitmap } from '../util/bit';\nimport { selectVectorChildrenArgs } from '../util/args';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message';\nimport {\n    DataType, Dictionary,\n    Float, Int, Date_, Interval, Time, Timestamp, Union,\n    Bool, Null, Utf8, Binary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct,\n} from '../type';\n\n/** @ignore */\nexport interface VectorAssembler extends Visitor {\n    visit<T extends Vector>(node: T): this;\n    visitMany<T extends Vector>(nodes: T[]): this[];\n    getVisitFn<T extends Type>(node: T): (vector: V<T>) => this;\n    getVisitFn<T extends DataType>(node: V<T> | Data<T> | T): (vector: V<T>) => this;\n\n    visitBool                 <T extends Bool>            (vector: V<T>): this;\n    visitInt                  <T extends Int>             (vector: V<T>): this;\n    visitFloat                <T extends Float>           (vector: V<T>): this;\n    visitUtf8                 <T extends Utf8>            (vector: V<T>): this;\n    visitBinary               <T extends Binary>          (vector: V<T>): this;\n    visitFixedSizeBinary      <T extends FixedSizeBinary> (vector: V<T>): this;\n    visitDate                 <T extends Date_>           (vector: V<T>): this;\n    visitTimestamp            <T extends Timestamp>       (vector: V<T>): this;\n    visitTime                 <T extends Time>            (vector: V<T>): this;\n    visitDecimal              <T extends Decimal>         (vector: V<T>): this;\n    visitList                 <T extends List>            (vector: V<T>): this;\n    visitStruct               <T extends Struct>          (vector: V<T>): this;\n    visitUnion                <T extends Union>           (vector: V<T>): this;\n    visitInterval             <T extends Interval>        (vector: V<T>): this;\n    visitFixedSizeList        <T extends FixedSizeList>   (vector: V<T>): this;\n    visitMap                  <T extends Map_>            (vector: V<T>): this;\n}\n\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n\n    /** @nocollapse */\n    public static assemble<T extends Vector | RecordBatch>(...args: (T | T[])[]) {\n        const assembler = new VectorAssembler();\n        const vectorChildren = selectVectorChildrenArgs(RecordBatch, args);\n        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);\n        return assembleResult;\n    }\n\n    private constructor() { super(); }\n\n    public visit<T extends Vector>(vector: T): this {\n        if (!DataType.isDictionary(vector.type)) {\n            const { data, length, nullCount } = vector;\n            if (length > 2147483647) {\n                /* istanbul ignore next */\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n            }\n            if (!DataType.isNull(vector.type)) {\n                addBuffer.call(this, nullCount <= 0\n                    ? new Uint8Array(0) // placeholder validity buffer\n                    : truncateBitmap(data.offset, length, data.nullBitmap)\n                );\n            }\n            this.nodes.push(new FieldNode(length, nullCount));\n        }\n        return super.visit(vector);\n    }\n\n    public visitNull<T extends Null>(_nullV: V<T>) {\n        return this;\n    }\n    public visitDictionary<T extends Dictionary>(vector: V<T>) {\n        // Assemble the indices here, Dictionary assembled separately.\n        return this.visit(vector.indices);\n    }\n\n    public get nodes() { return this._nodes; }\n    public get buffers() { return this._buffers; }\n    public get byteLength() { return this._byteLength; }\n    public get bufferRegions() { return this._bufferRegions; }\n\n    protected _byteLength = 0;\n    protected _nodes: FieldNode[] = [];\n    protected _buffers: ArrayBufferView[] = [];\n    protected _bufferRegions: BufferRegion[] = [];\n}\n\n/** @ignore */\nfunction addBuffer(this: VectorAssembler, values: ArrayBufferView) {\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\n    this.buffers.push(values);\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n    this._byteLength += byteLength;\n    return this;\n}\n\n/** @ignore */\nfunction assembleUnion<T extends Union>(this: VectorAssembler, vector: V<T>) {\n    const { type, length, typeIds, valueOffsets } = vector;\n    // All Union Vectors have a typeIds buffer\n    addBuffer.call(this, typeIds);\n    // If this is a Sparse Union, treat it like all other Nested types\n    if (type.mode === UnionMode.Sparse) {\n        return assembleNestedVector.call(this, vector);\n    } else if (type.mode === UnionMode.Dense) {\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n        if (vector.offset <= 0) {\n            // If the Vector hasn't been sliced, write the existing valueOffsets\n            addBuffer.call(this, valueOffsets);\n            // We can treat this like all other Nested types\n            return assembleNestedVector.call(this, vector);\n        } else {\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\n            // Union typeIds are not necessary 0-indexed\n            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\n            const childLengths = new Int32Array(maxChildTypeId + 1);\n            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n            const shiftedOffsets = new Int32Array(length);\n            // If we have a non-zero offset, then the value offsets do not start at\n            // zero. We must a) create a new offsets array with shifted offsets and\n            // b) slice the values array accordingly\n            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n            for (let typeId, shift, index = -1; ++index < length;) {\n                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n                }\n                shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n                ++childLengths[typeId];\n            }\n            addBuffer.call(this, shiftedOffsets);\n            // Slice and visit children accordingly\n            for (let child: Vector | null, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n                if (child = vector.getChildAt(childIndex)) {\n                    const typeId = type.typeIds[childIndex];\n                    const childLength = Math.min(length, childLengths[typeId]);\n                    this.visit(child.slice(childOffsets[typeId], childLength));\n                }\n            }\n        }\n    }\n    return this;\n}\n\n/** @ignore */\nfunction assembleBoolVector<T extends Bool>(this: VectorAssembler, vector: V<T>) {\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n    let values: Uint8Array;\n    if (vector.nullCount >= vector.length) {\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\n        return addBuffer.call(this, new Uint8Array(0));\n    } else if ((values = vector.values) instanceof Uint8Array) {\n        // If values is already a Uint8Array, slice the bitmap (fast path)\n        return addBuffer.call(this, truncateBitmap(vector.offset, vector.length, values));\n    }\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n    // values as bools and re-pack them into a Uint8Array. This code isn't\n    // reachable unless you're trying to manipulate the Data internals,\n    // we we're only doing this for safety.\n    /* istanbul ignore next */\n    return addBuffer.call(this, packBools(vector));\n}\n\n/** @ignore */\nfunction assembleFlatVector<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval>(this: VectorAssembler, vector: V<T>) {\n    return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));\n}\n\n/** @ignore */\nfunction assembleFlatListVector<T extends Utf8 | Binary>(this: VectorAssembler, vector: V<T>) {\n    const { length, values, valueOffsets } = vector;\n    const firstOffset = valueOffsets[0];\n    const lastOffset = valueOffsets[length];\n    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\n    // Push in the order FlatList types read their buffers\n    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n    return this;\n}\n\n/** @ignore */\nfunction assembleListVector<T extends Map_ | List | FixedSizeList>(this: VectorAssembler, vector: V<T>) {\n    const { length, valueOffsets } = vector;\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\n    if (valueOffsets) {\n        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n    }\n    // Then insert the List's values child\n    return this.visit(vector.getChildAt(0)!);\n}\n\n/** @ignore */\nfunction assembleNestedVector<T extends Struct | Union>(this: VectorAssembler, vector: V<T>) {\n    return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)!).filter(Boolean))[0];\n}\n\nVectorAssembler.prototype.visitBool            =     assembleBoolVector;\nVectorAssembler.prototype.visitInt             =     assembleFlatVector;\nVectorAssembler.prototype.visitFloat           =     assembleFlatVector;\nVectorAssembler.prototype.visitUtf8            = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary          = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary =     assembleFlatVector;\nVectorAssembler.prototype.visitDate            =     assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp       =     assembleFlatVector;\nVectorAssembler.prototype.visitTime            =     assembleFlatVector;\nVectorAssembler.prototype.visitDecimal         =     assembleFlatVector;\nVectorAssembler.prototype.visitList            =     assembleListVector;\nVectorAssembler.prototype.visitStruct          =   assembleNestedVector;\nVectorAssembler.prototype.visitUnion           =          assembleUnion;\nVectorAssembler.prototype.visitInterval        =     assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList   =     assembleListVector;\nVectorAssembler.prototype.visitMap             =     assembleListVector;\n"]},"metadata":{},"sourceType":"module"}