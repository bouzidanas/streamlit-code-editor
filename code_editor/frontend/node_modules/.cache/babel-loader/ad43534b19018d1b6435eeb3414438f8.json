{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Type } from '../enum';\nimport { Chunked } from './chunked';\nimport { clampRange } from '../util/vector';\nimport { AbstractVector, Vector } from '../vector';\n/** @ignore */\nexport class BaseVector extends AbstractVector {\n  constructor(data, children) {\n    super();\n    this._children = children;\n    this.numChildren = data.childData.length;\n    this._bindDataAccessors(this.data = data);\n  }\n  get type() {\n    return this.data.type;\n  }\n  get typeId() {\n    return this.data.typeId;\n  }\n  get length() {\n    return this.data.length;\n  }\n  get offset() {\n    return this.data.offset;\n  }\n  get stride() {\n    return this.data.stride;\n  }\n  get nullCount() {\n    return this.data.nullCount;\n  }\n  get byteLength() {\n    return this.data.byteLength;\n  }\n  get VectorName() {\n    return \"\".concat(Type[this.typeId], \"Vector\");\n  }\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n  get values() {\n    return this.data.values;\n  }\n  get typeIds() {\n    return this.data.typeIds;\n  }\n  get nullBitmap() {\n    return this.data.nullBitmap;\n  }\n  get valueOffsets() {\n    return this.data.valueOffsets;\n  }\n  get [Symbol.toStringTag]() {\n    return \"\".concat(this.VectorName, \"<\").concat(this.type[Symbol.toStringTag], \">\");\n  }\n  clone(data) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._children;\n    return Vector.new(data, children);\n  }\n  concat() {\n    for (var _len = arguments.length, others = new Array(_len), _key = 0; _key < _len; _key++) {\n      others[_key] = arguments[_key];\n    }\n    return Chunked.concat(this, ...others);\n  }\n  slice(begin, end) {\n    // Adjust args similar to Array.prototype.slice. Normalize begin/end to\n    // clamp between 0 and length, and wrap around on negative indices, e.g.\n    // slice(-1, 5) or slice(5, -1)\n    return clampRange(this, begin, end, this._sliceInternal);\n  }\n  isValid(index) {\n    if (this.nullCount > 0) {\n      const idx = this.offset + index;\n      const val = this.nullBitmap[idx >> 3];\n      const mask = val & 1 << idx % 8;\n      return mask !== 0;\n    }\n    return true;\n  }\n  getChildAt(index) {\n    return index < 0 || index >= this.numChildren ? null : (this._children || (this._children = []))[index] || (this._children[index] = Vector.new(this.data.childData[index]));\n  }\n  toJSON() {\n    return [...this];\n  }\n  _sliceInternal(self, begin, end) {\n    return self.clone(self.data.slice(begin, end - begin), null);\n  }\n  // @ts-ignore\n  _bindDataAccessors(data) {\n    // Implementation in src/vectors/index.ts due to circular dependency/packaging shenanigans\n  }\n}\nBaseVector.prototype[Symbol.isConcatSpreadable] = true;","map":{"version":3,"names":["Type","Chunked","clampRange","AbstractVector","Vector","BaseVector","constructor","data","children","_children","numChildren","childData","length","_bindDataAccessors","type","typeId","offset","stride","nullCount","byteLength","VectorName","concat","ArrayType","values","typeIds","nullBitmap","valueOffsets","Symbol","toStringTag","clone","arguments","undefined","new","_len","others","Array","_key","slice","begin","end","_sliceInternal","isValid","index","idx","val","mask","getChildAt","toJSON","self","prototype","isConcatSpreadable"],"sources":["vector/base.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Type } from '../enum';\nimport { DataType } from '../type';\nimport { Chunked } from './chunked';\nimport { clampRange } from '../util/vector';\nimport { VectorType as V } from '../interfaces';\nimport { AbstractVector, Vector, Clonable, Sliceable, Applicative } from '../vector';\n\n/** @ignore */\nexport interface BaseVector<T extends DataType = any> extends Clonable<V<T>>, Sliceable<V<T>>, Applicative<T, Chunked<T>> {\n    slice(begin?: number, end?: number): V<T>;\n    concat(...others: Vector<T>[]): Chunked<T>;\n    clone<R extends DataType = T>(data: Data<R>, children?: Vector<R>[]): V<R>;\n}\n\n/** @ignore */\nexport abstract class BaseVector<T extends DataType = any> extends AbstractVector<T>\n    implements Clonable<V<T>>, Sliceable<V<T>>, Applicative<T, Chunked<T>> {\n\n    protected _children?: Vector[];\n\n    constructor(data: Data<T>, children?: Vector[]) {\n        super();\n        this._children = children;\n        this.numChildren = data.childData.length;\n        this._bindDataAccessors(this.data = data);\n    }\n\n    public readonly data: Data<T>;\n    public readonly numChildren: number;\n\n    public get type() { return this.data.type; }\n    public get typeId() { return this.data.typeId; }\n    public get length() { return this.data.length; }\n    public get offset() { return this.data.offset; }\n    public get stride() { return this.data.stride; }\n    public get nullCount() { return this.data.nullCount; }\n    public get byteLength() { return this.data.byteLength; }\n    public get VectorName() { return `${Type[this.typeId]}Vector`; }\n\n    public get ArrayType(): T['ArrayType'] { return this.type.ArrayType; }\n\n    public get values() { return this.data.values; }\n    public get typeIds() { return this.data.typeIds; }\n    public get nullBitmap() { return this.data.nullBitmap; }\n    public get valueOffsets() { return this.data.valueOffsets; }\n\n    public get [Symbol.toStringTag]() { return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`; }\n\n    public clone<R extends DataType = T>(data: Data<R>, children = this._children) {\n        return Vector.new<R>(data, children) as any;\n    }\n\n    public concat(...others: Vector<T>[]) {\n        return Chunked.concat<T>(this, ...others);\n    }\n\n    public slice(begin?: number, end?: number) {\n        // Adjust args similar to Array.prototype.slice. Normalize begin/end to\n        // clamp between 0 and length, and wrap around on negative indices, e.g.\n        // slice(-1, 5) or slice(5, -1)\n        return clampRange(this, begin, end, this._sliceInternal);\n    }\n\n    public isValid(index: number): boolean {\n        if (this.nullCount > 0) {\n            const idx = this.offset + index;\n            const val = this.nullBitmap[idx >> 3];\n            const mask = (val & (1 << (idx % 8)));\n            return mask !== 0;\n        }\n        return true;\n    }\n\n    public getChildAt<R extends DataType = any>(index: number): Vector<R> | null {\n        return index < 0 || index >= this.numChildren ? null : (\n            (this._children || (this._children = []))[index] ||\n            (this._children[index] = Vector.new<R>(this.data.childData[index] as Data<R>))\n        ) as Vector<R>;\n    }\n\n    public toJSON(): any { return [...this]; }\n\n    protected _sliceInternal(self: this, begin: number, end: number) {\n        return self.clone(self.data.slice(begin, end - begin), null!);\n    }\n\n    // @ts-ignore\n    protected _bindDataAccessors(data: Data<T>) {\n        // Implementation in src/vectors/index.ts due to circular dependency/packaging shenanigans\n    }\n}\n\n(BaseVector.prototype as any)[Symbol.isConcatSpreadable] = true;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}