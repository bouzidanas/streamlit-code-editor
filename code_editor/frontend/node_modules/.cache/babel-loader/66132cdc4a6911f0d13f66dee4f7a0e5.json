{"ast":null,"code":"ace.define(\"ace/mode/ruby_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var constantOtherSymbol = exports.constantOtherSymbol = {\n    token: \"constant.other.symbol.ruby\",\n    // symbol\n    regex: \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n  };\n  exports.qString = {\n    token: \"string\",\n    // single line\n    regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n  };\n  exports.qqString = {\n    token: \"string\",\n    // single line\n    regex: '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n  };\n  exports.tString = {\n    token: \"string\",\n    // backtick string\n    regex: \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n  };\n  var constantNumericHex = exports.constantNumericHex = {\n    token: \"constant.numeric\",\n    // hex\n    regex: \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n  };\n  var constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n  };\n  var constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n  };\n  var constantNumericOctal = exports.constantNumericOctal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n  };\n  var constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\",\n    //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n  };\n  var constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\",\n    //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n  };\n  var constantNumericFloat = exports.constantNumericFloat = {\n    token: \"constant.numeric\",\n    // float + complex\n    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n  };\n  var instanceVariable = exports.instanceVariable = {\n    token: \"variable.instance\",\n    // instance variable\n    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n  };\n  var RubyHighlightRules = function () {\n    var builtinFunctions = \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" + \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" + \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" + \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" + \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" + \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" + \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" + \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" + \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" + \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" + \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" + \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" + \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" + \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" + \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" + \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" + \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" + \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" + \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" + \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" + \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" + \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" + \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" + \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" + \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" + \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" + \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" + \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" + \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" + \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" + \"private_class_method|remove_method|undef_method\";\n    var keywords = \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" + \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" + \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\";\n    var buildinConstants = \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" + \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\";\n    var builtinVariables = \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" + \"$!|root_url|flash|session|cookies|params|request|response|logger|self\";\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"constant.language\": buildinConstants,\n      \"variable.language\": builtinVariables,\n      \"support.function\": builtinFunctions,\n      \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n    var closeParen = {\n      \"(\": \")\",\n      \"[\": \"]\",\n      \"{\": \"}\",\n      \"<\": \">\",\n      \"^\": \"^\",\n      \"|\": \"|\",\n      \"%\": \"%\"\n    };\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"#.*$\"\n      }, {\n        token: \"comment.multiline\",\n        // multi line comment\n        regex: \"^=begin(?=$|\\\\s.*$)\",\n        next: \"comment\"\n      }, {\n        token: \"string.regexp\",\n        regex: /[/](?=.*\\/)/,\n        next: \"regex\"\n      }, [{\n        token: [\"constant.other.symbol.ruby\", \"string.start\"],\n        regex: /(:)?(\")/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: escapedChars\n        }, {\n          token: \"paren.start\",\n          regex: /#{/,\n          push: \"start\"\n        }, {\n          token: \"string.end\",\n          regex: /\"/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string.start\",\n        regex: /`/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: escapedChars\n        }, {\n          token: \"paren.start\",\n          regex: /#{/,\n          push: \"start\"\n        }, {\n          token: \"string.end\",\n          regex: /`/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: [\"constant.other.symbol.ruby\", \"string.start\"],\n        regex: /(:)?(')/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: /\\\\['\\\\]/\n        }, {\n          token: \"string.end\",\n          regex: /'/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string.start\",\n        //doesn't see any differences between strings and array of strings in highlighting\n        regex: /%[qwx]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"qStateWithoutInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"string.start\",\n        //doesn't see any differences between strings and array of strings in highlighting\n        regex: /%[QWX]?([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"qStateWithInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        //doesn't see any differences between symbols and array of symbols in highlighting\n        regex: /%[si]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"sStateWithoutInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        //doesn't see any differences between symbols and array of symbols in highlighting\n        regex: /%[SI]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"sStateWithInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"string.regexp\",\n        regex: /%[r]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"rState\";\n          return this.token;\n        }\n      }], {\n        token: \"punctuation\",\n        // namespaces aren't symbols\n        regex: \"::\"\n      }, instanceVariable, {\n        token: \"variable.global\",\n        // global variable\n        regex: \"[$][a-zA-Z_\\\\d]+\"\n      }, {\n        token: \"support.class\",\n        // class name\n        regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n      }, {\n        token: [\"punctuation.operator\", \"support.function\"],\n        regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n      }, {\n        token: [\"punctuation.operator\", \"identifier\"],\n        regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n      }, {\n        token: \"string.character\",\n        regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n      }, {\n        token: \"punctuation.operator\",\n        regex: /\\?(?=.+:)/\n      }, constantNumericRational, constantNumericComplex, constantOtherSymbol, constantNumericHex, constantNumericFloat, constantNumericBinary, constantNumericDecimal, constantNumericOctal, {\n        token: \"constant.language.boolean\",\n        regex: \"(?:true|false)\\\\b\"\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n      }, {\n        token: \"punctuation.separator.key-value\",\n        regex: \"=>\"\n      }, {\n        stateName: \"heredoc\",\n        onMatch: function (value, currentState, stack) {\n          var next = value[2] == '-' || value[2] == '~' ? \"indentedHeredoc\" : \"heredoc\";\n          var tokens = value.split(this.splitRegex);\n          stack.push(next, tokens[3]);\n          return [{\n            type: \"constant\",\n            value: tokens[1]\n          }, {\n            type: \"string\",\n            value: tokens[2]\n          }, {\n            type: \"support.class\",\n            value: tokens[3]\n          }, {\n            type: \"string\",\n            value: tokens[4]\n          }];\n        },\n        regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n        rules: {\n          heredoc: [{\n            onMatch: function (value, currentState, stack) {\n              if (value === stack[1]) {\n                stack.shift();\n                stack.shift();\n                this.next = stack[0] || \"start\";\n                return \"support.class\";\n              }\n              this.next = \"\";\n              return \"string\";\n            },\n            regex: \".*$\",\n            next: \"start\"\n          }],\n          indentedHeredoc: [{\n            token: \"string\",\n            regex: \"^ +\"\n          }, {\n            onMatch: function (value, currentState, stack) {\n              if (value === stack[1]) {\n                stack.shift();\n                stack.shift();\n                this.next = stack[0] || \"start\";\n                return \"support.class\";\n              }\n              this.next = \"\";\n              return \"string\";\n            },\n            regex: \".*$\",\n            next: \"start\"\n          }]\n        }\n      }, {\n        regex: \"$\",\n        token: \"empty\",\n        next: function (currentState, stack) {\n          if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\") return stack[0];\n          return currentState;\n        }\n      }, {\n        token: \"keyword.operator\",\n        regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\])}]\",\n        onMatch: function (value, currentState, stack) {\n          this.next = '';\n          if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n            stack.shift();\n            this.next = stack.shift();\n          }\n          return this.token;\n        }\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+\"\n      }, {\n        token: \"punctuation.operator\",\n        regex: /[?:,;.]/\n      }],\n      \"comment\": [{\n        token: \"comment.multiline\",\n        // closing comment\n        regex: \"^=end(?=$|\\\\s.*$)\",\n        next: \"start\"\n      }, {\n        token: \"comment\",\n        // comment spanning whole line\n        regex: \".+\"\n      }],\n      \"qStateWithInterpolation\": [{\n        token: \"string.start\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"string\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: escapedChars\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"string.end\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"string\";\n        }\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"qStateWithoutInterpolation\": [{\n        token: \"string.start\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"string\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\['\\\\]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"string.end\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"string\";\n        }\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"sStateWithoutInterpolation\": [{\n        token: \"constant.other.symbol.ruby\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        defaultToken: \"constant.other.symbol.ruby\"\n      }],\n      \"sStateWithInterpolation\": [{\n        token: \"constant.other.symbol.ruby\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: escapedChars\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        defaultToken: \"constant.other.symbol.ruby\"\n      }],\n      \"rState\": [{\n        token: \"string.regexp\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"constant.language.escape\";\n        }\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"string.regexp\",\n        regex: /\\//\n      }, {\n        token: \"string.regexp\",\n        regex: /[)\\]>}^|%][imxouesn]*/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val[0] === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"constant.language.escape\";\n        }\n      }, {\n        include: \"regex\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex\": [{\n        token: \"regexp.keyword\",\n        regex: /\\\\[wWdDhHsS]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\[AGbBzZ]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\g<[a-zA-Z0-9]*>/\n      }, {\n        token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n        regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n      }, {\n        token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n        regex: /(\\\\p{\\^?)([^/]*)(})/\n      }, {\n        token: \"regexp.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"string.regexp\",\n        regex: /[/][imxouesn]*/,\n        next: \"start\"\n      }, {\n        token: \"invalid\",\n        regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n      }, {\n        token: \"constant.language.delimiter\",\n        regex: /\\|/\n      }, {\n        token: \"regexp.keyword\",\n        regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\[\\^?/,\n        push: \"regex_character_class\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex_character_class\": [{\n        token: \"regexp.keyword\",\n        regex: /\\\\[wWdDhHsS]/\n      }, {\n        token: \"regexp.charclass.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: /&?&?\\[\\^?/,\n        push: \"regex_character_class\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"]\",\n        next: \"pop\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"-\"\n      }, {\n        defaultToken: \"string.regexp.characterclass\"\n      }]\n    };\n    this.normalizeRules();\n  };\n  oop.inherits(RubyHighlightRules, TextHighlightRules);\n  exports.RubyHighlightRules = RubyHighlightRules;\n});\nace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  var MatchingBraceOutdent = function () {};\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/folding/ruby\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var TokenIterator = require(\"../../token_iterator\").TokenIterator;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.indentKeywords = {\n      \"class\": 1,\n      \"def\": 1,\n      \"module\": 1,\n      \"do\": 1,\n      \"unless\": 1,\n      \"if\": 1,\n      \"while\": 1,\n      \"for\": 1,\n      \"until\": 1,\n      \"begin\": 1,\n      \"else\": 0,\n      \"elsif\": 0,\n      \"rescue\": 0,\n      \"ensure\": 0,\n      \"when\": 0,\n      \"end\": -1,\n      \"case\": 1,\n      \"=begin\": 1,\n      \"=end\": -1\n    };\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var isStart = this.foldingStartMarker.test(line);\n      var isEnd = this.foldingStopMarker.test(line);\n      if (isStart && !isEnd) {\n        var match = line.match(this.foldingStartMarker);\n        if (match[1]) {\n          if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n            if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n              return;\n            }\n            if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n              return;\n            }\n          }\n          if (match[1] == \"when\") {\n            if (/\\sthen\\s/.test(line) === true) {\n              return;\n            }\n          }\n          if (session.getTokenAt(row, match.index + 2).type === \"keyword\") return \"start\";\n        } else if (match[3]) {\n          if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return \"start\";\n        } else {\n          return \"start\";\n        }\n      }\n      if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd) return \"\";\n      var match = line.match(this.foldingStopMarker);\n      if (match[3] === \"end\") {\n        if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"end\";\n      } else if (match[1]) {\n        if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return \"end\";\n      } else return \"end\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n      if (match) {\n        if (match[1] || match[3]) return this.rubyBlock(session, row, match.index + 2);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n      var match = this.foldingStopMarker.exec(line);\n      if (match) {\n        if (match[3] === \"end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return this.rubyBlock(session, row, match.index + 1);\n        }\n        if (match[1] === \"=end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return this.rubyBlock(session, row, match.index + 1);\n        }\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n    this.rubyBlock = function (session, row, column, tokenRange) {\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"keyword\" && token.type != \"comment.multiline\") return;\n      var val = token.value;\n      var line = session.getLine(row);\n      switch (token.value) {\n        case \"if\":\n        case \"unless\":\n        case \"while\":\n        case \"until\":\n          var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n          if (!checkToken.test(line)) {\n            return;\n          }\n          var dir = this.indentKeywords[val];\n          break;\n        case \"when\":\n          if (/\\sthen\\s/.test(line)) {\n            return;\n          }\n        case \"elsif\":\n        case \"rescue\":\n        case \"ensure\":\n          var dir = 1;\n          break;\n        case \"else\":\n          var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n          if (!checkToken.test(line)) {\n            return;\n          }\n          var dir = 1;\n          break;\n        default:\n          var dir = this.indentKeywords[val];\n          break;\n      }\n      var stack = [val];\n      if (!dir) return;\n      var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n      var startRow = row;\n      var ranges = [];\n      ranges.push(stream.getCurrentTokenRange());\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n      if (token.type == \"comment.multiline\") {\n        while (token = stream.step()) {\n          if (token.type !== \"comment.multiline\") continue;\n          if (dir == 1) {\n            startColumn = 6;\n            if (token.value == \"=end\") {\n              break;\n            }\n          } else {\n            if (token.value == \"=begin\") {\n              break;\n            }\n          }\n        }\n      } else {\n        while (token = stream.step()) {\n          var ignore = false;\n          if (token.type !== \"keyword\") continue;\n          var level = dir * this.indentKeywords[token.value];\n          line = session.getLine(stream.getCurrentTokenRow());\n          switch (token.value) {\n            case \"do\":\n              for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                var prevToken = stream.$rowTokens[i];\n                if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                  level = 0;\n                  break;\n                }\n              }\n              break;\n            case \"else\":\n              var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n              if (!checkToken.test(line) || val == \"case\") {\n                level = 0;\n                ignore = true;\n              }\n              break;\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n              var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n              if (!checkToken.test(line)) {\n                level = 0;\n                ignore = true;\n              }\n              break;\n            case \"when\":\n              if (/\\sthen\\s/.test(line) || val == \"case\") {\n                level = 0;\n                ignore = true;\n              }\n              break;\n          }\n          if (level > 0) {\n            stack.unshift(token.value);\n          } else if (level <= 0 && ignore === false) {\n            stack.shift();\n            if (!stack.length) {\n              if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                break;\n              }\n              if (token.value == \"do\" && dir == -1 && level != 0) break;\n              if (token.value != \"do\") break;\n            }\n            if (level === 0) {\n              stack.unshift(token.value);\n            }\n          }\n        }\n      }\n      if (!token) return null;\n      if (tokenRange) {\n        ranges.push(stream.getCurrentTokenRange());\n        return ranges;\n      }\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) {\n        if (token.type === \"comment.multiline\") {\n          var endColumn = 6;\n        } else {\n          var endColumn = session.getLine(row).length;\n        }\n        return new Range(row, endColumn, startRow - 1, startColumn);\n      } else return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/ruby\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/ruby_highlight_rules\", \"ace/mode/matching_brace_outdent\", \"ace/range\", \"ace/mode/folding/ruby\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\n  var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n  var Range = require(\"../range\").Range;\n  var FoldMode = require(\"./folding/ruby\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n      var tokens = tokenizedLine.tokens;\n      if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n        return indent;\n      }\n      if (state == \"start\") {\n        var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n        var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n        var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n        var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n        if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n          indent += tab;\n        }\n      }\n      return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n      return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, session, row) {\n      var line = session.getLine(row);\n      if (/}/.test(line)) return this.$outdent.autoOutdent(session, row);\n      var indent = this.$getIndent(line);\n      var prevLine = session.getLine(row - 1);\n      var prevIndent = this.$getIndent(prevLine);\n      var tab = session.getTabString();\n      if (prevIndent.length <= indent.length) {\n        if (indent.slice(-tab.length) == tab) session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n      }\n    };\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) {\n        var pos = session.selection.lead;\n        column = pos.column;\n        row = pos.row;\n      }\n      var startToken = session.getTokenAt(row, column);\n      if (startToken && startToken.value in this.indentKeywords) return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/ruby\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"names":["ace","define","require","exports","module","oop","TextHighlightRules","constantOtherSymbol","token","regex","qString","qqString","tString","constantNumericHex","constantNumericBinary","constantNumericDecimal","constantNumericOctal","constantNumericRational","constantNumericComplex","constantNumericFloat","instanceVariable","RubyHighlightRules","builtinFunctions","keywords","buildinConstants","builtinVariables","keywordMapper","$keywords","createKeywordMapper","escapedChars","closeParen","$rules","next","push","defaultToken","onMatch","val","state","stack","length","paren","unshift","stateName","value","currentState","tokens","split","splitRegex","type","rules","heredoc","shift","indentedHeredoc","include","normalizeRules","inherits","Range","MatchingBraceOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","getLine","match","column","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","BaseFoldMode","FoldMode","TokenIterator","indentKeywords","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","isStart","isEnd","getTokenAt","index","getFoldWidgetRange","exec","rubyBlock","openingBracketBlock","closingBracketBlock","tokenRange","stream","getCurrentToken","checkToken","RegExp","dir","startColumn","startRow","ranges","getCurrentTokenRange","step","stepBackward","stepForward","ignore","level","getCurrentTokenRow","i","$tokenIndex","prevToken","$rowTokens","endColumn","TextMode","Mode","HighlightRules","$outdent","$behaviour","$defaultBehaviour","foldingRules","lineCommentStart","getNextLineIndent","tab","tokenizedLine","getTokenizer","getLineTokens","startingClassOrMethod","startingDoBlock","startingConditional","prevLine","prevIndent","getTabString","slice","remove","getMatching","undefined","pos","selection","lead","startToken","$id","snippetFileId","m"],"sources":["/home/anasbouzid/streamlit-code-editor/code_editor/frontend/node_modules/ace-builds/src-noconflict/mode-ruby.js"],"sourcesContent":["ace.define(\"ace/mode/ruby_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar constantOtherSymbol = exports.constantOtherSymbol = {\n    token: \"constant.other.symbol.ruby\", // symbol\n    regex: \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n};\nexports.qString = {\n    token: \"string\", // single line\n    regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n};\nexports.qqString = {\n    token: \"string\", // single line\n    regex: '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n};\nexports.tString = {\n    token: \"string\", // backtick string\n    regex: \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n};\nvar constantNumericHex = exports.constantNumericHex = {\n    token: \"constant.numeric\", // hex\n    regex: \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n};\nvar constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n};\nvar constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n};\nvar constantNumericOctal = exports.constantNumericOctal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n};\nvar constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\", //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n};\nvar constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\", //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n};\nvar constantNumericFloat = exports.constantNumericFloat = {\n    token: \"constant.numeric\", // float + complex\n    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n};\nvar instanceVariable = exports.instanceVariable = {\n    token: \"variable.instance\", // instance variable\n    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n};\nvar RubyHighlightRules = function () {\n    var builtinFunctions = (\"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" +\n        \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" +\n        \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" +\n        \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" +\n        \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" +\n        \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" +\n        \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" +\n        \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" +\n        \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" +\n        \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" +\n        \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" +\n        \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" +\n        \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" +\n        \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" +\n        \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" +\n        \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" +\n        \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" +\n        \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" +\n        \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" +\n        \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" +\n        \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" +\n        \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" +\n        \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" +\n        \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" +\n        \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" +\n        \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" +\n        \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" +\n        \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" +\n        \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" +\n        \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" +\n        \"private_class_method|remove_method|undef_method\");\n    var keywords = (\"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" +\n        \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" +\n        \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\");\n    var buildinConstants = (\"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" +\n        \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\");\n    var builtinVariables = (\"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"$!|root_url|flash|session|cookies|params|request|response|logger|self\");\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions,\n        \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n    var closeParen = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"<\": \">\",\n        \"^\": \"^\",\n        \"|\": \"|\",\n        \"%\": \"%\"\n    };\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \"#.*$\"\n            }, {\n                token: \"comment.multiline\", // multi line comment\n                regex: \"^=begin(?=$|\\\\s.*$)\",\n                next: \"comment\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/](?=.*\\/)/,\n                next: \"regex\"\n            },\n            [{\n                    token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                    regex: /(:)?(\")/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: escapedChars\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /\"/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: \"string.start\",\n                    regex: /`/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: escapedChars\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /`/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                    regex: /(:)?(')/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: /\\\\['\\\\]/\n                        }, {\n                            token: \"string.end\",\n                            regex: /'/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: \"string.start\", //doesn't see any differences between strings and array of strings in highlighting\n                    regex: /%[qwx]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"qStateWithoutInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"string.start\", //doesn't see any differences between strings and array of strings in highlighting\n                    regex: /%[QWX]?([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"qStateWithInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                    regex: /%[si]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"sStateWithoutInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                    regex: /%[SI]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"sStateWithInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"string.regexp\",\n                    regex: /%[r]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"rState\";\n                        return this.token;\n                    }\n                }],\n            {\n                token: \"punctuation\", // namespaces aren't symbols\n                regex: \"::\"\n            },\n            instanceVariable,\n            {\n                token: \"variable.global\", // global variable\n                regex: \"[$][a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"support.class\", // class name\n                regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n            }, {\n                token: [\"punctuation.operator\", \"support.function\"],\n                regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n            }, {\n                token: [\"punctuation.operator\", \"identifier\"],\n                regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n            }, {\n                token: \"string.character\",\n                regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /\\?(?=.+:)/\n            },\n            constantNumericRational,\n            constantNumericComplex,\n            constantOtherSymbol,\n            constantNumericHex,\n            constantNumericFloat,\n            constantNumericBinary,\n            constantNumericDecimal,\n            constantNumericOctal,\n            {\n                token: \"constant.language.boolean\",\n                regex: \"(?:true|false)\\\\b\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token: \"punctuation.separator.key-value\",\n                regex: \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch: function (value, currentState, stack) {\n                    var next = (value[2] == '-' || value[2] == '~') ? \"indentedHeredoc\" : \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        { type: \"constant\", value: tokens[1] },\n                        { type: \"string\", value: tokens[2] },\n                        { type: \"support.class\", value: tokens[3] },\n                        { type: \"string\", value: tokens[4] }\n                    ];\n                },\n                regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n                rules: {\n                    heredoc: [{\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }],\n                    indentedHeredoc: [{\n                            token: \"string\",\n                            regex: \"^ +\"\n                        }, {\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }]\n                }\n            }, {\n                regex: \"$\",\n                token: \"empty\",\n                next: function (currentState, stack) {\n                    if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            }, {\n                token: \"keyword.operator\",\n                regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[[({]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\])}]\",\n                onMatch: function (value, currentState, stack) {\n                    this.next = '';\n                    if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n                        stack.shift();\n                        this.next = stack.shift();\n                    }\n                    return this.token;\n                }\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[?:,;.]/\n            }\n        ],\n        \"comment\": [\n            {\n                token: \"comment.multiline\", // closing comment\n                regex: \"^=end(?=$|\\\\s.*$)\",\n                next: \"start\"\n            }, {\n                token: \"comment\", // comment spanning whole line\n                regex: \".+\"\n            }\n        ],\n        \"qStateWithInterpolation\": [{\n                token: \"string.start\", // excluded nested |^% due to difficulty in realization\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"string\";\n                }\n            }, {\n                token: \"constant.language.escape\",\n                regex: escapedChars\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\./\n            }, {\n                token: \"paren.start\",\n                regex: /#{/,\n                push: \"start\"\n            }, {\n                token: \"string.end\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"string\";\n                }\n            }, {\n                defaultToken: \"string\"\n            }],\n        \"qStateWithoutInterpolation\": [{\n                token: \"string.start\", // excluded nested |^% due to difficulty in realization\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"string\";\n                }\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\['\\\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\./\n            }, {\n                token: \"string.end\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"string\";\n                }\n            }, {\n                defaultToken: \"string\"\n            }],\n        \"sStateWithoutInterpolation\": [{\n                token: \"constant.other.symbol.ruby\", // excluded nested |^% due to difficulty in realization\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                defaultToken: \"constant.other.symbol.ruby\"\n            }],\n        \"sStateWithInterpolation\": [{\n                token: \"constant.other.symbol.ruby\", // excluded nested |^% due to difficulty in realization\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                token: \"constant.language.escape\",\n                regex: escapedChars\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\./\n            }, {\n                token: \"paren.start\",\n                regex: /#{/,\n                push: \"start\"\n            }, {\n                token: \"constant.other.symbol.ruby\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                defaultToken: \"constant.other.symbol.ruby\"\n            }],\n        \"rState\": [{\n                token: \"string.regexp\", // excluded nested |^% due to difficulty in realization\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"constant.language.escape\";\n                }\n            }, {\n                token: \"paren.start\",\n                regex: /#{/,\n                push: \"start\"\n            }, {\n                token: \"string.regexp\",\n                regex: /\\//\n            }, {\n                token: \"string.regexp\",\n                regex: /[)\\]>}^|%][imxouesn]*/, onMatch: function (val, state, stack) {\n                    if (stack.length && val[0] === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"constant.language.escape\";\n                }\n            },\n            { include: \"regex\" },\n            {\n                defaultToken: \"string.regexp\"\n            }],\n        \"regex\": [\n            {\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\[AGbBzZ]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\g<[a-zA-Z0-9]*>/\n            }, {\n                token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n            }, {\n                token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)([^/]*)(})/\n            }, {\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/][imxouesn]*/,\n                next: \"start\"\n            }, {\n                token: \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token: \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"regexp.keyword\",\n                regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: /&?&?\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"pop\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                defaultToken: \"string.regexp.characterclass\"\n            }\n        ]\n    };\n    this.normalizeRules();\n};\noop.inherits(RubyHighlightRules, TextHighlightRules);\nexports.RubyHighlightRules = RubyHighlightRules;\n\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar MatchingBraceOutdent = function () { };\n(function () {\n    this.checkOutdent = function (line, input) {\n        if (!/^\\s+$/.test(line))\n            return false;\n        return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n        if (!match)\n            return 0;\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({ row: row, column: column });\n        if (!openBracePos || openBracePos.row == row)\n            return 0;\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n        return line.match(/^\\s*/)[0];\n    };\n}).call(MatchingBraceOutdent.prototype);\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n\n});\n\nace.define(\"ace/mode/folding/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar FoldMode = exports.FoldMode = function () {\n};\noop.inherits(FoldMode, BaseFoldMode);\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            }\n            else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            }\n            else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        }\n        else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        }\n        else\n            return \"end\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n        var stack = [val];\n        if (!dir)\n            return;\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                }\n                else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n                if (level > 0) {\n                    stack.unshift(token.value);\n                }\n                else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n        if (!token)\n            return null;\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            }\n            else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        }\n        else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/ruby_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/folding/ruby\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\nvar Mode = function () {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n(function () {\n    this.lineCommentStart = \"#\";\n    this.getNextLineIndent = function (state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n        return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n    this.getMatching = function (session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/ruby\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}