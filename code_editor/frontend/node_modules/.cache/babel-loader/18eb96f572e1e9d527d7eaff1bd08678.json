{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { AsyncByteStream } from '../../io/stream';\n/** @ignore */\nexport function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {\n  const writer = new this(writableStrategy);\n  const reader = new AsyncByteStream(writer);\n  const readable = new ReadableStream({\n    type: 'bytes',\n    async cancel() {\n      await reader.cancel();\n    },\n    async pull(controller) {\n      await next(controller);\n    },\n    async start(controller) {\n      await next(controller);\n    }\n  }, {\n    'highWaterMark': 2 ** 14,\n    ...readableStrategy\n  });\n  return {\n    writable: new WritableStream(writer, writableStrategy),\n    readable\n  };\n  async function next(controller) {\n    let buf = null;\n    let size = controller.desiredSize;\n    while (buf = await reader.read(size || null)) {\n      controller.enqueue(buf);\n      if (size != null && (size -= buf.byteLength) <= 0) {\n        return;\n      }\n    }\n    controller.close();\n  }\n}","map":{"version":3,"names":["AsyncByteStream","recordBatchWriterThroughDOMStream","writableStrategy","readableStrategy","writer","reader","readable","ReadableStream","type","cancel","pull","controller","next","start","writable","WritableStream","buf","size","desiredSize","read","enqueue","byteLength","close"],"sources":["io/whatwg/writer.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType } from '../../type';\nimport { RecordBatch } from '../../recordbatch';\nimport { AsyncByteStream } from '../../io/stream';\nimport { RecordBatchWriter } from '../../ipc/writer';\n\n/** @ignore */\nexport function recordBatchWriterThroughDOMStream<T extends { [key: string]: DataType } = any>(\n    this: typeof RecordBatchWriter,\n    writableStrategy?: QueuingStrategy<RecordBatch<T>> & { autoDestroy: boolean },\n    readableStrategy?: { highWaterMark?: number, size?: any }\n) {\n\n    const writer = new this<T>(writableStrategy);\n    const reader = new AsyncByteStream(writer);\n    const readable = new ReadableStream({\n        type: 'bytes',\n        async cancel() { await reader.cancel(); },\n        async pull(controller) { await next(controller); },\n        async start(controller) { await next(controller); },\n    }, { 'highWaterMark': 2 ** 14, ...readableStrategy });\n\n    return { writable: new WritableStream(writer, writableStrategy), readable };\n\n    async function next(controller: ReadableStreamDefaultController<Uint8Array>) {\n        let buf: Uint8Array | null = null;\n        let size = controller.desiredSize;\n        while (buf = await reader.read(size || null)) {\n            controller.enqueue(buf);\n            if (size != null && (size -= buf.byteLength) <= 0) { return; }\n        }\n        controller.close();\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SAASA,eAAe,QAAQ,iBAAiB;AAGjD;AACA,OAAM,SAAUC,iCAAiCA,CAE7CC,gBAA6E,EAC7EC,gBAAyD;EAGzD,MAAMC,MAAM,GAAG,IAAI,IAAI,CAAIF,gBAAgB,CAAC;EAC5C,MAAMG,MAAM,GAAG,IAAIL,eAAe,CAACI,MAAM,CAAC;EAC1C,MAAME,QAAQ,GAAG,IAAIC,cAAc,CAAC;IAChCC,IAAI,EAAE,OAAO;IACb,MAAMC,MAAMA,CAAA;MAAK,MAAMJ,MAAM,CAACI,MAAM,EAAE;IAAE,CAAC;IACzC,MAAMC,IAAIA,CAACC,UAAU;MAAI,MAAMC,IAAI,CAACD,UAAU,CAAC;IAAE,CAAC;IAClD,MAAME,KAAKA,CAACF,UAAU;MAAI,MAAMC,IAAI,CAACD,UAAU,CAAC;IAAE;GACrD,EAAE;IAAE,eAAe,EAAE,CAAC,IAAI,EAAE;IAAE,GAAGR;EAAgB,CAAE,CAAC;EAErD,OAAO;IAAEW,QAAQ,EAAE,IAAIC,cAAc,CAACX,MAAM,EAAEF,gBAAgB,CAAC;IAAEI;EAAQ,CAAE;EAE3E,eAAeM,IAAIA,CAACD,UAAuD;IACvE,IAAIK,GAAG,GAAsB,IAAI;IACjC,IAAIC,IAAI,GAAGN,UAAU,CAACO,WAAW;IACjC,OAAOF,GAAG,GAAG,MAAMX,MAAM,CAACc,IAAI,CAACF,IAAI,IAAI,IAAI,CAAC,EAAE;MAC1CN,UAAU,CAACS,OAAO,CAACJ,GAAG,CAAC;MACvB,IAAIC,IAAI,IAAI,IAAI,IAAI,CAACA,IAAI,IAAID,GAAG,CAACK,UAAU,KAAK,CAAC,EAAE;QAAE;;;IAEzDV,UAAU,CAACW,KAAK,EAAE;EACtB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module"}