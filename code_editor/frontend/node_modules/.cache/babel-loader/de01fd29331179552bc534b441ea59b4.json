{"ast":null,"code":"ace.define(\"ace/mode/elixir_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  /* This file was autogenerated from https://raw.githubusercontent.com/elixir-lang/elixir-tmbundle/master/Syntaxes/Elixir.tmLanguage (uuid: ) */\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var ElixirHighlightRules = function () {\n    this.$rules = {\n      start: [{\n        token: ['meta.module.elixir', 'keyword.control.module.elixir', 'meta.module.elixir', 'entity.name.type.module.elixir'],\n        regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.false',\n        regex: '@(?:module|type)?doc false',\n        comment: '@doc false is treated as documentation'\n      }, {\n        token: 'comment.documentation.string',\n        regex: '@(?:module|type)?doc \"',\n        push: [{\n          token: 'comment.documentation.string',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.string'\n        }],\n        comment: '@doc with string is treated as documentation'\n      }, {\n        token: 'keyword.control.elixir',\n        regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])'\n      }, {\n        token: 'keyword.operator.elixir',\n        regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation'\n      }, {\n        token: 'constant.language.elixir',\n        regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])'\n      }, {\n        token: 'variable.language.elixir',\n        regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.readwrite.module.elixir'],\n        regex: '(@)([a-zA-Z_]\\\\w*)'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.anonymous.elixir'],\n        regex: '(&)(\\\\d*)'\n      }, {\n        token: 'variable.other.constant.elixir',\n        regex: '\\\\b[A-Z]\\\\w*\\\\b'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\\'',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.single-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\"',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.double-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\\'\\'\\')',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\\'\\'\\')',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.heredoc.elixir'\n        }],\n        comment: 'Single-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\\'',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.elixir'\n        }],\n        comment: 'single quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\"',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.elixir'\n        }],\n        comment: 'double quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[a-z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[A-Z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n        regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n        comment: 'symbols'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n        comment: 'symbols'\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(#)(.*)'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t'\n      }, {\n        token: 'keyword.operator.assignment.augmented.elixir',\n        regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&='\n      }, {\n        token: 'keyword.operator.comparison.elixir',\n        regex: '===?|!==?|<=?|>=?'\n      }, {\n        token: 'keyword.operator.bitwise.elixir',\n        regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}'\n      }, {\n        token: 'keyword.operator.logical.elixir',\n        regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n        originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b'\n      }, {\n        token: 'keyword.operator.arithmetic.elixir',\n        regex: '\\\\*|\\\\+|\\\\-|/'\n      }, {\n        token: 'keyword.operator.other.elixir',\n        regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>'\n      }, {\n        token: 'keyword.operator.assignment.elixir',\n        regex: '='\n      }, {\n        token: 'punctuation.separator.other.elixir',\n        regex: ':'\n      }, {\n        token: 'punctuation.separator.statement.elixir',\n        regex: '\\\\;'\n      }, {\n        token: 'punctuation.separator.object.elixir',\n        regex: ','\n      }, {\n        token: 'punctuation.separator.method.elixir',\n        regex: '\\\\.'\n      }, {\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{|\\\\}'\n      }, {\n        token: 'punctuation.section.array.elixir',\n        regex: '\\\\[|\\\\]'\n      }, {\n        token: 'punctuation.section.function.elixir',\n        regex: '\\\\(|\\\\)'\n      }],\n      '#escaped_char': [{\n        token: 'constant.character.escape.elixir',\n        regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)'\n      }],\n      '#interpolated_elixir': [{\n        token: ['source.elixir.embedded.source', 'source.elixir.embedded.source.empty'],\n        regex: '(#\\\\{)(\\\\})'\n      }, {\n        todo: {\n          token: 'punctuation.section.embedded.elixir',\n          regex: '#\\\\{',\n          push: [{\n            token: 'punctuation.section.embedded.elixir',\n            regex: '\\\\}',\n            next: 'pop'\n          }, {\n            include: '#nest_curly_and_self'\n          }, {\n            include: '$self'\n          }, {\n            defaultToken: 'source.elixir.embedded.source'\n          }]\n        }\n      }],\n      '#nest_curly_and_self': [{\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{',\n        push: [{\n          token: 'punctuation.section.scope.elixir',\n          regex: '\\\\}',\n          next: 'pop'\n        }, {\n          include: '#nest_curly_and_self'\n        }]\n      }, {\n        include: '$self'\n      }],\n      '#regex_sub': [{\n        include: '#interpolated_elixir'\n      }, {\n        include: '#escaped_char'\n      }, {\n        token: ['punctuation.definition.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'punctuation.definition.arbitrary-repitition.elixir'],\n        regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})'\n      }, {\n        token: 'punctuation.definition.character-class.elixir',\n        regex: '\\\\[(?:\\\\^?\\\\])?',\n        push: [{\n          token: 'punctuation.definition.character-class.elixir',\n          regex: '\\\\]',\n          next: 'pop'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.regexp.character-class.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.group.elixir',\n        regex: '\\\\(',\n        push: [{\n          token: 'punctuation.definition.group.elixir',\n          regex: '\\\\)',\n          next: 'pop'\n        }, {\n          include: '#regex_sub'\n        }, {\n          defaultToken: 'string.regexp.group.elixir'\n        }]\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n        originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n        comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.'\n      }]\n    };\n    this.normalizeRules();\n  };\n  ElixirHighlightRules.metaData = {\n    comment: 'Textmate bundle for Elixir Programming Language.',\n    fileTypes: ['ex', 'exs'],\n    firstLineMatch: '^#!/.*\\\\belixir',\n    foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n    foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n    keyEquivalent: '^~E',\n    name: 'Elixir',\n    scopeName: 'source.elixir'\n  };\n  oop.inherits(ElixirHighlightRules, TextHighlightRules);\n  exports.ElixirHighlightRules = ElixirHighlightRules;\n});\nace.define(\"ace/mode/folding/coffee\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.commentBlock = function (session, row) {\n      var re = /\\S/;\n      var line = session.getLine(row);\n      var startLevel = line.search(re);\n      if (startLevel == -1 || line[startLevel] != \"#\") return;\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n      while (++row < maxRow) {\n        line = session.getLine(row);\n        var level = line.search(re);\n        if (level == -1) continue;\n        if (line[level] != \"#\") break;\n        endRow = row;\n      }\n      if (endRow > startRow) {\n        var endColumn = session.getLine(endRow).length;\n        return new Range(startRow, startColumn, endRow, endColumn);\n      }\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var range = this.indentationBlock(session, row);\n      if (range) return range;\n      range = this.commentBlock(session, row);\n      if (range) return range;\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var indent = line.search(/\\S/);\n      var next = session.getLine(row + 1);\n      var prev = session.getLine(row - 1);\n      var prevIndent = prev.search(/\\S/);\n      var nextIndent = next.search(/\\S/);\n      if (indent == -1) {\n        session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n        return \"\";\n      }\n      if (prevIndent == -1) {\n        if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n          session.foldWidgets[row - 1] = \"\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"start\";\n        }\n      } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n        if (session.getLine(row - 2).search(/\\S/) == -1) {\n          session.foldWidgets[row - 1] = \"start\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"\";\n        }\n      }\n      if (prevIndent != -1 && prevIndent < indent) session.foldWidgets[row - 1] = \"start\";else session.foldWidgets[row - 1] = \"\";\n      if (indent < nextIndent) return \"start\";else return \"\";\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/elixir\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/elixir_highlight_rules\", \"ace/mode/folding/coffee\"], function (require, exports, module) {\n  /*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n  */\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var ElixirHighlightRules = require(\"./elixir_highlight_rules\").ElixirHighlightRules;\n  var FoldMode = require(\"./folding/coffee\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n    this.$id = \"ace/mode/elixir\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/elixir\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"names":["ace","define","require","exports","module","oop","TextHighlightRules","ElixirHighlightRules","$rules","start","token","regex","push","next","include","defaultToken","comment","TODO","originalRegex","todo","normalizeRules","metaData","fileTypes","firstLineMatch","foldingStartMarker","foldingStopMarker","keyEquivalent","name","scopeName","inherits","BaseFoldMode","FoldMode","Range","commentBlock","session","row","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidgetRange","foldStyle","range","indentationBlock","getFoldWidget","indent","prev","prevIndent","nextIndent","foldWidgets","call","prototype","TextMode","Mode","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","$id","m"],"sources":["/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/node_modules/ace-builds/src-noconflict/mode-elixir.js"],"sourcesContent":["ace.define(\"ace/mode/elixir_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){/* This file was autogenerated from https://raw.githubusercontent.com/elixir-lang/elixir-tmbundle/master/Syntaxes/Elixir.tmLanguage (uuid: ) */\n\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar ElixirHighlightRules = function () {\n    this.$rules = { start: [{ token: ['meta.module.elixir',\n                    'keyword.control.module.elixir',\n                    'meta.module.elixir',\n                    'entity.name.type.module.elixir'],\n                regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)' },\n            { token: 'comment.documentation.heredoc',\n                regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n                push: [{ token: 'comment.documentation.heredoc',\n                        regex: '\\\\s*\"\"\"',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'comment.documentation.heredoc' }],\n                comment: '@doc with heredocs is treated as documentation' },\n            { token: 'comment.documentation.heredoc',\n                regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n                push: [{ token: 'comment.documentation.heredoc',\n                        regex: '\\\\s*\"\"\"',\n                        next: 'pop' },\n                    { defaultToken: 'comment.documentation.heredoc' }],\n                comment: '@doc with heredocs is treated as documentation' },\n            { token: 'comment.documentation.heredoc',\n                regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n                push: [{ token: 'comment.documentation.heredoc',\n                        regex: '\\\\s*\\'\\'\\'',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'comment.documentation.heredoc' }],\n                comment: '@doc with heredocs is treated as documentation' },\n            { token: 'comment.documentation.heredoc',\n                regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n                push: [{ token: 'comment.documentation.heredoc',\n                        regex: '\\\\s*\\'\\'\\'',\n                        next: 'pop' },\n                    { defaultToken: 'comment.documentation.heredoc' }],\n                comment: '@doc with heredocs is treated as documentation' },\n            { token: 'comment.documentation.false',\n                regex: '@(?:module|type)?doc false',\n                comment: '@doc false is treated as documentation' },\n            { token: 'comment.documentation.string',\n                regex: '@(?:module|type)?doc \"',\n                push: [{ token: 'comment.documentation.string',\n                        regex: '\"',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'comment.documentation.string' }],\n                comment: '@doc with string is treated as documentation' },\n            { token: 'keyword.control.elixir',\n                regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])' },\n            { token: 'keyword.operator.elixir',\n                regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n                comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation' },\n            { token: 'constant.language.elixir',\n                regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])' },\n            { token: 'variable.language.elixir',\n                regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])' },\n            { token: ['punctuation.definition.variable.elixir',\n                    'variable.other.readwrite.module.elixir'],\n                regex: '(@)([a-zA-Z_]\\\\w*)' },\n            { token: ['punctuation.definition.variable.elixir',\n                    'variable.other.anonymous.elixir'],\n                regex: '(&)(\\\\d*)' },\n            { token: 'variable.other.constant.elixir',\n                regex: '\\\\b[A-Z]\\\\w*\\\\b' },\n            { token: 'constant.numeric.elixir',\n                regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b' },\n            { token: 'punctuation.definition.constant.elixir',\n                regex: ':\\'',\n                push: [{ token: 'punctuation.definition.constant.elixir',\n                        regex: '\\'',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'constant.other.symbol.single-quoted.elixir' }] },\n            { token: 'punctuation.definition.constant.elixir',\n                regex: ':\"',\n                push: [{ token: 'punctuation.definition.constant.elixir',\n                        regex: '\"',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'constant.other.symbol.double-quoted.elixir' }] },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '(?:\\'\\'\\')',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?>\\'\\'\\')',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '^\\\\s*\\'\\'\\'',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'support.function.variable.quoted.single.heredoc.elixir' }],\n                comment: 'Single-quoted heredocs' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '\\'',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\'',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'support.function.variable.quoted.single.elixir' }],\n                comment: 'single quoted string (allows for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '(?:\"\"\")',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?>\"\"\")',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '^\\\\s*\"\"\"',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.quoted.double.heredoc.elixir' }],\n                comment: 'Double-quoted heredocs' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '\"',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\"',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.quoted.double.elixir' }],\n                comment: 'double quoted string (allows for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[a-z](?:\"\"\")',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '~[a-z](?>\"\"\")',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '^\\\\s*\"\"\"',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.quoted.double.heredoc.elixir' }],\n                comment: 'Double-quoted heredocs sigils' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[a-z]\\\\{',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\}[a-z]*',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.interpolated.elixir' }],\n                comment: 'sigil (allow for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[a-z]\\\\[',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\][a-z]*',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.interpolated.elixir' }],\n                comment: 'sigil (allow for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[a-z]\\\\<',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\>[a-z]*',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.interpolated.elixir' }],\n                comment: 'sigil (allow for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[a-z]\\\\(',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\)[a-z]*',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.interpolated.elixir' }],\n                comment: 'sigil (allow for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[a-z][^\\\\w]',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '[^\\\\w][a-z]*',\n                        next: 'pop' },\n                    { include: '#interpolated_elixir' },\n                    { include: '#escaped_char' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.interpolated.elixir' }],\n                comment: 'sigil (allow for interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[A-Z](?:\"\"\")',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '~[A-Z](?>\"\"\")',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '^\\\\s*\"\"\"',\n                        next: 'pop' },\n                    { defaultToken: 'string.quoted.other.literal.upper.elixir' }],\n                comment: 'Double-quoted heredocs sigils' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[A-Z]\\\\{',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\}[a-z]*',\n                        next: 'pop' },\n                    { defaultToken: 'string.quoted.other.literal.upper.elixir' }],\n                comment: 'sigil (without interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[A-Z]\\\\[',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\][a-z]*',\n                        next: 'pop' },\n                    { defaultToken: 'string.quoted.other.literal.upper.elixir' }],\n                comment: 'sigil (without interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[A-Z]\\\\<',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\>[a-z]*',\n                        next: 'pop' },\n                    { defaultToken: 'string.quoted.other.literal.upper.elixir' }],\n                comment: 'sigil (without interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[A-Z]\\\\(',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '\\\\)[a-z]*',\n                        next: 'pop' },\n                    { defaultToken: 'string.quoted.other.literal.upper.elixir' }],\n                comment: 'sigil (without interpolation)' },\n            { token: 'punctuation.definition.string.begin.elixir',\n                regex: '~[A-Z][^\\\\w]',\n                push: [{ token: 'punctuation.definition.string.end.elixir',\n                        regex: '[^\\\\w][a-z]*',\n                        next: 'pop' },\n                    { defaultToken: 'string.quoted.other.literal.upper.elixir' }],\n                comment: 'sigil (without interpolation)' },\n            { token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n                regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n                comment: 'symbols' },\n            { token: 'punctuation.definition.constant.elixir',\n                regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n                comment: 'symbols' },\n            { token: ['punctuation.definition.comment.elixir',\n                    'comment.line.number-sign.elixir'],\n                regex: '(#)(.*)' },\n            { token: 'constant.numeric.elixir',\n                regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n                TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n                originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n                comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t' },\n            { token: 'keyword.operator.assignment.augmented.elixir',\n                regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&=' },\n            { token: 'keyword.operator.comparison.elixir',\n                regex: '===?|!==?|<=?|>=?' },\n            { token: 'keyword.operator.bitwise.elixir',\n                regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}' },\n            { token: 'keyword.operator.logical.elixir',\n                regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n                originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b' },\n            { token: 'keyword.operator.arithmetic.elixir',\n                regex: '\\\\*|\\\\+|\\\\-|/' },\n            { token: 'keyword.operator.other.elixir',\n                regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>' },\n            { token: 'keyword.operator.assignment.elixir', regex: '=' },\n            { token: 'punctuation.separator.other.elixir', regex: ':' },\n            { token: 'punctuation.separator.statement.elixir',\n                regex: '\\\\;' },\n            { token: 'punctuation.separator.object.elixir', regex: ',' },\n            { token: 'punctuation.separator.method.elixir', regex: '\\\\.' },\n            { token: 'punctuation.section.scope.elixir', regex: '\\\\{|\\\\}' },\n            { token: 'punctuation.section.array.elixir', regex: '\\\\[|\\\\]' },\n            { token: 'punctuation.section.function.elixir',\n                regex: '\\\\(|\\\\)' }],\n        '#escaped_char': [{ token: 'constant.character.escape.elixir',\n                regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)' }],\n        '#interpolated_elixir': [{ token: ['source.elixir.embedded.source',\n                    'source.elixir.embedded.source.empty'],\n                regex: '(#\\\\{)(\\\\})' },\n            { todo: { token: 'punctuation.section.embedded.elixir',\n                    regex: '#\\\\{',\n                    push: [{ token: 'punctuation.section.embedded.elixir',\n                            regex: '\\\\}',\n                            next: 'pop' },\n                        { include: '#nest_curly_and_self' },\n                        { include: '$self' },\n                        { defaultToken: 'source.elixir.embedded.source' }] } }],\n        '#nest_curly_and_self': [{ token: 'punctuation.section.scope.elixir',\n                regex: '\\\\{',\n                push: [{ token: 'punctuation.section.scope.elixir',\n                        regex: '\\\\}',\n                        next: 'pop' },\n                    { include: '#nest_curly_and_self' }] },\n            { include: '$self' }],\n        '#regex_sub': [{ include: '#interpolated_elixir' },\n            { include: '#escaped_char' },\n            { token: ['punctuation.definition.arbitrary-repitition.elixir',\n                    'string.regexp.arbitrary-repitition.elixir',\n                    'string.regexp.arbitrary-repitition.elixir',\n                    'punctuation.definition.arbitrary-repitition.elixir'],\n                regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})' },\n            { token: 'punctuation.definition.character-class.elixir',\n                regex: '\\\\[(?:\\\\^?\\\\])?',\n                push: [{ token: 'punctuation.definition.character-class.elixir',\n                        regex: '\\\\]',\n                        next: 'pop' },\n                    { include: '#escaped_char' },\n                    { defaultToken: 'string.regexp.character-class.elixir' }] },\n            { token: 'punctuation.definition.group.elixir',\n                regex: '\\\\(',\n                push: [{ token: 'punctuation.definition.group.elixir',\n                        regex: '\\\\)',\n                        next: 'pop' },\n                    { include: '#regex_sub' },\n                    { defaultToken: 'string.regexp.group.elixir' }] },\n            { token: ['punctuation.definition.comment.elixir',\n                    'comment.line.number-sign.elixir'],\n                regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n                originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n                comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.' }] };\n    this.normalizeRules();\n};\nElixirHighlightRules.metaData = { comment: 'Textmate bundle for Elixir Programming Language.',\n    fileTypes: ['ex', 'exs'],\n    firstLineMatch: '^#!/.*\\\\belixir',\n    foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n    foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n    keyEquivalent: '^~E',\n    name: 'Elixir',\n    scopeName: 'source.elixir' };\noop.inherits(ElixirHighlightRules, TextHighlightRules);\nexports.ElixirHighlightRules = ElixirHighlightRules;\n\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar FoldMode = exports.FoldMode = function () { };\noop.inherits(FoldMode, BaseFoldMode);\n(function () {\n    this.commentBlock = function (session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n            if (level == -1)\n                continue;\n            if (line[level] != \"#\")\n                break;\n            endRow = row;\n        }\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        }\n        else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n        if (prevIndent != -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/elixir\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/elixir_highlight_rules\",\"ace/mode/folding/coffee\"], function(require, exports, module){/*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n*/\n\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar ElixirHighlightRules = require(\"./elixir_highlight_rules\").ElixirHighlightRules;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\nvar Mode = function () {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n(function () {\n    this.lineCommentStart = \"#\";\n    this.$id = \"ace/mode/elixir\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/elixir\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"mappings":"AAAAA,GAAG,CAACC,MAAM,CAAC,iCAAiC,EAAC,CAAC,SAAS,EAAC,SAAS,EAAC,QAAQ,EAAC,aAAa,EAAC,+BAA+B,CAAC,EAAE,UAASC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAC;EAAC;EAC9J,YAAY;;EACZ,IAAIC,GAAG,GAAGH,OAAO,CAAC,YAAY,CAAC;EAC/B,IAAII,kBAAkB,GAAGJ,OAAO,CAAC,wBAAwB,CAAC,CAACI,kBAAkB;EAC7E,IAAIC,oBAAoB,GAAG,SAAAA,CAAA,EAAY;IACnC,IAAI,CAACC,MAAM,GAAG;MAAEC,KAAK,EAAE,CAAC;QAAEC,KAAK,EAAE,CAAC,oBAAoB,EACtC,+BAA+B,EAC/B,oBAAoB,EACpB,gCAAgC,CAAC;QACrCC,KAAK,EAAE;MAA+D,CAAC,EAC3E;QAAED,KAAK,EAAE,+BAA+B;QACpCC,KAAK,EAAE,qCAAqC;QAC5CC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,+BAA+B;UACvCC,KAAK,EAAE,SAAS;UAChBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAgC,CAAC,CAAC;QACtDC,OAAO,EAAE;MAAiD,CAAC,EAC/D;QAAEN,KAAK,EAAE,+BAA+B;QACpCC,KAAK,EAAE,gCAAgC;QACvCC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,+BAA+B;UACvCC,KAAK,EAAE,SAAS;UAChBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAAgC,CAAC,CAAC;QACtDC,OAAO,EAAE;MAAiD,CAAC,EAC/D;QAAEN,KAAK,EAAE,+BAA+B;QACpCC,KAAK,EAAE,wCAAwC;QAC/CC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,+BAA+B;UACvCC,KAAK,EAAE,YAAY;UACnBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAgC,CAAC,CAAC;QACtDC,OAAO,EAAE;MAAiD,CAAC,EAC/D;QAAEN,KAAK,EAAE,+BAA+B;QACpCC,KAAK,EAAE,mCAAmC;QAC1CC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,+BAA+B;UACvCC,KAAK,EAAE,YAAY;UACnBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAAgC,CAAC,CAAC;QACtDC,OAAO,EAAE;MAAiD,CAAC,EAC/D;QAAEN,KAAK,EAAE,6BAA6B;QAClCC,KAAK,EAAE,4BAA4B;QACnCK,OAAO,EAAE;MAAyC,CAAC,EACvD;QAAEN,KAAK,EAAE,8BAA8B;QACnCC,KAAK,EAAE,wBAAwB;QAC/BC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,8BAA8B;UACtCC,KAAK,EAAE,GAAG;UACVE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA+B,CAAC,CAAC;QACrDC,OAAO,EAAE;MAA+C,CAAC,EAC7D;QAAEN,KAAK,EAAE,wBAAwB;QAC7BC,KAAK,EAAE,qSAAqS;QAC5SM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE;MAA4S,CAAC,EAChU;QAAER,KAAK,EAAE,yBAAyB;QAC9BC,KAAK,EAAE,gDAAgD;QACvDM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,sDAAsD;QACrEF,OAAO,EAAE;MAAqE,CAAC,EACnF;QAAEN,KAAK,EAAE,0BAA0B;QAC/BC,KAAK,EAAE;MAAmC,CAAC,EAC/C;QAAED,KAAK,EAAE,0BAA0B;QAC/BC,KAAK,EAAE;MAA8C,CAAC,EAC1D;QAAED,KAAK,EAAE,CAAC,wCAAwC,EAC1C,wCAAwC,CAAC;QAC7CC,KAAK,EAAE;MAAqB,CAAC,EACjC;QAAED,KAAK,EAAE,CAAC,wCAAwC,EAC1C,iCAAiC,CAAC;QACtCC,KAAK,EAAE;MAAY,CAAC,EACxB;QAAED,KAAK,EAAE,gCAAgC;QACrCC,KAAK,EAAE;MAAkB,CAAC,EAC9B;QAAED,KAAK,EAAE,yBAAyB;QAC9BC,KAAK,EAAE,gJAAgJ;QACvJM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE;MAA2H,CAAC,EAC/I;QAAER,KAAK,EAAE,wCAAwC;QAC7CC,KAAK,EAAE,KAAK;QACZC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,wCAAwC;UAChDC,KAAK,EAAE,IAAI;UACXE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6C,CAAC;MAAE,CAAC,EACzE;QAAEL,KAAK,EAAE,wCAAwC;QAC7CC,KAAK,EAAE,IAAI;QACXC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,wCAAwC;UAChDC,KAAK,EAAE,GAAG;UACVE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6C,CAAC;MAAE,CAAC,EACzE;QAAEL,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,YAAY;QACnBM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,YAAY;QAC3BN,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,aAAa;UACpBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAyD,CAAC,CAAC;QAC/EC,OAAO,EAAE;MAAyB,CAAC,EACvC;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,IAAI;QACXC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,IAAI;UACXE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAiD,CAAC,CAAC;QACvEC,OAAO,EAAE;MAAkD,CAAC,EAChE;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,SAAS;QAChBM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,SAAS;QACxBN,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,UAAU;UACjBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAsC,CAAC,CAAC;QAC5DC,OAAO,EAAE;MAAyB,CAAC,EACvC;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,GAAG;QACVC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,GAAG;UACVE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA8B,CAAC,CAAC;QACpDC,OAAO,EAAE;MAAkD,CAAC,EAChE;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,eAAe;QACtBM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,eAAe;QAC9BN,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,UAAU;UACjBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAsC,CAAC,CAAC;QAC5DC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6B,CAAC,CAAC;QACnDC,OAAO,EAAE;MAAkC,CAAC,EAChD;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6B,CAAC,CAAC;QACnDC,OAAO,EAAE;MAAkC,CAAC,EAChD;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6B,CAAC,CAAC;QACnDC,OAAO,EAAE;MAAkC,CAAC,EAChD;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6B,CAAC,CAAC;QACnDC,OAAO,EAAE;MAAkC,CAAC,EAChD;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,cAAc;QACrBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,cAAc;UACrBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC,EACnC;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEA,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAA6B,CAAC,CAAC;QACnDC,OAAO,EAAE;MAAkC,CAAC,EAChD;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,eAAe;QACtBM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,eAAe;QAC9BN,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,UAAU;UACjBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAA2C,CAAC,CAAC;QACjEC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAA2C,CAAC,CAAC;QACjEC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAA2C,CAAC,CAAC;QACjEC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAA2C,CAAC,CAAC;QACjEC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,WAAW;QAClBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,WAAW;UAClBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAA2C,CAAC,CAAC;QACjEC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,4CAA4C;QACjDC,KAAK,EAAE,cAAc;QACrBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,0CAA0C;UAClDC,KAAK,EAAE,cAAc;UACrBE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEE,YAAY,EAAE;QAA2C,CAAC,CAAC;QACjEC,OAAO,EAAE;MAAgC,CAAC,EAC9C;QAAEN,KAAK,EAAE,CAAC,wCAAwC,EAAE,8BAA8B,CAAC;QAC/EC,KAAK,EAAE,qNAAqN;QAC5NM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,2NAA2N;QAC1OF,OAAO,EAAE;MAAU,CAAC,EACxB;QAAEN,KAAK,EAAE,wCAAwC;QAC7CC,KAAK,EAAE,qCAAqC;QAC5CM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,uCAAuC;QACtDF,OAAO,EAAE;MAAU,CAAC,EACxB;QAAEN,KAAK,EAAE,CAAC,uCAAuC,EACzC,iCAAiC,CAAC;QACtCC,KAAK,EAAE;MAAU,CAAC,EACtB;QAAED,KAAK,EAAE,yBAAyB;QAC9BC,KAAK,EAAE,sEAAsE;QAC7EM,IAAI,EAAE,2CAA2C;QACjDC,aAAa,EAAE,0DAA0D;QACzEF,OAAO,EAAE;MAA0Y,CAAC,EACxZ;QAAEN,KAAK,EAAE,8CAA8C;QACnDC,KAAK,EAAE;MAA2B,CAAC,EACvC;QAAED,KAAK,EAAE,oCAAoC;QACzCC,KAAK,EAAE;MAAoB,CAAC,EAChC;QAAED,KAAK,EAAE,iCAAiC;QACtCC,KAAK,EAAE;MAAoC,CAAC,EAChD;QAAED,KAAK,EAAE,iCAAiC;QACtCC,KAAK,EAAE,qDAAqD;QAC5DO,aAAa,EAAE;MAAiE,CAAC,EACrF;QAAER,KAAK,EAAE,oCAAoC;QACzCC,KAAK,EAAE;MAAgB,CAAC,EAC5B;QAAED,KAAK,EAAE,+BAA+B;QACpCC,KAAK,EAAE;MAAwF,CAAC,EACpG;QAAED,KAAK,EAAE,oCAAoC;QAAEC,KAAK,EAAE;MAAI,CAAC,EAC3D;QAAED,KAAK,EAAE,oCAAoC;QAAEC,KAAK,EAAE;MAAI,CAAC,EAC3D;QAAED,KAAK,EAAE,wCAAwC;QAC7CC,KAAK,EAAE;MAAM,CAAC,EAClB;QAAED,KAAK,EAAE,qCAAqC;QAAEC,KAAK,EAAE;MAAI,CAAC,EAC5D;QAAED,KAAK,EAAE,qCAAqC;QAAEC,KAAK,EAAE;MAAM,CAAC,EAC9D;QAAED,KAAK,EAAE,kCAAkC;QAAEC,KAAK,EAAE;MAAU,CAAC,EAC/D;QAAED,KAAK,EAAE,kCAAkC;QAAEC,KAAK,EAAE;MAAU,CAAC,EAC/D;QAAED,KAAK,EAAE,qCAAqC;QAC1CC,KAAK,EAAE;MAAU,CAAC,CAAC;MAC3B,eAAe,EAAE,CAAC;QAAED,KAAK,EAAE,kCAAkC;QACrDC,KAAK,EAAE;MAA8B,CAAC,CAAC;MAC/C,sBAAsB,EAAE,CAAC;QAAED,KAAK,EAAE,CAAC,+BAA+B,EACtD,qCAAqC,CAAC;QAC1CC,KAAK,EAAE;MAAc,CAAC,EAC1B;QAAEQ,IAAI,EAAE;UAAET,KAAK,EAAE,qCAAqC;UAC9CC,KAAK,EAAE,MAAM;UACbC,IAAI,EAAE,CAAC;YAAEF,KAAK,EAAE,qCAAqC;YAC7CC,KAAK,EAAE,KAAK;YACZE,IAAI,EAAE;UAAM,CAAC,EACjB;YAAEC,OAAO,EAAE;UAAuB,CAAC,EACnC;YAAEA,OAAO,EAAE;UAAQ,CAAC,EACpB;YAAEC,YAAY,EAAE;UAAgC,CAAC;QAAE;MAAE,CAAC,CAAC;MACvE,sBAAsB,EAAE,CAAC;QAAEL,KAAK,EAAE,kCAAkC;QAC5DC,KAAK,EAAE,KAAK;QACZC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,kCAAkC;UAC1CC,KAAK,EAAE,KAAK;UACZE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAuB,CAAC;MAAE,CAAC,EAC9C;QAAEA,OAAO,EAAE;MAAQ,CAAC,CAAC;MACzB,YAAY,EAAE,CAAC;QAAEA,OAAO,EAAE;MAAuB,CAAC,EAC9C;QAAEA,OAAO,EAAE;MAAgB,CAAC,EAC5B;QAAEJ,KAAK,EAAE,CAAC,oDAAoD,EACtD,2CAA2C,EAC3C,2CAA2C,EAC3C,oDAAoD,CAAC;QACzDC,KAAK,EAAE;MAA+B,CAAC,EAC3C;QAAED,KAAK,EAAE,+CAA+C;QACpDC,KAAK,EAAE,iBAAiB;QACxBC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,+CAA+C;UACvDC,KAAK,EAAE,KAAK;UACZE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAgB,CAAC,EAC5B;UAAEC,YAAY,EAAE;QAAuC,CAAC;MAAE,CAAC,EACnE;QAAEL,KAAK,EAAE,qCAAqC;QAC1CC,KAAK,EAAE,KAAK;QACZC,IAAI,EAAE,CAAC;UAAEF,KAAK,EAAE,qCAAqC;UAC7CC,KAAK,EAAE,KAAK;UACZE,IAAI,EAAE;QAAM,CAAC,EACjB;UAAEC,OAAO,EAAE;QAAa,CAAC,EACzB;UAAEC,YAAY,EAAE;QAA6B,CAAC;MAAE,CAAC,EACzD;QAAEL,KAAK,EAAE,CAAC,uCAAuC,EACzC,iCAAiC,CAAC;QACtCC,KAAK,EAAE,yDAAyD;QAChEO,aAAa,EAAE,4DAA4D;QAC3EF,OAAO,EAAE;MAA6J,CAAC;IAAE,CAAC;IACtL,IAAI,CAACI,cAAc,CAAC,CAAC;EACzB,CAAC;EACDb,oBAAoB,CAACc,QAAQ,GAAG;IAAEL,OAAO,EAAE,kDAAkD;IACzFM,SAAS,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;IACxBC,cAAc,EAAE,iBAAiB;IACjCC,kBAAkB,EAAE,kDAAkD;IACtEC,iBAAiB,EAAE,sDAAsD;IACzEC,aAAa,EAAE,KAAK;IACpBC,IAAI,EAAE,QAAQ;IACdC,SAAS,EAAE;EAAgB,CAAC;EAChCvB,GAAG,CAACwB,QAAQ,CAACtB,oBAAoB,EAAED,kBAAkB,CAAC;EACtDH,OAAO,CAACI,oBAAoB,GAAGA,oBAAoB;AAEnD,CAAC,CAAC;AAEFP,GAAG,CAACC,MAAM,CAAC,yBAAyB,EAAC,CAAC,SAAS,EAAC,SAAS,EAAC,QAAQ,EAAC,aAAa,EAAC,4BAA4B,EAAC,WAAW,CAAC,EAAE,UAASC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAC;EAAC,YAAY;;EAC3K,IAAIC,GAAG,GAAGH,OAAO,CAAC,eAAe,CAAC;EAClC,IAAI4B,YAAY,GAAG5B,OAAO,CAAC,aAAa,CAAC,CAAC6B,QAAQ;EAClD,IAAIC,KAAK,GAAG9B,OAAO,CAAC,aAAa,CAAC,CAAC8B,KAAK;EACxC,IAAID,QAAQ,GAAG5B,OAAO,CAAC4B,QAAQ,GAAG,YAAY,CAAE,CAAC;EACjD1B,GAAG,CAACwB,QAAQ,CAACE,QAAQ,EAAED,YAAY,CAAC;EACpC,CAAC,YAAY;IACT,IAAI,CAACG,YAAY,GAAG,UAAUC,OAAO,EAAEC,GAAG,EAAE;MACxC,IAAIC,EAAE,GAAG,IAAI;MACb,IAAIC,IAAI,GAAGH,OAAO,CAACI,OAAO,CAACH,GAAG,CAAC;MAC/B,IAAII,UAAU,GAAGF,IAAI,CAACG,MAAM,CAACJ,EAAE,CAAC;MAChC,IAAIG,UAAU,IAAI,CAAC,CAAC,IAAIF,IAAI,CAACE,UAAU,CAAC,IAAI,GAAG,EAC3C;MACJ,IAAIE,WAAW,GAAGJ,IAAI,CAACK,MAAM;MAC7B,IAAIC,MAAM,GAAGT,OAAO,CAACU,SAAS,CAAC,CAAC;MAChC,IAAIC,QAAQ,GAAGV,GAAG;MAClB,IAAIW,MAAM,GAAGX,GAAG;MAChB,OAAO,EAAEA,GAAG,GAAGQ,MAAM,EAAE;QACnBN,IAAI,GAAGH,OAAO,CAACI,OAAO,CAACH,GAAG,CAAC;QAC3B,IAAIY,KAAK,GAAGV,IAAI,CAACG,MAAM,CAACJ,EAAE,CAAC;QAC3B,IAAIW,KAAK,IAAI,CAAC,CAAC,EACX;QACJ,IAAIV,IAAI,CAACU,KAAK,CAAC,IAAI,GAAG,EAClB;QACJD,MAAM,GAAGX,GAAG;MAChB;MACA,IAAIW,MAAM,GAAGD,QAAQ,EAAE;QACnB,IAAIG,SAAS,GAAGd,OAAO,CAACI,OAAO,CAACQ,MAAM,CAAC,CAACJ,MAAM;QAC9C,OAAO,IAAIV,KAAK,CAACa,QAAQ,EAAEJ,WAAW,EAAEK,MAAM,EAAEE,SAAS,CAAC;MAC9D;IACJ,CAAC;IACD,IAAI,CAACC,kBAAkB,GAAG,UAAUf,OAAO,EAAEgB,SAAS,EAAEf,GAAG,EAAE;MACzD,IAAIgB,KAAK,GAAG,IAAI,CAACC,gBAAgB,CAAClB,OAAO,EAAEC,GAAG,CAAC;MAC/C,IAAIgB,KAAK,EACL,OAAOA,KAAK;MAChBA,KAAK,GAAG,IAAI,CAAClB,YAAY,CAACC,OAAO,EAAEC,GAAG,CAAC;MACvC,IAAIgB,KAAK,EACL,OAAOA,KAAK;IACpB,CAAC;IACD,IAAI,CAACE,aAAa,GAAG,UAAUnB,OAAO,EAAEgB,SAAS,EAAEf,GAAG,EAAE;MACpD,IAAIE,IAAI,GAAGH,OAAO,CAACI,OAAO,CAACH,GAAG,CAAC;MAC/B,IAAImB,MAAM,GAAGjB,IAAI,CAACG,MAAM,CAAC,IAAI,CAAC;MAC9B,IAAI3B,IAAI,GAAGqB,OAAO,CAACI,OAAO,CAACH,GAAG,GAAG,CAAC,CAAC;MACnC,IAAIoB,IAAI,GAAGrB,OAAO,CAACI,OAAO,CAACH,GAAG,GAAG,CAAC,CAAC;MACnC,IAAIqB,UAAU,GAAGD,IAAI,CAACf,MAAM,CAAC,IAAI,CAAC;MAClC,IAAIiB,UAAU,GAAG5C,IAAI,CAAC2B,MAAM,CAAC,IAAI,CAAC;MAClC,IAAIc,MAAM,IAAI,CAAC,CAAC,EAAE;QACdpB,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAGqB,UAAU,IAAI,CAAC,CAAC,IAAIA,UAAU,GAAGC,UAAU,GAAG,OAAO,GAAG,EAAE;QACzF,OAAO,EAAE;MACb;MACA,IAAID,UAAU,IAAI,CAAC,CAAC,EAAE;QAClB,IAAIF,MAAM,IAAIG,UAAU,IAAIpB,IAAI,CAACiB,MAAM,CAAC,IAAI,GAAG,IAAIzC,IAAI,CAACyC,MAAM,CAAC,IAAI,GAAG,EAAE;UACpEpB,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE;UACjCD,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE;UACjC,OAAO,OAAO;QAClB;MACJ,CAAC,MACI,IAAIqB,UAAU,IAAIF,MAAM,IAAIjB,IAAI,CAACiB,MAAM,CAAC,IAAI,GAAG,IAAIC,IAAI,CAACD,MAAM,CAAC,IAAI,GAAG,EAAE;QACzE,IAAIpB,OAAO,CAACI,OAAO,CAACH,GAAG,GAAG,CAAC,CAAC,CAACK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;UAC7CN,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAG,OAAO;UACtCD,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE;UACjC,OAAO,EAAE;QACb;MACJ;MACA,IAAIqB,UAAU,IAAI,CAAC,CAAC,IAAIA,UAAU,GAAGF,MAAM,EACvCpB,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,KAEvCD,OAAO,CAACwB,WAAW,CAACvB,GAAG,GAAG,CAAC,CAAC,GAAG,EAAE;MACrC,IAAImB,MAAM,GAAGG,UAAU,EACnB,OAAO,OAAO,CAAC,KAEf,OAAO,EAAE;IACjB,CAAC;EACL,CAAC,EAAEE,IAAI,CAAC5B,QAAQ,CAAC6B,SAAS,CAAC;AAE3B,CAAC,CAAC;AAEF5D,GAAG,CAACC,MAAM,CAAC,iBAAiB,EAAC,CAAC,SAAS,EAAC,SAAS,EAAC,QAAQ,EAAC,aAAa,EAAC,eAAe,EAAC,iCAAiC,EAAC,yBAAyB,CAAC,EAAE,UAASC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAC;EAAC;AAC1L;AACA;EACA,YAAY;;EACZ,IAAIC,GAAG,GAAGH,OAAO,CAAC,YAAY,CAAC;EAC/B,IAAI2D,QAAQ,GAAG3D,OAAO,CAAC,QAAQ,CAAC,CAAC4D,IAAI;EACrC,IAAIvD,oBAAoB,GAAGL,OAAO,CAAC,0BAA0B,CAAC,CAACK,oBAAoB;EACnF,IAAIwB,QAAQ,GAAG7B,OAAO,CAAC,kBAAkB,CAAC,CAAC6B,QAAQ;EACnD,IAAI+B,IAAI,GAAG,SAAAA,CAAA,EAAY;IACnB,IAAI,CAACC,cAAc,GAAGxD,oBAAoB;IAC1C,IAAI,CAACyD,YAAY,GAAG,IAAIjC,QAAQ,CAAC,CAAC;IAClC,IAAI,CAACkC,UAAU,GAAG,IAAI,CAACC,iBAAiB;EAC5C,CAAC;EACD7D,GAAG,CAACwB,QAAQ,CAACiC,IAAI,EAAED,QAAQ,CAAC;EAC5B,CAAC,YAAY;IACT,IAAI,CAACM,gBAAgB,GAAG,GAAG;IAC3B,IAAI,CAACC,GAAG,GAAG,iBAAiB;EAChC,CAAC,EAAET,IAAI,CAACG,IAAI,CAACF,SAAS,CAAC;EACvBzD,OAAO,CAAC2D,IAAI,GAAGA,IAAI;AAEnB,CAAC,CAAC;AAAiB,CAAC,YAAW;EACX9D,GAAG,CAACE,OAAO,CAAC,CAAC,iBAAiB,CAAC,EAAE,UAASmE,CAAC,EAAE;IACzC,IAAI,OAAOjE,MAAM,IAAI,QAAQ,IAAI,OAAOD,OAAO,IAAI,QAAQ,IAAIC,MAAM,EAAE;MACnEA,MAAM,CAACD,OAAO,GAAGkE,CAAC;IACtB;EACJ,CAAC,CAAC;AACN,CAAC,EAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}