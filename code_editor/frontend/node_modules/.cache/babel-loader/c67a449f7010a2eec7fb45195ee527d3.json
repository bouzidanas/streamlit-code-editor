{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n  const retv = privateData.get(event);\n  console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n  if (data.passiveListener != null) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n    }\n    return;\n  }\n  if (!data.event.cancelable) {\n    return;\n  }\n  data.canceled = true;\n  if (typeof data.event.preventDefault === \"function\") {\n    data.event.preventDefault();\n  }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n  privateData.set(this, {\n    eventTarget,\n    event,\n    eventPhase: 2,\n    currentTarget: eventTarget,\n    canceled: false,\n    stopped: false,\n    immediateStopped: false,\n    passiveListener: null,\n    timeStamp: event.timeStamp || Date.now()\n  });\n\n  // https://heycam.github.io/webidl/#Unforgeable\n  Object.defineProperty(this, \"isTrusted\", {\n    value: false,\n    enumerable: true\n  });\n\n  // Define accessors\n  const keys = Object.keys(event);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (!(key in this)) {\n      Object.defineProperty(this, key, defineRedirectDescriptor(key));\n    }\n  }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n  /**\n   * The type of this event.\n   * @type {string}\n   */\n  get type() {\n    return pd(this).event.type;\n  },\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get target() {\n    return pd(this).eventTarget;\n  },\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    return pd(this).currentTarget;\n  },\n  /**\n   * @returns {EventTarget[]} The composed path of this event.\n   */\n  composedPath() {\n    const currentTarget = pd(this).currentTarget;\n    if (currentTarget == null) {\n      return [];\n    }\n    return [currentTarget];\n  },\n  /**\n   * Constant of NONE.\n   * @type {number}\n   */\n  get NONE() {\n    return 0;\n  },\n  /**\n   * Constant of CAPTURING_PHASE.\n   * @type {number}\n   */\n  get CAPTURING_PHASE() {\n    return 1;\n  },\n  /**\n   * Constant of AT_TARGET.\n   * @type {number}\n   */\n  get AT_TARGET() {\n    return 2;\n  },\n  /**\n   * Constant of BUBBLING_PHASE.\n   * @type {number}\n   */\n  get BUBBLING_PHASE() {\n    return 3;\n  },\n  /**\n   * The target of this event.\n   * @type {number}\n   */\n  get eventPhase() {\n    return pd(this).eventPhase;\n  },\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopPropagation() {\n    const data = pd(this);\n    data.stopped = true;\n    if (typeof data.event.stopPropagation === \"function\") {\n      data.event.stopPropagation();\n    }\n  },\n  /**\n   * Stop event bubbling.\n   * @returns {void}\n   */\n  stopImmediatePropagation() {\n    const data = pd(this);\n    data.stopped = true;\n    data.immediateStopped = true;\n    if (typeof data.event.stopImmediatePropagation === \"function\") {\n      data.event.stopImmediatePropagation();\n    }\n  },\n  /**\n   * The flag to be bubbling.\n   * @type {boolean}\n   */\n  get bubbles() {\n    return Boolean(pd(this).event.bubbles);\n  },\n  /**\n   * The flag to be cancelable.\n   * @type {boolean}\n   */\n  get cancelable() {\n    return Boolean(pd(this).event.cancelable);\n  },\n  /**\n   * Cancel this event.\n   * @returns {void}\n   */\n  preventDefault() {\n    setCancelFlag(pd(this));\n  },\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    return pd(this).canceled;\n  },\n  /**\n   * The flag to be composed.\n   * @type {boolean}\n   */\n  get composed() {\n    return Boolean(pd(this).event.composed);\n  },\n  /**\n   * The unix time of this event.\n   * @type {number}\n   */\n  get timeStamp() {\n    return pd(this).timeStamp;\n  },\n  /**\n   * The target of this event.\n   * @type {EventTarget}\n   * @deprecated\n   */\n  get srcElement() {\n    return pd(this).eventTarget;\n  },\n  /**\n   * The flag to stop event bubbling.\n   * @type {boolean}\n   * @deprecated\n   */\n  get cancelBubble() {\n    return pd(this).stopped;\n  },\n  set cancelBubble(value) {\n    if (!value) {\n      return;\n    }\n    const data = pd(this);\n    data.stopped = true;\n    if (typeof data.event.cancelBubble === \"boolean\") {\n      data.event.cancelBubble = true;\n    }\n  },\n  /**\n   * The flag to indicate cancellation state.\n   * @type {boolean}\n   * @deprecated\n   */\n  get returnValue() {\n    return !pd(this).canceled;\n  },\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag(pd(this));\n    }\n  },\n  /**\n   * Initialize this event object. But do nothing under event dispatching.\n   * @param {string} type The event type.\n   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n   * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n   * @deprecated\n   */\n  initEvent() {\n    // Do nothing.\n  }\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n  value: Event,\n  configurable: true,\n  writable: true\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n  // Make association for wrappers.\n  wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n  return {\n    get() {\n      return pd(this).event[key];\n    },\n    set(value) {\n      pd(this).event[key] = value;\n    },\n    configurable: true,\n    enumerable: true\n  };\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n  return {\n    value() {\n      const event = pd(this).event;\n      return event[key].apply(event, arguments);\n    },\n    configurable: true,\n    enumerable: true\n  };\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n  const keys = Object.keys(proto);\n  if (keys.length === 0) {\n    return BaseEvent;\n  }\n\n  /** CustomEvent */\n  function CustomEvent(eventTarget, event) {\n    BaseEvent.call(this, eventTarget, event);\n  }\n  CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n    constructor: {\n      value: CustomEvent,\n      configurable: true,\n      writable: true\n    }\n  });\n\n  // Define accessors.\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (!(key in BaseEvent.prototype)) {\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n      const isFunc = typeof descriptor.value === \"function\";\n      Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n    }\n  }\n  return CustomEvent;\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n  if (proto == null || proto === Object.prototype) {\n    return Event;\n  }\n  let wrapper = wrappers.get(proto);\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n    wrappers.set(proto, wrapper);\n  }\n  return wrapper;\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n  const Wrapper = getWrapper(Object.getPrototypeOf(event));\n  return new Wrapper(eventTarget, event);\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n  return pd(event).immediateStopped;\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n  pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n  pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n  pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n  return x !== null && typeof x === \"object\"; //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n  const listeners = listenersMap.get(eventTarget);\n  if (listeners == null) {\n    throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n  }\n  return listeners;\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n  return {\n    get() {\n      const listeners = getListeners(this);\n      let node = listeners.get(eventName);\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          return node.listener;\n        }\n        node = node.next;\n      }\n      return null;\n    },\n    set(listener) {\n      if (typeof listener !== \"function\" && !isObject(listener)) {\n        listener = null; // eslint-disable-line no-param-reassign\n      }\n      const listeners = getListeners(this);\n\n      // Traverse to the tail while removing old value.\n      let prev = null;\n      let node = listeners.get(eventName);\n      while (node != null) {\n        if (node.listenerType === ATTRIBUTE) {\n          // Remove old value.\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners.delete(eventName);\n          }\n        } else {\n          prev = node;\n        }\n        node = node.next;\n      }\n\n      // Add new value.\n      if (listener !== null) {\n        const newNode = {\n          listener,\n          listenerType: ATTRIBUTE,\n          passive: false,\n          once: false,\n          next: null\n        };\n        if (prev === null) {\n          listeners.set(eventName, newNode);\n        } else {\n          prev.next = newNode;\n        }\n      }\n    },\n    configurable: true,\n    enumerable: true\n  };\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n  Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n  /** CustomEventTarget */\n  function CustomEventTarget() {\n    EventTarget.call(this);\n  }\n  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n    constructor: {\n      value: CustomEventTarget,\n      configurable: true,\n      writable: true\n    }\n  });\n  for (let i = 0; i < eventNames.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n  }\n  return CustomEventTarget;\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n  /*eslint-disable consistent-return */\n  if (this instanceof EventTarget) {\n    listenersMap.set(this, new Map());\n    return;\n  }\n  if (arguments.length === 1 && Array.isArray(arguments[0])) {\n    return defineCustomEventTarget(arguments[0]);\n  }\n  if (arguments.length > 0) {\n    const types = new Array(arguments.length);\n    for (let i = 0; i < arguments.length; ++i) {\n      types[i] = arguments[i];\n    }\n    return defineCustomEventTarget(types);\n  }\n  throw new TypeError(\"Cannot call a class as a function\");\n  /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n  /**\n   * Add a given listener to this event target.\n   * @param {string} eventName The event name to add.\n   * @param {Function} listener The listener to add.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  addEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n    if (typeof listener !== \"function\" && !isObject(listener)) {\n      throw new TypeError(\"'listener' should be a function or an object.\");\n    }\n    const listeners = getListeners(this);\n    const optionsIsObj = isObject(options);\n    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    const newNode = {\n      listener,\n      listenerType,\n      passive: optionsIsObj && Boolean(options.passive),\n      once: optionsIsObj && Boolean(options.once),\n      next: null\n    };\n\n    // Set it as the first node if the first node is null.\n    let node = listeners.get(eventName);\n    if (node === undefined) {\n      listeners.set(eventName, newNode);\n      return;\n    }\n\n    // Traverse to the tail while checking duplication..\n    let prev = null;\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        // Should ignore duplication.\n        return;\n      }\n      prev = node;\n      node = node.next;\n    }\n\n    // Add it.\n    prev.next = newNode;\n  },\n  /**\n   * Remove a given listener from this event target.\n   * @param {string} eventName The event name to remove.\n   * @param {Function} listener The listener to remove.\n   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n   * @returns {void}\n   */\n  removeEventListener(eventName, listener, options) {\n    if (listener == null) {\n      return;\n    }\n    const listeners = getListeners(this);\n    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n    const listenerType = capture ? CAPTURE : BUBBLE;\n    let prev = null;\n    let node = listeners.get(eventName);\n    while (node != null) {\n      if (node.listener === listener && node.listenerType === listenerType) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n        return;\n      }\n      prev = node;\n      node = node.next;\n    }\n  },\n  /**\n   * Dispatch a given event.\n   * @param {Event|{type:string}} event The event to dispatch.\n   * @returns {boolean} `false` if canceled.\n   */\n  dispatchEvent(event) {\n    if (event == null || typeof event.type !== \"string\") {\n      throw new TypeError('\"event.type\" should be a string.');\n    }\n\n    // If listeners aren't registered, terminate.\n    const listeners = getListeners(this);\n    const eventName = event.type;\n    let node = listeners.get(eventName);\n    if (node == null) {\n      return true;\n    }\n\n    // Since we cannot rewrite several properties, so wrap object.\n    const wrappedEvent = wrapEvent(this, event);\n\n    // This doesn't process capturing phase and bubbling phase.\n    // This isn't participating in a tree.\n    let prev = null;\n    while (node != null) {\n      // Remove this listener if it's once\n      if (node.once) {\n        if (prev !== null) {\n          prev.next = node.next;\n        } else if (node.next !== null) {\n          listeners.set(eventName, node.next);\n        } else {\n          listeners.delete(eventName);\n        }\n      } else {\n        prev = node;\n      }\n\n      // Call this listener\n      setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n      if (typeof node.listener === \"function\") {\n        try {\n          node.listener.call(this, wrappedEvent);\n        } catch (err) {\n          if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(err);\n          }\n        }\n      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n        node.listener.handleEvent(wrappedEvent);\n      }\n\n      // Break if `event.stopImmediatePropagation` was called.\n      if (isStopped(wrappedEvent)) {\n        break;\n      }\n      node = node.next;\n    }\n    setPassiveListener(wrappedEvent, null);\n    setEventPhase(wrappedEvent, 0);\n    setCurrentTarget(wrappedEvent, null);\n    return !wrappedEvent.defaultPrevented;\n  }\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n  value: EventTarget,\n  configurable: true,\n  writable: true\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };","map":{"version":3,"names":["privateData","WeakMap","wrappers","pd","event","retv","get","console","assert","setCancelFlag","data","passiveListener","error","cancelable","canceled","preventDefault","Event","eventTarget","set","eventPhase","currentTarget","stopped","immediateStopped","timeStamp","Date","now","Object","defineProperty","value","enumerable","keys","i","length","key","defineRedirectDescriptor","prototype","type","target","composedPath","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","stopPropagation","stopImmediatePropagation","bubbles","Boolean","defaultPrevented","composed","srcElement","cancelBubble","returnValue","initEvent","configurable","writable","window","setPrototypeOf","defineCallDescriptor","apply","arguments","defineWrapper","BaseEvent","proto","CustomEvent","call","create","constructor","descriptor","getOwnPropertyDescriptor","isFunc","getWrapper","wrapper","getPrototypeOf","wrapEvent","Wrapper","isStopped","setEventPhase","setCurrentTarget","setPassiveListener","listenersMap","CAPTURE","BUBBLE","ATTRIBUTE","isObject","x","getListeners","listeners","TypeError","defineEventAttributeDescriptor","eventName","node","listenerType","listener","next","prev","delete","newNode","passive","once","defineEventAttribute","eventTargetPrototype","defineCustomEventTarget","eventNames","CustomEventTarget","EventTarget","Map","Array","isArray","types","addEventListener","options","optionsIsObj","capture","undefined","removeEventListener","dispatchEvent","wrappedEvent","err","handleEvent"],"sources":["../src/event.mjs","../src/event-target.mjs"],"sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}