{"ast":null,"code":"ace.define(\"ace/ext/hardwrap\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/editor\", \"ace/config\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  function hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n      var line = session.getLine(row);\n      if (line.length > max) {\n        var space = findSpace(line, max, 5);\n        if (space) {\n          var indentation = /^\\s*/.exec(line)[0];\n          session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n        }\n        endRow++;\n      } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n        var nextLine = session.getLine(row + 1);\n        if (nextLine && /\\S/.test(nextLine)) {\n          var trimmedLine = line.replace(/\\s+$/, \"\");\n          var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n          var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n          var space = findSpace(mergedLine, max, 5);\n          if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n            var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n            session.replace(replaceRange, \" \");\n            row--;\n            endRow--;\n          } else if (trimmedLine.length < line.length) {\n            session.remove(new Range(row, trimmedLine.length, row, line.length));\n          }\n        }\n      }\n      row++;\n    }\n    function findSpace(line, max, min) {\n      if (line.length < max) return;\n      var before = line.slice(0, max);\n      var after = line.slice(max);\n      var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n      var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n      var start = 0;\n      var end = 0;\n      if (spaceBefore && !spaceBefore[2]) {\n        start = max - spaceBefore[1].length;\n        end = max;\n      }\n      if (spaceAfter && !spaceAfter[2]) {\n        if (!start) start = max;\n        end = max + spaceAfter[1].length;\n      }\n      if (start) {\n        return {\n          start: start,\n          end: end\n        };\n      }\n      if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n        return {\n          start: spaceBefore.index,\n          end: spaceBefore.index + spaceBefore[2].length\n        };\n      }\n      if (spaceAfter && spaceAfter[2]) {\n        start = max + spaceAfter[2].length;\n        return {\n          start: start,\n          end: start + spaceAfter[3].length\n        };\n      }\n    }\n  }\n  function wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n      var editor = e.editor;\n      var cursor = editor.selection.cursor;\n      if (cursor.column <= editor.renderer.$printMarginColumn) return;\n      var lastDelta = editor.session.$undoManager.$lastDelta;\n      hardWrap(editor, {\n        startRow: cursor.row,\n        endRow: cursor.row,\n        allowMerge: false\n      });\n      if (lastDelta != editor.session.$undoManager.$lastDelta) editor.session.markUndoGroup();\n    }\n  }\n  var Editor = require(\"../editor\").Editor;\n  require(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n      set: function (val) {\n        if (val) {\n          this.commands.on(\"afterExec\", wrapAfterInput);\n        } else {\n          this.commands.off(\"afterExec\", wrapAfterInput);\n        }\n      },\n      value: false\n    }\n  });\n  exports.hardWrap = hardWrap;\n});\nace.define(\"ace/keyboard/vim\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/lib/event_emitter\", \"ace/lib/dom\", \"ace/lib/oop\", \"ace/lib/keys\", \"ace/lib/event\", \"ace/search\", \"ace/lib/useragent\", \"ace/search_highlight\", \"ace/commands/multi_select_commands\", \"ace/mode/text\", \"ace/ext/hardwrap\", \"ace/multi_select\"], function (require, exports, module) {\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n  'use strict';\n\n  function log() {\n    var d = \"\";\n    function format(p) {\n      if (typeof p != \"object\") return p + \"\";\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n      if (Array.isArray(p)) return \"[\" + p.map(function (x) {\n        return format(x);\n      }) + \"]\";\n      return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n    console.log(d);\n  }\n  var Range = require(\"../range\").Range;\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n  var domLib = require(\"../lib/dom\");\n  var oop = require(\"../lib/oop\");\n  var KEYS = require(\"../lib/keys\");\n  var event = require(\"../lib/event\");\n  var Search = require(\"../search\").Search;\n  var useragent = require(\"../lib/useragent\");\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n  var hardWrap = require(\"../ext/hardwrap\").hardWrap;\n  require(\"../multi_select\");\n  var CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n  CodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  };\n  CodeMirror.defineOption = function (name, val, setter) {};\n  CodeMirror.commands = {\n    redo: function (cm) {\n      cm.ace.redo();\n    },\n    undo: function (cm) {\n      cm.ace.undo();\n    },\n    newlineAndIndent: function (cm) {\n      cm.ace.insert(\"\\n\");\n    },\n    goLineLeft: function (cm) {\n      cm.ace.selection.moveCursorLineStart();\n    },\n    goLineRight: function (cm) {\n      cm.ace.selection.moveCursorLineEnd();\n    }\n  };\n  CodeMirror.keyMap = {};\n  CodeMirror.addClass = CodeMirror.rmClass = function () {};\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n  CodeMirror.keyName = function (e) {\n    var key = KEYS[e.keyCode] || e.key || \"\";\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n  CodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\") map = CodeMirror.keyMap[map] || CodeMirror.keyMap['default'];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n  CodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n  };\n  CodeMirror.findEnclosingTag = function (cm, head) {};\n  CodeMirror.signal = function (o, name, e) {\n    return o._signal(name, e);\n  };\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n  CodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n  (function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n      this.ace.off('change', this.onChange);\n      this.ace.off('changeSelection', this.onSelectionChange);\n      this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n      this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n      return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n      if (this.$lineHandleChanges) {\n        this.$lineHandleChanges.push(delta);\n      }\n      var change = {\n        text: delta.action[0] == 'i' ? delta.lines : []\n      };\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.changeHandlers) curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n      this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n      this.curOp.cursorActivity = true;\n      if (this.ace.inMultiSelectMode) {\n        this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n      }\n    };\n    this.operation = function (fn, force) {\n      if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n        return fn();\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      if (!this.ace.curOp) {\n        var prevOp = this.ace.prevOp;\n        this.ace.startOperation({\n          command: {\n            name: \"vim\",\n            scrollIntoView: \"cursor\"\n          }\n        });\n      }\n      var curOp = this.curOp = this.curOp || {};\n      this.curOp.force = force;\n      var result = fn();\n      if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n        if (this.state.dialog) this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n        this.ace.endOperation();\n        if (!curOp.cursorActivity && !curOp.lastChange && prevOp) this.ace.prevOp = prevOp;\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      return result;\n    };\n    this.onBeforeEndOperation = function () {\n      var op = this.curOp;\n      if (op) {\n        if (op.change) {\n          this.signal(\"change\", op.change, op);\n        }\n        if (op && op.cursorActivity) {\n          this.signal(\"cursorActivity\", null, op);\n        }\n        this.curOp = null;\n      }\n    };\n    this.signal = function (eventName, e, handlers) {\n      var listeners = handlers ? handlers[eventName + \"Handlers\"] : (this._eventRegistry || {})[eventName];\n      if (!listeners) return;\n      listeners = listeners.slice();\n      for (var i = 0; i < listeners.length; i++) listeners[i](this, e);\n    };\n    this.firstLine = function () {\n      return 0;\n    };\n    this.lastLine = function () {\n      return this.ace.session.getLength() - 1;\n    };\n    this.lineCount = function () {\n      return this.ace.session.getLength();\n    };\n    this.setCursor = function (line, ch) {\n      if (typeof line === 'object') {\n        ch = line.ch;\n        line = line.line;\n      }\n      var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n      if (!this.ace.inVirtualSelectionMode) this.ace.exitMultiSelectMode();\n      this.ace.session.unfold({\n        row: line,\n        column: ch\n      });\n      this.ace.selection.moveTo(line, ch);\n      if (shouldScroll) {\n        this.ace.renderer.scrollCursorIntoView();\n        this.ace.endOperation();\n      }\n    };\n    this.getCursor = function (p) {\n      var sel = this.ace.selection;\n      var pos = p == 'anchor' ? sel.isEmpty() ? sel.lead : sel.anchor : p == 'head' || !p ? sel.lead : sel.getRange()[p];\n      return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n      var ranges = this.ace.multiSelect.rangeList.ranges;\n      if (!ranges.length || this.ace.inVirtualSelectionMode) return [{\n        anchor: this.getCursor('anchor'),\n        head: this.getCursor('head')\n      }];\n      return ranges.map(function (r) {\n        return {\n          anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n          head: this.clipPos(toCmPos(r.cursor))\n        };\n      }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n      var sel = this.ace.multiSelect;\n      var ranges = p.map(function (x) {\n        var anchor = toAcePos(x.anchor);\n        var head = toAcePos(x.head);\n        var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);\n        r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n        return r;\n      });\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.selection.fromOrientedRange(ranges[0]);\n        return;\n      }\n      if (!primIndex) {\n        ranges = ranges.reverse();\n      } else if (ranges[primIndex]) {\n        ranges.push(ranges.splice(primIndex, 1)[0]);\n      }\n      sel.toSingleRange(ranges[0].clone());\n      var session = this.ace.session;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n        sel.addRange(range);\n      }\n    };\n    this.setSelection = function (a, h, options) {\n      var sel = this.ace.selection;\n      sel.moveTo(a.line, a.ch);\n      sel.selectTo(h.line, h.ch);\n      if (options && options.origin == '*mouse') {\n        this.onBeforeEndOperation();\n      }\n    };\n    this.somethingSelected = function (p) {\n      return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n      var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n      return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n      this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n      return {\n        clear: function () {},\n        find: function () {}\n      };\n    };\n    this.$updateMarkers = function (delta) {\n      var isInsert = delta.action == \"insert\";\n      var start = delta.start;\n      var end = delta.end;\n      var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n      var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n      if (isInsert) end = start;\n      for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = Range.comparePoints(point, start);\n        if (cmp < 0) {\n          continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n          if (isInsert) {\n            if (!point.$insertRight) {\n              cmp = 1;\n            } else if (point.bias == 1) {\n              cmp = 1;\n            } else {\n              point.bias = -1;\n              continue;\n            }\n          }\n        }\n        var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n        if (cmp2 > 0) {\n          point.row += rowShift;\n          point.column += point.row == end.row ? colShift : 0;\n          continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n          point.row = start.row;\n          point.column = start.column;\n          if (cmp2 === 0) point.bias = 1;\n        }\n      }\n    };\n    var Marker = function (cm, id, row, column) {\n      this.cm = cm;\n      this.id = id;\n      this.row = row;\n      this.column = column;\n      cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () {\n      delete this.cm.marks[this.id];\n    };\n    Marker.prototype.find = function () {\n      return toCmPos(this);\n    };\n    this.setBookmark = function (cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n      if (!options || !options.insertLeft) bm.$insertRight = true;\n      this.marks[bm.id] = bm;\n      return bm;\n    };\n    this.moveH = function (increment, unit) {\n      if (unit == 'char') {\n        var sel = this.ace.selection;\n        sel.clearSelection();\n        sel.moveCursorBy(0, increment);\n      }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n      if (unit == 'page') {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        amount = amount * Math.floor(config.height / config.lineHeight);\n        unit = 'line';\n      }\n      if (unit == 'line') {\n        var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n        if (goalColumn != null) screenPos.column = goalColumn;\n        screenPos.row += amount;\n        screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n        var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n        return toCmPos(pos);\n      } else {\n        debugger;\n      }\n    };\n    this.charCoords = function (pos, mode) {\n      if (mode == 'div' || !mode) {\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        return {\n          left: sc.column,\n          top: sc.row\n        };\n      }\n      if (mode == 'local') {\n        var renderer = this.ace.renderer;\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        var lh = renderer.layerConfig.lineHeight;\n        var cw = renderer.layerConfig.characterWidth;\n        var top = lh * sc.row;\n        return {\n          left: sc.column * cw,\n          top: top,\n          bottom: top + lh\n        };\n      }\n    };\n    this.coordsChar = function (pos, mode) {\n      var renderer = this.ace.renderer;\n      if (mode == 'local') {\n        var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n        var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n        var ch = renderer.session.screenToDocumentPosition(row, col);\n        return toCmPos(ch);\n      } else if (mode == 'div') {\n        throw \"not implemented\";\n      }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n      var caseSensitive = false;\n      var isRegexp = false;\n      if (query instanceof RegExp && !query.global) {\n        caseSensitive = !query.ignoreCase;\n        query = query.source;\n        isRegexp = true;\n      }\n      if (query == \"\\\\n\") {\n        query = \"\\n\";\n        isRegexp = false;\n      }\n      var search = new Search();\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var acePos = {\n        row: pos.line,\n        column: pos.ch\n      };\n      var cm = this;\n      var last = null;\n      return {\n        findNext: function () {\n          return this.find(false);\n        },\n        findPrevious: function () {\n          return this.find(true);\n        },\n        find: function (back) {\n          search.setOptions({\n            needle: query,\n            caseSensitive: caseSensitive,\n            wrap: false,\n            backwards: back,\n            regExp: isRegexp,\n            start: last || acePos\n          });\n          var range = search.find(cm.ace.session);\n          last = range;\n          return last && [!last.isEmpty()];\n        },\n        from: function () {\n          return last && toCmPos(last.start);\n        },\n        to: function () {\n          return last && toCmPos(last.end);\n        },\n        replace: function (text) {\n          if (last) {\n            last.end = cm.ace.session.doc.replace(last, text);\n          }\n        }\n      };\n    };\n    this.scrollTo = function (x, y) {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      var maxHeight = config.maxHeight;\n      maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n      if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n      if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () {\n      return 0;\n    };\n    this.scrollIntoView = function (pos, margin) {\n      if (pos) {\n        var renderer = this.ace.renderer;\n        var viewMargin = {\n          \"top\": 0,\n          \"bottom\": margin\n        };\n        renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);\n      }\n    };\n    this.getLine = function (row) {\n      return this.ace.session.getLine(row);\n    };\n    this.getRange = function (s, e) {\n      return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n      if (!e) e = s;\n      var range = new Range(s.line, s.ch, e.line, e.ch);\n      this.ace.session.$clipRangeToDocument(range);\n      return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection = this.replaceSelections = function (p) {\n      var strings = Array.isArray(p) && p;\n      var sel = this.ace.selection;\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.session.replace(sel.getRange(), strings ? p[0] || \"\" : p);\n        return;\n      }\n      sel.inVirtualSelectionMode = true;\n      var ranges = sel.rangeList.ranges;\n      if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n      for (var i = ranges.length; i--;) this.ace.session.replace(ranges[i], strings ? p[i] || \"\" : p);\n      sel.inVirtualSelectionMode = false;\n    };\n    this.getSelection = function () {\n      return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n      return this.listSelections().map(function (x) {\n        return this.getRange(x.anchor, x.head);\n      }, this);\n    };\n    this.getInputField = function () {\n      return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n      return this.ace.container;\n    };\n    var optMap = {\n      indentWithTabs: \"useSoftTabs\",\n      indentUnit: \"tabSize\",\n      tabSize: \"tabSize\",\n      firstLineNumber: \"firstLineNumber\",\n      readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n      this.state[name] = val;\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          val = !val;\n          break;\n        case 'keyMap':\n          this.state.$keyMap = val;\n          return;\n          break;\n        default:\n          name = optMap[name];\n      }\n      if (name) this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n      var val;\n      var aceOpt = optMap[name];\n      if (aceOpt) val = this.ace.getOption(aceOpt);\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          return !val;\n        case 'keyMap':\n          return this.state.$keyMap || 'vim';\n      }\n      return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n      this.state.overwrite = on;\n      return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n      if (!this.$searchHighlight || !this.$searchHighlight.session) {\n        var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n        var marker = this.ace.session.addDynamicMarker(highlight);\n        highlight.id = marker.id;\n        highlight.session = this.ace.session;\n        highlight.destroy = function (o) {\n          highlight.session.off(\"change\", highlight.updateOnChange);\n          highlight.session.off(\"changeEditor\", highlight.destroy);\n          highlight.session.removeMarker(highlight.id);\n          highlight.session = null;\n        };\n        highlight.updateOnChange = function (delta) {\n          var row = delta.start.row;\n          if (row == delta.end.row) highlight.cache[row] = undefined;else highlight.cache.splice(row, highlight.cache.length);\n        };\n        highlight.session.on(\"changeEditor\", highlight.destroy);\n        highlight.session.on(\"change\", highlight.updateOnChange);\n      }\n      var re = new RegExp(o.query.source, \"gmi\");\n      this.$searchHighlight = o.highlight = highlight;\n      this.$searchHighlight.setRegexp(re);\n      this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n      if (this.$searchHighlight && this.$searchHighlight.session) {\n        this.$searchHighlight.destroy();\n      }\n    };\n    this.getScrollInfo = function () {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      return {\n        left: renderer.scrollLeft,\n        top: renderer.scrollTop,\n        height: config.maxHeight,\n        width: config.width,\n        clientHeight: config.height,\n        clientWidth: config.width\n      };\n    };\n    this.getValue = function () {\n      return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n      return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n      var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n      return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n      var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n      return {\n        to: m && toCmPos(m)\n      };\n    };\n    this.findMatchingTag = function (pos) {\n      var m = this.ace.session.getMatchingTags(toAcePos(pos));\n      if (!m) return;\n      return {\n        open: {\n          from: toCmPos(m.openTag.start),\n          to: toCmPos(m.openTag.end)\n        },\n        close: {\n          from: toCmPos(m.closeTag.start),\n          to: toCmPos(m.closeTag.end)\n        }\n      };\n    };\n    this.indentLine = function (line, method) {\n      if (method === true) this.ace.session.indentRows(line, line, \"\\t\");else if (method === false) this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n      return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n      return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n      return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n      return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n      return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n      var re = options.bracketRegex.source;\n      var tokenRe = /paren|text|operator|tag/;\n      if (dir == 1) {\n        var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n      } else {\n        var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {\n          row: pos.line,\n          column: pos.ch + 1\n        }, tokenRe);\n        if (!m && options.bracketRegex && options.bracketRegex.test(this.getLine(pos.line)[pos.ch - 1])) {\n          m = {\n            row: pos.line,\n            column: pos.ch - 1\n          };\n        }\n      }\n      return m && {\n        pos: toCmPos(m)\n      };\n    };\n    this.refresh = function () {\n      return this.ace.resize(true);\n    };\n    this.getMode = function () {\n      return {\n        name: this.getOption(\"mode\")\n      };\n    };\n    this.execCommand = function (name) {\n      if (CodeMirror.commands.hasOwnProperty(name)) return CodeMirror.commands[name](this);\n      if (name == \"indentAuto\") return this.ace.execCommand(\"autoindent\");\n      console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n      var deltas = this.$lineHandleChanges;\n      if (!deltas) return null;\n      var row = handle.row;\n      for (var i = 0; i < deltas.length; i++) {\n        var delta = deltas[i];\n        if (delta.start.row != delta.end.row) {\n          if (delta.action[0] == \"i\") {\n            if (delta.start.row < row) row += delta.end.row - delta.start.row;\n          } else {\n            if (delta.start.row < row) {\n              if (row < delta.end.row || row == delta.end.row && delta.start.column > 0) {\n                return null;\n              }\n              row -= delta.end.row - delta.start.row;\n            }\n          }\n        }\n      }\n      return row;\n    };\n    this.getLineHandle = function (row) {\n      if (!this.$lineHandleChanges) this.$lineHandleChanges = [];\n      return {\n        text: this.ace.session.getLine(row),\n        row: row\n      };\n    };\n    this.releaseLineHandles = function () {\n      this.$lineHandleChanges = undefined;\n    };\n    this.getLastEditEnd = function () {\n      var undoManager = this.ace.session.$undoManager;\n      if (undoManager && undoManager.$lastDelta) return toCmPos(undoManager.$lastDelta.end);\n    };\n  }).call(CodeMirror.prototype);\n  function toAcePos(cmPos) {\n    return {\n      row: cmPos.line,\n      column: cmPos.ch\n    };\n  }\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n  var StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n  StringStream.prototype = {\n    eol: function () {\n      return this.pos >= this.string.length;\n    },\n    sol: function () {\n      return this.pos == this.lineStart;\n    },\n    peek: function () {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function () {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function (match) {\n      var start = this.pos;\n      while (this.eat(match)) {}\n      return this.pos > start;\n    },\n    eatSpace: function () {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function () {\n      this.pos = this.string.length;\n    },\n    skipTo: function (ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function (n) {\n      this.pos -= n;\n    },\n    column: function () {\n      throw \"not implemented\";\n    },\n    indentation: function () {\n      throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function (str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function () {\n      return this.string.slice(this.start, this.pos);\n    },\n    hideFirstChars: function (n, inner) {\n      this.lineStart += n;\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    }\n  };\n  CodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n  };\n  domLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n  (function () {\n    function dialogDiv(cm, template, bottom) {\n      var wrap = cm.ace.container;\n      var dialog;\n      dialog = wrap.appendChild(document.createElement(\"div\"));\n      if (bottom) dialog.className = \"ace_dialog ace_dialog-bottom\";else dialog.className = \"ace_dialog ace_dialog-top\";\n      if (typeof template == \"string\") {\n        dialog.innerHTML = template;\n      } else {\n        // Assuming it's a detached DOM element.\n        dialog.appendChild(template);\n      }\n      return dialog;\n    }\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n      if (this.virtualSelectionMode()) return;\n      if (!options) options = {};\n      closeNotification(this, null);\n      var dialog = dialogDiv(this, template, options.bottom);\n      var closed = false,\n        me = this;\n      this.state.dialog = dialog;\n      function close(newVal) {\n        if (typeof newVal == 'string') {\n          inp.value = newVal;\n        } else {\n          if (closed) return;\n          if (newVal && newVal.type == \"blur\") {\n            if (document.activeElement === inp) return;\n          }\n          if (me.state.dialog == dialog) {\n            me.state.dialog = null;\n            me.focus();\n          }\n          closed = true;\n          dialog.remove();\n          if (options.onClose) options.onClose(dialog);\n          var cm = me;\n          if (cm.state.vim) {\n            cm.state.vim.status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n          }\n        }\n      }\n      var inp = dialog.getElementsByTagName(\"input\")[0],\n        button;\n      if (inp) {\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) inp.select();\n        }\n        if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n          options.onInput(e, inp.value, close);\n        });\n        if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n          options.onKeyUp(e, inp.value, close);\n        });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n          if (e.keyCode == 13) callback(inp.value);\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            CodeMirror.e_stop(e);\n            close();\n          }\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n        inp.focus();\n      } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function () {\n          close();\n          me.focus();\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n      return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n      if (this.virtualSelectionMode()) return;\n      closeNotification(this, close);\n      var dialog = dialogDiv(this, template, options && options.bottom);\n      var closed = false,\n        doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n      function close() {\n        if (closed) return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n      }\n      CodeMirror.on(dialog, 'click', function (e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration) doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  })();\n  var Pos = CodeMirror.Pos;\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n    return {\n      start: curStart,\n      end: curEnd\n    };\n  }\n  var defaultKeymap = [{\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  },\n  // ipad keyboard sends C-Esc instead of C-[\n  {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<register>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<register>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  }, {\n    keys: 'gw',\n    type: 'operator',\n    operator: 'hardWrap',\n    operatorArgs: {\n      keepCursor: true\n    }\n  }, {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<register>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<register>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<register>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<register>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: '<C-r><register>',\n    type: 'action',\n    action: 'insertRegister',\n    context: 'insert',\n    isEdit: true\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'oneNormalCommand',\n    context: 'insert'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, {\n    keys: 'a<register>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<register>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'omap',\n    shortName: 'om'\n  }, {\n    name: 'noremap',\n    shortName: 'no'\n  }, {\n    name: 'nnoremap',\n    shortName: 'nn'\n  }, {\n    name: 'vnoremap',\n    shortName: 'vn'\n  }, {\n    name: 'inoremap',\n    shortName: 'ino'\n  }, {\n    name: 'onoremap',\n    shortName: 'ono'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'mapclear',\n    shortName: 'mapc'\n  }, {\n    name: 'nmapclear',\n    shortName: 'nmapc'\n  }, {\n    name: 'vmapclear',\n    shortName: 'vmapc'\n  }, {\n    name: 'imapclear',\n    shortName: 'imapc'\n  }, {\n    name: 'omapclear',\n    shortName: 'omapc'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'startinsert',\n    shortName: 'start'\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'delete',\n    shortName: 'd'\n  }, {\n    name: 'join',\n    shortName: 'j'\n  }, {\n    name: 'normal',\n    shortName: 'norm'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  var langmap = parseLangmap('');\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n    bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n  var validMarks = ['<', '>'];\n  var validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\n  var latinCharRegex = /^\\w$/;\n  var upperCaseChars;\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var options = {};\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n      type = 'string';\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  defineOption('textwidth', 80, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (width === undefined) {\n      var value = cm.getOption('textwidth');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.setOption('textwidth', column);\n      }\n    }\n  });\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined,\n      //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      changes: [],\n      expectCursorActivityForChange: false\n    };\n  };\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {\n            class: 'cm-vim-message'\n          }, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {\n            bottom: true\n          });\n        }\n        this.isRecording = true;\n      }\n    }\n  };\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      cm.state.vim = {\n        inputState: new InputState(),\n        lastEditInputState: undefined,\n        lastEditActionCommand: undefined,\n        lastHPos: -1,\n        lastHSPos: -1,\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeReturn: false,\n        insertModeRepeat: undefined,\n        visualMode: false,\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        options: {},\n        expectLiteralNext: false\n      };\n    }\n    return cm.state.vim;\n  }\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      searchQuery: null,\n      searchIsReversed: false,\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      searchHistoryController: new HistoryController(),\n      exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {},\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    mapclear: function (ctx) {\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          } else {\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        var changeQueue = vim.inputState.changeQueue;\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = keysAreChars && window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer.length) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            if (!changeQueue || changeQueue.removed.length != selections.length) changeQueue = vim.inputState.changeQueue = new ChangeQueue();\n            changeQueue.inserted += key;\n            for (var i = 0; i < selections.length; i++) {\n              var from = cursorMin(selections[i].anchor, selections[i].head);\n              var to = cursorMax(selections[i].anchor, selections[i].head);\n              var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n              changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n            }\n          }\n          return !keysAreChars;\n        }\n        vim.expectLiteralNext = false;\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (match.command && changeQueue) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(changeQueue.removed[i] || \"\", offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        if (!match.command) clearInputState(cm);\n        return match.command;\n      }\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          return true;\n        } else if (match.type == 'clear') {\n          clearInputState(cm);\n          return true;\n        }\n        vim.expectLiteralNext = false;\n        vim.inputState.keyBuffer.length = 0;\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return !vim.insertMode && key.length === 1 ? function () {\n          return true;\n        } : undefined;\n      } else if (command === true) {\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          if ((command.operator || command.isEdit) && cm.getOption('readOnly')) return; // ace_patch\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(cm, command.toKeys, command);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n  var keyToKeyStack = [];\n  var noremap = false;\n  var virtualPrompt;\n  function sendKeyToPrompt(key) {\n    if (key[0] == \"<\") {\n      var lowerKey = key.toLowerCase().slice(1, -1);\n      var parts = lowerKey.split('-');\n      lowerKey = parts.pop() || '';\n      if (lowerKey == 'lt') key = '<';else if (lowerKey == 'space') key = ' ';else if (lowerKey == 'cr') key = '\\n';else if (vimToCmKeyMap[lowerKey]) {\n        var value = virtualPrompt.value;\n        var event = {\n          key: vimToCmKeyMap[lowerKey],\n          target: {\n            value: value,\n            selectionEnd: value.length,\n            selectionStart: value.length\n          }\n        };\n        if (virtualPrompt.onKeyDown) {\n          virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n        }\n        if (virtualPrompt && virtualPrompt.onKeyUp) {\n          virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n        }\n        return;\n      }\n    }\n    if (key == '\\n') {\n      var prompt = virtualPrompt;\n      virtualPrompt = null;\n      prompt.onClose && prompt.onClose(prompt.value);\n    } else {\n      virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n    function close(value) {\n      if (typeof value == 'string') {\n        virtualPrompt.value = value;\n      } else {\n        virtualPrompt = null;\n      }\n    }\n  }\n  function doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    if (fromKey) {\n      if (keyToKeyStack.indexOf(fromKey) != -1) return;\n      keyToKeyStack.push(fromKey);\n      noremap = fromKey.noremap != false;\n    }\n    try {\n      var vim = maybeInitVimState(cm);\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n      var match;\n      while (match = keyRe.exec(keys)) {\n        var key = match[0];\n        var wasInsert = vim.insertMode;\n        if (virtualPrompt) {\n          sendKeyToPrompt(key);\n          continue;\n        }\n        var result = vimApi.handleKey(cm, key, 'mapping');\n        if (!result && wasInsert && vim.insertMode) {\n          if (key[0] == \"<\") {\n            var lowerKey = key.toLowerCase().slice(1, -1);\n            var parts = lowerKey.split('-');\n            lowerKey = parts.pop() || '';\n            if (lowerKey == 'lt') key = '<';else if (lowerKey == 'space') key = ' ';else if (lowerKey == 'cr') key = '\\n';else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n              key = vimToCmKeyMap[lowerKey];\n              sendCmKey(cm, key);\n              continue;\n            } else {\n              key = key[0];\n              keyRe.lastIndex = match.index + 1;\n            }\n          }\n          cm.replaceSelection(key);\n        }\n      }\n    } finally {\n      keyToKeyStack.pop();\n      noremap = keyToKeyStack.length ? noremapBefore : false;\n      if (!keyToKeyStack.length && virtualPrompt) {\n        var promptOptions = virtualPrompt;\n        virtualPrompt = null;\n        showPrompt(cm, promptOptions);\n      }\n    }\n  }\n  var specialKey = {\n    Return: 'CR',\n    Backspace: 'BS',\n    'Delete': 'Del',\n    Escape: 'Esc',\n    Insert: 'Ins',\n    ArrowLeft: 'Left',\n    ArrowRight: 'Right',\n    ArrowUp: 'Up',\n    ArrowDown: 'Down',\n    Enter: 'CR',\n    ' ': 'Space'\n  };\n  var ignoredKeys = {\n    Shift: 1,\n    Alt: 1,\n    Command: 1,\n    Control: 1,\n    CapsLock: 1,\n    AltGraph: 1,\n    Dead: 1,\n    Unidentified: 1\n  };\n  var vimToCmKeyMap = {};\n  'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function (x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()] = vimToCmKeyMap[x.toLowerCase()] = x;\n  });\n  function vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key]) return;\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if (e.metaKey) {\n      name += 'M-';\n    }\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n      name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl != false || !name) key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code && e.code.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  ;\n  function updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n      langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n  }\n  function parseLangmap(langmapString) {\n    var keymap = {};\n    if (!langmapString) return {\n      keymap: keymap,\n      string: ''\n    };\n    function getEscaped(list) {\n      return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(function (part) {\n      if (!part) return;\n      var semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n      if (semicolon.length == 3) {\n        var from = getEscaped(semicolon[1]);\n        var to = getEscaped(semicolon[2]);\n        if (from.length !== to.length) return; // skip over malformed part\n        for (var i = 0; i < from.length; ++i) keymap[from[i]] = to[i];\n      } else if (semicolon.length == 1) {\n        var pairs = getEscaped(part);\n        if (pairs.length % 2 !== 0) return; // skip over malformed part\n        for (var i = 0; i < pairs.length; i += 2) keymap[pairs[i]] = pairs[i + 1];\n      }\n    });\n    return {\n      keymap: keymap,\n      string: langmapString\n    };\n  }\n  defineOption('langmap', undefined, 'string', ['lmap'], function (name, cm) {\n    if (name === undefined) {\n      return langmap.string;\n    } else {\n      updateLangmap(name);\n    }\n  });\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n    this.changeQueue = null; // For restoring text used by insert mode keybindings\n  }\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n    return repeat;\n  };\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n  function ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n  }\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n  Register.prototype = {\n    setText: function (text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n      this.searchQueries.push(query);\n    },\n    clear: function () {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function () {\n      return this.keyBuffer.join('');\n    }\n  };\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n  }\n  RegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+' && typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined' && typeof navigator.clipboard.readText === 'function') {\n        navigator.clipboard.writeText(text);\n      }\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    },\n    isValidRegister: function (name) {\n      return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    },\n    shiftNumericRegisters_: function () {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n  HistoryController.prototype = {\n    nextMatch: function (input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      if (i < 0) return input;\n    },\n    pushInput: function (input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function () {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial',\n          expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n        };\n      }\n      var bestMatch;\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {\n          type: 'clear'\n        };\n        inputState.selectedCharacter = character;\n      }\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n        default:\n          break;\n      }\n    },\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n      function onPromptClose(query) {\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function onPromptKeyUp(e, query, close) {\n        var keyName = vimKeyFromEvent(e),\n          up,\n          offset;\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {}\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      function onPromptKeyDown(e, query, close) {\n        var keyName = vimKeyFromEvent(e);\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' || keyName == '<BS>' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == '<C-u>') {\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: '(JavaScript regexp)',\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, {\n            noSymbol: true\n          });\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, {\n              noSymbol: false\n            });\n            isKeyword = false;\n          }\n          if (!word) {\n            showConfirm(cm, 'No word under cursor');\n            clearInputState(cm);\n            return;\n          }\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    processEx: function (cm, vim, command) {\n      function onPromptClose(input) {\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n      function onPromptKeyDown(e, input, close) {\n        var keyName = vimKeyFromEvent(e),\n          up,\n          offset;\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' || keyName == '<BS>' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == '<C-u>') {\n          CodeMirror.e_stop(e);\n          close('');\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function (cm, vim) {\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          if (!operator && cm.ace.curOp != null) cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n          var jumpList = vimGlobalState.jumpList;\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          if (cm.ace.curOp) cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n        if (vim.visualMode) {\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n      if (!next) {\n        return;\n      }\n      if (prevInputState.operator) {\n        return next;\n      }\n      var from = next[0];\n      var to = new Pos(next[1].line, next[1].ch - 1);\n      if (vim.visualMode) {\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n            return [anchor, from];\n          }\n        }\n      } else {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n          if (isWrongDirection) {\n            continue;\n          }\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n      if (motionArgs.linewise) {\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      var fold = cm.ace.session.getFoldLine(line);\n      if (fold) {\n        if (motionArgs.forward) {\n          if (line > fold.start.row) line = fold.end.row + 1;\n        } else {\n          line = fold.start.row;\n        }\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n        var matched = cm.findMatchingBracket(new Pos(line, ch + 1), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter;\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp, move;\n      if (mirroredPairs[character]) {\n        move = true;\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n        if (!tmp) {\n          var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n          if (sc.find()) {\n            tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n          }\n        }\n      } else if (selfPaired[character]) {\n        move = true;\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W' || character === 'w') {\n        var repeat = motionArgs.repeat || 1;\n        while (repeat-- > 0) {\n          var repeated = expandWordUnderCursor(cm, {\n            inclusive: inclusive,\n            innerWord: !inclusive,\n            bigWord: character === 'W',\n            noSymbol: character === 'W',\n            multiline: true\n          }, tmp && tmp.end);\n          if (repeated) {\n            if (!tmp) tmp = repeated;\n            tmp.end = repeated.end;\n          }\n        }\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n          start = {\n            line: start.line,\n            ch: start.ch + 1\n          };\n        }\n        tmp = {\n          start: start,\n          end: end\n        };\n      }\n      if (!tmp) {\n        return null;\n      }\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end, move);\n      }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n        head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        if (args.linewise) {\n          anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n          if (head.line > anchor.line) {\n            head = new Pos(head.line - 1, Number.MAX_VALUE);\n          }\n        }\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n      if (cm.indentMore) {\n        var repeat = vim.visualMode ? args.repeat : 1;\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        var repeat = vim.visualMode ? args.repeat : 1;\n        if (args.linewise) {\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n      if (!cm.hardWrap) return;\n      var from = ranges[0].anchor.line;\n      var to = ranges[0].head.line;\n      if (operatorArgs.linewise) to--;\n      var endRow = cm.hardWrap({\n        from: from,\n        to: to\n      });\n      if (endRow > from && operatorArgs.linewise) endRow--;\n      return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n      cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center':\n          y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        cm.on('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(head, {\n          insertLeft: true\n        });\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      if (!vim.visualMode) {\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var _this = this;\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      var fallback = function () {\n        var text = register.toString();\n        _this.continuePaste(cm, actionArgs, vim, text, register);\n      };\n      if (actionArgs.registerName === '+' && typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined' && typeof navigator.clipboard.readText === 'function') {\n        navigator.clipboard.readText().then(function (value) {\n          _this.continuePaste(cm, actionArgs, vim, value, register);\n        }, function () {\n          fallback();\n        });\n      } else {\n        fallback();\n      }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        var whitespaceLength = function (str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        text = text.split('\\n');\n        if (linewise) {\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      if (vim.visualMode) {\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          cm.replaceSelections(emptyStrings);\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          if (linewise) {\n            var line = actionArgs.after ? cur.line + 1 : cur.line;\n            curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n          } else {\n            curPosFinal = copyCursor(cur);\n            if (!/\\n/.test(text)) {\n              curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n            }\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      var text = register && register.toString();\n      if (text) {\n        cm.replaceSelection(text);\n      }\n    },\n    oneNormalCommand: function (cm, actionArgs, vim) {\n      exitInsertMode(cm, true);\n      vim.insertModeReturn = true;\n      CodeMirror.on(cm, 'vim-command-done', function handler() {\n        if (vim.visualMode) return;\n        if (vim.insertModeReturn) {\n          vim.insertModeReturn = false;\n          if (!vim.insertMode) {\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        }\n        CodeMirror.off(cm, 'vim-command-done', handler);\n      });\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n        direction = -1;\n      }\n      ch += direction;\n      if (ch > maxCh) ch -= 2;\n    }\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    if (inputState.operator) context = \"operatorPending\";\n    var match,\n      partial = [],\n      full = [];\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n      if (match == 'partial') {\n        partial.push(command);\n      }\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  function commandMatch(pressed, mapped) {\n    var isLastCharacter = mapped.slice(-11) == '<character>';\n    var isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n      var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  function cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n    cm.setSelections(sel, 0);\n  }\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n  function expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start : sel.head;\n    var anchor = move ? start : sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n        fromCh = anchor.ch,\n        bottom = Math.max(anchor.line, head.line),\n        toCh = head.ch;\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n      ;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  }\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      lines.pop();\n      var line;\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n  function expandWordUnderCursor(cm, _a, cursor) {\n    var inclusive = _a.inclusive,\n      innerWord = _a.innerWord,\n      bigWord = _a.bigWord,\n      noSymbol = _a.noSymbol,\n      multiline = _a.multiline;\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n    var wordOnNextLine;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n      test = function (ch) {\n        return /\\s/.test(ch);\n      };\n    } else {\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n          if (!multiline) return null;\n          idx--;\n          wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n          break;\n        }\n      }\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n    }\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n    if (wordOnNextLine) {\n      end = wordOnNextLine.to;\n      endLineNumber = wordOnNextLine.line;\n      endLine = cm.getLine(endLineNumber);\n      if (!endLine && end == 0) end++;\n    } else {\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n    }\n    if (inclusive) {\n      var wordEnd = end;\n      var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n      if (!startsWithSpace) {\n        while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) {\n          end++;\n        }\n      }\n      if (wordEnd == end || startsWithSpace) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start && !startsWithSpace) {\n          start = wordStart;\n        }\n      }\n    }\n    return {\n      start: new Pos(startLineNumber, start),\n      end: new Pos(endLineNumber, end)\n    };\n  }\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    method: {\n      init: function (state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0) return true;\n        }\n        return false;\n      }\n    }\n  };\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n  }\n  function moveToCharacter(cm, repeat, forward, character, head) {\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return null;\n      }\n      start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n  }\n  function moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    function isEmpty(i) {\n      return !/\\S/.test(cm.getLine(i));\n    } // ace_patch\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n      dir = dir > 0 ? 1 : -1;\n      var foldLine = cm.ace.session.getFoldLine(i);\n      if (foldLine) {\n        if (i + dir > foldLine.start.row && i + dir < foldLine.end.row) dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n      }\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        skipFold(i);\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      } else {\n        curr.pos += curr.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos + 1\n            };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos + 1\n            };\n          }\n        }\n        nextChar(curr);\n      }\n      return {\n        ln: curr.ln,\n        pos: lastSentencePos + 1\n      };\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos\n            };\n          } else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return {\n                ln: curr.ln,\n                pos: curr.pos + 1\n              };\n            } else {\n              return {\n                ln: curr.ln,\n                pos: lastSentencePos\n              };\n            }\n          }\n        }\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      } else {\n        return {\n          ln: curr.ln,\n          pos: lastSentencePos\n        };\n      }\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n      start,\n      end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    if (!start || !end) return null;\n    start = start.pos;\n    end = end.pos;\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n      var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n      var isStringStart = stringAfter && !stringBefore;\n      if (!isStringStart) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n    }\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  defineOption('pcre', true, 'boolean');\n  function SearchState() {}\n  SearchState.prototype = {\n    getQuery: function () {\n      return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n      return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n      this.annotate = annotate;\n    }\n  };\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n    return slashes;\n  }\n  function translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t',\n    '\\\\&': '&'\n  };\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n  function parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n      return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      regexPart = query;\n    } else {\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n    return regexp;\n  }\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n  function showConfirm(cm, template) {\n    var pre = dom('div', {\n      $color: 'red',\n      $whiteSpace: 'pre',\n      class: 'cm-vim-message'\n    }, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  function makePrompt(prefix, desc) {\n    return dom('div', {\n      $display: 'flex'\n    }, dom('span', {\n      $fontFamily: 'monospace',\n      $whiteSpace: 'pre',\n      $flex: 1\n    }, prefix, dom('input', {\n      type: 'text',\n      autocorrect: 'off',\n      autocapitalize: 'off',\n      spellcheck: 'false',\n      $width: '100%'\n    })), desc && dom('span', {\n      $color: '#888'\n    }, desc));\n  }\n  function showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n      if (!options.value) options.value = '';\n      virtualPrompt = options;\n      return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      searchState.highlightTimeout = null;\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  function findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      var found = cursor.find(!prev);\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n      clearTimeout(state.highlightTimeout);\n      state.highlightTimeout = null;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  function getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n      top: renderer.getFirstFullyVisibleRow(),\n      bottom: renderer.getLastFullyVisibleRow()\n    };\n  }\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n  function getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n      return cm.getLastEditEnd();\n    }\n    var done = cm.doc.history.done;\n    for (var i = done.length; i--;) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n  var ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n  };\n  ExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function (cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      var inputStream = new CodeMirror.StringStream(input);\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            doKeyToKey(cm, command.toKeys, command);\n            return;\n          } else if (command.type == 'exToEx') {\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function (cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n      if (result.line == undefined) {\n        if (cm.state.vim.visualMode) {\n          var pos = getMarkPos(cm, cm.state.vim, '<');\n          result.selectionLine = pos && pos.line;\n          pos = getMarkPos(cm, cm.state.vim, '>');\n          result.selectionLineEnd = pos && pos.line;\n        } else {\n          result.selectionLine = cm.getCursor().line;\n        }\n      } else {\n        result.selectionLine = result.line;\n        result.selectionLineEnd = result.lineEnd;\n      }\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n      return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function (commandName) {\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    },\n    buildCommandMap_: function () {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function (lhs, rhs, ctx, noremap) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        var mapping = {\n          keys: lhs,\n          type: 'keyToKey',\n          toKeys: rhs,\n          noremap: !!noremap\n        };\n        if (ctx) {\n          mapping.context = ctx;\n        }\n        defaultKeymap.unshift(mapping);\n      }\n    },\n    unmap: function (lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx, defaultOnly) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    imap: function (cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function (cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function (cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    omap: function (cm, params) {\n      this.map(cm, params, 'operatorPending');\n    },\n    noremap: function (cm, params) {\n      this.map(cm, params, undefined, true);\n    },\n    inoremap: function (cm, params) {\n      this.map(cm, params, 'insert', true);\n    },\n    nnoremap: function (cm, params) {\n      this.map(cm, params, 'normal', true);\n    },\n    vnoremap: function (cm, params) {\n      this.map(cm, params, 'visual', true);\n    },\n    onoremap: function (cm, params) {\n      this.map(cm, params, 'operatorPending', true);\n    },\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    mapclear: function (cm, params) {\n      vimApi.mapclear();\n    },\n    imapclear: function (cm, params) {\n      vimApi.mapclear('insert');\n    },\n    nmapclear: function (cm, params) {\n      vimApi.mapclear('normal');\n    },\n    vmapclear: function (cm, params) {\n      vimApi.mapclear('visual');\n    },\n    omapclear: function (cm, params) {\n      vimApi.mapclear('operatorPending');\n    },\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function (cm, params) {\n      var setArgs = params.args;\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n      var forceToggle = false;\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      } else if (optionName.charAt(optionName.length - 1) == '!') {\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceToggle = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        optionName = optionName.substring(2);\n        value = false;\n      }\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean) {\n        if (forceToggle) {\n          value = !getOption(optionName, cm, setCfg);\n        } else if (value == undefined) {\n          value = true;\n        }\n      }\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function (cm, params) {\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat('!')) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n      this.global(cm, params);\n    },\n    normal: function (cm, params) {\n      var argString = params.argString;\n      if (argString && argString[0] == '!') {\n        argString = argString.slice(1);\n        noremap = true;\n      }\n      argString = argString.trimStart();\n      if (!argString) {\n        showConfirm(cm, 'Argument is required.');\n        return;\n      }\n      var line = params.line;\n      if (typeof line == 'number') {\n        var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n        for (var i = line; i <= lineEnd; i++) {\n          cm.setCursor(i, 0);\n          doKeyToKey(cm, params.argString.trimStart());\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      } else {\n        doKeyToKey(cm, params.argString.trimStart());\n        if (cm.state.vim.insertMode) {\n          exitInsertMode(cm, true);\n        }\n      }\n    },\n    global: function (cm, params) {\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      if (argString[0] === '!' && params.commandName[0] === 'g') {\n        inverted = true;\n        argString = argString.slice(1);\n      }\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd;\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLine(i);\n        var matched = query.test(line);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n        }\n      }\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var lineHandle = matchedLines[index++];\n          var lineNum = cm.getLineNumber(lineHandle);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        } else if (cm.releaseLineHandles) {\n          cm.releaseLineHandles();\n        }\n      };\n      nextCommand();\n    },\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n        replacePart = '',\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    startinsert: function (cm, params) {\n      doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        cm.save();\n      }\n    },\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delete: function (cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      operators.delete(cm, {\n        linewise: true\n      }, [{\n        anchor: new Pos(line, 0),\n        head: new Pos(lineEnd + 1, 0)\n      }]);\n    },\n    join: function (cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      cm.setCursor(new Pos(line, 0));\n      actions.joinLines(cm, {\n        repeat: lineEnd - line\n      }, cm.state.vim);\n    },\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n        var count = stream.pos;\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n        var sym = stream.next();\n        if (stream.match('-', true)) {\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var startMark = sym;\n          var finishMark = stream.next();\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    function onPromptKeyDown(e, _value, close) {\n      CodeMirror.e_stop(e);\n      var keyName = vimKeyFromEvent(e);\n      switch (keyName) {\n        case 'y':\n          replace();\n          next();\n          break;\n        case 'n':\n          next();\n          break;\n        case 'a':\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'l':\n          replace();\n        case 'q':\n        case '<Esc>':\n        case '<C-c>':\n        case '<C-[>':\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n  function exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      if (vim.insertEnd) vim.insertEnd.clear();\n      vim.insertEnd = null;\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) command[key] = extra[key];\n    _mapCommand(command);\n  }\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      while (text) {\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      var vim = cm.state.vim;\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              if (text.length > 1) {\n                var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                var cursor = cm.getCursor();\n                if (insertEnd && insertEnd.line == cursor.line) {\n                  var offset = insertEnd.ch - cursor.ch;\n                  if (offset > 0 && offset < text.length) {\n                    lastChange.changes.push([text, offset]);\n                    text = '';\n                  }\n                }\n              }\n              if (text) lastChange.changes.push(text);\n            }\n          }\n        }\n        changeObj = changeObj.next;\n      }\n    }\n  }\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        lastChange.maybeReset = true;\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(cm.getCursor(), {\n          insertLeft: true\n        });\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  function handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n    if (vim.visualMode) {\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode && !keepHPos) {\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n  function InsertModeKey(keyName, e) {\n    this.keyName = keyName;\n    this.key = e.key;\n    this.ctrlKey = e.ctrlKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    this.shiftKey = e.shiftKey;\n  }\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n    if (!keyName) {\n      return;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n  }\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  function sendCmKey(cm, key) {\n    CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    });\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          sendCmKey(cm, change.keyName, change);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n          cm.replaceRange(change[0], start, change[1] ? start : end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n  CodeMirror.Vim = vimApi;\n  var specialKeyAce = {\n    'return': 'CR',\n    backspace: 'BS',\n    'delete': 'Del',\n    esc: 'Esc',\n    left: 'Left',\n    right: 'Right',\n    up: 'Up',\n    down: 'Down',\n    space: 'Space',\n    insert: 'Ins',\n    home: 'Home',\n    end: 'End',\n    pageup: 'PageUp',\n    pagedown: 'PageDown',\n    enter: 'CR'\n  };\n  function lookupKey(hashId, key, e, vim) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKeyAce[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl !== false || !name) key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code && e.code.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  var handleKey = vimApi.handleKey.bind(vimApi);\n  vimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n      return handleKey(cm, key, origin);\n    }, true);\n  };\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      if (key == \"insertEnd\") return;\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      var changeQueueList = vim.inputState.changeQueueList || [];\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        var index = 0;\n        cm.ace.forEachSelection(function () {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          cm.state.vim.inputState.changeQueue = changeQueueList[index];\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n          if (cm.ace.inVirtualSelectionMode) {\n            changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n          }\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n          index++;\n        });\n        if (cm.curOp.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n        vim.status = cm.state.vim.status;\n        cm.state.vim = vim;\n        vim.inputState.changeQueueList = changeQueueList;\n        vim.inputState.changeQueue = null;\n      }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n  }\n  resetVimGlobalState();\n  exports.CodeMirror = CodeMirror;\n  var getVim = vimApi.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w) left -= w;\n      }\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n      domLib.translate(element, left, top);\n      domLib.setStyle(element.style, \"width\", w + \"px\");\n      domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (!vim.insertMode) {\n        return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n      }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4) key = key.toUpperCase();\n            }\n          }\n          data.inputChar = key;\n        } else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1;\n          } else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        } else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n      if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n        return {\n          command: \"gotoleft\"\n        };\n      }\n      if (key == \"c\" && hashId == 1) {\n        // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function () {\n            if (vim.insertMode) editor.selection.clearSelection();else cm.operation(function () {\n              exitVisualMode(cm);\n            });\n          });\n          return {\n            command: \"null\",\n            passEvent: true\n          };\n        }\n      }\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {}, vim);\n        if (vim.status == null) vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n        if (isHandled && vim.status != null) vim.status += name;else if (vim.status == null) vim.status = \"\";\n        cm._signal(\"changeStatus\");\n        if (!isHandled && (hashId != -1 || insertMode)) return;\n        return {\n          command: \"null\",\n          passEvent: !isHandled\n        };\n      }\n    },\n    attach: function (editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      enterVimMode(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function () {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n        cm.ace._signal(\"changeStatus\");\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function () {\n        cm.ace.renderer.updateCursor();\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function () {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n        cm._signal(\"changeStatus\");\n      });\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n      var cm = editor.state.cm;\n      leaveVimMode(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode) return \"INSERT\";\n      var status = \"\";\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine) status += \" LINE\";\n        if (vim.visualBlock) status += \" BLOCK\";\n      }\n      if (vim.status) status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  vimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n      if (cm) {\n        cm.ace.setOption(\"wrap\", value);\n      }\n    },\n    type: \"boolean\"\n  }, false);\n  vimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n  });\n  defaultKeymap.push({\n    keys: 'zc',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false\n    }\n  }, {\n    keys: 'zC',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false,\n      all: true\n    }\n  }, {\n    keys: 'zo',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true\n    }\n  }, {\n    keys: 'zO',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'za',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true\n    }\n  }, {\n    keys: 'zA',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true,\n      all: true\n    }\n  }, {\n    keys: 'zf',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'zd',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: '<C-A-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAbove\"\n    }\n  }, {\n    keys: '<C-A-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelow\"\n    }\n  }, {\n    keys: '<C-A-S-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAboveSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-S-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelowSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreBefore\"\n    }\n  }, {\n    keys: '<C-A-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreAfter\"\n    }\n  }, {\n    keys: '<C-A-S-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextBefore\"\n    }\n  }, {\n    keys: '<C-A-S-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextAfter\"\n    }\n  });\n  defaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  });\n  vimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise) head--;\n    hardWrap(cm.ace, {\n      startRow: anchor,\n      endRow: head\n    });\n    return Pos(head, 0);\n  });\n  defineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (width === undefined) {\n      var value = cm.ace.getOption('printMarginColumn');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.ace.setOption('printMarginColumn', column);\n      }\n    }\n  });\n  actions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode) cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);else delayedExecAceCommand(null, cm.ace);\n  };\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n  }\n  actions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n  defaultKeymapLength = defaultKeymap.length; // ace_patch\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = vimApi;\n});\n(function () {\n  ace.require([\"ace/keyboard/vim\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"names":["ace","define","require","exports","module","Range","hardWrap","editor","options","max","column","getOption","allowMerge","row","Math","min","startRow","endRow","session","line","getLine","length","space","findSpace","indentation","exec","replace","start","end","test","nextLine","trimmedLine","trimmedNextLine","mergedLine","replaceRange","remove","before","slice","after","spaceAfter","spaceBefore","index","wrapAfterInput","e","command","name","args","cursor","selection","renderer","$printMarginColumn","lastDelta","$undoManager","$lastDelta","markUndoGroup","Editor","defineOptions","prototype","set","val","commands","on","off","value","log","d","format","p","ch","anchor","head","Array","isArray","map","x","JSON","stringify","i","arguments","f","console","EventEmitter","domLib","oop","KEYS","event","Search","useragent","SearchHighlight","multiSelectCommands","TextModeTokenRe","Mode","tokenRe","CodeMirror","state","marks","$uid","onChange","bind","onSelectionChange","onBeforeEndOperation","Pos","defineOption","setter","redo","cm","undo","newlineAndIndent","insert","goLineLeft","moveCursorLineStart","goLineRight","moveCursorLineEnd","keyMap","addClass","rmClass","e_stop","e_preventDefault","stopEvent","keyName","key","keyCode","toUpperCase","getModifierString","m","cmd","commandKeyBinding","toLowerCase","execCommand","lookupKey","handle","found","fallthrough","result","findMatchingTag","findEnclosingTag","signal","o","_signal","addListener","removeListener","isWordChar","lastIndex","implement","destroy","removeOverlay","virtualSelectionMode","inVirtualSelectionMode","delta","$lineHandleChanges","push","change","text","action","lines","curOp","changeHandlers","_eventRegistry","lastChange","next","$updateMarkers","cursorActivityHandlers","cursorActivity","inMultiSelectMode","keyBinding","removeKeyboardHandler","keyboardHandler","operation","fn","force","prevOp","startOperation","scrollIntoView","dialog","vimDialogScroll","endOperation","op","eventName","handlers","listeners","firstLine","lastLine","getLength","lineCount","setCursor","shouldScroll","exitMultiSelectMode","unfold","moveTo","scrollCursorIntoView","getCursor","sel","pos","isEmpty","lead","getRange","toCmPos","listSelections","ranges","multiSelect","rangeList","r","clipPos","setSelections","primIndex","toAcePos","comparePoints","fromPoints","fromOrientedRange","reverse","splice","toSingleRange","clone","range","$clipRangeToDocument","addRange","setSelection","a","h","selectTo","origin","somethingSelected","$clipPositionToDocument","foldCode","$toggleFoldWidget","markText","clear","find","isInsert","rowShift","colShift","point","cmp","$insertRight","bias","cmp2","Marker","id","setBookmark","bm","insertLeft","moveH","increment","unit","clearSelection","moveCursorBy","findPosV","amount","goalColumn","config","layerConfig","floor","height","lineHeight","screenPos","documentToScreenPosition","getScreenLength","screenToDocumentPosition","charCoords","mode","sc","left","top","lh","cw","characterWidth","bottom","coordsChar","col","getSearchCursor","query","caseFold","caseSensitive","isRegexp","RegExp","global","ignoreCase","source","search","undefined","Number","MAX_VALUE","acePos","last","findNext","findPrevious","back","setOptions","needle","wrap","backwards","regExp","from","to","doc","scrollTo","y","maxHeight","$size","scrollerHeight","$scrollPastEnd","setScrollTop","setScrollLeft","width","scrollInfo","margin","viewMargin","s","getTextRange","replaceSelection","replaceSelections","strings","getSelection","getSelectedText","getSelections","getInputField","textInput","getElement","getWrapperElement","container","optMap","indentWithTabs","indentUnit","tabSize","firstLineNumber","readOnly","setOption","$keyMap","aceOpt","toggleOverwrite","overwrite","setOverwrite","addOverlay","$searchHighlight","highlight","marker","addDynamicMarker","updateOnChange","removeMarker","cache","re","setRegexp","updateBackMarkers","getScrollInfo","scrollLeft","scrollTop","clientHeight","clientWidth","getValue","setValue","v","getTokenTypeAt","token","getTokenAt","type","findMatchingBracket","getMatchingTags","open","openTag","close","closeTag","indentLine","method","indentRows","outdentRows","indexFromPos","positionToIndex","posFromIndex","indexToPosition","focus","blur","defaultTextHeight","scanForBracket","dir","_","bracketRegex","$findClosingBracket","$findOpeningBracket","refresh","resize","getMode","hasOwnProperty","getLineNumber","deltas","getLineHandle","releaseLineHandles","getLastEditEnd","undoManager","call","cmPos","StringStream","string","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","charAt","eat","match","ok","eatWhile","eatSpace","skipToEnd","skipTo","indexOf","backUp","n","pattern","consume","caseInsensitive","cased","str","substr","current","hideFirstChars","inner","defineExtension","importCssString","dialogDiv","template","appendChild","document","createElement","className","innerHTML","closeNotification","newVal","currentNotificationClose","callback","closed","me","inp","activeElement","onClose","vim","status","$loop","schedule","CHANGE_CURSOR","getElementsByTagName","button","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","closeOnEnter","closeOnBlur","doneTimer","duration","clearTimeout","setTimeout","updateSelectionForSurrogateCharacters","curStart","curEnd","charCode","charCodeAt","defaultKeymap","keys","toKeys","context","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","keepCursor","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","langmap","parseLangmap","enterVimMode","onCursorActivity","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","onPasteFn","insertMode","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","validMarks","validRegisters","latinCharRegex","upperCaseChars","isLine","isLowerCase","k","isMatchableSymbol","isNumber","isUpperCase","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","round","createCircularJumpList","size","pointer","tail","buffer","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","dom","class","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeReturn","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","expectLiteralNext","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","mapclear","actualLength","origLength","userKeymap","mapping","_mapCommand","contexts","j","newMapping","updateLangmap","vimKeyFromEvent","defineEx","prefix","func","exCommands","commandMap_","handleKey","findKey","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","handleKeyInsertMode","keyBuffer","join","keysAreChars","commandDispatcher","matchCommand","changeQueue","window","selections","removed","ChangeQueue","inserted","cursorMin","cursorMax","here","pop","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","doKeyToKey","processCommand","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","keyToKeyStack","virtualPrompt","sendKeyToPrompt","lowerKey","parts","split","vimToCmKeyMap","target","selectionEnd","selectionStart","prompt","fromKey","noremapBefore","keyRe","wasInsert","sendCmKey","promptOptions","showPrompt","specialKey","Return","Backspace","Escape","Insert","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Enter","ignoredKeys","Shift","Alt","Command","Control","CapsLock","AltGraph","Dead","Unidentified","concat","Object","forEach","ctrlKey","altKey","metaKey","isMac","shiftKey","keymap","remapCtrl","code","langmapString","getEscaped","list","filter","Boolean","part","semicolon","pairs","prefixRepeat","motionRepeat","getRepeat","repeat","parseInt","reason","Register","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","navigator","clipboard","readText","writeText","historyBuffer","iterator","initialPrefix","nextMatch","up","element","substring","pushInput","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","smartCase","updateSearchQuery","showConfirm","onPromptClose","logSearchQuery","onPromptKeyUp","parsedQuery","clearSearchHighlight","onPromptKeyDown","shift","desc","word","expandWordUnderCursor","noSymbol","isKeyword","escapeRegex","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","cmSel","newPositions","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","cur","prev","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","moveToStartOfLine","fold","getFoldLine","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","matched","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","repeated","innerWord","multiline","expandTagUnderCursor","content","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","fillArray","times","finalHead","lastState","replacement","delete","indent","indentMore","indentLess","startLine","endLine","indentAuto","_args","changeCase","swapped","toSwap","yank","endPos","jumpListWalk","scroll","newPos","cursorCoords","ceil","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","newPosition","getLastEditPos","insertEnd","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","nextStartCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","_this","fallback","continuePaste","then","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","lastCh","extendLineToColumn","repeatFn","setRegister","insertRegister","oneNormalCommand","handler","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","direction","ret","prop","offsetLine","offsetCh","startIndex","commandMatch","pressed","mapped","isLastCharacter","isLastRegister","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","apply","cur3","cur1before2","cur2before3","trim","isClipped","curHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","_a","startLineNumber","endLineNumber","idx","wordOnNextLine","findWord","startsWithSpace","wordStart","tags","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","preprocess","curCh","lineLen","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isBoundary","any","skipFold","foldLine","startState","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","chars","len","firstIndex","stringAfter","stringBefore","isStringStart","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","output","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","createTextNode","nodeType","setAttribute","pre","$color","$whiteSpace","openNotification","alert","innerText","makePrompt","$display","$fontFamily","$flex","autocorrect","autocapitalize","spellcheck","$width","shortText","textContent","regexEqual","r1","r2","props","rawQuery","matchSol","searchState","showMatchesOnScrollbar","lastEndPos","isInRange","getFirstFullyVisibleRow","getLastFullyVisibleRow","done","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","selectionLine","selectionLineEnd","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","defaultOnly","mapArgs","imap","nmap","vmap","omap","inoremap","nnoremap","vnoremap","onoremap","imapclear","nmapclear","vmapclear","omapclear","setArgs","setCfg","expr","forceGet","forceToggle","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","parseArgs","opts","decimal","hex","octal","err","radix","numPart","textPart","matchPart","compareFn","b","anum","bnum","comparePatternFn","textOld","vglobal","normal","trimStart","isNaN","inverted","matchedLines","nextCommand","lineHandle","substitute","replacePart","trailing","count","confirm","startPos","doReplace","startinsert","write","save","nohlsearch","delmarks","sym","startMark","finishMark","finish","String","fromCharCode","searchCursor","exMode","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","Vim","specialKeyAce","backspace","esc","right","down","home","pageup","pagedown","enter","hashId","cloneVimState","constructor","isHandled","wasInVisualBlock","wasMultiselect","old","changeQueueList","forEachSelection","$desiredColumn","getVim","$id","drawCursor","pixelPos","w","isbackwards","isBackwards","translate","setStyle","$getDirectionForHighlight","handleKeyboard","data","inputKey","inputHash","inputChar","getCopyText","once","passEvent","attach","$vimModeHandler","updateCursor","updateInputMode","isIntsert","setCommandMode","$keepTextAreaAtCursor","$blockCursor","$cursorLayer","detach","getStatusText","all","toggle","aceCommand","vimCmd","delayedExecAceCommand"],"sources":["/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/node_modules/ace-builds/src-noconflict/keybinding-vim.js"],"sourcesContent":["ace.define(\"ace/ext/hardwrap\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/editor\",\"ace/config\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nfunction hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n        var line = session.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = /^\\s*/.exec(line)[0];\n                session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n            }\n            endRow++;\n        }\n        else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = session.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n                    session.replace(replaceRange, \" \");\n                    row--;\n                    endRow--;\n                }\n                else if (trimmedLine.length < line.length) {\n                    session.remove(new Range(row, trimmedLine.length, row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start = max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n}\nfunction wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n        var editor = e.editor;\n        var cursor = editor.selection.cursor;\n        if (cursor.column <= editor.renderer.$printMarginColumn)\n            return;\n        var lastDelta = editor.session.$undoManager.$lastDelta;\n        hardWrap(editor, {\n            startRow: cursor.row, endRow: cursor.row,\n            allowMerge: false\n        });\n        if (lastDelta != editor.session.$undoManager.$lastDelta)\n            editor.session.markUndoGroup();\n    }\n}\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n        set: function (val) {\n            if (val) {\n                this.commands.on(\"afterExec\", wrapAfterInput);\n            }\n            else {\n                this.commands.off(\"afterExec\", wrapAfterInput);\n            }\n        },\n        value: false\n    }\n});\nexports.hardWrap = hardWrap;\n\n});\n\nace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/ext/hardwrap\",\"ace/multi_select\"], function(require, exports, module){// CodeMirror, copyright (c) by Marijn Haverbeke and others\n'use strict';\nfunction log() {\n    var d = \"\";\n    function format(p) {\n        if (typeof p != \"object\")\n            return p + \"\";\n        if (\"line\" in p) {\n            return p.line + \":\" + p.ch;\n        }\n        if (\"anchor\" in p) {\n            return format(p.anchor) + \"->\" + format(p.head);\n        }\n        if (Array.isArray(p))\n            return \"[\" + p.map(function (x) {\n                return format(x);\n            }) + \"]\";\n        return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n        var p = arguments[i];\n        var f = format(p);\n        d += f + \"  \";\n    }\n    console.log(d);\n}\nvar Range = require(\"../range\").Range;\nvar EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\nvar domLib = require(\"../lib/dom\");\nvar oop = require(\"../lib/oop\");\nvar KEYS = require(\"../lib/keys\");\nvar event = require(\"../lib/event\");\nvar Search = require(\"../search\").Search;\nvar useragent = require(\"../lib/useragent\");\nvar SearchHighlight = require(\"../search_highlight\").SearchHighlight;\nvar multiSelectCommands = require(\"../commands/multi_select_commands\");\nvar TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\nvar hardWrap = require(\"../ext/hardwrap\").hardWrap;\nrequire(\"../multi_select\");\nvar CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n};\nCodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos))\n        return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.commands = {\n    redo: function (cm) { cm.ace.redo(); },\n    undo: function (cm) { cm.ace.undo(); },\n    newlineAndIndent: function (cm) { cm.ace.insert(\"\\n\"); },\n    goLineLeft: function (cm) { cm.ace.selection.moveCursorLineStart(); },\n    goLineRight: function (cm) { cm.ace.selection.moveCursorLineEnd(); }\n};\nCodeMirror.keyMap = {};\nCodeMirror.addClass = CodeMirror.rmClass = function () { };\nCodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\nCodeMirror.keyName = function (e) {\n    var key = (KEYS[e.keyCode] || e.key || \"\");\n    if (key.length == 1)\n        key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n        return m.toUpperCase();\n    }) + key;\n    return key;\n};\nCodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n        var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n        return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map)\n        map = \"default\";\n    if (typeof map == \"string\")\n        map = CodeMirror.keyMap[map] || CodeMirror.keyMap['default'];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false)\n        return \"nothing\";\n    if (found === \"...\")\n        return \"multi\";\n    if (found != null && handle(found))\n        return \"handled\";\n    if (map.fallthrough) {\n        if (!Array.isArray(map.fallthrough))\n            return lookupKey(key, map.fallthrough, handle);\n        for (var i = 0; i < map.fallthrough.length; i++) {\n            var result = lookupKey(key, map.fallthrough[i], handle);\n            if (result)\n                return result;\n        }\n    }\n};\nCodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n};\nCodeMirror.findEnclosingTag = function (cm, head) {\n};\nCodeMirror.signal = function (o, name, e) { return o._signal(name, e); };\nCodeMirror.on = event.addListener;\nCodeMirror.off = event.removeListener;\nCodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\")\n        return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n};\n(function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n        this.ace.off('change', this.onChange);\n        this.ace.off('changeSelection', this.onSelectionChange);\n        this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n        this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n        return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n        if (this.$lineHandleChanges) {\n            this.$lineHandleChanges.push(delta);\n        }\n        var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n        if (!curOp.lastChange) {\n            curOp.lastChange = curOp.change = change;\n        }\n        else {\n            curOp.lastChange.next = curOp.lastChange = change;\n        }\n        this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n        if (this.ace.inMultiSelectMode) {\n            this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n        }\n    };\n    this.operation = function (fn, force) {\n        if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n            return fn();\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        if (!this.ace.curOp) {\n            var prevOp = this.ace.prevOp;\n            this.ace.startOperation({\n                command: { name: \"vim\", scrollIntoView: \"cursor\" }\n            });\n        }\n        var curOp = this.curOp = this.curOp || {};\n        this.curOp.force = force;\n        var result = fn();\n        if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n            if (this.state.dialog)\n                this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n            this.ace.endOperation();\n            if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\n                this.ace.prevOp = prevOp;\n        }\n        if (force || !this.ace.curOp) {\n            if (this.curOp)\n                this.onBeforeEndOperation();\n        }\n        return result;\n    };\n    this.onBeforeEndOperation = function () {\n        var op = this.curOp;\n        if (op) {\n            if (op.change) {\n                this.signal(\"change\", op.change, op);\n            }\n            if (op && op.cursorActivity) {\n                this.signal(\"cursorActivity\", null, op);\n            }\n            this.curOp = null;\n        }\n    };\n    this.signal = function (eventName, e, handlers) {\n        var listeners = handlers ? handlers[eventName + \"Handlers\"]\n            : (this._eventRegistry || {})[eventName];\n        if (!listeners)\n            return;\n        listeners = listeners.slice();\n        for (var i = 0; i < listeners.length; i++)\n            listeners[i](this, e);\n    };\n    this.firstLine = function () { return 0; };\n    this.lastLine = function () { return this.ace.session.getLength() - 1; };\n    this.lineCount = function () { return this.ace.session.getLength(); };\n    this.setCursor = function (line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n        if (!this.ace.inVirtualSelectionMode)\n            this.ace.exitMultiSelectMode();\n        this.ace.session.unfold({ row: line, column: ch });\n        this.ace.selection.moveTo(line, ch);\n        if (shouldScroll) {\n            this.ace.renderer.scrollCursorIntoView();\n            this.ace.endOperation();\n        }\n    };\n    this.getCursor = function (p) {\n        var sel = this.ace.selection;\n        var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\n            p == 'head' || !p ? sel.lead : sel.getRange()[p];\n        return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n        var ranges = this.ace.multiSelect.rangeList.ranges;\n        if (!ranges.length || this.ace.inVirtualSelectionMode)\n            return [{ anchor: this.getCursor('anchor'), head: this.getCursor('head') }];\n        return ranges.map(function (r) {\n            return {\n                anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n                head: this.clipPos(toCmPos(r.cursor))\n            };\n        }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n        var sel = this.ace.multiSelect;\n        var ranges = p.map(function (x) {\n            var anchor = toAcePos(x.anchor);\n            var head = toAcePos(x.head);\n            var r = Range.comparePoints(anchor, head) < 0\n                ? new Range.fromPoints(anchor, head)\n                : new Range.fromPoints(head, anchor);\n            r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n            return r;\n        });\n        if (this.ace.inVirtualSelectionMode) {\n            this.ace.selection.fromOrientedRange(ranges[0]);\n            return;\n        }\n        if (!primIndex) {\n            ranges = ranges.reverse();\n        }\n        else if (ranges[primIndex]) {\n            ranges.push(ranges.splice(primIndex, 1)[0]);\n        }\n        sel.toSingleRange(ranges[0].clone());\n        var session = this.ace.session;\n        for (var i = 0; i < ranges.length; i++) {\n            var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n            sel.addRange(range);\n        }\n    };\n    this.setSelection = function (a, h, options) {\n        var sel = this.ace.selection;\n        sel.moveTo(a.line, a.ch);\n        sel.selectTo(h.line, h.ch);\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    };\n    this.somethingSelected = function (p) {\n        return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n        var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n        return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n        this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n        return { clear: function () { }, find: function () { } };\n    };\n    this.$updateMarkers = function (delta) {\n        var isInsert = delta.action == \"insert\";\n        var start = delta.start;\n        var end = delta.end;\n        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n        if (isInsert)\n            end = start;\n        for (var i in this.marks) {\n            var point = this.marks[i];\n            var cmp = Range.comparePoints(point, start);\n            if (cmp < 0) {\n                continue; // delta starts after the range\n            }\n            if (cmp === 0) {\n                if (isInsert) {\n                    if (!point.$insertRight) {\n                        cmp = 1;\n                    }\n                    else if (point.bias == 1) {\n                        cmp = 1;\n                    }\n                    else {\n                        point.bias = -1;\n                        continue;\n                    }\n                }\n            }\n            var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n            if (cmp2 > 0) {\n                point.row += rowShift;\n                point.column += point.row == end.row ? colShift : 0;\n                continue;\n            }\n            if (!isInsert && cmp2 <= 0) {\n                point.row = start.row;\n                point.column = start.column;\n                if (cmp2 === 0)\n                    point.bias = 1;\n            }\n        }\n    };\n    var Marker = function (cm, id, row, column) {\n        this.cm = cm;\n        this.id = id;\n        this.row = row;\n        this.column = column;\n        cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () { delete this.cm.marks[this.id]; };\n    Marker.prototype.find = function () { return toCmPos(this); };\n    this.setBookmark = function (cursor, options) {\n        var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n        if (!options || !options.insertLeft)\n            bm.$insertRight = true;\n        this.marks[bm.id] = bm;\n        return bm;\n    };\n    this.moveH = function (increment, unit) {\n        if (unit == 'char') {\n            var sel = this.ace.selection;\n            sel.clearSelection();\n            sel.moveCursorBy(0, increment);\n        }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n        if (unit == 'page') {\n            var renderer = this.ace.renderer;\n            var config = renderer.layerConfig;\n            amount = amount * Math.floor(config.height / config.lineHeight);\n            unit = 'line';\n        }\n        if (unit == 'line') {\n            var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n            if (goalColumn != null)\n                screenPos.column = goalColumn;\n            screenPos.row += amount;\n            screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n            var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n            return toCmPos(pos);\n        }\n        else {\n            debugger;\n        }\n    };\n    this.charCoords = function (pos, mode) {\n        if (mode == 'div' || !mode) {\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            return { left: sc.column, top: sc.row };\n        }\n        if (mode == 'local') {\n            var renderer = this.ace.renderer;\n            var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n            var lh = renderer.layerConfig.lineHeight;\n            var cw = renderer.layerConfig.characterWidth;\n            var top = lh * sc.row;\n            return { left: sc.column * cw, top: top, bottom: top + lh };\n        }\n    };\n    this.coordsChar = function (pos, mode) {\n        var renderer = this.ace.renderer;\n        if (mode == 'local') {\n            var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n            var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n            var ch = renderer.session.screenToDocumentPosition(row, col);\n            return toCmPos(ch);\n        }\n        else if (mode == 'div') {\n            throw \"not implemented\";\n        }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n        var caseSensitive = false;\n        var isRegexp = false;\n        if (query instanceof RegExp && !query.global) {\n            caseSensitive = !query.ignoreCase;\n            query = query.source;\n            isRegexp = true;\n        }\n        if (query == \"\\\\n\") {\n            query = \"\\n\";\n            isRegexp = false;\n        }\n        var search = new Search();\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var acePos = { row: pos.line, column: pos.ch };\n        var cm = this;\n        var last = null;\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                search.setOptions({\n                    needle: query,\n                    caseSensitive: caseSensitive,\n                    wrap: false,\n                    backwards: back,\n                    regExp: isRegexp,\n                    start: last || acePos\n                });\n                var range = search.find(cm.ace.session);\n                last = range;\n                return last && [!last.isEmpty()];\n            },\n            from: function () { return last && toCmPos(last.start); },\n            to: function () { return last && toCmPos(last.end); },\n            replace: function (text) {\n                if (last) {\n                    last.end = cm.ace.session.doc.replace(last, text);\n                }\n            }\n        };\n    };\n    this.scrollTo = function (x, y) {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        var maxHeight = config.maxHeight;\n        maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n        if (y != null)\n            this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n        if (x != null)\n            this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () { return 0; };\n    this.scrollIntoView = function (pos, margin) {\n        if (pos) {\n            var renderer = this.ace.renderer;\n            var viewMargin = { \"top\": 0, \"bottom\": margin };\n            renderer.scrollCursorIntoView(toAcePos(pos), (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\n        }\n    };\n    this.getLine = function (row) { return this.ace.session.getLine(row); };\n    this.getRange = function (s, e) {\n        return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n        if (!e)\n            e = s;\n        var range = new Range(s.line, s.ch, e.line, e.ch);\n        this.ace.session.$clipRangeToDocument(range);\n        return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection =\n        this.replaceSelections = function (p) {\n            var strings = Array.isArray(p) && p;\n            var sel = this.ace.selection;\n            if (this.ace.inVirtualSelectionMode) {\n                this.ace.session.replace(sel.getRange(), strings ? p[0] || \"\" : p);\n                return;\n            }\n            sel.inVirtualSelectionMode = true;\n            var ranges = sel.rangeList.ranges;\n            if (!ranges.length)\n                ranges = [this.ace.multiSelect.getRange()];\n            for (var i = ranges.length; i--;)\n                this.ace.session.replace(ranges[i], strings ? p[i] || \"\" : p);\n            sel.inVirtualSelectionMode = false;\n        };\n    this.getSelection = function () {\n        return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n        return this.listSelections().map(function (x) {\n            return this.getRange(x.anchor, x.head);\n        }, this);\n    };\n    this.getInputField = function () {\n        return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n        return this.ace.container;\n    };\n    var optMap = {\n        indentWithTabs: \"useSoftTabs\",\n        indentUnit: \"tabSize\",\n        tabSize: \"tabSize\",\n        firstLineNumber: \"firstLineNumber\",\n        readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n        this.state[name] = val;\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                val = !val;\n                break;\n            case 'keyMap':\n                this.state.$keyMap = val;\n                return;\n                break;\n            default:\n                name = optMap[name];\n        }\n        if (name)\n            this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n        var val;\n        var aceOpt = optMap[name];\n        if (aceOpt)\n            val = this.ace.getOption(aceOpt);\n        switch (name) {\n            case 'indentWithTabs':\n                name = optMap[name];\n                return !val;\n            case 'keyMap':\n                return this.state.$keyMap || 'vim';\n        }\n        return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n        this.state.overwrite = on;\n        return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n        if (!this.$searchHighlight || !this.$searchHighlight.session) {\n            var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n            var marker = this.ace.session.addDynamicMarker(highlight);\n            highlight.id = marker.id;\n            highlight.session = this.ace.session;\n            highlight.destroy = function (o) {\n                highlight.session.off(\"change\", highlight.updateOnChange);\n                highlight.session.off(\"changeEditor\", highlight.destroy);\n                highlight.session.removeMarker(highlight.id);\n                highlight.session = null;\n            };\n            highlight.updateOnChange = function (delta) {\n                var row = delta.start.row;\n                if (row == delta.end.row)\n                    highlight.cache[row] = undefined;\n                else\n                    highlight.cache.splice(row, highlight.cache.length);\n            };\n            highlight.session.on(\"changeEditor\", highlight.destroy);\n            highlight.session.on(\"change\", highlight.updateOnChange);\n        }\n        var re = new RegExp(o.query.source, \"gmi\");\n        this.$searchHighlight = o.highlight = highlight;\n        this.$searchHighlight.setRegexp(re);\n        this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n        if (this.$searchHighlight && this.$searchHighlight.session) {\n            this.$searchHighlight.destroy();\n        }\n    };\n    this.getScrollInfo = function () {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        return {\n            left: renderer.scrollLeft,\n            top: renderer.scrollTop,\n            height: config.maxHeight,\n            width: config.width,\n            clientHeight: config.height,\n            clientWidth: config.width\n        };\n    };\n    this.getValue = function () {\n        return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n        return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n        var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n        return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n        var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n        return { to: m && toCmPos(m) };\n    };\n    this.findMatchingTag = function (pos) {\n        var m = this.ace.session.getMatchingTags(toAcePos(pos));\n        if (!m)\n            return;\n        return {\n            open: {\n                from: toCmPos(m.openTag.start),\n                to: toCmPos(m.openTag.end)\n            },\n            close: {\n                from: toCmPos(m.closeTag.start),\n                to: toCmPos(m.closeTag.end)\n            }\n        };\n    };\n    this.indentLine = function (line, method) {\n        if (method === true)\n            this.ace.session.indentRows(line, line, \"\\t\");\n        else if (method === false)\n            this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n        return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n        return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n        return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n        return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n        return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n        var re = options.bracketRegex.source;\n        var tokenRe = /paren|text|operator|tag/;\n        if (dir == 1) {\n            var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n        }\n        else {\n            var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), { row: pos.line, column: pos.ch + 1 }, tokenRe);\n            if (!m && options.bracketRegex && options.bracketRegex.test(this.getLine(pos.line)[pos.ch - 1])) {\n                m = { row: pos.line, column: pos.ch - 1 };\n            }\n        }\n        return m && { pos: toCmPos(m) };\n    };\n    this.refresh = function () {\n        return this.ace.resize(true);\n    };\n    this.getMode = function () {\n        return { name: this.getOption(\"mode\") };\n    };\n    this.execCommand = function (name) {\n        if (CodeMirror.commands.hasOwnProperty(name))\n            return CodeMirror.commands[name](this);\n        if (name == \"indentAuto\")\n            return this.ace.execCommand(\"autoindent\");\n        console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n        var deltas = this.$lineHandleChanges;\n        if (!deltas)\n            return null;\n        var row = handle.row;\n        for (var i = 0; i < deltas.length; i++) {\n            var delta = deltas[i];\n            if (delta.start.row != delta.end.row) {\n                if (delta.action[0] == \"i\") {\n                    if (delta.start.row < row)\n                        row += delta.end.row - delta.start.row;\n                }\n                else {\n                    if (delta.start.row < row) {\n                        if (row < delta.end.row || row == delta.end.row && delta.start.column > 0) {\n                            return null;\n                        }\n                        row -= delta.end.row - delta.start.row;\n                    }\n                }\n            }\n        }\n        return row;\n    };\n    this.getLineHandle = function (row) {\n        if (!this.$lineHandleChanges)\n            this.$lineHandleChanges = [];\n        return { text: this.ace.session.getLine(row), row: row };\n    };\n    this.releaseLineHandles = function () {\n        this.$lineHandleChanges = undefined;\n    };\n    this.getLastEditEnd = function () {\n        var undoManager = this.ace.session.$undoManager;\n        if (undoManager && undoManager.$lastDelta)\n            return toCmPos(undoManager.$lastDelta.end);\n    };\n}).call(CodeMirror.prototype);\nfunction toAcePos(cmPos) {\n    return { row: cmPos.line, column: cmPos.ch };\n}\nfunction toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n}\nvar StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n};\nStringStream.prototype = {\n    eol: function () { return this.pos >= this.string.length; },\n    sol: function () { return this.pos == this.lineStart; },\n    peek: function () { return this.string.charAt(this.pos) || undefined; },\n    next: function () {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n        var ch = this.string.charAt(this.pos);\n        if (typeof match == \"string\")\n            var ok = ch == match;\n        else\n            var ok = ch && (match.test ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    },\n    eatWhile: function (match) {\n        var start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    },\n    eatSpace: function () {\n        var start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    },\n    skipToEnd: function () { this.pos = this.string.length; },\n    skipTo: function (ch) {\n        var found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    },\n    backUp: function (n) { this.pos -= n; },\n    column: function () {\n        throw \"not implemented\";\n    },\n    indentation: function () {\n        throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n            var substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n        }\n        else {\n            var match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    },\n    current: function () { return this.string.slice(this.start, this.pos); },\n    hideFirstChars: function (n, inner) {\n        this.lineStart += n;\n        try {\n            return inner();\n        }\n        finally {\n            this.lineStart -= n;\n        }\n    }\n};\nCodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n};\ndomLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n(function () {\n    function dialogDiv(cm, template, bottom) {\n        var wrap = cm.ace.container;\n        var dialog;\n        dialog = wrap.appendChild(document.createElement(\"div\"));\n        if (bottom)\n            dialog.className = \"ace_dialog ace_dialog-bottom\";\n        else\n            dialog.className = \"ace_dialog ace_dialog-top\";\n        if (typeof template == \"string\") {\n            dialog.innerHTML = template;\n        }\n        else { // Assuming it's a detached DOM element.\n            dialog.appendChild(template);\n        }\n        return dialog;\n    }\n    function closeNotification(cm, newVal) {\n        if (cm.state.currentNotificationClose)\n            cm.state.currentNotificationClose();\n        cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n        if (this.virtualSelectionMode())\n            return;\n        if (!options)\n            options = {};\n        closeNotification(this, null);\n        var dialog = dialogDiv(this, template, options.bottom);\n        var closed = false, me = this;\n        this.state.dialog = dialog;\n        function close(newVal) {\n            if (typeof newVal == 'string') {\n                inp.value = newVal;\n            }\n            else {\n                if (closed)\n                    return;\n                if (newVal && newVal.type == \"blur\") {\n                    if (document.activeElement === inp)\n                        return;\n                }\n                if (me.state.dialog == dialog) {\n                    me.state.dialog = null;\n                    me.focus();\n                }\n                closed = true;\n                dialog.remove();\n                if (options.onClose)\n                    options.onClose(dialog);\n                var cm = me;\n                if (cm.state.vim) {\n                    cm.state.vim.status = null;\n                    cm.ace._signal(\"changeStatus\");\n                    cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n                }\n            }\n        }\n        var inp = dialog.getElementsByTagName(\"input\")[0], button;\n        if (inp) {\n            if (options.value) {\n                inp.value = options.value;\n                if (options.selectValueOnOpen !== false)\n                    inp.select();\n            }\n            if (options.onInput)\n                CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n            if (options.onKeyUp)\n                CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n            CodeMirror.on(inp, \"keydown\", function (e) {\n                if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                    return;\n                }\n                if (e.keyCode == 13)\n                    callback(inp.value);\n                if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                    CodeMirror.e_stop(e);\n                    close();\n                }\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(inp, \"blur\", close);\n            inp.focus();\n        }\n        else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n            CodeMirror.on(button, \"click\", function () {\n                close();\n                me.focus();\n            });\n            if (options.closeOnBlur !== false)\n                CodeMirror.on(button, \"blur\", close);\n            button.focus();\n        }\n        return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n        if (this.virtualSelectionMode())\n            return;\n        closeNotification(this, close);\n        var dialog = dialogDiv(this, template, options && options.bottom);\n        var closed = false, doneTimer;\n        var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n        function close() {\n            if (closed)\n                return;\n            closed = true;\n            clearTimeout(doneTimer);\n            dialog.remove();\n        }\n        CodeMirror.on(dialog, 'click', function (e) {\n            CodeMirror.e_preventDefault(e);\n            close();\n        });\n        if (duration)\n            doneTimer = setTimeout(close, duration);\n        return close;\n    });\n})();\nvar Pos = CodeMirror.Pos;\nfunction updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n        var text = cm.getLine(curStart.line);\n        var charCode = text.charCodeAt(curStart.ch);\n        if (0xD800 <= charCode && charCode <= 0xD8FF) {\n            curEnd.ch += 1;\n        }\n    }\n    return { start: curStart, end: curEnd };\n}\nvar defaultKeymap = [\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true } },\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false } },\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true } },\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true } },\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true } },\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true } },\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false } },\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false } },\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true } },\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true } },\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false } },\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true } },\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true } },\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false } },\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true } },\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true } },\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false } },\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true } },\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true } },\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },\n    { keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\" },\n    { keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true } },\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar: true } },\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true } },\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true } },\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false } },\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true } },\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false } },\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true } },\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false } },\n    { keys: '\\'<register>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true, linewise: true } },\n    { keys: '`<register>', type: 'motion', motion: 'goToMark', motionArgs: { toJumplist: true } },\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true } },\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true } },\n    { keys: '|', type: 'motion', motion: 'moveToColumn' },\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context: 'visual' },\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: { sameLine: true }, context: 'visual' },\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true } },\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false } },\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true } },\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true } },\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true } },\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false } },\n    { keys: 'gq', type: 'operator', operator: 'hardWrap' },\n    { keys: 'gw', type: 'operator', operator: 'hardWrap', operatorArgs: { keepCursor: true } },\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal' },\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal' },\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual' },\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal' },\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual' },\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true } },\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false } },\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true } },\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true } },\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank' }, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true } },\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true } },\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true } },\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true } },\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<register>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<register>', type: 'action', action: 'enterMacroRecordMode' },\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal' },\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true },\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: true }, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: { toLower: false }, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<register>', type: 'action', action: 'setMark' },\n    { keys: '\"<register>', type: 'action', action: 'setRegister' },\n    { keys: '<C-r><register>', type: 'action', action: 'insertRegister', context: 'insert', isEdit: true },\n    { keys: '<C-o>', type: 'action', action: 'oneNormalCommand', context: 'insert' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' } },\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' } },\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' } },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: true, backtrack: false } },\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: { increase: false, backtrack: false } },\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    { keys: 'a<register>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<register>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true } },\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true } },\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true } },\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true } },\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true } },\n    { keys: ':', type: 'ex' }\n];\nvar defaultKeymapLength = defaultKeymap.length;\nvar defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'omap', shortName: 'om' },\n    { name: 'noremap', shortName: 'no' },\n    { name: 'nnoremap', shortName: 'nn' },\n    { name: 'vnoremap', shortName: 'vn' },\n    { name: 'inoremap', shortName: 'ino' },\n    { name: 'onoremap', shortName: 'ono' },\n    { name: 'unmap' },\n    { name: 'mapclear', shortName: 'mapc' },\n    { name: 'nmapclear', shortName: 'nmapc' },\n    { name: 'vmapclear', shortName: 'vmapc' },\n    { name: 'imapclear', shortName: 'imapc' },\n    { name: 'omapclear', shortName: 'omapc' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'startinsert', shortName: 'start' },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'delete', shortName: 'd' },\n    { name: 'join', shortName: 'j' },\n    { name: 'normal', shortName: 'norm' },\n    { name: 'global', shortName: 'g' }\n];\nvar langmap = parseLangmap('');\nfunction enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n}\nfunction leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout)\n        clearTimeout(highlightTimeout);\n}\nfunction getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n            if (!vim.insertMode) {\n                cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n                actions.enterInsertMode(cm, {}, vim);\n            }\n        };\n    }\n    return vim.onPasteFn;\n}\nvar numberRegex = /[\\d]/;\nvar wordCharTest = [CodeMirror.isWordChar, function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function (ch) {\n        return /\\S/.test(ch);\n    }];\nvar validMarks = ['<', '>'];\nvar validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\nvar latinCharRegex = /^\\w$/;\nvar upperCaseChars;\ntry {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n}\ncatch (_) {\n    upperCaseChars = /^[A-Z]$/;\n}\nfunction isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n}\nfunction isLowerCase(k) {\n    return (/^[a-z]$/).test(k);\n}\nfunction isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n}\nfunction isNumber(k) {\n    return numberRegex.test(k);\n}\nfunction isUpperCase(k) {\n    return upperCaseChars.test(k);\n}\nfunction isWhiteSpaceString(k) {\n    return (/^\\s*$/).test(k);\n}\nfunction isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n}\nfunction inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n            return true;\n        }\n    }\n    return false;\n}\nvar options = {};\nfunction defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n        type = 'string';\n    }\n    options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n    };\n    if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n            options[aliases[i]] = options[name];\n        }\n    }\n    if (defaultValue) {\n        setOption(name, defaultValue);\n    }\n}\nfunction setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n        if (value && value !== true) {\n            return new Error('Invalid argument: ' + name + '=' + value);\n        }\n        else if (value !== false) {\n            value = true;\n        }\n    }\n    if (option.callback) {\n        if (scope !== 'local') {\n            option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n            option.callback(value, cm);\n        }\n    }\n    else {\n        if (scope !== 'local') {\n            option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n            cm.state.vim.options[name] = { value: value };\n        }\n    }\n}\nfunction getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n        return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n            return local;\n        }\n        if (scope !== 'local') {\n            return option.callback();\n        }\n        return;\n    }\n    else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n    }\n}\ndefineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n    }\n    else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n    }\n});\ndefineOption('textwidth', 80, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (width === undefined) {\n        var value = cm.getOption('textwidth');\n        return value;\n    }\n    else {\n        var column = Math.round(width);\n        if (column > 1) {\n            cm.setOption('textwidth', column);\n        }\n    }\n});\nvar createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n            var next = ++pointer % size;\n            var trashMark = buffer[next];\n            if (trashMark) {\n                trashMark.clear();\n            }\n            buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n            var markPos = curMark.find();\n            if (markPos && !cursorEqual(markPos, oldCur)) {\n                useNextSlot(oldCur);\n            }\n        }\n        else {\n            useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n            tail = 0;\n        }\n    }\n    function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n            pointer = head;\n        }\n        else if (pointer < tail) {\n            pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        if (mark && !mark.find()) {\n            var inc = offset > 0 ? 1 : -1;\n            var newCur;\n            var oldCur = cm.getCursor();\n            do {\n                pointer += inc;\n                mark = buffer[(size + pointer) % size];\n                if (mark &&\n                    (newCur = mark.find()) &&\n                    !cursorEqual(oldCur, newCur)) {\n                    break;\n                }\n            } while (pointer < head && pointer > tail);\n        }\n        return mark;\n    }\n    function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n    }\n    return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n    };\n};\nvar createInsertModeChanges = function (c) {\n    if (c) {\n        return {\n            changes: c.changes,\n            expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n    }\n    return {\n        changes: [],\n        expectCursorActivityForChange: false\n    };\n};\nfunction MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n}\nMacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n            macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n            register.clear();\n            this.latestRegister = registerName;\n            if (cm.openDialog) {\n                var template = dom('span', { class: 'cm-vim-message' }, 'recording @' + registerName);\n                this.onRecordingDone = cm.openDialog(template, null, { bottom: true });\n            }\n            this.isRecording = true;\n        }\n    }\n};\nfunction maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n        cm.state.vim = {\n            inputState: new InputState(),\n            lastEditInputState: undefined,\n            lastEditActionCommand: undefined,\n            lastHPos: -1,\n            lastHSPos: -1,\n            lastMotion: null,\n            marks: {},\n            insertMode: false,\n            insertModeReturn: false,\n            insertModeRepeat: undefined,\n            visualMode: false,\n            visualLine: false,\n            visualBlock: false,\n            lastSelection: null,\n            lastPastedText: null,\n            sel: {},\n            options: {},\n            expectLiteralNext: false\n        };\n    }\n    return cm.state.vim;\n}\nvar vimGlobalState;\nfunction resetVimGlobalState() {\n    vimGlobalState = {\n        searchQuery: null,\n        searchIsReversed: false,\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: '' },\n        registerController: new RegisterController({}),\n        searchHistoryController: new HistoryController(),\n        exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n    }\n}\nvar lastInsertModeKeyTimer;\nvar vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {\n    },\n    getRegisterController: function () {\n        return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n        return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    mapclear: function (ctx) {\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n            for (var i = userKeymap.length - 1; i >= 0; i--) {\n                var mapping = userKeymap[i];\n                if (ctx !== mapping.context) {\n                    if (mapping.context) {\n                        this._mapCommand(mapping);\n                    }\n                    else {\n                        var contexts = ['normal', 'insert', 'visual'];\n                        for (var j in contexts) {\n                            if (contexts[j] !== ctx) {\n                                var newMapping = {};\n                                for (var key in mapping) {\n                                    newMapping[key] = mapping[key];\n                                }\n                                newMapping.context = contexts[j];\n                                this._mapCommand(newMapping);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n        if (!prefix) {\n            prefix = name;\n        }\n        else if (name.indexOf(prefix) !== 0) {\n            throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = { name: name, shortName: prefix, type: 'api' };\n    },\n    handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n            return command();\n        }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                if (key == 'q') {\n                    macroModeState.exitMacroRecordMode();\n                    clearInputState(cm);\n                    return true;\n                }\n                if (origin != 'mapping') {\n                    logKey(macroModeState, key);\n                }\n            }\n        }\n        function handleEsc() {\n            if (key == '<Esc>') {\n                if (vim.visualMode) {\n                    exitVisualMode(cm);\n                }\n                else if (vim.insertMode) {\n                    exitInsertMode(cm);\n                }\n                else {\n                    return;\n                }\n                clearInputState(cm);\n                return true;\n            }\n        }\n        function handleKeyInsertMode() {\n            if (handleEsc()) {\n                return true;\n            }\n            vim.inputState.keyBuffer.push(key);\n            var keys = vim.inputState.keyBuffer.join(\"\");\n            var keysAreChars = key.length == 1;\n            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            var changeQueue = vim.inputState.changeQueue;\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                if (match.expectLiteralNext)\n                    vim.expectLiteralNext = true;\n                if (lastInsertModeKeyTimer) {\n                    window.clearTimeout(lastInsertModeKeyTimer);\n                }\n                lastInsertModeKeyTimer = keysAreChars && window.setTimeout(function () { if (vim.insertMode && vim.inputState.keyBuffer.length) {\n                    clearInputState(cm);\n                } }, getOption('insertModeEscKeysTimeout'));\n                if (keysAreChars) {\n                    var selections = cm.listSelections();\n                    if (!changeQueue || changeQueue.removed.length != selections.length)\n                        changeQueue = vim.inputState.changeQueue = new ChangeQueue;\n                    changeQueue.inserted += key;\n                    for (var i = 0; i < selections.length; i++) {\n                        var from = cursorMin(selections[i].anchor, selections[i].head);\n                        var to = cursorMax(selections[i].anchor, selections[i].head);\n                        var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n                        changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n                    }\n                }\n                return !keysAreChars;\n            }\n            vim.expectLiteralNext = false;\n            if (lastInsertModeKeyTimer) {\n                window.clearTimeout(lastInsertModeKeyTimer);\n            }\n            if (match.command && changeQueue) {\n                var selections = cm.listSelections();\n                for (var i = 0; i < selections.length; i++) {\n                    var here = selections[i].head;\n                    cm.replaceRange(changeQueue.removed[i] || \"\", offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n                }\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n            }\n            if (!match.command)\n                clearInputState(cm);\n            return match.command;\n        }\n        function handleKeyNonInsertMode() {\n            if (handleMacroRecording() || handleEsc()) {\n                return true;\n            }\n            vim.inputState.keyBuffer.push(key);\n            var keys = vim.inputState.keyBuffer.join(\"\");\n            if (/^[1-9]\\d*$/.test(keys)) {\n                return true;\n            }\n            var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (!keysMatcher) {\n                clearInputState(cm);\n                return false;\n            }\n            var context = vim.visualMode ? 'visual' :\n                'normal';\n            var mainKey = keysMatcher[2] || keysMatcher[1];\n            if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n                mainKey = vim.inputState.operatorShortcut;\n            }\n            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n            if (match.type == 'none') {\n                clearInputState(cm);\n                return false;\n            }\n            else if (match.type == 'partial') {\n                if (match.expectLiteralNext)\n                    vim.expectLiteralNext = true;\n                return true;\n            }\n            else if (match.type == 'clear') {\n                clearInputState(cm);\n                return true;\n            }\n            vim.expectLiteralNext = false;\n            vim.inputState.keyBuffer.length = 0;\n            keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n            if (keysMatcher[1] && keysMatcher[1] != '0') {\n                vim.inputState.pushRepeatDigit(keysMatcher[1]);\n            }\n            return match.command;\n        }\n        var command;\n        if (vim.insertMode) {\n            command = handleKeyInsertMode();\n        }\n        else {\n            command = handleKeyNonInsertMode();\n        }\n        if (command === false) {\n            return !vim.insertMode && key.length === 1 ? function () { return true; } : undefined;\n        }\n        else if (command === true) {\n            return function () { return true; };\n        }\n        else {\n            return function () {\n                if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\n                    return; // ace_patch\n                return cm.operation(function () {\n                    cm.curOp.isVimOp = true;\n                    try {\n                        if (command.type == 'keyToKey') {\n                            doKeyToKey(cm, command.toKeys, command);\n                        }\n                        else {\n                            commandDispatcher.processCommand(cm, vim, command);\n                        }\n                    }\n                    catch (e) {\n                        cm.state.vim = undefined;\n                        maybeInitVimState(cm);\n                        if (!vimApi.suppressErrorLogging) {\n                            console['log'](e);\n                        }\n                        throw e;\n                    }\n                    return true;\n                });\n            };\n        }\n    },\n    handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n};\nvar keyToKeyStack = [];\nvar noremap = false;\nvar virtualPrompt;\nfunction sendKeyToPrompt(key) {\n    if (key[0] == \"<\") {\n        var lowerKey = key.toLowerCase().slice(1, -1);\n        var parts = lowerKey.split('-');\n        lowerKey = parts.pop() || '';\n        if (lowerKey == 'lt')\n            key = '<';\n        else if (lowerKey == 'space')\n            key = ' ';\n        else if (lowerKey == 'cr')\n            key = '\\n';\n        else if (vimToCmKeyMap[lowerKey]) {\n            var value = virtualPrompt.value;\n            var event = {\n                key: vimToCmKeyMap[lowerKey],\n                target: {\n                    value: value,\n                    selectionEnd: value.length,\n                    selectionStart: value.length\n                }\n            };\n            if (virtualPrompt.onKeyDown) {\n                virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n            }\n            if (virtualPrompt && virtualPrompt.onKeyUp) {\n                virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n            }\n            return;\n        }\n    }\n    if (key == '\\n') {\n        var prompt = virtualPrompt;\n        virtualPrompt = null;\n        prompt.onClose && prompt.onClose(prompt.value);\n    }\n    else {\n        virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n    function close(value) {\n        if (typeof value == 'string') {\n            virtualPrompt.value = value;\n        }\n        else {\n            virtualPrompt = null;\n        }\n    }\n}\nfunction doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    if (fromKey) {\n        if (keyToKeyStack.indexOf(fromKey) != -1)\n            return;\n        keyToKeyStack.push(fromKey);\n        noremap = fromKey.noremap != false;\n    }\n    try {\n        var vim = maybeInitVimState(cm);\n        var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n        var match;\n        while ((match = keyRe.exec(keys))) {\n            var key = match[0];\n            var wasInsert = vim.insertMode;\n            if (virtualPrompt) {\n                sendKeyToPrompt(key);\n                continue;\n            }\n            var result = vimApi.handleKey(cm, key, 'mapping');\n            if (!result && wasInsert && vim.insertMode) {\n                if (key[0] == \"<\") {\n                    var lowerKey = key.toLowerCase().slice(1, -1);\n                    var parts = lowerKey.split('-');\n                    lowerKey = parts.pop() || '';\n                    if (lowerKey == 'lt')\n                        key = '<';\n                    else if (lowerKey == 'space')\n                        key = ' ';\n                    else if (lowerKey == 'cr')\n                        key = '\\n';\n                    else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n                        key = vimToCmKeyMap[lowerKey];\n                        sendCmKey(cm, key);\n                        continue;\n                    }\n                    else {\n                        key = key[0];\n                        keyRe.lastIndex = match.index + 1;\n                    }\n                }\n                cm.replaceSelection(key);\n            }\n        }\n    }\n    finally {\n        keyToKeyStack.pop();\n        noremap = keyToKeyStack.length ? noremapBefore : false;\n        if (!keyToKeyStack.length && virtualPrompt) {\n            var promptOptions = virtualPrompt;\n            virtualPrompt = null;\n            showPrompt(cm, promptOptions);\n        }\n    }\n}\nvar specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n};\nvar ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1,\n    CapsLock: 1, AltGraph: 1, Dead: 1, Unidentified: 1 };\nvar vimToCmKeyMap = {};\n'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function (x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()]\n        = vimToCmKeyMap[x.toLowerCase()] = x;\n});\nfunction vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if (e.metaKey) {\n        name += 'M-';\n    }\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n        name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n        if (langmap.keymap && key in langmap.keymap) {\n            if (langmap.remapCtrl != false || !name)\n                key = langmap.keymap[key];\n        }\n        else if (key.charCodeAt(0) > 255) {\n            var code = e.code && e.code.slice(-1) || \"\";\n            if (!e.shiftKey)\n                code = code.toLowerCase();\n            if (code)\n                key = code;\n        }\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n}\n;\nfunction updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n        langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n}\nfunction parseLangmap(langmapString) {\n    var keymap = {};\n    if (!langmapString)\n        return { keymap: keymap, string: '' };\n    function getEscaped(list) {\n        return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(function (part) {\n        if (!part)\n            return;\n        var semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n        if (semicolon.length == 3) {\n            var from = getEscaped(semicolon[1]);\n            var to = getEscaped(semicolon[2]);\n            if (from.length !== to.length)\n                return; // skip over malformed part\n            for (var i = 0; i < from.length; ++i)\n                keymap[from[i]] = to[i];\n        }\n        else if (semicolon.length == 1) {\n            var pairs = getEscaped(part);\n            if (pairs.length % 2 !== 0)\n                return; // skip over malformed part\n            for (var i = 0; i < pairs.length; i += 2)\n                keymap[pairs[i]] = pairs[i + 1];\n        }\n    });\n    return { keymap: keymap, string: langmapString };\n}\ndefineOption('langmap', undefined, 'string', ['lmap'], function (name, cm) {\n    if (name === undefined) {\n        return langmap.string;\n    }\n    else {\n        updateLangmap(name);\n    }\n});\nfunction InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n    this.changeQueue = null; // For restoring text used by insert mode keybindings\n}\nInputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n    }\n    else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n    }\n};\nInputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n            repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n            repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n    }\n    return repeat;\n};\nfunction clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n}\nfunction ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n}\nfunction Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n}\nRegister.prototype = {\n    setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n        if (linewise) {\n            if (!this.linewise) {\n                this.keyBuffer.push('\\n');\n            }\n            this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n        this.searchQueries.push(query);\n    },\n    clear: function () {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n    },\n    toString: function () {\n        return this.keyBuffer.join('');\n    }\n};\nfunction defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n}\nfunction RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n}\nRegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n        if (registerName === '_')\n            return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n            text += '\\n';\n        }\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        if (!register) {\n            switch (operator) {\n                case 'yank':\n                    this.registers['0'] = new Register(text, linewise, blockwise);\n                    break;\n                case 'delete':\n                case 'change':\n                    if (text.indexOf('\\n') == -1) {\n                        this.registers['-'] = new Register(text, linewise);\n                    }\n                    else {\n                        this.shiftNumericRegisters_();\n                        this.registers['1'] = new Register(text, linewise);\n                    }\n                    break;\n            }\n            this.unnamedRegister.setText(text, linewise, blockwise);\n            return;\n        }\n        var append = isUpperCase(registerName);\n        if (append) {\n            register.pushText(text, linewise);\n        }\n        else {\n            register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+' && typeof navigator !== 'undefined' &&\n            typeof navigator.clipboard !== 'undefined' &&\n            typeof navigator.clipboard.readText === 'function') {\n            navigator.clipboard.writeText(text);\n        }\n        this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n            return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n            this.registers[name] = new Register();\n        }\n        return this.registers[name];\n    },\n    isValidRegister: function (name) {\n        return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    },\n    shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n            this.registers[i] = this.getRegister('' + (i - 1));\n        }\n    }\n};\nfunction HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n}\nHistoryController.prototype = {\n    nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null)\n            this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n            var element = historyBuffer[i];\n            for (var j = 0; j <= element.length; j++) {\n                if (this.initialPrefix == element.substring(0, j)) {\n                    this.iterator = i;\n                    return element;\n                }\n            }\n        }\n        if (i >= historyBuffer.length) {\n            this.iterator = historyBuffer.length;\n            return this.initialPrefix;\n        }\n        if (i < 0)\n            return input;\n    },\n    pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1)\n            this.historyBuffer.splice(index, 1);\n        if (input.length)\n            this.historyBuffer.push(input);\n    },\n    reset: function () {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n    }\n};\nvar commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n            return { type: 'none' };\n        }\n        else if (!matches.full && matches.partial) {\n            return {\n                type: 'partial',\n                expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n            };\n        }\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n            var match = matches.full[i];\n            if (!bestMatch) {\n                bestMatch = match;\n            }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n            var character = lastChar(keys);\n            if (!character || character.length > 1)\n                return { type: 'clear' };\n            inputState.selectedCharacter = character;\n        }\n        return { type: 'full', command: bestMatch };\n    },\n    processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n            case 'motion':\n                this.processMotion(cm, vim, command);\n                break;\n            case 'operator':\n                this.processOperator(cm, vim, command);\n                break;\n            case 'operatorMotion':\n                this.processOperatorMotion(cm, vim, command);\n                break;\n            case 'action':\n                this.processAction(cm, vim, command);\n                break;\n            case 'search':\n                this.processSearch(cm, vim, command);\n                break;\n            case 'ex':\n            case 'keyToEx':\n                this.processEx(cm, vim, command);\n                break;\n            default:\n                break;\n        }\n    },\n    processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n            if (inputState.operator == command.operator) {\n                inputState.motion = 'expandToLine';\n                inputState.motionArgs = { linewise: true };\n                this.evalInput(cm, vim);\n                return;\n            }\n            else {\n                clearInputState(cm);\n            }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n            inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n            this.evalInput(cm, vim);\n        }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n            if (visualMode && operatorMotionArgs.visualLine) {\n                vim.visualLine = true;\n            }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n            this.processMotion(cm, vim, command);\n        }\n    },\n    processAction: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n            actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        if (command.operator) {\n            this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n            this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n            this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n            this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n            return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            try {\n                updateSearchQuery(cm, query, ignoreCase, smartCase);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + query);\n                clearInputState(cm);\n                return;\n            }\n            commandDispatcher.processMotion(cm, vim, {\n                type: 'motion',\n                motion: 'findNext',\n                motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n            });\n        }\n        function onPromptClose(query) {\n            handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isRecording) {\n                logSearchQuery(macroModeState, query);\n            }\n        }\n        function onPromptKeyUp(e, query, close) {\n            var keyName = vimKeyFromEvent(e), up, offset;\n            if (keyName == '<Up>' || keyName == '<Down>') {\n                up = keyName == '<Up>' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n                close(query);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n                vimGlobalState.searchHistoryController.reset();\n            }\n            var parsedQuery;\n            try {\n                parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n            }\n            if (parsedQuery) {\n                cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n            }\n            else {\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            }\n        }\n        function onPromptKeyDown(e, query, close) {\n            var keyName = vimKeyFromEvent(e);\n            if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n                (keyName == '<BS>' && query == '')) {\n                vimGlobalState.searchHistoryController.pushInput(query);\n                vimGlobalState.searchHistoryController.reset();\n                updateSearchQuery(cm, originalQuery);\n                clearSearchHighlight(cm);\n                cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            else if (keyName == '<Up>' || keyName == '<Down>') {\n                CodeMirror.e_stop(e);\n            }\n            else if (keyName == '<C-u>') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n        }\n        switch (command.searchArgs.querySrc) {\n            case 'prompt':\n                var macroModeState = vimGlobalState.macroModeState;\n                if (macroModeState.isPlaying) {\n                    var query = macroModeState.replaySearchQueries.shift();\n                    handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                }\n                else {\n                    showPrompt(cm, {\n                        onClose: onPromptClose,\n                        prefix: promptPrefix,\n                        desc: '(JavaScript regexp)',\n                        onKeyUp: onPromptKeyUp,\n                        onKeyDown: onPromptKeyDown\n                    });\n                }\n                break;\n            case 'wordUnderCursor':\n                var word = expandWordUnderCursor(cm, { noSymbol: true });\n                var isKeyword = true;\n                if (!word) {\n                    word = expandWordUnderCursor(cm, { noSymbol: false });\n                    isKeyword = false;\n                }\n                if (!word) {\n                    showConfirm(cm, 'No word under cursor');\n                    clearInputState(cm);\n                    return;\n                }\n                var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n                if (isKeyword && wholeWordOnly) {\n                    query = '\\\\b' + query + '\\\\b';\n                }\n                else {\n                    query = escapeRegex(query);\n                }\n                vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n                cm.setCursor(word.start);\n                handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n                break;\n        }\n    },\n    processEx: function (cm, vim, command) {\n        function onPromptClose(input) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            exCommandDispatcher.processCommand(cm, input);\n            if (cm.state.vim)\n                clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n            var keyName = vimKeyFromEvent(e), up, offset;\n            if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n                (keyName == '<BS>' && input == '')) {\n                vimGlobalState.exCommandHistoryController.pushInput(input);\n                vimGlobalState.exCommandHistoryController.reset();\n                CodeMirror.e_stop(e);\n                clearInputState(cm);\n                close();\n                cm.focus();\n            }\n            if (keyName == '<Up>' || keyName == '<Down>') {\n                CodeMirror.e_stop(e);\n                up = keyName == '<Up>' ? true : false;\n                offset = e.target ? e.target.selectionEnd : 0;\n                input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n                close(input);\n                if (offset && e.target)\n                    e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n            }\n            else if (keyName == '<C-u>') {\n                CodeMirror.e_stop(e);\n                close('');\n            }\n            else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n                vimGlobalState.exCommandHistoryController.reset();\n            }\n        }\n        if (command.type == 'keyToEx') {\n            exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        }\n        else {\n            if (vim.visualMode) {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                    onKeyDown: onPromptKeyDown, selectValueOnOpen: false });\n            }\n            else {\n                showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                    onKeyDown: onPromptKeyDown });\n            }\n        }\n    },\n    evalInput: function (cm, vim) {\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n            this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n            repeat = inputState.repeatOverride;\n        }\n        else {\n            repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n            motionArgs.repeatIsExplicit = true;\n        }\n        else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n            repeat = 1;\n            motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n            motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n                inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n            vim.lastMotion = motions[motion];\n            if (!motionResult) {\n                return;\n            }\n            if (motionArgs.toJumplist) {\n                if (!operator && cm.ace.curOp != null)\n                    cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n                var jumpList = vimGlobalState.jumpList;\n                var cachedCursor = jumpList.cachedCursor;\n                if (cachedCursor) {\n                    recordJumpPosition(cm, cachedCursor, motionResult);\n                    delete jumpList.cachedCursor;\n                }\n                else {\n                    recordJumpPosition(cm, origHead, motionResult);\n                }\n            }\n            if (motionResult instanceof Array) {\n                newAnchor = motionResult[0];\n                newHead = motionResult[1];\n            }\n            else {\n                newHead = motionResult;\n            }\n            if (!newHead) {\n                newHead = copyCursor(origHead);\n            }\n            if (vim.visualMode) {\n                if (!(vim.visualBlock && newHead.ch === Infinity)) {\n                    newHead = clipCursorToContent(cm, newHead, oldHead);\n                }\n                if (newAnchor) {\n                    newAnchor = clipCursorToContent(cm, newAnchor);\n                }\n                newAnchor = newAnchor || oldAnchor;\n                sel.anchor = newAnchor;\n                sel.head = newHead;\n                updateCmSelection(cm);\n                updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n                updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n            }\n            else if (!operator) {\n                if (cm.ace.curOp)\n                    cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n                newHead = clipCursorToContent(cm, newHead, oldHead);\n                cm.setCursor(newHead.line, newHead.ch);\n            }\n        }\n        if (operator) {\n            if (operatorArgs.lastSel) {\n                newAnchor = oldAnchor;\n                var lastSel = operatorArgs.lastSel;\n                var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n                var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n                if (lastSel.visualLine) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                else if (lastSel.visualBlock) {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n                }\n                else if (lastSel.head.line == lastSel.anchor.line) {\n                    newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n                }\n                else {\n                    newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n                }\n                vim.visualMode = true;\n                vim.visualLine = lastSel.visualLine;\n                vim.visualBlock = lastSel.visualBlock;\n                sel = vim.sel = {\n                    anchor: newAnchor,\n                    head: newHead\n                };\n                updateCmSelection(cm);\n            }\n            else if (vim.visualMode) {\n                operatorArgs.lastSel = {\n                    anchor: copyCursor(sel.anchor),\n                    head: copyCursor(sel.head),\n                    visualBlock: vim.visualBlock,\n                    visualLine: vim.visualLine\n                };\n            }\n            var curStart, curEnd, linewise, mode;\n            var cmSel;\n            if (vim.visualMode) {\n                curStart = cursorMin(sel.head, sel.anchor);\n                curEnd = cursorMax(sel.head, sel.anchor);\n                linewise = vim.visualLine || operatorArgs.linewise;\n                mode = vim.visualBlock ? 'block' :\n                    linewise ? 'line' :\n                        'char';\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode);\n                if (linewise) {\n                    var ranges = cmSel.ranges;\n                    if (mode == 'block') {\n                        for (var i = 0; i < ranges.length; i++) {\n                            ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                        }\n                    }\n                    else if (mode == 'line') {\n                        ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n                    }\n                }\n            }\n            else {\n                curStart = copyCursor(newAnchor || oldAnchor);\n                curEnd = copyCursor(newHead || oldHead);\n                if (cursorIsBefore(curEnd, curStart)) {\n                    var tmp = curStart;\n                    curStart = curEnd;\n                    curEnd = tmp;\n                }\n                linewise = motionArgs.linewise || operatorArgs.linewise;\n                if (linewise) {\n                    expandSelectionToLine(cm, curStart, curEnd);\n                }\n                else if (motionArgs.forward) {\n                    clipToLine(cm, curStart, curEnd);\n                }\n                mode = 'char';\n                var exclusive = !motionArgs.inclusive || linewise;\n                var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n                cmSel = makeCmSelection(cm, {\n                    anchor: newPositions.start,\n                    head: newPositions.end\n                }, mode, exclusive);\n            }\n            cm.setSelections(cmSel.ranges, cmSel.primary);\n            vim.lastMotion = null;\n            operatorArgs.repeat = repeat; // For indent in visual mode.\n            operatorArgs.registerName = registerName;\n            operatorArgs.linewise = linewise;\n            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n            if (vim.visualMode) {\n                exitVisualMode(cm, operatorMoveTo != null);\n            }\n            if (operatorMoveTo) {\n                cm.setCursor(operatorMoveTo);\n            }\n        }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n};\nvar motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n            return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n        if (!next) {\n            return;\n        }\n        if (prevInputState.operator) {\n            return next;\n        }\n        var from = next[0];\n        var to = new Pos(next[1].line, next[1].ch - 1);\n        if (vim.visualMode) {\n            if (vim.visualLine || vim.visualBlock) {\n                vim.visualLine = false;\n                vim.visualBlock = false;\n                CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n            }\n            var anchor = vim.sel.anchor;\n            if (anchor) {\n                if (state.isReversed()) {\n                    if (motionArgs.forward) {\n                        return [anchor, from];\n                    }\n                    return [anchor, to];\n                }\n                else {\n                    if (motionArgs.forward) {\n                        return [anchor, to];\n                    }\n                    return [anchor, from];\n                }\n            }\n        }\n        else {\n            vim.visualMode = true;\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: \"\" });\n        }\n        return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n            return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n            var sel = vim.sel;\n            return [\n                clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n                clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n            ];\n        }\n        else {\n            return ([vim.sel.head, vim.sel.anchor]);\n        }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n            var cursor = best;\n            for (var key in vim.marks) {\n                if (!isLowerCase(key)) {\n                    continue;\n                }\n                var mark = vim.marks[key].find();\n                var isWrongDirection = (motionArgs.forward) ?\n                    cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n                if (isWrongDirection) {\n                    continue;\n                }\n                if (motionArgs.linewise && (mark.line == cursor.line)) {\n                    continue;\n                }\n                var equal = cursorEqual(cursor, best);\n                var between = (motionArgs.forward) ?\n                    cursorIsBetween(cursor, mark, best) :\n                    cursorIsBetween(best, mark, cursor);\n                if (equal || between) {\n                    best = mark;\n                }\n            }\n        }\n        if (motionArgs.linewise) {\n            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        switch (vim.lastMotion) {\n            case this.moveByLines:\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveToColumn:\n            case this.moveToEol:\n                endCh = vim.lastHPos;\n                break;\n            default:\n                vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        if (line < first && cur.line == first) {\n            return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }\n        else if (line > last && cur.line == last) {\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        var fold = cm.ace.session.getFoldLine(line);\n        if (fold) {\n            if (motionArgs.forward) {\n                if (line > fold.start.row)\n                    line = fold.end.row + 1;\n            }\n            else {\n                line = fold.start.row;\n            }\n        }\n        if (motionArgs.toFirstChar) {\n            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n            vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n        return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n            case this.moveByDisplayLines:\n            case this.moveByScroll:\n            case this.moveByLines:\n            case this.moveToColumn:\n            case this.moveToEol:\n                break;\n            default:\n                vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        if (res.hitSide) {\n            if (motionArgs.forward) {\n                var lastCharCoords = cm.charCoords(res, 'div');\n                var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n                var res = cm.coordsChar(goalCoords, 'div');\n            }\n            else {\n                var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n                resCoords.left = vim.lastHSPos;\n                res = cm.coordsChar(resCoords, 'div');\n            }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n            return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd)\n            return null;\n        curEnd.ch += increment;\n        return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        var cursor = head;\n        return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n            symbol = lineText.charAt(ch);\n            if (symbol && isMatchableSymbol(symbol)) {\n                var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n                if (style !== \"string\" && style !== \"comment\") {\n                    break;\n                }\n            }\n        }\n        if (ch < lineText.length) {\n            var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n            var matched = cm.findMatchingBracket(new Pos(line, ch + 1), { bracketRegex: re });\n            return matched.to;\n        }\n        else {\n            return cursor;\n        }\n    },\n    moveToStartOfLine: function (_cm, head) {\n        return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n            lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\")\n            head.ch--;\n        return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n        var mirroredPairs = { '(': ')', ')': '(',\n            '{': '}', '}': '{',\n            '[': ']', ']': '[',\n            '<': '>', '>': '<' };\n        var selfPaired = { '\\'': true, '\"': true, '`': true };\n        var character = motionArgs.selectedCharacter;\n        if (character == 'b') {\n            character = '(';\n        }\n        else if (character == 'B') {\n            character = '{';\n        }\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp, move;\n        if (mirroredPairs[character]) {\n            move = true;\n            tmp = selectCompanionObject(cm, head, character, inclusive);\n            if (!tmp) {\n                var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n                if (sc.find()) {\n                    tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n                }\n            }\n        }\n        else if (selfPaired[character]) {\n            move = true;\n            tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        }\n        else if (character === 'W' || character === 'w') {\n            var repeat = motionArgs.repeat || 1;\n            while (repeat-- > 0) {\n                var repeated = expandWordUnderCursor(cm, {\n                    inclusive: inclusive,\n                    innerWord: !inclusive,\n                    bigWord: character === 'W',\n                    noSymbol: character === 'W',\n                    multiline: true\n                }, tmp && tmp.end);\n                if (repeated) {\n                    if (!tmp)\n                        tmp = repeated;\n                    tmp.end = repeated.end;\n                }\n            }\n        }\n        else if (character === 'p') {\n            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n            motionArgs.linewise = true;\n            if (vim.visualMode) {\n                if (!vim.visualLine) {\n                    vim.visualLine = true;\n                }\n            }\n            else {\n                var operatorArgs = vim.inputState.operatorArgs;\n                if (operatorArgs) {\n                    operatorArgs.linewise = true;\n                }\n                tmp.end.line--;\n            }\n        }\n        else if (character === 't') {\n            tmp = expandTagUnderCursor(cm, head, inclusive);\n        }\n        else if (character === 's') {\n            var content = cm.getLine(head.line);\n            if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n                head.ch -= 1;\n            }\n            var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n            var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n            if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n                && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n                start = { line: start.line, ch: start.ch + 1 };\n            }\n            tmp = { start: start, end: end };\n        }\n        if (!tmp) {\n            return null;\n        }\n        if (!cm.state.vim.visualMode) {\n            return [tmp.start, tmp.end];\n        }\n        else {\n            return expandSelection(cm, tmp.start, tmp.end, move);\n        }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n            cm.moveH(increment, 'char');\n            return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n    }\n};\nfunction defineMotion(name, fn) {\n    motions[name] = fn;\n}\nfunction fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n        arr.push(val);\n    }\n    return arr;\n}\nvar operators = {\n    change: function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor, head = ranges[0].head;\n        if (!vim.visualMode) {\n            text = cm.getRange(anchor, head);\n            var lastState = vim.lastEditInputState || {};\n            if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n                var match = (/\\s+$/).exec(text);\n                if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n                    head = offsetCursor(head, 0, -match[0].length);\n                    text = text.slice(0, -match[0].length);\n                }\n            }\n            if (args.linewise) {\n                anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n                if (head.line > anchor.line) {\n                    head = new Pos(head.line - 1, Number.MAX_VALUE);\n                }\n            }\n            cm.replaceRange('', anchor, head);\n            finalHead = anchor;\n        }\n        else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n            var anchor = ranges[0].anchor, head = ranges[0].head;\n            if (args.linewise &&\n                head.line != cm.firstLine() &&\n                anchor.line == cm.lastLine() &&\n                anchor.line == head.line - 1) {\n                if (anchor.line == cm.firstLine()) {\n                    anchor.ch = 0;\n                }\n                else {\n                    anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n                }\n            }\n            text = cm.getRange(anchor, head);\n            cm.replaceRange('', anchor, head);\n            finalHead = anchor;\n            if (args.linewise) {\n                finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n            }\n        }\n        else {\n            text = cm.getSelection();\n            var replacement = fillArray('', ranges.length);\n            cm.replaceSelections(replacement);\n            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            for (var j = 0; j < repeat; j++) {\n                if (args.indentRight)\n                    cm.indentMore();\n                else\n                    cm.indentLess();\n            }\n        }\n        else {\n            var startLine = ranges[0].anchor.line;\n            var endLine = vim.visualBlock ?\n                ranges[ranges.length - 1].anchor.line :\n                ranges[0].head.line;\n            var repeat = (vim.visualMode) ? args.repeat : 1;\n            if (args.linewise) {\n                endLine--;\n            }\n            for (var i = startLine; i <= endLine; i++) {\n                for (var j = 0; j < repeat; j++) {\n                    cm.indentLine(i, args.indentRight);\n                }\n            }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n        if (!cm.hardWrap)\n            return;\n        var from = ranges[0].anchor.line;\n        var to = ranges[0].head.line;\n        if (operatorArgs.linewise)\n            to--;\n        var endRow = cm.hardWrap({ from: from, to: to });\n        if (endRow > from && operatorArgs.linewise)\n            endRow--;\n        return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n            var toSwap = selections[j];\n            var text = '';\n            if (toLower === true) {\n                text = toSwap.toLowerCase();\n            }\n            else if (toLower === false) {\n                text = toSwap.toUpperCase();\n            }\n            else {\n                for (var i = 0; i < toSwap.length; i++) {\n                    var character = toSwap.charAt(i);\n                    text += isUpperCase(character) ? character.toLowerCase() :\n                        character.toUpperCase();\n                }\n            }\n            swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor) {\n            return newHead;\n        }\n        else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        }\n        else if (args.linewise) {\n            return oldAnchor;\n        }\n        else {\n            return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n            ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n            : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n    }\n};\nfunction defineOperator(name, fn) {\n    operators[name] = fn;\n}\nvar actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n            return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n            if (newPos > cursorCoords.top) {\n                cursor.line += (newPos - cursorCoords.top) / lineHeight;\n                cursor.line = Math.ceil(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.top);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n        else {\n            var newBottom = newPos + cm.getScrollInfo().clientHeight;\n            if (newBottom < cursorCoords.bottom) {\n                cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n                cursor.line = Math.floor(cursor.line);\n                cm.setCursor(cursor);\n                cursorCoords = cm.charCoords(cursor, 'local');\n                cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n            }\n            else {\n                cm.scrollTo(null, newPos);\n            }\n        }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n            case 'center':\n                y = charCoords.bottom - height / 2;\n                break;\n            case 'bottom':\n                var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n                var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n                var lineHeight = lineLastCharCoords.bottom - y;\n                y = y - height + lineHeight;\n                break;\n        }\n        cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n            registerName = macroModeState.latestRegister;\n        }\n        else {\n            macroModeState.latestRegister = registerName;\n        }\n        while (repeat--) {\n            executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n            macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n    },\n    toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n            return;\n        }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n            head = new Pos(head.line, lineLength(cm, head.line));\n        }\n        else if (insertAt == 'bol') {\n            head = new Pos(head.line, 0);\n        }\n        else if (insertAt == 'charAfter') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'firstNonBlank') {\n            var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n            head = newPosition.end;\n        }\n        else if (insertAt == 'startOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line < sel.anchor.line) {\n                    head = sel.head;\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n                return;\n            if (!vim.visualBlock) {\n                if (sel.head.line >= sel.anchor.line) {\n                    head = offsetCursor(sel.head, 0, 1);\n                }\n                else {\n                    head = new Pos(sel.anchor.line, 0);\n                }\n            }\n            else {\n                head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n                height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n            }\n        }\n        else if (insertAt == 'inplace') {\n            if (vim.visualMode) {\n                return;\n            }\n        }\n        else if (insertAt == 'lastEdit') {\n            head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n            cm.toggleOverwrite(true);\n            cm.setOption('keyMap', 'vim-replace');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n        }\n        else {\n            cm.toggleOverwrite(false);\n            cm.setOption('keyMap', 'vim-insert');\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n            cm.on('change', onChange);\n            if (vim.insertEnd)\n                vim.insertEnd.clear();\n            vim.insertEnd = cm.setBookmark(head, { insertLeft: true });\n            CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        if (!vim.visualMode) {\n            vim.visualMode = true;\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n            var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n            vim.sel = {\n                anchor: newPosition.start,\n                head: newPosition.end\n            };\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n        }\n        else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n            vim.visualLine = !!actionArgs.linewise;\n            vim.visualBlock = !!actionArgs.blockwise;\n            CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\" });\n            updateCmSelection(cm);\n        }\n        else {\n            exitVisualMode(cm);\n        }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n            updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n            var anchor = lastSelection.anchorMark.find();\n            var head = lastSelection.headMark.find();\n            if (!anchor || !head) {\n                return;\n            }\n            vim.sel = {\n                anchor: anchor,\n                head: head\n            };\n            vim.visualMode = true;\n            vim.visualLine = lastSelection.visualLine;\n            vim.visualBlock = lastSelection.visualBlock;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorMin(anchor, head));\n            updateMark(cm, vim, '>', cursorMax(anchor, head));\n            CodeMirror.signal(cm, 'vim-mode-change', {\n                mode: 'visual',\n                subMode: vim.visualLine ? 'linewise' :\n                    vim.visualBlock ? 'blockwise' : ''\n            });\n        }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n            curStart = cm.getCursor('anchor');\n            curEnd = cm.getCursor('head');\n            if (cursorIsBefore(curEnd, curStart)) {\n                var tmp = curEnd;\n                curEnd = curStart;\n                curStart = tmp;\n            }\n            curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        }\n        else {\n            var repeat = Math.max(actionArgs.repeat, 2);\n            curStart = cm.getCursor();\n            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n            finalCh = lineLength(cm, curStart.line);\n            var text = '';\n            var nextStartCh = 0;\n            if (!actionArgs.keepSpaces) {\n                var nextLine = cm.getLine(curStart.line + 1);\n                nextStartCh = nextLine.search(/\\S/);\n                if (nextStartCh == -1) {\n                    nextStartCh = nextLine.length;\n                }\n                else {\n                    text = \" \";\n                }\n            }\n            cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n        }\n        var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n            cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n            cm.setCursor(cm.firstLine(), 0);\n        }\n        else {\n            insertAt.line = (actionArgs.after) ? insertAt.line :\n                insertAt.line - 1;\n            insertAt.ch = lineLength(cm, insertAt.line);\n            cm.setCursor(insertAt);\n            var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n                CodeMirror.commands.newlineAndIndent;\n            newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n        var _this = this;\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var fallback = function () {\n            var text = register.toString();\n            _this.continuePaste(cm, actionArgs, vim, text, register);\n        };\n        if (actionArgs.registerName === '+' &&\n            typeof navigator !== 'undefined' &&\n            typeof navigator.clipboard !== 'undefined' &&\n            typeof navigator.clipboard.readText === 'function') {\n            navigator.clipboard.readText().then(function (value) {\n                _this.continuePaste(cm, actionArgs, vim, value, register);\n            }, function () { fallback(); });\n        }\n        else {\n            fallback();\n        }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n            return;\n        }\n        if (actionArgs.matchIndent) {\n            var tabSize = cm.getOption(\"tabSize\");\n            var whitespaceLength = function (str) {\n                var tabs = (str.split(\"\\t\").length - 1);\n                var spaces = (str.split(\" \").length - 1);\n                return tabs * tabSize + spaces * 1;\n            };\n            var currentLine = cm.getLine(cm.getCursor().line);\n            var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n            var chompedText = text.replace(/\\n$/, '');\n            var wasChomped = text !== chompedText;\n            var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n            var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n                var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n                if (newIndent < 0) {\n                    return \"\";\n                }\n                else if (cm.getOption(\"indentWithTabs\")) {\n                    var quotient = Math.floor(newIndent / tabSize);\n                    return Array(quotient + 1).join('\\t');\n                }\n                else {\n                    return Array(newIndent + 1).join(' ');\n                }\n            });\n            text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n            var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n            text = text.split('\\n');\n            if (linewise) {\n                text.pop();\n            }\n            for (var i = 0; i < text.length; i++) {\n                text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n            cur.ch += actionArgs.after ? 1 : 0;\n            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        }\n        else if (linewise) {\n            if (vim.visualMode) {\n                text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n            }\n            else if (actionArgs.after) {\n                text = '\\n' + text.slice(0, text.length - 1);\n                cur.ch = lineLength(cm, cur.line);\n            }\n            else {\n                cur.ch = 0;\n            }\n        }\n        else {\n            cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        if (vim.visualMode) {\n            vim.lastPastedText = text;\n            var lastSelectionCurEnd;\n            var selectedArea = getSelectedAreaRange(cm, vim);\n            var selectionStart = selectedArea[0];\n            var selectionEnd = selectedArea[1];\n            var selectedText = cm.getSelection();\n            var selections = cm.listSelections();\n            var emptyStrings = new Array(selections.length).join('1').split('1');\n            if (vim.lastSelection) {\n                lastSelectionCurEnd = vim.lastSelection.headMark.find();\n            }\n            vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n            if (blockwise) {\n                cm.replaceSelections(emptyStrings);\n                selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n                cm.setCursor(selectionStart);\n                selectBlock(cm, selectionEnd);\n                cm.replaceSelections(text);\n                curPosFinal = selectionStart;\n            }\n            else if (vim.visualBlock) {\n                cm.replaceSelections(emptyStrings);\n                cm.setCursor(selectionStart);\n                cm.replaceRange(text, selectionStart, selectionStart);\n                curPosFinal = selectionStart;\n            }\n            else {\n                cm.replaceRange(text, selectionStart, selectionEnd);\n                curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n            }\n            if (lastSelectionCurEnd) {\n                vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n            }\n            if (linewise) {\n                curPosFinal.ch = 0;\n            }\n        }\n        else {\n            if (blockwise) {\n                cm.setCursor(cur);\n                for (var i = 0; i < text.length; i++) {\n                    var line = cur.line + i;\n                    if (line > cm.lastLine()) {\n                        cm.replaceRange('\\n', new Pos(line, 0));\n                    }\n                    var lastCh = lineLength(cm, line);\n                    if (lastCh < cur.ch) {\n                        extendLineToColumn(cm, line, cur.ch);\n                    }\n                }\n                cm.setCursor(cur);\n                selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n                cm.replaceSelections(text);\n                curPosFinal = cur;\n            }\n            else {\n                cm.replaceRange(text, cur);\n                if (linewise) {\n                    var line = actionArgs.after ? cur.line + 1 : cur.line;\n                    curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n                }\n                else {\n                    curPosFinal = copyCursor(cur);\n                    if (!/\\n/.test(text)) {\n                        curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n                    }\n                }\n            }\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n        cm.operation(function () {\n            repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n            cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n        });\n    },\n    redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        var text = register && register.toString();\n        if (text) {\n            cm.replaceSelection(text);\n        }\n    },\n    oneNormalCommand: function (cm, actionArgs, vim) {\n        exitInsertMode(cm, true);\n        vim.insertModeReturn = true;\n        CodeMirror.on(cm, 'vim-command-done', function handler() {\n            if (vim.visualMode)\n                return;\n            if (vim.insertModeReturn) {\n                vim.insertModeReturn = false;\n                if (!vim.insertMode) {\n                    actions.enterInsertMode(cm, {}, vim);\n                }\n            }\n            CodeMirror.off(cm, 'vim-command-done', handler);\n        });\n    },\n    setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n            curStart = cm.getCursor('start');\n            curEnd = cm.getCursor('end');\n        }\n        else {\n            var line = cm.getLine(curStart.line);\n            replaceTo = curStart.ch + actionArgs.repeat;\n            if (replaceTo > line.length) {\n                replaceTo = line.length;\n            }\n            curEnd = new Pos(curStart.line, replaceTo);\n        }\n        var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n        curStart = newPositions.start;\n        curEnd = newPositions.end;\n        if (replaceWith == '\\n') {\n            if (!vim.visualMode)\n                cm.replaceRange('', curStart, curEnd);\n            (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        }\n        else {\n            var replaceWithStr = cm.getRange(curStart, curEnd);\n            replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n            replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n            if (vim.visualBlock) {\n                var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n                replaceWithStr = cm.getSelection();\n                replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n                replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n                cm.replaceSelections(replaceWithStr);\n            }\n            else {\n                cm.replaceRange(replaceWithStr, curStart, curEnd);\n            }\n            if (vim.visualMode) {\n                curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                    selections[0].anchor : selections[0].head;\n                cm.setCursor(curStart);\n                exitVisualMode(cm, false);\n            }\n            else {\n                cm.setCursor(offsetCursor(curEnd, 0, -1));\n            }\n        }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n            start = match.index;\n            end = start + match[0].length;\n            if (cur.ch < end)\n                break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))\n            return;\n        if (match) {\n            var baseStr = match[2] || match[4];\n            var digits = match[3] || match[5];\n            var increment = actionArgs.increase ? 1 : -1;\n            var base = { '0b': 2, '0': 8, '': 10, '0x': 16 }[baseStr.toLowerCase()];\n            var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n            numberStr = number.toString(base);\n            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n            if (numberStr.charAt(0) === '-') {\n                numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n            }\n            else {\n                numberStr = baseStr + zeroPadding + numberStr;\n            }\n            var from = new Pos(cur.line, start);\n            var to = new Pos(cur.line, end);\n            cm.replaceRange(numberStr, from, to);\n        }\n        else {\n            return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) {\n            return;\n        }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n            vim.lastEditInputState.repeatOverride = repeat;\n        }\n        else {\n            repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n};\nfunction defineAction(name, fn) {\n    actions[name] = fn;\n}\nfunction clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n        var direction = 1;\n        if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n            direction = -1;\n        }\n        ch += direction;\n        if (ch > maxCh)\n            ch -= 2;\n    }\n    return new Pos(line, ch);\n}\nfunction copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n            ret[prop] = args[prop];\n        }\n    }\n    return ret;\n}\nfunction offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n}\nfunction commandMatches(keys, keyMap, context, inputState) {\n    if (inputState.operator)\n        context = \"operatorPending\";\n    var match, partial = [], full = [];\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            (command.context && command.context != context) ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) {\n            continue;\n        }\n        if (match == 'partial') {\n            partial.push(command);\n        }\n        if (match == 'full') {\n            full.push(command);\n        }\n    }\n    return {\n        partial: partial.length && partial,\n        full: full.length && full\n    };\n}\nfunction commandMatch(pressed, mapped) {\n    var isLastCharacter = mapped.slice(-11) == '<character>';\n    var isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n        var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n            mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    }\n    else {\n        return pressed == mapped ? 'full' :\n            mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n}\nfunction lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n            case '<CR>':\n                selectedCharacter = '\\n';\n                break;\n            case '<Space>':\n                selectedCharacter = ' ';\n                break;\n            default:\n                selectedCharacter = '';\n                break;\n        }\n    }\n    return selectedCharacter;\n}\nfunction repeatFn(cm, fn, repeat) {\n    return function () {\n        for (var i = 0; i < repeat; i++) {\n            fn(cm);\n        }\n    };\n}\nfunction copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n}\nfunction cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n}\nfunction cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n        return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n    }\n    return false;\n}\nfunction cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n}\nfunction cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n}\nfunction cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n}\nfunction lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n}\nfunction trim(s) {\n    if (s.trim) {\n        return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n}\nfunction escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n}\nfunction extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n}\nfunction selectBlock(cm, selectionEnd) {\n    var selections = [], ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch, headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) {\n            headCh--;\n        }\n    }\n    else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) {\n            headCh++;\n        }\n    }\n    else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n        var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };\n        selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n}\nfunction selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({ anchor: lineHead, head: lineHead });\n    }\n    cm.setSelections(sel, 0);\n}\nfunction getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n            var width = block.width;\n            var height = block.height;\n            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n            var selections = [];\n            for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n                var anchor = new Pos(i, selectionStart.ch);\n                var head = new Pos(i, selectionEnd.ch);\n                var range = { anchor: anchor, head: head };\n                selections.push(range);\n            }\n            cm.setSelections(selections);\n        }\n        else {\n            var start = lastSelection.anchorMark.find();\n            var end = lastSelection.headMark.find();\n            var line = end.line - start.line;\n            var ch = end.ch - start.ch;\n            selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };\n            if (lastSelection.visualLine) {\n                selectionStart = new Pos(selectionStart.line, 0);\n                selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n            }\n            cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n        return getLastSelectedAreaRange();\n    }\n    else {\n        return getCurrentSelectedAreaRange();\n    }\n}\nfunction updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n    }\n    vim.lastSelection = { 'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock };\n}\nfunction expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start : sel.head;\n    var anchor = move ? start : sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n    }\n    else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n    }\n    return [anchor, head];\n}\nfunction updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n}\nfunction makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n            anchor.ch = 0;\n            var lastLine = cm.lastLine();\n            if (head.line > lastLine) {\n                head.line = lastLine;\n            }\n            head.ch = lineLength(cm, head.line);\n        }\n        else {\n            head.ch = 0;\n            anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n            ranges: [{ anchor: anchor, head: head }],\n            primary: 0\n        };\n    }\n    else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;\n        if (fromCh < toCh) {\n            toCh += 1;\n        }\n        else {\n            fromCh += 1;\n        }\n        ;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n            ranges.push({\n                anchor: new Pos(top + i, fromCh),\n                head: new Pos(top + i, toCh)\n            });\n        }\n        return {\n            ranges: ranges,\n            primary: primary\n        };\n    }\n}\nfunction getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n}\nfunction exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode)\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n}\nfunction clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        lines.pop();\n        var line;\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n            curEnd.line--;\n            curEnd.ch = 0;\n        }\n        if (line) {\n            curEnd.line--;\n            curEnd.ch = lineLength(cm, curEnd.line);\n        }\n        else {\n            curEnd.ch = 0;\n        }\n    }\n}\nfunction expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n}\nfunction findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n        return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n}\nfunction expandWordUnderCursor(cm, _a, cursor) {\n    var inclusive = _a.inclusive, innerWord = _a.innerWord, bigWord = _a.bigWord, noSymbol = _a.noSymbol, multiline = _a.multiline;\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n    var wordOnNextLine;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n        test = function (ch) { return /\\s/.test(ch); };\n    }\n    else {\n        while (!test(line.charAt(idx))) {\n            idx++;\n            if (idx >= line.length) {\n                if (!multiline)\n                    return null;\n                idx--;\n                wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n                break;\n            }\n        }\n        if (bigWord) {\n            test = bigWordCharTest[0];\n        }\n        else {\n            test = wordCharTest[0];\n            if (!test(line.charAt(idx))) {\n                test = wordCharTest[1];\n            }\n        }\n    }\n    var end = idx, start = idx;\n    while (test(line.charAt(start)) && start >= 0) {\n        start--;\n    }\n    start++;\n    if (wordOnNextLine) {\n        end = wordOnNextLine.to;\n        endLineNumber = wordOnNextLine.line;\n        endLine = cm.getLine(endLineNumber);\n        if (!endLine && end == 0)\n            end++;\n    }\n    else {\n        while (test(line.charAt(end)) && end < line.length) {\n            end++;\n        }\n    }\n    if (inclusive) {\n        var wordEnd = end;\n        var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n        if (!startsWithSpace) {\n            while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) {\n                end++;\n            }\n        }\n        if (wordEnd == end || startsWithSpace) {\n            var wordStart = start;\n            while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n                start--;\n            }\n            if (!start && !startsWithSpace) {\n                start = wordStart;\n            }\n        }\n    }\n    return { start: new Pos(startLineNumber, start), end: new Pos(endLineNumber, end) };\n}\nfunction expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n}\nfunction recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n}\nfunction recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n}\nvar symbolToMode = {\n    '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n    '[': 'section', ']': 'section',\n    '*': 'comment', '/': 'comment',\n    'm': 'method', 'M': 'method',\n    '#': 'preprocess'\n};\nvar findSymbolModes = {\n    bracket: {\n        isComplete: function (state) {\n            if (state.nextCh === state.symb) {\n                state.depth++;\n                if (state.depth >= 1)\n                    return true;\n            }\n            else if (state.nextCh === state.reverseSymb) {\n                state.depth--;\n            }\n            return false;\n        }\n    },\n    section: {\n        init: function (state) {\n            state.curMoveThrough = true;\n            state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function (state) {\n            return state.index === 0 && state.nextCh === state.symb;\n        }\n    },\n    comment: {\n        isComplete: function (state) {\n            var found = state.lastCh === '*' && state.nextCh === '/';\n            state.lastCh = state.nextCh;\n            return found;\n        }\n    },\n    method: {\n        init: function (state) {\n            state.symb = (state.symb === 'm' ? '{' : '}');\n            state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function (state) {\n            if (state.nextCh === state.symb)\n                return true;\n            return false;\n        }\n    },\n    preprocess: {\n        init: function (state) {\n            state.index = 0;\n        },\n        isComplete: function (state) {\n            if (state.nextCh === '#') {\n                var token = state.lineText.match(/^#(\\w+)/)[1];\n                if (token === 'endif') {\n                    if (state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth++;\n                }\n                else if (token === 'if') {\n                    if (!state.forward && state.depth === 0) {\n                        return true;\n                    }\n                    state.depth--;\n                }\n                if (token === 'else' && state.depth === 0)\n                    return true;\n            }\n            return false;\n        }\n    }\n};\nfunction findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode)\n        return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n        init(state);\n    }\n    while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n            line += increment;\n            state.lineText = cm.getLine(line) || '';\n            if (increment > 0) {\n                state.index = 0;\n            }\n            else {\n                var lineLen = state.lineText.length;\n                state.index = (lineLen > 0) ? (lineLen - 1) : 0;\n            }\n            state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n            cur.line = line;\n            cur.ch = state.index;\n            repeat--;\n        }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n    }\n    return cur;\n}\nfunction findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        pos = (forward) ? 0 : line.length;\n    }\n    while (true) {\n        if (emptyLineIsWord && line == '') {\n            return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        while (pos != stop) {\n            var foundWord = false;\n            for (var i = 0; i < charTests.length && !foundWord; ++i) {\n                if (charTests[i](line.charAt(pos))) {\n                    wordStart = pos;\n                    while (pos != stop && charTests[i](line.charAt(pos))) {\n                        pos += dir;\n                    }\n                    wordEnd = pos;\n                    foundWord = wordStart != wordEnd;\n                    if (wordStart == cur.ch && lineNum == cur.line &&\n                        wordEnd == wordStart + dir) {\n                        continue;\n                    }\n                    else {\n                        return {\n                            from: Math.min(wordStart, wordEnd + 1),\n                            to: Math.max(wordStart, wordEnd),\n                            line: lineNum\n                        };\n                    }\n                }\n            }\n            if (!foundWord) {\n                pos += dir;\n            }\n        }\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n            return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n    }\n}\nfunction moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n            var eodCh = lineLength(cm, cm.lastLine());\n            words.push(forward\n                ? { line: cm.lastLine(), from: eodCh, to: eodCh }\n                : { line: 0, from: 0, to: 0 });\n            break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n    }\n    else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n    }\n    else if (!forward && wordEnd) {\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n            lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n    }\n    else {\n        return new Pos(lastWord.line, lastWord.from);\n    }\n}\nfunction moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n}\nfunction moveToCharacter(cm, repeat, forward, character, head) {\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n            return null;\n        }\n        start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n}\nfunction moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n}\nfunction updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n        return;\n    }\n    if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n}\nfunction charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n            idx -= 1;\n        }\n    }\n    else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n            idx += 1;\n        }\n    }\n    return idx;\n}\nfunction findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start, end, i = line;\n    function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\n    function isBoundary(i, dir, any) {\n        if (any) {\n            return isEmpty(i) != isEmpty(i + dir);\n        }\n        return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n        dir = dir > 0 ? 1 : -1;\n        var foldLine = cm.ace.session.getFoldLine(i);\n        if (foldLine) {\n            if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\n                dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n        }\n    }\n    if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n            skipFold(i);\n            if (isBoundary(i, dir)) {\n                repeat--;\n            }\n            i += dir;\n        }\n        return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n            if (!inclusive || anchor.line != line) {\n                line += 1;\n            }\n        }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n            if (!inclusive || isEmpty(i) != startState) {\n                repeat--;\n            }\n        }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n        startState = true;\n    }\n    else {\n        inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n            if (isBoundary(i, -1, true)) {\n                break;\n            }\n        }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n}\nfunction getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n        if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n            curr.line = null;\n        }\n        else {\n            curr.pos += curr.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            lastSentencePos = curr.pos;\n            if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: curr.pos + 1 };\n                }\n                else {\n                    nextChar(curr);\n                    while (curr.line !== null) {\n                        if (isWhiteSpaceString(curr.line[curr.pos])) {\n                            lastSentencePos = curr.pos;\n                            nextChar(curr);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    return { ln: curr.ln, pos: lastSentencePos + 1 };\n                }\n            }\n            nextChar(curr);\n        }\n        return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        if (curr.line === \"\") {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        var lastSentencePos = curr.pos;\n        nextChar(curr);\n        while (curr.line !== null) {\n            if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n                if (!inclusive) {\n                    return { ln: curr.ln, pos: lastSentencePos };\n                }\n                else {\n                    if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                        return { ln: curr.ln, pos: curr.pos + 1 };\n                    }\n                    else {\n                        return { ln: curr.ln, pos: lastSentencePos };\n                    }\n                }\n            }\n            nextChar(curr);\n        }\n        curr.line = line;\n        if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos };\n        }\n        else {\n            return { ln: curr.ln, pos: lastSentencePos };\n        }\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n            idx.ln += idx.dir;\n            if (!isLine(cm, idx.ln)) {\n                idx.line = null;\n                idx.ln = null;\n                idx.pos = null;\n                return;\n            }\n            idx.line = cm.getLine(idx.ln);\n            idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n            idx.pos += idx.dir;\n        }\n    }\n    function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: curr.pos,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            last_valid.ln = curr.ln;\n            last_valid.pos = curr.pos;\n            if (curr.line === \"\" && !skip_empty_lines) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                return { ln: curr.ln, pos: curr.pos, };\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && !stop\n                && (curr.pos === curr.line.length - 1\n                    || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n                stop = true;\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = line.length - 1; i >= 0; --i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n            line: line,\n            ln: ln,\n            pos: pos,\n            dir: dir,\n        };\n        var last_valid = {\n            ln: curr.ln,\n            pos: null,\n        };\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n            if (curr.line === \"\" && !skip_empty_lines) {\n                if (last_valid.pos !== null) {\n                    return last_valid;\n                }\n                else {\n                    return { ln: curr.ln, pos: curr.pos };\n                }\n            }\n            else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n                && last_valid.pos !== null\n                && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n                return last_valid;\n            }\n            else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n                skip_empty_lines = false;\n                last_valid = { ln: curr.ln, pos: curr.pos };\n            }\n            nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = 0; i < line.length; ++i) {\n            if (!isWhiteSpaceString(line[i])) {\n                last_valid.pos = i;\n                break;\n            }\n        }\n        return last_valid;\n    }\n    var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n    };\n    while (repeat > 0) {\n        if (dir < 0) {\n            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n}\nfunction selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head, start, end;\n    var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/\n    })[symb];\n    var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'\n    })[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, { 'bracketRegex': bracketRegexp });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, { 'bracketRegex': bracketRegexp });\n    if (!start || !end)\n        return null;\n    start = start.pos;\n    end = end.pos;\n    if ((start.line == end.line && start.ch > end.ch)\n        || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n    }\n    if (inclusive) {\n        end.ch += 1;\n    }\n    else {\n        start.ch += 1;\n    }\n    return { start: start, end: end };\n}\nfunction findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n    }\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n        var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n        var isStringStart = stringAfter && !stringBefore;\n        if (!isStringStart) {\n            end = cur.ch; // assign end to the current cursor\n            --cur.ch; // make sure to look backwards\n        }\n    }\n    if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n    }\n    else {\n        for (i = cur.ch; i > -1 && !start; i--) {\n            if (chars[i] == symb) {\n                start = i + 1;\n            }\n        }\n    }\n    if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n            if (chars[i] == symb) {\n                end = i;\n            }\n        }\n    }\n    if (!start || !end) {\n        return { start: cur, end: cur };\n    }\n    if (inclusive) {\n        --start;\n        ++end;\n    }\n    return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n    };\n}\ndefineOption('pcre', true, 'boolean');\nfunction SearchState() { }\nSearchState.prototype = {\n    getQuery: function () {\n        return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n        vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n        return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n        this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n        return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n        return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate;\n    }\n};\nfunction getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n}\nfunction splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n}\nfunction findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n}\nfunction splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length)\n        return [];\n    var tokens = [];\n    if (slashes[0] !== 0)\n        return;\n    for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n            tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n}\nfunction findUnescapedSeparators(str, separator) {\n    if (!separator)\n        separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n            slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n    }\n    return slashes;\n}\nfunction translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n            if (c !== '\\\\' || !specialComesNext) {\n                out.push(c);\n            }\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if (n && unescape.indexOf(n) != -1) {\n                    specialComesNext = true;\n                }\n                if (!specialComesNext || n === '\\\\') {\n                    out.push(c);\n                }\n            }\n            else {\n                out.push(c);\n                if (specialComesNext && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar charUnescapes = { '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t' };\nfunction translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        if (charUnescapes[c + n]) {\n            out.push(charUnescapes[c + n]);\n            i++;\n        }\n        else if (escapeNextChar) {\n            out.push(c);\n            escapeNextChar = false;\n        }\n        else {\n            if (c === '\\\\') {\n                escapeNextChar = true;\n                if ((isNumber(n) || n === '$')) {\n                    out.push('$');\n                }\n                else if (n !== '/' && n !== '\\\\') {\n                    out.push('\\\\');\n                }\n            }\n            else {\n                if (c === '$') {\n                    out.push('$');\n                }\n                out.push(c);\n                if (n === '/') {\n                    out.push('\\\\');\n                }\n            }\n        }\n    }\n    return out.join('');\n}\nvar unescapes = { '\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&': '&' };\nfunction unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n        while (stream.peek() && stream.peek() != '\\\\') {\n            output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n            if (stream.match(matcher, true)) {\n                matched = true;\n                output.push(unescapes[matcher]);\n                break;\n            }\n        }\n        if (!matched) {\n            output.push(stream.next());\n        }\n    }\n    return output.join('');\n}\nfunction parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n        return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n        regexPart = query;\n    }\n    else {\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n    }\n    if (!regexPart) {\n        return null;\n    }\n    if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n    return regexp;\n}\nfunction dom(n) {\n    if (typeof n === 'string')\n        n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i]))\n            continue;\n        if (typeof a !== 'object')\n            a = document.createTextNode(a);\n        if (a.nodeType)\n            n.appendChild(a);\n        else\n            for (var key in a) {\n                if (!Object.prototype.hasOwnProperty.call(a, key))\n                    continue;\n                if (key[0] === '$')\n                    n.style[key.slice(1)] = a[key];\n                else\n                    n.setAttribute(key, a[key]);\n            }\n    }\n    return n;\n}\nfunction showConfirm(cm, template) {\n    var pre = dom('div', { $color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message' }, template);\n    if (cm.openNotification) {\n        cm.openNotification(pre, { bottom: true, duration: 5000 });\n    }\n    else {\n        alert(pre.innerText);\n    }\n}\nfunction makePrompt(prefix, desc) {\n    return dom('div', { $display: 'flex' }, dom('span', { $fontFamily: 'monospace', $whiteSpace: 'pre', $flex: 1 }, prefix, dom('input', { type: 'text', autocorrect: 'off',\n        autocapitalize: 'off', spellcheck: 'false', $width: '100%' })), desc && dom('span', { $color: '#888' }, desc));\n}\nfunction showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n        if (!options.value)\n            options.value = '';\n        virtualPrompt = options;\n        return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            bottom: true, selectValueOnOpen: false, value: options.value\n        });\n    }\n    else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix)\n            shortText += options.prefix.textContent;\n        if (options.desc)\n            shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n    }\n}\nfunction regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n        for (var i = 0; i < props.length; i++) {\n            var prop = props[i];\n            if (r1[prop] !== r2[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n        return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n        return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n        return query;\n    }\n    state.setQuery(query);\n    return query;\n}\nfunction searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n    }\n    return {\n        token: function (stream) {\n            if (matchSol && !stream.sol()) {\n                stream.skipToEnd();\n                return;\n            }\n            var match = stream.match(query, false);\n            if (match) {\n                if (match[0].length == 0) {\n                    stream.next();\n                    return 'searching';\n                }\n                if (!stream.sol()) {\n                    stream.backUp(1);\n                    if (!query.exec(stream.next() + match[0])) {\n                        stream.next();\n                        return null;\n                    }\n                }\n                stream.match(query);\n                return 'searching';\n            }\n            while (!stream.eol()) {\n                stream.next();\n                if (stream.match(query, false))\n                    break;\n            }\n        },\n        query: query\n    };\n}\nvar highlightTimeout = 0;\nfunction highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function () {\n        if (!cm.state.vim)\n            return;\n        var searchState = getSearchState(cm);\n        searchState.highlightTimeout = null;\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n            if (overlay) {\n                cm.removeOverlay(overlay);\n            }\n            overlay = searchOverlay(query);\n            cm.addOverlay(overlay);\n            if (cm.showMatchesOnScrollbar) {\n                if (searchState.getScrollbarAnnotate()) {\n                    searchState.getScrollbarAnnotate().clear();\n                }\n                searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n            }\n            searchState.setOverlay(overlay);\n        }\n    }, 50);\n}\nfunction findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n            var found = cursor.find(prev);\n            if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n                var lastEndPos = prev ? cursor.from() : cursor.to();\n                found = cursor.find(prev);\n                if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n                    if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                        found = cursor.find(prev);\n                }\n            }\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return cursor.from();\n    });\n}\nfunction findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n        repeat = 1;\n    }\n    return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        var found = cursor.find(!prev);\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n            cursor.find(!prev);\n        }\n        for (var i = 0; i < repeat; i++) {\n            found = cursor.find(prev);\n            if (!found) {\n                cursor = cm.getSearchCursor(query, (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n                if (!cursor.find(prev)) {\n                    return;\n                }\n            }\n        }\n        return [cursor.from(), cursor.to()];\n    });\n}\nfunction clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n        clearTimeout(state.highlightTimeout);\n        state.highlightTimeout = null;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n    }\n}\nfunction isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n        pos = pos.line;\n    }\n    if (start instanceof Array) {\n        return inArray(pos, start);\n    }\n    else {\n        if (typeof end == 'number') {\n            return (pos >= start && pos <= end);\n        }\n        else {\n            return pos == start;\n        }\n    }\n}\nfunction getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n        top: renderer.getFirstFullyVisibleRow(),\n        bottom: renderer.getLastFullyVisibleRow()\n    };\n}\nfunction getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    }\n    else if (markName == '.') {\n        return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n}\nfunction getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n        return cm.getLastEditEnd();\n    }\n    var done = cm.doc.history.done;\n    for (var i = done.length; i--;) {\n        if (done[i].changes) {\n            return copyCursor(done[i].changes[0].to);\n        }\n    }\n}\nvar ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n};\nExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            that._processCommand(cm, input, opt_params);\n        });\n    },\n    _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        var inputStream = new CodeMirror.StringStream(input);\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n            this.parseInput_(cm, inputStream, params);\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n        if (vim.visualMode) {\n            exitVisualMode(cm);\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n            if (params.line !== undefined) {\n                commandName = 'move';\n            }\n        }\n        else {\n            command = this.matchCommand_(params.commandName);\n            if (command) {\n                commandName = command.name;\n                if (command.excludeFromCommandHistory) {\n                    commandHistoryRegister.setText(previousCommand);\n                }\n                this.parseCommandArgs_(inputStream, params, command);\n                if (command.type == 'exToKey') {\n                    doKeyToKey(cm, command.toKeys, command);\n                    return;\n                }\n                else if (command.type == 'exToEx') {\n                    this.processCommand(cm, command.toInput);\n                    return;\n                }\n            }\n        }\n        if (!commandName) {\n            showConfirm(cm, 'Not an editor command \":' + input + '\"');\n            return;\n        }\n        try {\n            exCommands[commandName](cm, params);\n            if ((!command || !command.possiblyAsync) && params.callback) {\n                params.callback();\n            }\n        }\n        catch (e) {\n            showConfirm(cm, e.toString());\n            throw e;\n        }\n    },\n    parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        if (inputStream.eat('%')) {\n            result.line = cm.firstLine();\n            result.lineEnd = cm.lastLine();\n        }\n        else {\n            result.line = this.parseLineSpec_(cm, inputStream);\n            if (result.line !== undefined && inputStream.eat(',')) {\n                result.lineEnd = this.parseLineSpec_(cm, inputStream);\n            }\n        }\n        if (result.line == undefined) {\n            if (cm.state.vim.visualMode) {\n                var pos = getMarkPos(cm, cm.state.vim, '<');\n                result.selectionLine = pos && pos.line;\n                pos = getMarkPos(cm, cm.state.vim, '>');\n                result.selectionLineEnd = pos && pos.line;\n            }\n            else {\n                result.selectionLine = cm.getCursor().line;\n            }\n        }\n        else {\n            result.selectionLine = result.line;\n            result.selectionLineEnd = result.lineEnd;\n        }\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n            result.commandName = commandMatch[1];\n        }\n        else {\n            result.commandName = inputStream.match(/.*/)[0];\n        }\n        return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n            return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n            case '.':\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            case '$':\n                return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n            case '\\'':\n                var markName = inputStream.next();\n                var markPos = getMarkPos(cm, cm.state.vim, markName);\n                if (!markPos)\n                    throw new Error('Mark not set');\n                return this.parseLineSpecOffset_(inputStream, markPos.line);\n            case '-':\n            case '+':\n                inputStream.backUp(1);\n                return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n            default:\n                inputStream.backUp(1);\n                return undefined;\n        }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n            var offset = parseInt(offsetMatch[2], 10);\n            if (offsetMatch[1] == \"-\") {\n                line -= offset;\n            }\n            else {\n                line += offset;\n            }\n        }\n        return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n            return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n            params.args = args;\n        }\n    },\n    matchCommand_: function (commandName) {\n        for (var i = commandName.length; i > 0; i--) {\n            var prefix = commandName.substring(0, i);\n            if (this.commandMap_[prefix]) {\n                var command = this.commandMap_[prefix];\n                if (command.name.indexOf(commandName) === 0) {\n                    return command;\n                }\n            }\n        }\n        return null;\n    },\n    buildCommandMap_: function () {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n            var command = defaultExCommandMap[i];\n            var key = command.shortName || command.name;\n            this.commandMap_[key] = command;\n        }\n    },\n    map: function (lhs, rhs, ctx, noremap) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (rhs != ':' && rhs.charAt(0) == ':') {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToEx',\n                    toInput: rhs.substring(1),\n                    user: true\n                };\n            }\n            else {\n                this.commandMap_[commandName] = {\n                    name: commandName,\n                    type: 'exToKey',\n                    toKeys: rhs,\n                    user: true\n                };\n            }\n        }\n        else {\n            var mapping = {\n                keys: lhs,\n                type: 'keyToKey',\n                toKeys: rhs,\n                noremap: !!noremap\n            };\n            if (ctx) {\n                mapping.context = ctx;\n            }\n            defaultKeymap.unshift(mapping);\n        }\n    },\n    unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n            if (ctx) {\n                throw Error('Mode not supported for ex mappings');\n            }\n            var commandName = lhs.substring(1);\n            if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n                delete this.commandMap_[commandName];\n                return true;\n            }\n        }\n        else {\n            var keys = lhs;\n            for (var i = 0; i < defaultKeymap.length; i++) {\n                if (keys == defaultKeymap[i].keys\n                    && defaultKeymap[i].context === ctx) {\n                    defaultKeymap.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n    }\n};\nvar exCommands = {\n    colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n            showConfirm(cm, cm.getOption('theme'));\n            return;\n        }\n        cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx, defaultOnly) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    imap: function (cm, params) { this.map(cm, params, 'insert'); },\n    nmap: function (cm, params) { this.map(cm, params, 'normal'); },\n    vmap: function (cm, params) { this.map(cm, params, 'visual'); },\n    omap: function (cm, params) { this.map(cm, params, 'operatorPending'); },\n    noremap: function (cm, params) { this.map(cm, params, undefined, true); },\n    inoremap: function (cm, params) { this.map(cm, params, 'insert', true); },\n    nnoremap: function (cm, params) { this.map(cm, params, 'normal', true); },\n    vnoremap: function (cm, params) { this.map(cm, params, 'visual', true); },\n    onoremap: function (cm, params) { this.map(cm, params, 'operatorPending', true); },\n    unmap: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n            if (cm) {\n                showConfirm(cm, 'No such mapping: ' + params.input);\n            }\n        }\n    },\n    mapclear: function (cm, params) { vimApi.mapclear(); },\n    imapclear: function (cm, params) { vimApi.mapclear('insert'); },\n    nmapclear: function (cm, params) { vimApi.mapclear('normal'); },\n    vmapclear: function (cm, params) { vimApi.mapclear('visual'); },\n    omapclear: function (cm, params) { vimApi.mapclear('operatorPending'); },\n    move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n                linewise: true },\n            repeatOverride: params.line + 1\n        });\n    },\n    set: function (cm, params) {\n        var setArgs = params.args;\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n            if (cm) {\n                showConfirm(cm, 'Invalid mapping: ' + params.input);\n            }\n            return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n        var forceToggle = false;\n        if (optionName.charAt(optionName.length - 1) == '?') {\n            if (value) {\n                throw Error('Trailing characters: ' + params.argString);\n            }\n            optionName = optionName.substring(0, optionName.length - 1);\n            forceGet = true;\n        }\n        else if (optionName.charAt(optionName.length - 1) == '!') {\n            optionName = optionName.substring(0, optionName.length - 1);\n            forceToggle = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n            optionName = optionName.substring(2);\n            value = false;\n        }\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean) {\n            if (forceToggle) {\n                value = !getOption(optionName, cm, setCfg);\n            }\n            else if (value == undefined) {\n                value = true;\n            }\n        }\n        if (!optionIsBoolean && value === undefined || forceGet) {\n            var oldValue = getOption(optionName, cm, setCfg);\n            if (oldValue instanceof Error) {\n                showConfirm(cm, oldValue.message);\n            }\n            else if (oldValue === true || oldValue === false) {\n                showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n            }\n            else {\n                showConfirm(cm, '  ' + optionName + '=' + oldValue);\n            }\n        }\n        else {\n            var setOptionReturn = setOption(optionName, value, cm, setCfg);\n            if (setOptionReturn instanceof Error) {\n                showConfirm(cm, setOptionReturn.message);\n            }\n        }\n    },\n    setlocal: function (cm, params) {\n        params.setCfg = { scope: 'local' };\n        this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n        params.setCfg = { scope: 'global' };\n        this.set(cm, params);\n    },\n    registers: function (cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n            for (var registerName in registers) {\n                var text = registers[registerName].toString();\n                if (text.length) {\n                    regInfo += '\"' + registerName + '    ' + text + '\\n';\n                }\n            }\n        }\n        else {\n            var registerName;\n            regArgs = regArgs.join('');\n            for (var i = 0; i < regArgs.length; i++) {\n                registerName = regArgs.charAt(i);\n                if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n                    continue;\n                }\n                var register = registers[registerName] || new Register();\n                regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n            }\n        }\n        showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n            if (params.argString) {\n                var args = new CodeMirror.StringStream(params.argString);\n                if (args.eat('!')) {\n                    reverse = true;\n                }\n                if (args.eol()) {\n                    return;\n                }\n                if (!args.eatSpace()) {\n                    return 'Invalid arguments';\n                }\n                var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n                if (!opts && !args.eol()) {\n                    return 'Invalid arguments';\n                }\n                if (opts[1]) {\n                    ignoreCase = opts[1].indexOf('i') != -1;\n                    unique = opts[1].indexOf('u') != -1;\n                    var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n                    var hex = opts[1].indexOf('x') != -1 && 1;\n                    var octal = opts[1].indexOf('o') != -1 && 1;\n                    if (decimal + hex + octal > 1) {\n                        return 'Invalid arguments';\n                    }\n                    number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n                }\n                if (opts[2]) {\n                    pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n                }\n            }\n        }\n        var err = parseArgs();\n        if (err) {\n            showConfirm(cm, err + ': ' + params.argString);\n            return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) {\n            return;\n        }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n            (number == 'decimal') ? /(-?)([\\d]+)/ :\n                (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n                    (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n            for (var i = 0; i < text.length; i++) {\n                var matchPart = pattern ? text[i].match(pattern) : null;\n                if (matchPart && matchPart[0] != '') {\n                    numPart.push(matchPart);\n                }\n                else if (!pattern && numberRegex.exec(text[i])) {\n                    numPart.push(text[i]);\n                }\n                else {\n                    textPart.push(text[i]);\n                }\n            }\n        }\n        else {\n            textPart = text;\n        }\n        function compareFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a = a.toLowerCase();\n                b = b.toLowerCase();\n            }\n            var anum = number && numberRegex.exec(a);\n            var bnum = number && numberRegex.exec(b);\n            if (!anum) {\n                return a < b ? -1 : 1;\n            }\n            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n            return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n            if (reverse) {\n                var tmp;\n                tmp = a;\n                a = b;\n                b = tmp;\n            }\n            if (ignoreCase) {\n                a[0] = a[0].toLowerCase();\n                b[0] = b[0].toLowerCase();\n            }\n            return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n            for (var i = 0; i < numPart.length; i++) {\n                numPart[i] = numPart[i].input;\n            }\n        }\n        else if (!number) {\n            textPart.sort(compareFn);\n        }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n            var textOld = text;\n            var lastLine;\n            text = [];\n            for (var i = 0; i < textOld.length; i++) {\n                if (textOld[i] != lastLine) {\n                    text.push(textOld[i]);\n                }\n                lastLine = textOld[i];\n            }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n        this.global(cm, params);\n    },\n    normal: function (cm, params) {\n        var argString = params.argString;\n        if (argString && argString[0] == '!') {\n            argString = argString.slice(1);\n            noremap = true;\n        }\n        argString = argString.trimStart();\n        if (!argString) {\n            showConfirm(cm, 'Argument is required.');\n            return;\n        }\n        var line = params.line;\n        if (typeof line == 'number') {\n            var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n            for (var i = line; i <= lineEnd; i++) {\n                cm.setCursor(i, 0);\n                doKeyToKey(cm, params.argString.trimStart());\n                if (cm.state.vim.insertMode) {\n                    exitInsertMode(cm, true);\n                }\n            }\n        }\n        else {\n            doKeyToKey(cm, params.argString.trimStart());\n            if (cm.state.vim.insertMode) {\n                exitInsertMode(cm, true);\n            }\n        }\n    },\n    global: function (cm, params) {\n        var argString = params.argString;\n        if (!argString) {\n            showConfirm(cm, 'Regular Expression missing from global');\n            return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        if (argString[0] === '!' && params.commandName[0] === 'g') {\n            inverted = true;\n            argString = argString.slice(1);\n        }\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n            regexPart = tokens[0];\n            cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n            var line = cm.getLine(i);\n            var matched = query.test(line);\n            if (matched !== inverted) {\n                matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n            }\n        }\n        if (!cmd) {\n            showConfirm(cm, matchedLines.join('\\n'));\n            return;\n        }\n        var index = 0;\n        var nextCommand = function () {\n            if (index < matchedLines.length) {\n                var lineHandle = matchedLines[index++];\n                var lineNum = cm.getLineNumber(lineHandle);\n                if (lineNum == null) {\n                    nextCommand();\n                    return;\n                }\n                var command = (lineNum + 1) + cmd;\n                exCommandDispatcher.processCommand(cm, command, {\n                    callback: nextCommand\n                });\n            }\n            else if (cm.releaseLineHandles) {\n                cm.releaseLineHandles();\n            }\n        };\n        nextCommand();\n    },\n    substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n            throw new Error('Search feature not available. Requires searchcursor.js or ' +\n                'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n            regexPart = tokens[0];\n            if (getOption('pcre') && regexPart !== '') {\n                regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n            }\n            replacePart = tokens[1];\n            if (replacePart !== undefined) {\n                if (getOption('pcre')) {\n                    replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n                }\n                else {\n                    replacePart = translateRegexReplace(replacePart);\n                }\n                vimGlobalState.lastSubstituteReplacePart = replacePart;\n            }\n            trailing = tokens[2] ? tokens[2].split(' ') : [];\n        }\n        else {\n            if (argString && argString.length) {\n                showConfirm(cm, 'Substitutions should be of the form ' +\n                    ':s/pattern/replace/');\n                return;\n            }\n        }\n        if (trailing) {\n            flagsPart = trailing[0];\n            count = parseInt(trailing[1]);\n            if (flagsPart) {\n                if (flagsPart.indexOf('c') != -1) {\n                    confirm = true;\n                }\n                if (flagsPart.indexOf('g') != -1) {\n                    global = true;\n                }\n                if (getOption('pcre')) {\n                    regexPart = regexPart + '/' + flagsPart;\n                }\n                else {\n                    regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n                }\n            }\n        }\n        if (regexPart) {\n            try {\n                updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n            }\n            catch (e) {\n                showConfirm(cm, 'Invalid regex: ' + regexPart);\n                return;\n            }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n            showConfirm(cm, 'No previous substitute regular expression');\n            return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n            lineEnd = Infinity;\n        }\n        if (count) {\n            lineStart = lineEnd;\n            lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    startinsert: function (cm, params) {\n        doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n        if (CodeMirror.commands.save) {\n            CodeMirror.commands.save(cm);\n        }\n        else if (cm.save) {\n            cm.save();\n        }\n    },\n    nohlsearch: function (cm) {\n        clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delete: function (cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        operators.delete(cm, { linewise: true }, [\n            { anchor: new Pos(line, 0),\n                head: new Pos(lineEnd + 1, 0) }\n        ]);\n    },\n    join: function (cm, params) {\n        var line = params.selectionLine;\n        var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n        cm.setCursor(new Pos(line, 0));\n        actions.joinLines(cm, { repeat: lineEnd - line }, cm.state.vim);\n    },\n    delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n            showConfirm(cm, 'Argument required');\n            return;\n        }\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n            stream.eatSpace();\n            var count = stream.pos;\n            if (!stream.match(/[a-zA-Z]/, false)) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n            }\n            var sym = stream.next();\n            if (stream.match('-', true)) {\n                if (!stream.match(/[a-zA-Z]/, false)) {\n                    showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                    return;\n                }\n                var startMark = sym;\n                var finishMark = stream.next();\n                if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                    isUpperCase(startMark) && isUpperCase(finishMark)) {\n                    var start = startMark.charCodeAt(0);\n                    var finish = finishMark.charCodeAt(0);\n                    if (start >= finish) {\n                        showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                        return;\n                    }\n                    for (var j = 0; j <= finish - start; j++) {\n                        var mark = String.fromCharCode(start + j);\n                        delete state.marks[mark];\n                    }\n                }\n                else {\n                    showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n                    return;\n                }\n            }\n            else {\n                delete state.marks[sym];\n            }\n        }\n    }\n};\nvar exCommandDispatcher = new ExCommandDispatcher();\nfunction doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n        cm.operation(function () {\n            while (!done) {\n                replace();\n                next();\n            }\n            stop();\n        });\n    }\n    function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n            match = searchCursor.findNext();\n        }\n        return match;\n    }\n    function next() {\n        while (findNextValidMatch() &&\n            isInRange(searchCursor.from(), lineStart, lineEnd)) {\n            if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n                continue;\n            }\n            cm.scrollIntoView(searchCursor.from(), 30);\n            cm.setSelection(searchCursor.from(), searchCursor.to());\n            lastPos = searchCursor.from();\n            done = false;\n            return;\n        }\n        done = true;\n    }\n    function stop(close) {\n        if (close) {\n            close();\n        }\n        cm.focus();\n        if (lastPos) {\n            cm.setCursor(lastPos);\n            var vim = cm.state.vim;\n            vim.exMode = false;\n            vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) {\n            callback();\n        }\n    }\n    function onPromptKeyDown(e, _value, close) {\n        CodeMirror.e_stop(e);\n        var keyName = vimKeyFromEvent(e);\n        switch (keyName) {\n            case 'y':\n                replace();\n                next();\n                break;\n            case 'n':\n                next();\n                break;\n            case 'a':\n                var savedCallback = callback;\n                callback = undefined;\n                cm.operation(replaceAll);\n                callback = savedCallback;\n                break;\n            case 'l':\n                replace();\n            case 'q':\n            case '<Esc>':\n            case '<C-c>':\n            case '<C-[>':\n                stop(close);\n                break;\n        }\n        if (done) {\n            stop(close);\n        }\n        return true;\n    }\n    next();\n    if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n    }\n    if (!confirm) {\n        replaceAll();\n        if (callback) {\n            callback();\n        }\n        return;\n    }\n    showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n    });\n}\nfunction exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n        cm.off('change', onChange);\n        if (vim.insertEnd)\n            vim.insertEnd.clear();\n        vim.insertEnd = null;\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n        cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n    }\n}\nfunction _mapCommand(command) {\n    defaultKeymap.unshift(command);\n}\nfunction mapCommand(keys, type, name, args, extra) {\n    var command = { keys: keys, type: type };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra)\n        command[key] = extra[key];\n    _mapCommand(command);\n}\ndefineOption('insertModeEscKeysTimeout', 200, 'number');\nfunction executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n        if (register.keyBuffer[0]) {\n            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n            key = match[0];\n            text = text.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'macro');\n            if (vim.insertMode) {\n                var changes = register.insertModeChanges[imc++].changes;\n                vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                    changes;\n                repeatInsertModeChanges(cm, changes, 1);\n                exitInsertMode(cm);\n            }\n        }\n    }\n    macroModeState.isPlaying = false;\n}\nfunction logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n        register.pushText(key);\n    }\n}\nfunction logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n}\nfunction logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n        return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n    }\n}\nfunction onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n        var vim = cm.state.vim;\n        while (changeObj) {\n            lastChange.expectCursorActivityForChange = true;\n            if (lastChange.ignoreCount > 1) {\n                lastChange.ignoreCount--;\n            }\n            else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n                || changeObj.origin === undefined /* only in testing */) {\n                var selectionCount = cm.listSelections().length;\n                if (selectionCount > 1)\n                    lastChange.ignoreCount = selectionCount;\n                var text = changeObj.text.join('\\n');\n                if (lastChange.maybeReset) {\n                    lastChange.changes = [];\n                    lastChange.maybeReset = false;\n                }\n                if (text) {\n                    if (cm.state.overwrite && !/\\n/.test(text)) {\n                        lastChange.changes.push([text]);\n                    }\n                    else {\n                        if (text.length > 1) {\n                            var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                            var cursor = cm.getCursor();\n                            if (insertEnd && insertEnd.line == cursor.line) {\n                                var offset = insertEnd.ch - cursor.ch;\n                                if (offset > 0 && offset < text.length) {\n                                    lastChange.changes.push([text, offset]);\n                                    text = '';\n                                }\n                            }\n                        }\n                        if (text)\n                            lastChange.changes.push(text);\n                    }\n                }\n            }\n            changeObj = changeObj.next;\n        }\n    }\n}\nfunction onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n            return;\n        }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n            lastChange.expectCursorActivityForChange = false;\n        }\n        else {\n            lastChange.maybeReset = true;\n            if (vim.insertEnd)\n                vim.insertEnd.clear();\n            vim.insertEnd = cm.setBookmark(cm.getCursor(), { insertLeft: true });\n        }\n    }\n    else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n    }\n}\nfunction handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n    }\n    else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\" });\n    }\n    if (vim.visualMode) {\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n            anchor: anchor,\n            head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n    }\n    else if (!vim.insertMode && !keepHPos) {\n        vim.lastHPos = cm.getCursor().ch;\n    }\n}\nfunction InsertModeKey(keyName, e) {\n    this.keyName = keyName;\n    this.key = e.key;\n    this.ctrlKey = e.ctrlKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    this.shiftKey = e.shiftKey;\n}\nfunction onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n    if (!keyName) {\n        return;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n}\nfunction repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n        if (isAction) {\n            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        }\n        else {\n            commandDispatcher.evalInput(cm, vim);\n        }\n    }\n    function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n            repeat = !vim.lastEditActionCommand ? 1 : repeat;\n            var changeObject = macroModeState.lastInsertModeChanges;\n            repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        for (var i = 0; i < repeat; i++) {\n            repeatCommand();\n            repeatInsert(1);\n        }\n    }\n    else {\n        if (!repeatForInsert) {\n            repeatCommand();\n        }\n        repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n        exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n}\nfunction sendCmKey(cm, key) {\n    CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n        if (typeof binding == 'string') {\n            CodeMirror.commands[binding](cm);\n        }\n        else {\n            binding(cm);\n        }\n        return true;\n    });\n}\nfunction repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n            cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n            var change = changes[j];\n            if (change instanceof InsertModeKey) {\n                sendCmKey(cm, change.keyName, change);\n            }\n            else if (typeof change == \"string\") {\n                cm.replaceSelection(change);\n            }\n            else {\n                var start = cm.getCursor();\n                var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n                cm.replaceRange(change[0], start, change[1] ? start : end);\n                cm.setCursor(end);\n            }\n        }\n    }\n    if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n    }\n}\nCodeMirror.Vim = vimApi;\nvar specialKeyAce = { 'return': 'CR', backspace: 'BS', 'delete': 'Del', esc: 'Esc',\n    left: 'Left', right: 'Right', up: 'Up', down: 'Down', space: 'Space', insert: 'Ins',\n    home: 'Home', end: 'End', pageup: 'PageUp', pagedown: 'PageDown', enter: 'CR'\n};\nfunction lookupKey(hashId, key, e, vim) {\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKeyAce[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n        if (langmap.keymap && key in langmap.keymap) {\n            if (langmap.remapCtrl !== false || !name)\n                key = langmap.keymap[key];\n        }\n        else if (key.charCodeAt(0) > 255) {\n            var code = e.code && e.code.slice(-1) || \"\";\n            if (!e.shiftKey)\n                code = code.toLowerCase();\n            if (code)\n                key = code;\n        }\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n}\nvar handleKey = vimApi.handleKey.bind(vimApi);\nvimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n        return handleKey(cm, key, origin);\n    }, true);\n};\nfunction cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n        if (key == \"insertEnd\")\n            return;\n        var o = state[key];\n        if (Array.isArray(o))\n            o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n            o = cloneVimState(o);\n        n[key] = o;\n    });\n    if (state.sel) {\n        n.sel = {\n            head: state.sel.head && copyCursor(state.sel.head),\n            anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n    }\n    return n;\n}\nfunction multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n    }\n    else if (wasMultiselect && vim.visualBlock) {\n        vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n        cm.ace.exitMultiSelectMode();\n    }\n    else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n    }\n    else {\n        var old = cloneVimState(vim);\n        var changeQueueList = vim.inputState.changeQueueList || [];\n        cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            var index = 0;\n            cm.ace.forEachSelection(function () {\n                var sel = cm.ace.selection;\n                cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n                cm.state.vim.inputState.changeQueue = changeQueueList[index];\n                var head = cm.getCursor(\"head\");\n                var anchor = cm.getCursor(\"anchor\");\n                var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n                var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n                head = offsetCursor(head, 0, headOffset);\n                anchor = offsetCursor(anchor, 0, anchorOffset);\n                cm.state.vim.sel.head = head;\n                cm.state.vim.sel.anchor = anchor;\n                isHandled = handleKey(cm, key, origin);\n                sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n                if (cm.ace.inVirtualSelectionMode) {\n                    changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n                }\n                if (cm.virtualSelectionMode()) {\n                    cm.state.vim = cloneVimState(old);\n                }\n                index++;\n            });\n            if (cm.curOp.cursorActivity && !isHandled)\n                cm.curOp.cursorActivity = false;\n            vim.status = cm.state.vim.status;\n            cm.state.vim = vim;\n            vim.inputState.changeQueueList = changeQueueList;\n            vim.inputState.changeQueue = null;\n        }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n}\nresetVimGlobalState();\nexports.CodeMirror = CodeMirror;\nvar getVim = vimApi.maybeInitVimState_;\nexports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n        var vim = this.state.vim || {};\n        var w = config.characterWidth;\n        var h = config.lineHeight;\n        var top = pixelPos.top;\n        var left = pixelPos.left;\n        if (!vim.insertMode) {\n            var isbackwards = !sel.cursor\n                ? session.selection.isBackwards() || session.selection.isEmpty()\n                : Range.comparePoints(sel.cursor, sel.start) <= 0;\n            if (!isbackwards && left > w)\n                left -= w;\n        }\n        if (!vim.insertMode && vim.status) {\n            h = h / 2;\n            top += h;\n        }\n        domLib.translate(element, left, top);\n        domLib.setStyle(element.style, \"width\", w + \"px\");\n        domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (!vim.insertMode) {\n            return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n        }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n        var editor = data.editor;\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (keyCode == -1)\n            return;\n        if (!vim.insertMode) {\n            if (hashId == -1) {\n                if (key.charCodeAt(0) > 0xFF) {\n                    if (data.inputKey) {\n                        key = data.inputKey;\n                        if (key && data.inputHash == 4)\n                            key = key.toUpperCase();\n                    }\n                }\n                data.inputChar = key;\n            }\n            else if (hashId == 4 || hashId == 0) {\n                if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n                    key = data.inputChar;\n                    hashId = -1;\n                }\n                else {\n                    data.inputChar = null;\n                    data.inputKey = key;\n                    data.inputHash = hashId;\n                }\n            }\n            else {\n                data.inputChar = data.inputKey = null;\n            }\n        }\n        if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n            return { command: \"gotoleft\" };\n        }\n        if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\n            if (!useragent.isMac && editor.getCopyText()) {\n                editor.once(\"copy\", function () {\n                    if (vim.insertMode)\n                        editor.selection.clearSelection();\n                    else\n                        cm.operation(function () { exitVisualMode(cm); });\n                });\n                return { command: \"null\", passEvent: true };\n            }\n        }\n        if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n            var searchState = getSearchState(cm);\n            var overlay = searchState.getOverlay();\n            if (overlay)\n                cm.removeOverlay(overlay);\n        }\n        if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n            var insertMode = vim.insertMode;\n            var name = lookupKey(hashId, key, e || {}, vim);\n            if (vim.status == null)\n                vim.status = \"\";\n            var isHandled = multiSelectHandleKey(cm, name, 'user');\n            vim = getVim(cm); // may be changed by multiSelectHandleKey\n            if (isHandled && vim.status != null)\n                vim.status += name;\n            else if (vim.status == null)\n                vim.status = \"\";\n            cm._signal(\"changeStatus\");\n            if (!isHandled && (hashId != -1 || insertMode))\n                return;\n            return { command: \"null\", passEvent: !isHandled };\n        }\n    },\n    attach: function (editor) {\n        if (!editor.state)\n            editor.state = {};\n        var cm = new CodeMirror(editor);\n        editor.state.cm = cm;\n        editor.$vimModeHandler = this;\n        enterVimMode(cm);\n        getVim(cm).status = null;\n        cm.on('vim-command-done', function () {\n            if (cm.virtualSelectionMode())\n                return;\n            getVim(cm).status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.session.markUndoGroup();\n        });\n        cm.on(\"changeStatus\", function () {\n            cm.ace.renderer.updateCursor();\n            cm.ace._signal(\"changeStatus\");\n        });\n        cm.on(\"vim-mode-change\", function () {\n            if (cm.virtualSelectionMode())\n                return;\n            updateInputMode();\n            cm._signal(\"changeStatus\");\n        });\n        function updateInputMode() {\n            var isIntsert = getVim(cm).insertMode;\n            cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n            editor.textInput.setCommandMode(!isIntsert);\n            editor.renderer.$keepTextAreaAtCursor = isIntsert;\n            editor.renderer.$blockCursor = !isIntsert;\n        }\n        updateInputMode();\n        editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n        var cm = editor.state.cm;\n        leaveVimMode(cm);\n        cm.destroy();\n        editor.state.cm = null;\n        editor.$vimModeHandler = null;\n        editor.renderer.$cursorLayer.drawCursor = null;\n        editor.renderer.setStyle(\"normal-mode\", false);\n        editor.textInput.setCommandMode(false);\n        editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n        var cm = editor.state.cm;\n        var vim = getVim(cm);\n        if (vim.insertMode)\n            return \"INSERT\";\n        var status = \"\";\n        if (vim.visualMode) {\n            status += \"VISUAL\";\n            if (vim.visualLine)\n                status += \" LINE\";\n            if (vim.visualBlock)\n                status += \" BLOCK\";\n        }\n        if (vim.status)\n            status += (status ? \" \" : \"\") + vim.status;\n        return status;\n    }\n};\nvimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n        if (cm) {\n            cm.ace.setOption(\"wrap\", value);\n        }\n    },\n    type: \"boolean\"\n}, false);\nvimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n});\ndefaultKeymap.push({ keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } }, { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } }, { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } }, { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } }, { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } }, { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } }, { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } }, { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } }, { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } }, { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } }, { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } }, { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } }, { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } }, { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } });\ndefaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n});\nvimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise)\n        head--;\n    hardWrap(cm.ace, { startRow: anchor, endRow: head });\n    return Pos(head, 0);\n});\ndefineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n        return;\n    }\n    if (width === undefined) {\n        var value = cm.ace.getOption('printMarginColumn');\n        return value;\n    }\n    else {\n        var column = Math.round(width);\n        if (column > 1) {\n            cm.ace.setOption('printMarginColumn', column);\n        }\n    }\n});\nactions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode)\n        cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\n    else\n        delayedExecAceCommand(null, cm.ace);\n};\nfunction delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n        ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n}\nactions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\n    ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n};\ndefaultKeymapLength = defaultKeymap.length; // ace_patch\nexports.handler.defaultKeymap = defaultKeymap;\nexports.handler.actions = actions;\nexports.Vim = vimApi;\n\n});                (function() {\n                    ace.require([\"ace/keyboard/vim\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"mappings":"AAAAA,GAAG,CAACC,MAAM,CAAC,kBAAkB,EAAC,CAAC,SAAS,EAAC,SAAS,EAAC,QAAQ,EAAC,WAAW,EAAC,YAAY,EAAC,YAAY,CAAC,EAAE,UAASC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAC;EAAC,YAAY;;EACnJ,IAAIC,KAAK,GAAGH,OAAO,CAAC,UAAU,CAAC,CAACG,KAAK;EACrC,SAASC,QAAQA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAC/B,IAAIC,GAAG,GAAGD,OAAO,CAACE,MAAM,IAAIH,MAAM,CAACI,SAAS,CAAC,mBAAmB,CAAC;IACjE,IAAIC,UAAU,GAAGJ,OAAO,CAACI,UAAU,IAAI,KAAK;IAC5C,IAAIC,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACP,OAAO,CAACQ,QAAQ,EAAER,OAAO,CAACS,MAAM,CAAC;IACpD,IAAIA,MAAM,GAAGH,IAAI,CAACL,GAAG,CAACD,OAAO,CAACQ,QAAQ,EAAER,OAAO,CAACS,MAAM,CAAC;IACvD,IAAIC,OAAO,GAAGX,MAAM,CAACW,OAAO;IAC5B,OAAOL,GAAG,IAAII,MAAM,EAAE;MAClB,IAAIE,IAAI,GAAGD,OAAO,CAACE,OAAO,CAACP,GAAG,CAAC;MAC/B,IAAIM,IAAI,CAACE,MAAM,GAAGZ,GAAG,EAAE;QACnB,IAAIa,KAAK,GAAGC,SAAS,CAACJ,IAAI,EAAEV,GAAG,EAAE,CAAC,CAAC;QACnC,IAAIa,KAAK,EAAE;UACP,IAAIE,WAAW,GAAG,MAAM,CAACC,IAAI,CAACN,IAAI,CAAC,CAAC,CAAC,CAAC;UACtCD,OAAO,CAACQ,OAAO,CAAC,IAAIrB,KAAK,CAACQ,GAAG,EAAES,KAAK,CAACK,KAAK,EAAEd,GAAG,EAAES,KAAK,CAACM,GAAG,CAAC,EAAE,IAAI,GAAGJ,WAAW,CAAC;QACpF;QACAP,MAAM,EAAE;MACZ,CAAC,MACI,IAAIL,UAAU,IAAI,IAAI,CAACiB,IAAI,CAACV,IAAI,CAAC,IAAIN,GAAG,IAAII,MAAM,EAAE;QACrD,IAAIa,QAAQ,GAAGZ,OAAO,CAACE,OAAO,CAACP,GAAG,GAAG,CAAC,CAAC;QACvC,IAAIiB,QAAQ,IAAI,IAAI,CAACD,IAAI,CAACC,QAAQ,CAAC,EAAE;UACjC,IAAIC,WAAW,GAAGZ,IAAI,CAACO,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;UAC1C,IAAIM,eAAe,GAAGF,QAAQ,CAACJ,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;UAClD,IAAIO,UAAU,GAAGF,WAAW,GAAG,GAAG,GAAGC,eAAe;UACpD,IAAIV,KAAK,GAAGC,SAAS,CAACU,UAAU,EAAExB,GAAG,EAAE,CAAC,CAAC;UACzC,IAAIa,KAAK,IAAIA,KAAK,CAACK,KAAK,GAAGI,WAAW,CAACV,MAAM,IAAIY,UAAU,CAACZ,MAAM,GAAGZ,GAAG,EAAE;YACtE,IAAIyB,YAAY,GAAG,IAAI7B,KAAK,CAACQ,GAAG,EAAEkB,WAAW,CAACV,MAAM,EAAER,GAAG,GAAG,CAAC,EAAEiB,QAAQ,CAACT,MAAM,GAAGW,eAAe,CAACX,MAAM,CAAC;YACxGH,OAAO,CAACQ,OAAO,CAACQ,YAAY,EAAE,GAAG,CAAC;YAClCrB,GAAG,EAAE;YACLI,MAAM,EAAE;UACZ,CAAC,MACI,IAAIc,WAAW,CAACV,MAAM,GAAGF,IAAI,CAACE,MAAM,EAAE;YACvCH,OAAO,CAACiB,MAAM,CAAC,IAAI9B,KAAK,CAACQ,GAAG,EAAEkB,WAAW,CAACV,MAAM,EAAER,GAAG,EAAEM,IAAI,CAACE,MAAM,CAAC,CAAC;UACxE;QACJ;MACJ;MACAR,GAAG,EAAE;IACT;IACA,SAASU,SAASA,CAACJ,IAAI,EAAEV,GAAG,EAAEM,GAAG,EAAE;MAC/B,IAAII,IAAI,CAACE,MAAM,GAAGZ,GAAG,EACjB;MACJ,IAAI2B,MAAM,GAAGjB,IAAI,CAACkB,KAAK,CAAC,CAAC,EAAE5B,GAAG,CAAC;MAC/B,IAAI6B,KAAK,GAAGnB,IAAI,CAACkB,KAAK,CAAC5B,GAAG,CAAC;MAC3B,IAAI8B,UAAU,GAAG,uBAAuB,CAACd,IAAI,CAACa,KAAK,CAAC;MACpD,IAAIE,WAAW,GAAG,uBAAuB,CAACf,IAAI,CAACW,MAAM,CAAC;MACtD,IAAIT,KAAK,GAAG,CAAC;MACb,IAAIC,GAAG,GAAG,CAAC;MACX,IAAIY,WAAW,IAAI,CAACA,WAAW,CAAC,CAAC,CAAC,EAAE;QAChCb,KAAK,GAAGlB,GAAG,GAAG+B,WAAW,CAAC,CAAC,CAAC,CAACnB,MAAM;QACnCO,GAAG,GAAGnB,GAAG;MACb;MACA,IAAI8B,UAAU,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,EAAE;QAC9B,IAAI,CAACZ,KAAK,EACNA,KAAK,GAAGlB,GAAG;QACfmB,GAAG,GAAGnB,GAAG,GAAG8B,UAAU,CAAC,CAAC,CAAC,CAAClB,MAAM;MACpC;MACA,IAAIM,KAAK,EAAE;QACP,OAAO;UACHA,KAAK,EAAEA,KAAK;UACZC,GAAG,EAAEA;QACT,CAAC;MACL;MACA,IAAIY,WAAW,IAAIA,WAAW,CAAC,CAAC,CAAC,IAAIA,WAAW,CAACC,KAAK,GAAG1B,GAAG,EAAE;QAC1D,OAAO;UACHY,KAAK,EAAEa,WAAW,CAACC,KAAK;UACxBb,GAAG,EAAEY,WAAW,CAACC,KAAK,GAAGD,WAAW,CAAC,CAAC,CAAC,CAACnB;QAC5C,CAAC;MACL;MACA,IAAIkB,UAAU,IAAIA,UAAU,CAAC,CAAC,CAAC,EAAE;QAC7BZ,KAAK,GAAGlB,GAAG,GAAG8B,UAAU,CAAC,CAAC,CAAC,CAAClB,MAAM;QAClC,OAAO;UACHM,KAAK,EAAEA,KAAK;UACZC,GAAG,EAAED,KAAK,GAAGY,UAAU,CAAC,CAAC,CAAC,CAAClB;QAC/B,CAAC;MACL;IACJ;EACJ;EACA,SAASqB,cAAcA,CAACC,CAAC,EAAE;IACvB,IAAIA,CAAC,CAACC,OAAO,CAACC,IAAI,IAAI,cAAc,IAAI,IAAI,CAAChB,IAAI,CAACc,CAAC,CAACG,IAAI,CAAC,EAAE;MACvD,IAAIvC,MAAM,GAAGoC,CAAC,CAACpC,MAAM;MACrB,IAAIwC,MAAM,GAAGxC,MAAM,CAACyC,SAAS,CAACD,MAAM;MACpC,IAAIA,MAAM,CAACrC,MAAM,IAAIH,MAAM,CAAC0C,QAAQ,CAACC,kBAAkB,EACnD;MACJ,IAAIC,SAAS,GAAG5C,MAAM,CAACW,OAAO,CAACkC,YAAY,CAACC,UAAU;MACtD/C,QAAQ,CAACC,MAAM,EAAE;QACbS,QAAQ,EAAE+B,MAAM,CAAClC,GAAG;QAAEI,MAAM,EAAE8B,MAAM,CAAClC,GAAG;QACxCD,UAAU,EAAE;MAChB,CAAC,CAAC;MACF,IAAIuC,SAAS,IAAI5C,MAAM,CAACW,OAAO,CAACkC,YAAY,CAACC,UAAU,EACnD9C,MAAM,CAACW,OAAO,CAACoC,aAAa,CAAC,CAAC;IACtC;EACJ;EACA,IAAIC,MAAM,GAAGrD,OAAO,CAAC,WAAW,CAAC,CAACqD,MAAM;EACxCrD,OAAO,CAAC,WAAW,CAAC,CAACsD,aAAa,CAACD,MAAM,CAACE,SAAS,EAAE,QAAQ,EAAE;IAC3DnD,QAAQ,EAAE;MACNoD,GAAG,EAAE,SAAAA,CAAUC,GAAG,EAAE;QAChB,IAAIA,GAAG,EAAE;UACL,IAAI,CAACC,QAAQ,CAACC,EAAE,CAAC,WAAW,EAAEnB,cAAc,CAAC;QACjD,CAAC,MACI;UACD,IAAI,CAACkB,QAAQ,CAACE,GAAG,CAAC,WAAW,EAAEpB,cAAc,CAAC;QAClD;MACJ,CAAC;MACDqB,KAAK,EAAE;IACX;EACJ,CAAC,CAAC;EACF5D,OAAO,CAACG,QAAQ,GAAGA,QAAQ;AAE3B,CAAC,CAAC;AAEFN,GAAG,CAACC,MAAM,CAAC,kBAAkB,EAAC,CAAC,SAAS,EAAC,SAAS,EAAC,QAAQ,EAAC,WAAW,EAAC,uBAAuB,EAAC,aAAa,EAAC,aAAa,EAAC,cAAc,EAAC,eAAe,EAAC,YAAY,EAAC,mBAAmB,EAAC,sBAAsB,EAAC,oCAAoC,EAAC,eAAe,EAAC,kBAAkB,EAAC,kBAAkB,CAAC,EAAE,UAASC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAC;EAAC;EACnV,YAAY;;EACZ,SAAS4D,GAAGA,CAAA,EAAG;IACX,IAAIC,CAAC,GAAG,EAAE;IACV,SAASC,MAAMA,CAACC,CAAC,EAAE;MACf,IAAI,OAAOA,CAAC,IAAI,QAAQ,EACpB,OAAOA,CAAC,GAAG,EAAE;MACjB,IAAI,MAAM,IAAIA,CAAC,EAAE;QACb,OAAOA,CAAC,CAAChD,IAAI,GAAG,GAAG,GAAGgD,CAAC,CAACC,EAAE;MAC9B;MACA,IAAI,QAAQ,IAAID,CAAC,EAAE;QACf,OAAOD,MAAM,CAACC,CAAC,CAACE,MAAM,CAAC,GAAG,IAAI,GAAGH,MAAM,CAACC,CAAC,CAACG,IAAI,CAAC;MACnD;MACA,IAAIC,KAAK,CAACC,OAAO,CAACL,CAAC,CAAC,EAChB,OAAO,GAAG,GAAGA,CAAC,CAACM,GAAG,CAAC,UAAUC,CAAC,EAAE;QAC5B,OAAOR,MAAM,CAACQ,CAAC,CAAC;MACpB,CAAC,CAAC,GAAG,GAAG;MACZ,OAAOC,IAAI,CAACC,SAAS,CAACT,CAAC,CAAC;IAC5B;IACA,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACzD,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACvC,IAAIV,CAAC,GAAGW,SAAS,CAACD,CAAC,CAAC;MACpB,IAAIE,CAAC,GAAGb,MAAM,CAACC,CAAC,CAAC;MACjBF,CAAC,IAAIc,CAAC,GAAG,IAAI;IACjB;IACAC,OAAO,CAAChB,GAAG,CAACC,CAAC,CAAC;EAClB;EACA,IAAI5D,KAAK,GAAGH,OAAO,CAAC,UAAU,CAAC,CAACG,KAAK;EACrC,IAAI4E,YAAY,GAAG/E,OAAO,CAAC,sBAAsB,CAAC,CAAC+E,YAAY;EAC/D,IAAIC,MAAM,GAAGhF,OAAO,CAAC,YAAY,CAAC;EAClC,IAAIiF,GAAG,GAAGjF,OAAO,CAAC,YAAY,CAAC;EAC/B,IAAIkF,IAAI,GAAGlF,OAAO,CAAC,aAAa,CAAC;EACjC,IAAImF,KAAK,GAAGnF,OAAO,CAAC,cAAc,CAAC;EACnC,IAAIoF,MAAM,GAAGpF,OAAO,CAAC,WAAW,CAAC,CAACoF,MAAM;EACxC,IAAIC,SAAS,GAAGrF,OAAO,CAAC,kBAAkB,CAAC;EAC3C,IAAIsF,eAAe,GAAGtF,OAAO,CAAC,qBAAqB,CAAC,CAACsF,eAAe;EACpE,IAAIC,mBAAmB,GAAGvF,OAAO,CAAC,mCAAmC,CAAC;EACtE,IAAIwF,eAAe,GAAGxF,OAAO,CAAC,cAAc,CAAC,CAACyF,IAAI,CAAClC,SAAS,CAACmC,OAAO;EACpE,IAAItF,QAAQ,GAAGJ,OAAO,CAAC,iBAAiB,CAAC,CAACI,QAAQ;EAClDJ,OAAO,CAAC,iBAAiB,CAAC;EAC1B,IAAI2F,UAAU,GAAG,SAAAA,CAAU7F,GAAG,EAAE;IAC5B,IAAI,CAACA,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC8F,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACC,KAAK,GAAG,CAAC,CAAC;IACf,IAAI,CAACvF,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAACwF,IAAI,GAAG,CAAC;IACb,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACC,IAAI,CAAC,IAAI,CAAC;IACxC,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACD,IAAI,CAAC,IAAI,CAAC;IAC1D,IAAI,CAACE,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACF,IAAI,CAAC,IAAI,CAAC;IAChE,IAAI,CAAClG,GAAG,CAAC6D,EAAE,CAAC,QAAQ,EAAE,IAAI,CAACoC,QAAQ,CAAC;IACpC,IAAI,CAACjG,GAAG,CAAC6D,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAACsC,iBAAiB,CAAC;IACtD,IAAI,CAACnG,GAAG,CAAC6D,EAAE,CAAC,oBAAoB,EAAE,IAAI,CAACuC,oBAAoB,CAAC;EAChE,CAAC;EACDP,UAAU,CAACQ,GAAG,GAAG,UAAUlF,IAAI,EAAEiD,EAAE,EAAE;IACjC,IAAI,EAAE,IAAI,YAAYiC,GAAG,CAAC,EACtB,OAAO,IAAIA,GAAG,CAAClF,IAAI,EAAEiD,EAAE,CAAC;IAC5B,IAAI,CAACjD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiD,EAAE,GAAGA,EAAE;EAChB,CAAC;EACDyB,UAAU,CAACS,YAAY,GAAG,UAAUzD,IAAI,EAAEc,GAAG,EAAE4C,MAAM,EAAE,CAAE,CAAC;EAC1DV,UAAU,CAACjC,QAAQ,GAAG;IAClB4C,IAAI,EAAE,SAAAA,CAAUC,EAAE,EAAE;MAAEA,EAAE,CAACzG,GAAG,CAACwG,IAAI,CAAC,CAAC;IAAE,CAAC;IACtCE,IAAI,EAAE,SAAAA,CAAUD,EAAE,EAAE;MAAEA,EAAE,CAACzG,GAAG,CAAC0G,IAAI,CAAC,CAAC;IAAE,CAAC;IACtCC,gBAAgB,EAAE,SAAAA,CAAUF,EAAE,EAAE;MAAEA,EAAE,CAACzG,GAAG,CAAC4G,MAAM,CAAC,IAAI,CAAC;IAAE,CAAC;IACxDC,UAAU,EAAE,SAAAA,CAAUJ,EAAE,EAAE;MAAEA,EAAE,CAACzG,GAAG,CAACgD,SAAS,CAAC8D,mBAAmB,CAAC,CAAC;IAAE,CAAC;IACrEC,WAAW,EAAE,SAAAA,CAAUN,EAAE,EAAE;MAAEA,EAAE,CAACzG,GAAG,CAACgD,SAAS,CAACgE,iBAAiB,CAAC,CAAC;IAAE;EACvE,CAAC;EACDnB,UAAU,CAACoB,MAAM,GAAG,CAAC,CAAC;EACtBpB,UAAU,CAACqB,QAAQ,GAAGrB,UAAU,CAACsB,OAAO,GAAG,YAAY,CAAE,CAAC;EAC1DtB,UAAU,CAACuB,MAAM,GAAGvB,UAAU,CAACwB,gBAAgB,GAAGhC,KAAK,CAACiC,SAAS;EACjEzB,UAAU,CAAC0B,OAAO,GAAG,UAAU5E,CAAC,EAAE;IAC9B,IAAI6E,GAAG,GAAIpC,IAAI,CAACzC,CAAC,CAAC8E,OAAO,CAAC,IAAI9E,CAAC,CAAC6E,GAAG,IAAI,EAAG;IAC1C,IAAIA,GAAG,CAACnG,MAAM,IAAI,CAAC,EACfmG,GAAG,GAAGA,GAAG,CAACE,WAAW,CAAC,CAAC;IAC3BF,GAAG,GAAGnC,KAAK,CAACsC,iBAAiB,CAAChF,CAAC,CAAC,CAACjB,OAAO,CAAC,UAAU,EAAE,UAAUkG,CAAC,EAAE;MAC9D,OAAOA,CAAC,CAACF,WAAW,CAAC,CAAC;IAC1B,CAAC,CAAC,GAAGF,GAAG;IACR,OAAOA,GAAG;EACd,CAAC;EACD3B,UAAU,CAACoB,MAAM,CAAC,SAAS,CAAC,GAAG,UAAUO,GAAG,EAAE;IAC1C,OAAO,UAAUf,EAAE,EAAE;MACjB,IAAIoB,GAAG,GAAGpB,EAAE,CAACzG,GAAG,CAAC4D,QAAQ,CAACkE,iBAAiB,CAACN,GAAG,CAACO,WAAW,CAAC,CAAC,CAAC;MAC9D,OAAOF,GAAG,IAAIpB,EAAE,CAACzG,GAAG,CAACgI,WAAW,CAACH,GAAG,CAAC,KAAK,KAAK;IACnD,CAAC;EACL,CAAC;EACDhC,UAAU,CAACoC,SAAS,GAAG,SAASA,SAASA,CAACT,GAAG,EAAE/C,GAAG,EAAEyD,MAAM,EAAE;IACxD,IAAI,CAACzD,GAAG,EACJA,GAAG,GAAG,SAAS;IACnB,IAAI,OAAOA,GAAG,IAAI,QAAQ,EACtBA,GAAG,GAAGoB,UAAU,CAACoB,MAAM,CAACxC,GAAG,CAAC,IAAIoB,UAAU,CAACoB,MAAM,CAAC,SAAS,CAAC;IAChE,IAAIkB,KAAK,GAAG,OAAO1D,GAAG,IAAI,UAAU,GAAGA,GAAG,CAAC+C,GAAG,CAAC,GAAG/C,GAAG,CAAC+C,GAAG,CAAC;IAC1D,IAAIW,KAAK,KAAK,KAAK,EACf,OAAO,SAAS;IACpB,IAAIA,KAAK,KAAK,KAAK,EACf,OAAO,OAAO;IAClB,IAAIA,KAAK,IAAI,IAAI,IAAID,MAAM,CAACC,KAAK,CAAC,EAC9B,OAAO,SAAS;IACpB,IAAI1D,GAAG,CAAC2D,WAAW,EAAE;MACjB,IAAI,CAAC7D,KAAK,CAACC,OAAO,CAACC,GAAG,CAAC2D,WAAW,CAAC,EAC/B,OAAOH,SAAS,CAACT,GAAG,EAAE/C,GAAG,CAAC2D,WAAW,EAAEF,MAAM,CAAC;MAClD,KAAK,IAAIrD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAAC2D,WAAW,CAAC/G,MAAM,EAAEwD,CAAC,EAAE,EAAE;QAC7C,IAAIwD,MAAM,GAAGJ,SAAS,CAACT,GAAG,EAAE/C,GAAG,CAAC2D,WAAW,CAACvD,CAAC,CAAC,EAAEqD,MAAM,CAAC;QACvD,IAAIG,MAAM,EACN,OAAOA,MAAM;MACrB;IACJ;EACJ,CAAC;EACDxC,UAAU,CAACyC,eAAe,GAAG,UAAU7B,EAAE,EAAEnC,IAAI,EAAE;IAC7C,OAAOmC,EAAE,CAAC6B,eAAe,CAAChE,IAAI,CAAC;EACnC,CAAC;EACDuB,UAAU,CAAC0C,gBAAgB,GAAG,UAAU9B,EAAE,EAAEnC,IAAI,EAAE,CAClD,CAAC;EACDuB,UAAU,CAAC2C,MAAM,GAAG,UAAUC,CAAC,EAAE5F,IAAI,EAAEF,CAAC,EAAE;IAAE,OAAO8F,CAAC,CAACC,OAAO,CAAC7F,IAAI,EAAEF,CAAC,CAAC;EAAE,CAAC;EACxEkD,UAAU,CAAChC,EAAE,GAAGwB,KAAK,CAACsD,WAAW;EACjC9C,UAAU,CAAC/B,GAAG,GAAGuB,KAAK,CAACuD,cAAc;EACrC/C,UAAU,CAACgD,UAAU,GAAG,UAAUzE,EAAE,EAAE;IAClC,IAAIA,EAAE,GAAG,MAAM,EACX,OAAO,MAAM,CAACvC,IAAI,CAACuC,EAAE,CAAC;IAC1BsB,eAAe,CAACoD,SAAS,GAAG,CAAC;IAC7B,OAAOpD,eAAe,CAAC7D,IAAI,CAACuC,EAAE,CAAC;EACnC,CAAC;EACD,CAAC,YAAY;IACTe,GAAG,CAAC4D,SAAS,CAAClD,UAAU,CAACpC,SAAS,EAAEwB,YAAY,CAAC;IACjD,IAAI,CAAC+D,OAAO,GAAG,YAAY;MACvB,IAAI,CAAChJ,GAAG,CAAC8D,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACmC,QAAQ,CAAC;MACrC,IAAI,CAACjG,GAAG,CAAC8D,GAAG,CAAC,iBAAiB,EAAE,IAAI,CAACqC,iBAAiB,CAAC;MACvD,IAAI,CAACnG,GAAG,CAAC8D,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAACsC,oBAAoB,CAAC;MAC7D,IAAI,CAAC6C,aAAa,CAAC,CAAC;IACxB,CAAC;IACD,IAAI,CAACC,oBAAoB,GAAG,YAAY;MACpC,OAAO,IAAI,CAAClJ,GAAG,CAACmJ,sBAAsB,IAAI,IAAI,CAACnJ,GAAG,CAACgD,SAAS,CAACP,KAAK;IACtE,CAAC;IACD,IAAI,CAACwD,QAAQ,GAAG,UAAUmD,KAAK,EAAE;MAC7B,IAAI,IAAI,CAACC,kBAAkB,EAAE;QACzB,IAAI,CAACA,kBAAkB,CAACC,IAAI,CAACF,KAAK,CAAC;MACvC;MACA,IAAIG,MAAM,GAAG;QAAEC,IAAI,EAAEJ,KAAK,CAACK,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,GAAGL,KAAK,CAACM,KAAK,GAAG;MAAG,CAAC;MAChE,IAAIC,KAAK,GAAG,IAAI,CAACA,KAAK,GAAG,IAAI,CAACA,KAAK,IAAI,CAAC,CAAC;MACzC,IAAI,CAACA,KAAK,CAACC,cAAc,EACrBD,KAAK,CAACC,cAAc,GAAG,IAAI,CAACC,cAAc,CAAC,QAAQ,CAAC,IAAI,IAAI,CAACA,cAAc,CAAC,QAAQ,CAAC,CAACxH,KAAK,CAAC,CAAC;MACjG,IAAI,CAACsH,KAAK,CAACG,UAAU,EAAE;QACnBH,KAAK,CAACG,UAAU,GAAGH,KAAK,CAACJ,MAAM,GAAGA,MAAM;MAC5C,CAAC,MACI;QACDI,KAAK,CAACG,UAAU,CAACC,IAAI,GAAGJ,KAAK,CAACG,UAAU,GAAGP,MAAM;MACrD;MACA,IAAI,CAACS,cAAc,CAACZ,KAAK,CAAC;IAC9B,CAAC;IACD,IAAI,CAACjD,iBAAiB,GAAG,YAAY;MACjC,IAAIwD,KAAK,GAAG,IAAI,CAACA,KAAK,GAAG,IAAI,CAACA,KAAK,IAAI,CAAC,CAAC;MACzC,IAAI,CAACA,KAAK,CAACM,sBAAsB,EAC7BN,KAAK,CAACM,sBAAsB,GAAG,IAAI,CAACJ,cAAc,CAAC,gBAAgB,CAAC,IAAI,IAAI,CAACA,cAAc,CAAC,gBAAgB,CAAC,CAACxH,KAAK,CAAC,CAAC;MACzH,IAAI,CAACsH,KAAK,CAACO,cAAc,GAAG,IAAI;MAChC,IAAI,IAAI,CAAClK,GAAG,CAACmK,iBAAiB,EAAE;QAC5B,IAAI,CAACnK,GAAG,CAACoK,UAAU,CAACC,qBAAqB,CAAC5E,mBAAmB,CAAC6E,eAAe,CAAC;MAClF;IACJ,CAAC;IACD,IAAI,CAACC,SAAS,GAAG,UAAUC,EAAE,EAAEC,KAAK,EAAE;MAClC,IAAI,CAACA,KAAK,IAAI,IAAI,CAACd,KAAK,IAAIc,KAAK,IAAI,IAAI,CAACd,KAAK,IAAI,IAAI,CAACA,KAAK,CAACc,KAAK,EAAE;QACjE,OAAOD,EAAE,CAAC,CAAC;MACf;MACA,IAAIC,KAAK,IAAI,CAAC,IAAI,CAACzK,GAAG,CAAC2J,KAAK,EAAE;QAC1B,IAAI,IAAI,CAACA,KAAK,EACV,IAAI,CAACvD,oBAAoB,CAAC,CAAC;MACnC;MACA,IAAI,CAAC,IAAI,CAACpG,GAAG,CAAC2J,KAAK,EAAE;QACjB,IAAIe,MAAM,GAAG,IAAI,CAAC1K,GAAG,CAAC0K,MAAM;QAC5B,IAAI,CAAC1K,GAAG,CAAC2K,cAAc,CAAC;UACpB/H,OAAO,EAAE;YAAEC,IAAI,EAAE,KAAK;YAAE+H,cAAc,EAAE;UAAS;QACrD,CAAC,CAAC;MACN;MACA,IAAIjB,KAAK,GAAG,IAAI,CAACA,KAAK,GAAG,IAAI,CAACA,KAAK,IAAI,CAAC,CAAC;MACzC,IAAI,CAACA,KAAK,CAACc,KAAK,GAAGA,KAAK;MACxB,IAAIpC,MAAM,GAAGmC,EAAE,CAAC,CAAC;MACjB,IAAI,IAAI,CAACxK,GAAG,CAAC2J,KAAK,IAAI,IAAI,CAAC3J,GAAG,CAAC2J,KAAK,CAAC/G,OAAO,CAACC,IAAI,IAAI,KAAK,EAAE;QACxD,IAAI,IAAI,CAACiD,KAAK,CAAC+E,MAAM,EACjB,IAAI,CAAC7K,GAAG,CAAC2J,KAAK,CAAC/G,OAAO,CAACgI,cAAc,GAAG,IAAI,CAAC5K,GAAG,CAAC2J,KAAK,CAACmB,eAAe;QAC1E,IAAI,CAAC9K,GAAG,CAAC+K,YAAY,CAAC,CAAC;QACvB,IAAI,CAACpB,KAAK,CAACO,cAAc,IAAI,CAACP,KAAK,CAACG,UAAU,IAAIY,MAAM,EACpD,IAAI,CAAC1K,GAAG,CAAC0K,MAAM,GAAGA,MAAM;MAChC;MACA,IAAID,KAAK,IAAI,CAAC,IAAI,CAACzK,GAAG,CAAC2J,KAAK,EAAE;QAC1B,IAAI,IAAI,CAACA,KAAK,EACV,IAAI,CAACvD,oBAAoB,CAAC,CAAC;MACnC;MACA,OAAOiC,MAAM;IACjB,CAAC;IACD,IAAI,CAACjC,oBAAoB,GAAG,YAAY;MACpC,IAAI4E,EAAE,GAAG,IAAI,CAACrB,KAAK;MACnB,IAAIqB,EAAE,EAAE;QACJ,IAAIA,EAAE,CAACzB,MAAM,EAAE;UACX,IAAI,CAACf,MAAM,CAAC,QAAQ,EAAEwC,EAAE,CAACzB,MAAM,EAAEyB,EAAE,CAAC;QACxC;QACA,IAAIA,EAAE,IAAIA,EAAE,CAACd,cAAc,EAAE;UACzB,IAAI,CAAC1B,MAAM,CAAC,gBAAgB,EAAE,IAAI,EAAEwC,EAAE,CAAC;QAC3C;QACA,IAAI,CAACrB,KAAK,GAAG,IAAI;MACrB;IACJ,CAAC;IACD,IAAI,CAACnB,MAAM,GAAG,UAAUyC,SAAS,EAAEtI,CAAC,EAAEuI,QAAQ,EAAE;MAC5C,IAAIC,SAAS,GAAGD,QAAQ,GAAGA,QAAQ,CAACD,SAAS,GAAG,UAAU,CAAC,GACrD,CAAC,IAAI,CAACpB,cAAc,IAAI,CAAC,CAAC,EAAEoB,SAAS,CAAC;MAC5C,IAAI,CAACE,SAAS,EACV;MACJA,SAAS,GAAGA,SAAS,CAAC9I,KAAK,CAAC,CAAC;MAC7B,KAAK,IAAIwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsG,SAAS,CAAC9J,MAAM,EAAEwD,CAAC,EAAE,EACrCsG,SAAS,CAACtG,CAAC,CAAC,CAAC,IAAI,EAAElC,CAAC,CAAC;IAC7B,CAAC;IACD,IAAI,CAACyI,SAAS,GAAG,YAAY;MAAE,OAAO,CAAC;IAAE,CAAC;IAC1C,IAAI,CAACC,QAAQ,GAAG,YAAY;MAAE,OAAO,IAAI,CAACrL,GAAG,CAACkB,OAAO,CAACoK,SAAS,CAAC,CAAC,GAAG,CAAC;IAAE,CAAC;IACxE,IAAI,CAACC,SAAS,GAAG,YAAY;MAAE,OAAO,IAAI,CAACvL,GAAG,CAACkB,OAAO,CAACoK,SAAS,CAAC,CAAC;IAAE,CAAC;IACrE,IAAI,CAACE,SAAS,GAAG,UAAUrK,IAAI,EAAEiD,EAAE,EAAE;MACjC,IAAI,OAAOjD,IAAI,KAAK,QAAQ,EAAE;QAC1BiD,EAAE,GAAGjD,IAAI,CAACiD,EAAE;QACZjD,IAAI,GAAGA,IAAI,CAACA,IAAI;MACpB;MACA,IAAIsK,YAAY,GAAG,CAAC,IAAI,CAAC9B,KAAK,IAAI,CAAC,IAAI,CAAC3J,GAAG,CAACmJ,sBAAsB;MAClE,IAAI,CAAC,IAAI,CAACnJ,GAAG,CAACmJ,sBAAsB,EAChC,IAAI,CAACnJ,GAAG,CAAC0L,mBAAmB,CAAC,CAAC;MAClC,IAAI,CAAC1L,GAAG,CAACkB,OAAO,CAACyK,MAAM,CAAC;QAAE9K,GAAG,EAAEM,IAAI;QAAET,MAAM,EAAE0D;MAAG,CAAC,CAAC;MAClD,IAAI,CAACpE,GAAG,CAACgD,SAAS,CAAC4I,MAAM,CAACzK,IAAI,EAAEiD,EAAE,CAAC;MACnC,IAAIqH,YAAY,EAAE;QACd,IAAI,CAACzL,GAAG,CAACiD,QAAQ,CAAC4I,oBAAoB,CAAC,CAAC;QACxC,IAAI,CAAC7L,GAAG,CAAC+K,YAAY,CAAC,CAAC;MAC3B;IACJ,CAAC;IACD,IAAI,CAACe,SAAS,GAAG,UAAU3H,CAAC,EAAE;MAC1B,IAAI4H,GAAG,GAAG,IAAI,CAAC/L,GAAG,CAACgD,SAAS;MAC5B,IAAIgJ,GAAG,GAAG7H,CAAC,IAAI,QAAQ,GAAI4H,GAAG,CAACE,OAAO,CAAC,CAAC,GAAGF,GAAG,CAACG,IAAI,GAAGH,GAAG,CAAC1H,MAAM,GAC5DF,CAAC,IAAI,MAAM,IAAI,CAACA,CAAC,GAAG4H,GAAG,CAACG,IAAI,GAAGH,GAAG,CAACI,QAAQ,CAAC,CAAC,CAAChI,CAAC,CAAC;MACpD,OAAOiI,OAAO,CAACJ,GAAG,CAAC;IACvB,CAAC;IACD,IAAI,CAACK,cAAc,GAAG,UAAUlI,CAAC,EAAE;MAC/B,IAAImI,MAAM,GAAG,IAAI,CAACtM,GAAG,CAACuM,WAAW,CAACC,SAAS,CAACF,MAAM;MAClD,IAAI,CAACA,MAAM,CAACjL,MAAM,IAAI,IAAI,CAACrB,GAAG,CAACmJ,sBAAsB,EACjD,OAAO,CAAC;QAAE9E,MAAM,EAAE,IAAI,CAACyH,SAAS,CAAC,QAAQ,CAAC;QAAExH,IAAI,EAAE,IAAI,CAACwH,SAAS,CAAC,MAAM;MAAE,CAAC,CAAC;MAC/E,OAAOQ,MAAM,CAAC7H,GAAG,CAAC,UAAUgI,CAAC,EAAE;QAC3B,OAAO;UACHpI,MAAM,EAAE,IAAI,CAACqI,OAAO,CAACN,OAAO,CAACK,CAAC,CAAC1J,MAAM,IAAI0J,CAAC,CAAC7K,GAAG,GAAG6K,CAAC,CAAC9K,KAAK,GAAG8K,CAAC,CAAC7K,GAAG,CAAC,CAAC;UAClE0C,IAAI,EAAE,IAAI,CAACoI,OAAO,CAACN,OAAO,CAACK,CAAC,CAAC1J,MAAM,CAAC;QACxC,CAAC;MACL,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC;IACD,IAAI,CAAC4J,aAAa,GAAG,UAAUxI,CAAC,EAAEyI,SAAS,EAAE;MACzC,IAAIb,GAAG,GAAG,IAAI,CAAC/L,GAAG,CAACuM,WAAW;MAC9B,IAAID,MAAM,GAAGnI,CAAC,CAACM,GAAG,CAAC,UAAUC,CAAC,EAAE;QAC5B,IAAIL,MAAM,GAAGwI,QAAQ,CAACnI,CAAC,CAACL,MAAM,CAAC;QAC/B,IAAIC,IAAI,GAAGuI,QAAQ,CAACnI,CAAC,CAACJ,IAAI,CAAC;QAC3B,IAAImI,CAAC,GAAGpM,KAAK,CAACyM,aAAa,CAACzI,MAAM,EAAEC,IAAI,CAAC,GAAG,CAAC,GACvC,IAAIjE,KAAK,CAAC0M,UAAU,CAAC1I,MAAM,EAAEC,IAAI,CAAC,GAClC,IAAIjE,KAAK,CAAC0M,UAAU,CAACzI,IAAI,EAAED,MAAM,CAAC;QACxCoI,CAAC,CAAC1J,MAAM,GAAG1C,KAAK,CAACyM,aAAa,CAACL,CAAC,CAAC9K,KAAK,EAAE2C,IAAI,CAAC,GAAGmI,CAAC,CAAC7K,GAAG,GAAG6K,CAAC,CAAC9K,KAAK;QAC/D,OAAO8K,CAAC;MACZ,CAAC,CAAC;MACF,IAAI,IAAI,CAACzM,GAAG,CAACmJ,sBAAsB,EAAE;QACjC,IAAI,CAACnJ,GAAG,CAACgD,SAAS,CAACgK,iBAAiB,CAACV,MAAM,CAAC,CAAC,CAAC,CAAC;QAC/C;MACJ;MACA,IAAI,CAACM,SAAS,EAAE;QACZN,MAAM,GAAGA,MAAM,CAACW,OAAO,CAAC,CAAC;MAC7B,CAAC,MACI,IAAIX,MAAM,CAACM,SAAS,CAAC,EAAE;QACxBN,MAAM,CAAChD,IAAI,CAACgD,MAAM,CAACY,MAAM,CAACN,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC/C;MACAb,GAAG,CAACoB,aAAa,CAACb,MAAM,CAAC,CAAC,CAAC,CAACc,KAAK,CAAC,CAAC,CAAC;MACpC,IAAIlM,OAAO,GAAG,IAAI,CAAClB,GAAG,CAACkB,OAAO;MAC9B,KAAK,IAAI2D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyH,MAAM,CAACjL,MAAM,EAAEwD,CAAC,EAAE,EAAE;QACpC,IAAIwI,KAAK,GAAGnM,OAAO,CAACoM,oBAAoB,CAAChB,MAAM,CAACzH,CAAC,CAAC,CAAC,CAAC,CAAC;QACrDkH,GAAG,CAACwB,QAAQ,CAACF,KAAK,CAAC;MACvB;IACJ,CAAC;IACD,IAAI,CAACG,YAAY,GAAG,UAAUC,CAAC,EAAEC,CAAC,EAAElN,OAAO,EAAE;MACzC,IAAIuL,GAAG,GAAG,IAAI,CAAC/L,GAAG,CAACgD,SAAS;MAC5B+I,GAAG,CAACH,MAAM,CAAC6B,CAAC,CAACtM,IAAI,EAAEsM,CAAC,CAACrJ,EAAE,CAAC;MACxB2H,GAAG,CAAC4B,QAAQ,CAACD,CAAC,CAACvM,IAAI,EAAEuM,CAAC,CAACtJ,EAAE,CAAC;MAC1B,IAAI5D,OAAO,IAAIA,OAAO,CAACoN,MAAM,IAAI,QAAQ,EAAE;QACvC,IAAI,CAACxH,oBAAoB,CAAC,CAAC;MAC/B;IACJ,CAAC;IACD,IAAI,CAACyH,iBAAiB,GAAG,UAAU1J,CAAC,EAAE;MAClC,OAAO,CAAC,IAAI,CAACnE,GAAG,CAACgD,SAAS,CAACiJ,OAAO,CAAC,CAAC;IACxC,CAAC;IACD,IAAI,CAACS,OAAO,GAAG,UAAUvI,CAAC,EAAE;MACxB,IAAI6H,GAAG,GAAG,IAAI,CAAChM,GAAG,CAACkB,OAAO,CAAC4M,uBAAuB,CAAC3J,CAAC,CAAChD,IAAI,EAAEgD,CAAC,CAACC,EAAE,CAAC;MAChE,OAAOgI,OAAO,CAACJ,GAAG,CAAC;IACvB,CAAC;IACD,IAAI,CAAC+B,QAAQ,GAAG,UAAU/B,GAAG,EAAE;MAC3B,IAAI,CAAChM,GAAG,CAACkB,OAAO,CAAC8M,iBAAiB,CAAChC,GAAG,CAAC7K,IAAI,EAAE,CAAC,CAAC,CAAC;IACpD,CAAC;IACD,IAAI,CAAC8M,QAAQ,GAAG,UAAUlL,MAAM,EAAE;MAC9B,OAAO;QAAEmL,KAAK,EAAE,SAAAA,CAAA,EAAY,CAAE,CAAC;QAAEC,IAAI,EAAE,SAAAA,CAAA,EAAY,CAAE;MAAE,CAAC;IAC5D,CAAC;IACD,IAAI,CAACnE,cAAc,GAAG,UAAUZ,KAAK,EAAE;MACnC,IAAIgF,QAAQ,GAAGhF,KAAK,CAACK,MAAM,IAAI,QAAQ;MACvC,IAAI9H,KAAK,GAAGyH,KAAK,CAACzH,KAAK;MACvB,IAAIC,GAAG,GAAGwH,KAAK,CAACxH,GAAG;MACnB,IAAIyM,QAAQ,GAAG,CAACzM,GAAG,CAACf,GAAG,GAAGc,KAAK,CAACd,GAAG,KAAKuN,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MAC1D,IAAIE,QAAQ,GAAG,CAAC1M,GAAG,CAAClB,MAAM,GAAGiB,KAAK,CAACjB,MAAM,KAAK0N,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MAChE,IAAIA,QAAQ,EACRxM,GAAG,GAAGD,KAAK;MACf,KAAK,IAAIkD,CAAC,IAAI,IAAI,CAACkB,KAAK,EAAE;QACtB,IAAIwI,KAAK,GAAG,IAAI,CAACxI,KAAK,CAAClB,CAAC,CAAC;QACzB,IAAI2J,GAAG,GAAGnO,KAAK,CAACyM,aAAa,CAACyB,KAAK,EAAE5M,KAAK,CAAC;QAC3C,IAAI6M,GAAG,GAAG,CAAC,EAAE;UACT,SAAS,CAAC;QACd;QACA,IAAIA,GAAG,KAAK,CAAC,EAAE;UACX,IAAIJ,QAAQ,EAAE;YACV,IAAI,CAACG,KAAK,CAACE,YAAY,EAAE;cACrBD,GAAG,GAAG,CAAC;YACX,CAAC,MACI,IAAID,KAAK,CAACG,IAAI,IAAI,CAAC,EAAE;cACtBF,GAAG,GAAG,CAAC;YACX,CAAC,MACI;cACDD,KAAK,CAACG,IAAI,GAAG,CAAC,CAAC;cACf;YACJ;UACJ;QACJ;QACA,IAAIC,IAAI,GAAGP,QAAQ,GAAGI,GAAG,GAAGnO,KAAK,CAACyM,aAAa,CAACyB,KAAK,EAAE3M,GAAG,CAAC;QAC3D,IAAI+M,IAAI,GAAG,CAAC,EAAE;UACVJ,KAAK,CAAC1N,GAAG,IAAIwN,QAAQ;UACrBE,KAAK,CAAC7N,MAAM,IAAI6N,KAAK,CAAC1N,GAAG,IAAIe,GAAG,CAACf,GAAG,GAAGyN,QAAQ,GAAG,CAAC;UACnD;QACJ;QACA,IAAI,CAACF,QAAQ,IAAIO,IAAI,IAAI,CAAC,EAAE;UACxBJ,KAAK,CAAC1N,GAAG,GAAGc,KAAK,CAACd,GAAG;UACrB0N,KAAK,CAAC7N,MAAM,GAAGiB,KAAK,CAACjB,MAAM;UAC3B,IAAIiO,IAAI,KAAK,CAAC,EACVJ,KAAK,CAACG,IAAI,GAAG,CAAC;QACtB;MACJ;IACJ,CAAC;IACD,IAAIE,MAAM,GAAG,SAAAA,CAAUnI,EAAE,EAAEoI,EAAE,EAAEhO,GAAG,EAAEH,MAAM,EAAE;MACxC,IAAI,CAAC+F,EAAE,GAAGA,EAAE;MACZ,IAAI,CAACoI,EAAE,GAAGA,EAAE;MACZ,IAAI,CAAChO,GAAG,GAAGA,GAAG;MACd,IAAI,CAACH,MAAM,GAAGA,MAAM;MACpB+F,EAAE,CAACV,KAAK,CAAC,IAAI,CAAC8I,EAAE,CAAC,GAAG,IAAI;IAC5B,CAAC;IACDD,MAAM,CAACnL,SAAS,CAACyK,KAAK,GAAG,YAAY;MAAE,OAAO,IAAI,CAACzH,EAAE,CAACV,KAAK,CAAC,IAAI,CAAC8I,EAAE,CAAC;IAAE,CAAC;IACvED,MAAM,CAACnL,SAAS,CAAC0K,IAAI,GAAG,YAAY;MAAE,OAAO/B,OAAO,CAAC,IAAI,CAAC;IAAE,CAAC;IAC7D,IAAI,CAAC0C,WAAW,GAAG,UAAU/L,MAAM,EAAEvC,OAAO,EAAE;MAC1C,IAAIuO,EAAE,GAAG,IAAIH,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC5I,IAAI,EAAE,EAAEjD,MAAM,CAAC5B,IAAI,EAAE4B,MAAM,CAACqB,EAAE,CAAC;MAC9D,IAAI,CAAC5D,OAAO,IAAI,CAACA,OAAO,CAACwO,UAAU,EAC/BD,EAAE,CAACN,YAAY,GAAG,IAAI;MAC1B,IAAI,CAAC1I,KAAK,CAACgJ,EAAE,CAACF,EAAE,CAAC,GAAGE,EAAE;MACtB,OAAOA,EAAE;IACb,CAAC;IACD,IAAI,CAACE,KAAK,GAAG,UAAUC,SAAS,EAAEC,IAAI,EAAE;MACpC,IAAIA,IAAI,IAAI,MAAM,EAAE;QAChB,IAAIpD,GAAG,GAAG,IAAI,CAAC/L,GAAG,CAACgD,SAAS;QAC5B+I,GAAG,CAACqD,cAAc,CAAC,CAAC;QACpBrD,GAAG,CAACsD,YAAY,CAAC,CAAC,EAAEH,SAAS,CAAC;MAClC;IACJ,CAAC;IACD,IAAI,CAACI,QAAQ,GAAG,UAAU3N,KAAK,EAAE4N,MAAM,EAAEJ,IAAI,EAAEK,UAAU,EAAE;MACvD,IAAIL,IAAI,IAAI,MAAM,EAAE;QAChB,IAAIlM,QAAQ,GAAG,IAAI,CAACjD,GAAG,CAACiD,QAAQ;QAChC,IAAIwM,MAAM,GAAGxM,QAAQ,CAACyM,WAAW;QACjCH,MAAM,GAAGA,MAAM,GAAGzO,IAAI,CAAC6O,KAAK,CAACF,MAAM,CAACG,MAAM,GAAGH,MAAM,CAACI,UAAU,CAAC;QAC/DV,IAAI,GAAG,MAAM;MACjB;MACA,IAAIA,IAAI,IAAI,MAAM,EAAE;QAChB,IAAIW,SAAS,GAAG,IAAI,CAAC9P,GAAG,CAACkB,OAAO,CAAC6O,wBAAwB,CAACpO,KAAK,CAACR,IAAI,EAAEQ,KAAK,CAACyC,EAAE,CAAC;QAC/E,IAAIoL,UAAU,IAAI,IAAI,EAClBM,SAAS,CAACpP,MAAM,GAAG8O,UAAU;QACjCM,SAAS,CAACjP,GAAG,IAAI0O,MAAM;QACvBO,SAAS,CAACjP,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACL,GAAG,CAAC,CAAC,EAAEqP,SAAS,CAACjP,GAAG,CAAC,EAAE,IAAI,CAACb,GAAG,CAACkB,OAAO,CAAC8O,eAAe,CAAC,CAAC,GAAG,CAAC,CAAC;QAC5F,IAAIhE,GAAG,GAAG,IAAI,CAAChM,GAAG,CAACkB,OAAO,CAAC+O,wBAAwB,CAACH,SAAS,CAACjP,GAAG,EAAEiP,SAAS,CAACpP,MAAM,CAAC;QACpF,OAAO0L,OAAO,CAACJ,GAAG,CAAC;MACvB,CAAC,MACI;QACD;MACJ;IACJ,CAAC;IACD,IAAI,CAACkE,UAAU,GAAG,UAAUlE,GAAG,EAAEmE,IAAI,EAAE;MACnC,IAAIA,IAAI,IAAI,KAAK,IAAI,CAACA,IAAI,EAAE;QACxB,IAAIC,EAAE,GAAG,IAAI,CAACpQ,GAAG,CAACkB,OAAO,CAAC6O,wBAAwB,CAAC/D,GAAG,CAAC7K,IAAI,EAAE6K,GAAG,CAAC5H,EAAE,CAAC;QACpE,OAAO;UAAEiM,IAAI,EAAED,EAAE,CAAC1P,MAAM;UAAE4P,GAAG,EAAEF,EAAE,CAACvP;QAAI,CAAC;MAC3C;MACA,IAAIsP,IAAI,IAAI,OAAO,EAAE;QACjB,IAAIlN,QAAQ,GAAG,IAAI,CAACjD,GAAG,CAACiD,QAAQ;QAChC,IAAImN,EAAE,GAAG,IAAI,CAACpQ,GAAG,CAACkB,OAAO,CAAC6O,wBAAwB,CAAC/D,GAAG,CAAC7K,IAAI,EAAE6K,GAAG,CAAC5H,EAAE,CAAC;QACpE,IAAImM,EAAE,GAAGtN,QAAQ,CAACyM,WAAW,CAACG,UAAU;QACxC,IAAIW,EAAE,GAAGvN,QAAQ,CAACyM,WAAW,CAACe,cAAc;QAC5C,IAAIH,GAAG,GAAGC,EAAE,GAAGH,EAAE,CAACvP,GAAG;QACrB,OAAO;UAAEwP,IAAI,EAAED,EAAE,CAAC1P,MAAM,GAAG8P,EAAE;UAAEF,GAAG,EAAEA,GAAG;UAAEI,MAAM,EAAEJ,GAAG,GAAGC;QAAG,CAAC;MAC/D;IACJ,CAAC;IACD,IAAI,CAACI,UAAU,GAAG,UAAU3E,GAAG,EAAEmE,IAAI,EAAE;MACnC,IAAIlN,QAAQ,GAAG,IAAI,CAACjD,GAAG,CAACiD,QAAQ;MAChC,IAAIkN,IAAI,IAAI,OAAO,EAAE;QACjB,IAAItP,GAAG,GAAGC,IAAI,CAACL,GAAG,CAAC,CAAC,EAAEK,IAAI,CAAC6O,KAAK,CAAC3D,GAAG,CAACsE,GAAG,GAAGrN,QAAQ,CAAC4M,UAAU,CAAC,CAAC;QAChE,IAAIe,GAAG,GAAG9P,IAAI,CAACL,GAAG,CAAC,CAAC,EAAEK,IAAI,CAAC6O,KAAK,CAAC3D,GAAG,CAACqE,IAAI,GAAGpN,QAAQ,CAACwN,cAAc,CAAC,CAAC;QACrE,IAAIrM,EAAE,GAAGnB,QAAQ,CAAC/B,OAAO,CAAC+O,wBAAwB,CAACpP,GAAG,EAAE+P,GAAG,CAAC;QAC5D,OAAOxE,OAAO,CAAChI,EAAE,CAAC;MACtB,CAAC,MACI,IAAI+L,IAAI,IAAI,KAAK,EAAE;QACpB,MAAM,iBAAiB;MAC3B;IACJ,CAAC;IACD,IAAI,CAACU,eAAe,GAAG,UAAUC,KAAK,EAAE9E,GAAG,EAAE+E,QAAQ,EAAE;MACnD,IAAIC,aAAa,GAAG,KAAK;MACzB,IAAIC,QAAQ,GAAG,KAAK;MACpB,IAAIH,KAAK,YAAYI,MAAM,IAAI,CAACJ,KAAK,CAACK,MAAM,EAAE;QAC1CH,aAAa,GAAG,CAACF,KAAK,CAACM,UAAU;QACjCN,KAAK,GAAGA,KAAK,CAACO,MAAM;QACpBJ,QAAQ,GAAG,IAAI;MACnB;MACA,IAAIH,KAAK,IAAI,KAAK,EAAE;QAChBA,KAAK,GAAG,IAAI;QACZG,QAAQ,GAAG,KAAK;MACpB;MACA,IAAIK,MAAM,GAAG,IAAIhM,MAAM,CAAC,CAAC;MACzB,IAAI0G,GAAG,CAAC5H,EAAE,IAAImN,SAAS,EACnBvF,GAAG,CAAC5H,EAAE,GAAGoN,MAAM,CAACC,SAAS;MAC7B,IAAIC,MAAM,GAAG;QAAE7Q,GAAG,EAAEmL,GAAG,CAAC7K,IAAI;QAAET,MAAM,EAAEsL,GAAG,CAAC5H;MAAG,CAAC;MAC9C,IAAIqC,EAAE,GAAG,IAAI;MACb,IAAIkL,IAAI,GAAG,IAAI;MACf,OAAO;QACHC,QAAQ,EAAE,SAAAA,CAAA,EAAY;UAAE,OAAO,IAAI,CAACzD,IAAI,CAAC,KAAK,CAAC;QAAE,CAAC;QAClD0D,YAAY,EAAE,SAAAA,CAAA,EAAY;UAAE,OAAO,IAAI,CAAC1D,IAAI,CAAC,IAAI,CAAC;QAAE,CAAC;QACrDA,IAAI,EAAE,SAAAA,CAAU2D,IAAI,EAAE;UAClBR,MAAM,CAACS,UAAU,CAAC;YACdC,MAAM,EAAElB,KAAK;YACbE,aAAa,EAAEA,aAAa;YAC5BiB,IAAI,EAAE,KAAK;YACXC,SAAS,EAAEJ,IAAI;YACfK,MAAM,EAAElB,QAAQ;YAChBtP,KAAK,EAAEgQ,IAAI,IAAID;UACnB,CAAC,CAAC;UACF,IAAIrE,KAAK,GAAGiE,MAAM,CAACnD,IAAI,CAAC1H,EAAE,CAACzG,GAAG,CAACkB,OAAO,CAAC;UACvCyQ,IAAI,GAAGtE,KAAK;UACZ,OAAOsE,IAAI,IAAI,CAAC,CAACA,IAAI,CAAC1F,OAAO,CAAC,CAAC,CAAC;QACpC,CAAC;QACDmG,IAAI,EAAE,SAAAA,CAAA,EAAY;UAAE,OAAOT,IAAI,IAAIvF,OAAO,CAACuF,IAAI,CAAChQ,KAAK,CAAC;QAAE,CAAC;QACzD0Q,EAAE,EAAE,SAAAA,CAAA,EAAY;UAAE,OAAOV,IAAI,IAAIvF,OAAO,CAACuF,IAAI,CAAC/P,GAAG,CAAC;QAAE,CAAC;QACrDF,OAAO,EAAE,SAAAA,CAAU8H,IAAI,EAAE;UACrB,IAAImI,IAAI,EAAE;YACNA,IAAI,CAAC/P,GAAG,GAAG6E,EAAE,CAACzG,GAAG,CAACkB,OAAO,CAACoR,GAAG,CAAC5Q,OAAO,CAACiQ,IAAI,EAAEnI,IAAI,CAAC;UACrD;QACJ;MACJ,CAAC;IACL,CAAC;IACD,IAAI,CAAC+I,QAAQ,GAAG,UAAU7N,CAAC,EAAE8N,CAAC,EAAE;MAC5B,IAAIvP,QAAQ,GAAG,IAAI,CAACjD,GAAG,CAACiD,QAAQ;MAChC,IAAIwM,MAAM,GAAGxM,QAAQ,CAACyM,WAAW;MACjC,IAAI+C,SAAS,GAAGhD,MAAM,CAACgD,SAAS;MAChCA,SAAS,IAAI,CAACxP,QAAQ,CAACyP,KAAK,CAACC,cAAc,GAAG1P,QAAQ,CAAC4M,UAAU,IAAI5M,QAAQ,CAAC2P,cAAc;MAC5F,IAAIJ,CAAC,IAAI,IAAI,EACT,IAAI,CAACxS,GAAG,CAACkB,OAAO,CAAC2R,YAAY,CAAC/R,IAAI,CAACL,GAAG,CAAC,CAAC,EAAEK,IAAI,CAACC,GAAG,CAACyR,CAAC,EAAEC,SAAS,CAAC,CAAC,CAAC;MACtE,IAAI/N,CAAC,IAAI,IAAI,EACT,IAAI,CAAC1E,GAAG,CAACkB,OAAO,CAAC4R,aAAa,CAAChS,IAAI,CAACL,GAAG,CAAC,CAAC,EAAEK,IAAI,CAACC,GAAG,CAAC2D,CAAC,EAAE+K,MAAM,CAACsD,KAAK,CAAC,CAAC,CAAC;IAC9E,CAAC;IACD,IAAI,CAACC,UAAU,GAAG,YAAY;MAAE,OAAO,CAAC;IAAE,CAAC;IAC3C,IAAI,CAACpI,cAAc,GAAG,UAAUoB,GAAG,EAAEiH,MAAM,EAAE;MACzC,IAAIjH,GAAG,EAAE;QACL,IAAI/I,QAAQ,GAAG,IAAI,CAACjD,GAAG,CAACiD,QAAQ;QAChC,IAAIiQ,UAAU,GAAG;UAAE,KAAK,EAAE,CAAC;UAAE,QAAQ,EAAED;QAAO,CAAC;QAC/ChQ,QAAQ,CAAC4I,oBAAoB,CAACgB,QAAQ,CAACb,GAAG,CAAC,EAAG/I,QAAQ,CAAC4M,UAAU,GAAG,CAAC,GAAI5M,QAAQ,CAACyP,KAAK,CAACC,cAAc,EAAEO,UAAU,CAAC;MACvH;IACJ,CAAC;IACD,IAAI,CAAC9R,OAAO,GAAG,UAAUP,GAAG,EAAE;MAAE,OAAO,IAAI,CAACb,GAAG,CAACkB,OAAO,CAACE,OAAO,CAACP,GAAG,CAAC;IAAE,CAAC;IACvE,IAAI,CAACsL,QAAQ,GAAG,UAAUgH,CAAC,EAAExQ,CAAC,EAAE;MAC5B,OAAO,IAAI,CAAC3C,GAAG,CAACkB,OAAO,CAACkS,YAAY,CAAC,IAAI/S,KAAK,CAAC8S,CAAC,CAAChS,IAAI,EAAEgS,CAAC,CAAC/O,EAAE,EAAEzB,CAAC,CAACxB,IAAI,EAAEwB,CAAC,CAACyB,EAAE,CAAC,CAAC;IAC/E,CAAC;IACD,IAAI,CAAClC,YAAY,GAAG,UAAUsH,IAAI,EAAE2J,CAAC,EAAExQ,CAAC,EAAE;MACtC,IAAI,CAACA,CAAC,EACFA,CAAC,GAAGwQ,CAAC;MACT,IAAI9F,KAAK,GAAG,IAAIhN,KAAK,CAAC8S,CAAC,CAAChS,IAAI,EAAEgS,CAAC,CAAC/O,EAAE,EAAEzB,CAAC,CAACxB,IAAI,EAAEwB,CAAC,CAACyB,EAAE,CAAC;MACjD,IAAI,CAACpE,GAAG,CAACkB,OAAO,CAACoM,oBAAoB,CAACD,KAAK,CAAC;MAC5C,OAAO,IAAI,CAACrN,GAAG,CAACkB,OAAO,CAACQ,OAAO,CAAC2L,KAAK,EAAE7D,IAAI,CAAC;IAChD,CAAC;IACD,IAAI,CAAC6J,gBAAgB,GACjB,IAAI,CAACC,iBAAiB,GAAG,UAAUnP,CAAC,EAAE;MAClC,IAAIoP,OAAO,GAAGhP,KAAK,CAACC,OAAO,CAACL,CAAC,CAAC,IAAIA,CAAC;MACnC,IAAI4H,GAAG,GAAG,IAAI,CAAC/L,GAAG,CAACgD,SAAS;MAC5B,IAAI,IAAI,CAAChD,GAAG,CAACmJ,sBAAsB,EAAE;QACjC,IAAI,CAACnJ,GAAG,CAACkB,OAAO,CAACQ,OAAO,CAACqK,GAAG,CAACI,QAAQ,CAAC,CAAC,EAAEoH,OAAO,GAAGpP,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,GAAGA,CAAC,CAAC;QAClE;MACJ;MACA4H,GAAG,CAAC5C,sBAAsB,GAAG,IAAI;MACjC,IAAImD,MAAM,GAAGP,GAAG,CAACS,SAAS,CAACF,MAAM;MACjC,IAAI,CAACA,MAAM,CAACjL,MAAM,EACdiL,MAAM,GAAG,CAAC,IAAI,CAACtM,GAAG,CAACuM,WAAW,CAACJ,QAAQ,CAAC,CAAC,CAAC;MAC9C,KAAK,IAAItH,CAAC,GAAGyH,MAAM,CAACjL,MAAM,EAAEwD,CAAC,EAAE,GAC3B,IAAI,CAAC7E,GAAG,CAACkB,OAAO,CAACQ,OAAO,CAAC4K,MAAM,CAACzH,CAAC,CAAC,EAAE0O,OAAO,GAAGpP,CAAC,CAACU,CAAC,CAAC,IAAI,EAAE,GAAGV,CAAC,CAAC;MACjE4H,GAAG,CAAC5C,sBAAsB,GAAG,KAAK;IACtC,CAAC;IACL,IAAI,CAACqK,YAAY,GAAG,YAAY;MAC5B,OAAO,IAAI,CAACxT,GAAG,CAACyT,eAAe,CAAC,CAAC;IACrC,CAAC;IACD,IAAI,CAACC,aAAa,GAAG,YAAY;MAC7B,OAAO,IAAI,CAACrH,cAAc,CAAC,CAAC,CAAC5H,GAAG,CAAC,UAAUC,CAAC,EAAE;QAC1C,OAAO,IAAI,CAACyH,QAAQ,CAACzH,CAAC,CAACL,MAAM,EAAEK,CAAC,CAACJ,IAAI,CAAC;MAC1C,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC;IACD,IAAI,CAACqP,aAAa,GAAG,YAAY;MAC7B,OAAO,IAAI,CAAC3T,GAAG,CAAC4T,SAAS,CAACC,UAAU,CAAC,CAAC;IAC1C,CAAC;IACD,IAAI,CAACC,iBAAiB,GAAG,YAAY;MACjC,OAAO,IAAI,CAAC9T,GAAG,CAAC+T,SAAS;IAC7B,CAAC;IACD,IAAIC,MAAM,GAAG;MACTC,cAAc,EAAE,aAAa;MAC7BC,UAAU,EAAE,SAAS;MACrBC,OAAO,EAAE,SAAS;MAClBC,eAAe,EAAE,iBAAiB;MAClCC,QAAQ,EAAE;IACd,CAAC;IACD,IAAI,CAACC,SAAS,GAAG,UAAUzR,IAAI,EAAEc,GAAG,EAAE;MAClC,IAAI,CAACmC,KAAK,CAACjD,IAAI,CAAC,GAAGc,GAAG;MACtB,QAAQd,IAAI;QACR,KAAK,gBAAgB;UACjBA,IAAI,GAAGmR,MAAM,CAACnR,IAAI,CAAC;UACnBc,GAAG,GAAG,CAACA,GAAG;UACV;QACJ,KAAK,QAAQ;UACT,IAAI,CAACmC,KAAK,CAACyO,OAAO,GAAG5Q,GAAG;UACxB;UACA;QACJ;UACId,IAAI,GAAGmR,MAAM,CAACnR,IAAI,CAAC;MAC3B;MACA,IAAIA,IAAI,EACJ,IAAI,CAAC7C,GAAG,CAACsU,SAAS,CAACzR,IAAI,EAAEc,GAAG,CAAC;IACrC,CAAC;IACD,IAAI,CAAChD,SAAS,GAAG,UAAUkC,IAAI,EAAE;MAC7B,IAAIc,GAAG;MACP,IAAI6Q,MAAM,GAAGR,MAAM,CAACnR,IAAI,CAAC;MACzB,IAAI2R,MAAM,EACN7Q,GAAG,GAAG,IAAI,CAAC3D,GAAG,CAACW,SAAS,CAAC6T,MAAM,CAAC;MACpC,QAAQ3R,IAAI;QACR,KAAK,gBAAgB;UACjBA,IAAI,GAAGmR,MAAM,CAACnR,IAAI,CAAC;UACnB,OAAO,CAACc,GAAG;QACf,KAAK,QAAQ;UACT,OAAO,IAAI,CAACmC,KAAK,CAACyO,OAAO,IAAI,KAAK;MAC1C;MACA,OAAOC,MAAM,GAAG7Q,GAAG,GAAG,IAAI,CAACmC,KAAK,CAACjD,IAAI,CAAC;IAC1C,CAAC;IACD,IAAI,CAAC4R,eAAe,GAAG,UAAU5Q,EAAE,EAAE;MACjC,IAAI,CAACiC,KAAK,CAAC4O,SAAS,GAAG7Q,EAAE;MACzB,OAAO,IAAI,CAAC7D,GAAG,CAAC2U,YAAY,CAAC9Q,EAAE,CAAC;IACpC,CAAC;IACD,IAAI,CAAC+Q,UAAU,GAAG,UAAUnM,CAAC,EAAE;MAC3B,IAAI,CAAC,IAAI,CAACoM,gBAAgB,IAAI,CAAC,IAAI,CAACA,gBAAgB,CAAC3T,OAAO,EAAE;QAC1D,IAAI4T,SAAS,GAAG,IAAItP,eAAe,CAAC,IAAI,EAAE,sBAAsB,EAAE,MAAM,CAAC;QACzE,IAAIuP,MAAM,GAAG,IAAI,CAAC/U,GAAG,CAACkB,OAAO,CAAC8T,gBAAgB,CAACF,SAAS,CAAC;QACzDA,SAAS,CAACjG,EAAE,GAAGkG,MAAM,CAAClG,EAAE;QACxBiG,SAAS,CAAC5T,OAAO,GAAG,IAAI,CAAClB,GAAG,CAACkB,OAAO;QACpC4T,SAAS,CAAC9L,OAAO,GAAG,UAAUP,CAAC,EAAE;UAC7BqM,SAAS,CAAC5T,OAAO,CAAC4C,GAAG,CAAC,QAAQ,EAAEgR,SAAS,CAACG,cAAc,CAAC;UACzDH,SAAS,CAAC5T,OAAO,CAAC4C,GAAG,CAAC,cAAc,EAAEgR,SAAS,CAAC9L,OAAO,CAAC;UACxD8L,SAAS,CAAC5T,OAAO,CAACgU,YAAY,CAACJ,SAAS,CAACjG,EAAE,CAAC;UAC5CiG,SAAS,CAAC5T,OAAO,GAAG,IAAI;QAC5B,CAAC;QACD4T,SAAS,CAACG,cAAc,GAAG,UAAU7L,KAAK,EAAE;UACxC,IAAIvI,GAAG,GAAGuI,KAAK,CAACzH,KAAK,CAACd,GAAG;UACzB,IAAIA,GAAG,IAAIuI,KAAK,CAACxH,GAAG,CAACf,GAAG,EACpBiU,SAAS,CAACK,KAAK,CAACtU,GAAG,CAAC,GAAG0Q,SAAS,CAAC,KAEjCuD,SAAS,CAACK,KAAK,CAACjI,MAAM,CAACrM,GAAG,EAAEiU,SAAS,CAACK,KAAK,CAAC9T,MAAM,CAAC;QAC3D,CAAC;QACDyT,SAAS,CAAC5T,OAAO,CAAC2C,EAAE,CAAC,cAAc,EAAEiR,SAAS,CAAC9L,OAAO,CAAC;QACvD8L,SAAS,CAAC5T,OAAO,CAAC2C,EAAE,CAAC,QAAQ,EAAEiR,SAAS,CAACG,cAAc,CAAC;MAC5D;MACA,IAAIG,EAAE,GAAG,IAAIlE,MAAM,CAACzI,CAAC,CAACqI,KAAK,CAACO,MAAM,EAAE,KAAK,CAAC;MAC1C,IAAI,CAACwD,gBAAgB,GAAGpM,CAAC,CAACqM,SAAS,GAAGA,SAAS;MAC/C,IAAI,CAACD,gBAAgB,CAACQ,SAAS,CAACD,EAAE,CAAC;MACnC,IAAI,CAACpV,GAAG,CAACiD,QAAQ,CAACqS,iBAAiB,CAAC,CAAC;IACzC,CAAC;IACD,IAAI,CAACrM,aAAa,GAAG,UAAUR,CAAC,EAAE;MAC9B,IAAI,IAAI,CAACoM,gBAAgB,IAAI,IAAI,CAACA,gBAAgB,CAAC3T,OAAO,EAAE;QACxD,IAAI,CAAC2T,gBAAgB,CAAC7L,OAAO,CAAC,CAAC;MACnC;IACJ,CAAC;IACD,IAAI,CAACuM,aAAa,GAAG,YAAY;MAC7B,IAAItS,QAAQ,GAAG,IAAI,CAACjD,GAAG,CAACiD,QAAQ;MAChC,IAAIwM,MAAM,GAAGxM,QAAQ,CAACyM,WAAW;MACjC,OAAO;QACHW,IAAI,EAAEpN,QAAQ,CAACuS,UAAU;QACzBlF,GAAG,EAAErN,QAAQ,CAACwS,SAAS;QACvB7F,MAAM,EAAEH,MAAM,CAACgD,SAAS;QACxBM,KAAK,EAAEtD,MAAM,CAACsD,KAAK;QACnB2C,YAAY,EAAEjG,MAAM,CAACG,MAAM;QAC3B+F,WAAW,EAAElG,MAAM,CAACsD;MACxB,CAAC;IACL,CAAC;IACD,IAAI,CAAC6C,QAAQ,GAAG,YAAY;MACxB,OAAO,IAAI,CAAC5V,GAAG,CAAC4V,QAAQ,CAAC,CAAC;IAC9B,CAAC;IACD,IAAI,CAACC,QAAQ,GAAG,UAAUC,CAAC,EAAE;MACzB,OAAO,IAAI,CAAC9V,GAAG,CAAC6V,QAAQ,CAACC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;IACD,IAAI,CAACC,cAAc,GAAG,UAAU/J,GAAG,EAAE;MACjC,IAAIgK,KAAK,GAAG,IAAI,CAAChW,GAAG,CAACkB,OAAO,CAAC+U,UAAU,CAACjK,GAAG,CAAC7K,IAAI,EAAE6K,GAAG,CAAC5H,EAAE,CAAC;MACzD,OAAO4R,KAAK,IAAI,gBAAgB,CAACnU,IAAI,CAACmU,KAAK,CAACE,IAAI,CAAC,GAAG,QAAQ,GAAG,EAAE;IACrE,CAAC;IACD,IAAI,CAACC,mBAAmB,GAAG,UAAUnK,GAAG,EAAE;MACtC,IAAIpE,CAAC,GAAG,IAAI,CAAC5H,GAAG,CAACkB,OAAO,CAACiV,mBAAmB,CAACtJ,QAAQ,CAACb,GAAG,CAAC,CAAC;MAC3D,OAAO;QAAEqG,EAAE,EAAEzK,CAAC,IAAIwE,OAAO,CAACxE,CAAC;MAAE,CAAC;IAClC,CAAC;IACD,IAAI,CAACU,eAAe,GAAG,UAAU0D,GAAG,EAAE;MAClC,IAAIpE,CAAC,GAAG,IAAI,CAAC5H,GAAG,CAACkB,OAAO,CAACkV,eAAe,CAACvJ,QAAQ,CAACb,GAAG,CAAC,CAAC;MACvD,IAAI,CAACpE,CAAC,EACF;MACJ,OAAO;QACHyO,IAAI,EAAE;UACFjE,IAAI,EAAEhG,OAAO,CAACxE,CAAC,CAAC0O,OAAO,CAAC3U,KAAK,CAAC;UAC9B0Q,EAAE,EAAEjG,OAAO,CAACxE,CAAC,CAAC0O,OAAO,CAAC1U,GAAG;QAC7B,CAAC;QACD2U,KAAK,EAAE;UACHnE,IAAI,EAAEhG,OAAO,CAACxE,CAAC,CAAC4O,QAAQ,CAAC7U,KAAK,CAAC;UAC/B0Q,EAAE,EAAEjG,OAAO,CAACxE,CAAC,CAAC4O,QAAQ,CAAC5U,GAAG;QAC9B;MACJ,CAAC;IACL,CAAC;IACD,IAAI,CAAC6U,UAAU,GAAG,UAAUtV,IAAI,EAAEuV,MAAM,EAAE;MACtC,IAAIA,MAAM,KAAK,IAAI,EACf,IAAI,CAAC1W,GAAG,CAACkB,OAAO,CAACyV,UAAU,CAACxV,IAAI,EAAEA,IAAI,EAAE,IAAI,CAAC,CAAC,KAC7C,IAAIuV,MAAM,KAAK,KAAK,EACrB,IAAI,CAAC1W,GAAG,CAACkB,OAAO,CAAC0V,WAAW,CAAC,IAAIvW,KAAK,CAACc,IAAI,EAAE,CAAC,EAAEA,IAAI,EAAE,CAAC,CAAC,CAAC;IACjE,CAAC;IACD,IAAI,CAAC0V,YAAY,GAAG,UAAU7K,GAAG,EAAE;MAC/B,OAAO,IAAI,CAAChM,GAAG,CAACkB,OAAO,CAACoR,GAAG,CAACwE,eAAe,CAACjK,QAAQ,CAACb,GAAG,CAAC,CAAC;IAC9D,CAAC;IACD,IAAI,CAAC+K,YAAY,GAAG,UAAUtU,KAAK,EAAE;MACjC,OAAO2J,OAAO,CAAC,IAAI,CAACpM,GAAG,CAACkB,OAAO,CAACoR,GAAG,CAAC0E,eAAe,CAACvU,KAAK,CAAC,CAAC;IAC/D,CAAC;IACD,IAAI,CAACwU,KAAK,GAAG,UAAUxU,KAAK,EAAE;MAC1B,OAAO,IAAI,CAACzC,GAAG,CAAC4T,SAAS,CAACqD,KAAK,CAAC,CAAC;IACrC,CAAC;IACD,IAAI,CAACC,IAAI,GAAG,UAAUzU,KAAK,EAAE;MACzB,OAAO,IAAI,CAACzC,GAAG,CAACkX,IAAI,CAAC,CAAC;IAC1B,CAAC;IACD,IAAI,CAACC,iBAAiB,GAAG,UAAU1U,KAAK,EAAE;MACtC,OAAO,IAAI,CAACzC,GAAG,CAACiD,QAAQ,CAACyM,WAAW,CAACG,UAAU;IACnD,CAAC;IACD,IAAI,CAACuH,cAAc,GAAG,UAAUpL,GAAG,EAAEqL,GAAG,EAAEC,CAAC,EAAE9W,OAAO,EAAE;MAClD,IAAI4U,EAAE,GAAG5U,OAAO,CAAC+W,YAAY,CAAClG,MAAM;MACpC,IAAIzL,OAAO,GAAG,yBAAyB;MACvC,IAAIyR,GAAG,IAAI,CAAC,EAAE;QACV,IAAIzP,CAAC,GAAG,IAAI,CAAC5H,GAAG,CAACkB,OAAO,CAACsW,mBAAmB,CAACpC,EAAE,CAAC/S,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEwK,QAAQ,CAACb,GAAG,CAAC,EAAEpG,OAAO,CAAC;MACxF,CAAC,MACI;QACD,IAAIgC,CAAC,GAAG,IAAI,CAAC5H,GAAG,CAACkB,OAAO,CAACuW,mBAAmB,CAACrC,EAAE,CAAC/S,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;UAAExB,GAAG,EAAEmL,GAAG,CAAC7K,IAAI;UAAET,MAAM,EAAEsL,GAAG,CAAC5H,EAAE,GAAG;QAAE,CAAC,EAAEwB,OAAO,CAAC;QAC9G,IAAI,CAACgC,CAAC,IAAIpH,OAAO,CAAC+W,YAAY,IAAI/W,OAAO,CAAC+W,YAAY,CAAC1V,IAAI,CAAC,IAAI,CAACT,OAAO,CAAC4K,GAAG,CAAC7K,IAAI,CAAC,CAAC6K,GAAG,CAAC5H,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;UAC7FwD,CAAC,GAAG;YAAE/G,GAAG,EAAEmL,GAAG,CAAC7K,IAAI;YAAET,MAAM,EAAEsL,GAAG,CAAC5H,EAAE,GAAG;UAAE,CAAC;QAC7C;MACJ;MACA,OAAOwD,CAAC,IAAI;QAAEoE,GAAG,EAAEI,OAAO,CAACxE,CAAC;MAAE,CAAC;IACnC,CAAC;IACD,IAAI,CAAC8P,OAAO,GAAG,YAAY;MACvB,OAAO,IAAI,CAAC1X,GAAG,CAAC2X,MAAM,CAAC,IAAI,CAAC;IAChC,CAAC;IACD,IAAI,CAACC,OAAO,GAAG,YAAY;MACvB,OAAO;QAAE/U,IAAI,EAAE,IAAI,CAAClC,SAAS,CAAC,MAAM;MAAE,CAAC;IAC3C,CAAC;IACD,IAAI,CAACqH,WAAW,GAAG,UAAUnF,IAAI,EAAE;MAC/B,IAAIgD,UAAU,CAACjC,QAAQ,CAACiU,cAAc,CAAChV,IAAI,CAAC,EACxC,OAAOgD,UAAU,CAACjC,QAAQ,CAACf,IAAI,CAAC,CAAC,IAAI,CAAC;MAC1C,IAAIA,IAAI,IAAI,YAAY,EACpB,OAAO,IAAI,CAAC7C,GAAG,CAACgI,WAAW,CAAC,YAAY,CAAC;MAC7ChD,OAAO,CAAChB,GAAG,CAACnB,IAAI,GAAG,qBAAqB,CAAC;IAC7C,CAAC;IACD,IAAI,CAACiV,aAAa,GAAG,UAAU5P,MAAM,EAAE;MACnC,IAAI6P,MAAM,GAAG,IAAI,CAAC1O,kBAAkB;MACpC,IAAI,CAAC0O,MAAM,EACP,OAAO,IAAI;MACf,IAAIlX,GAAG,GAAGqH,MAAM,CAACrH,GAAG;MACpB,KAAK,IAAIgE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkT,MAAM,CAAC1W,MAAM,EAAEwD,CAAC,EAAE,EAAE;QACpC,IAAIuE,KAAK,GAAG2O,MAAM,CAAClT,CAAC,CAAC;QACrB,IAAIuE,KAAK,CAACzH,KAAK,CAACd,GAAG,IAAIuI,KAAK,CAACxH,GAAG,CAACf,GAAG,EAAE;UAClC,IAAIuI,KAAK,CAACK,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;YACxB,IAAIL,KAAK,CAACzH,KAAK,CAACd,GAAG,GAAGA,GAAG,EACrBA,GAAG,IAAIuI,KAAK,CAACxH,GAAG,CAACf,GAAG,GAAGuI,KAAK,CAACzH,KAAK,CAACd,GAAG;UAC9C,CAAC,MACI;YACD,IAAIuI,KAAK,CAACzH,KAAK,CAACd,GAAG,GAAGA,GAAG,EAAE;cACvB,IAAIA,GAAG,GAAGuI,KAAK,CAACxH,GAAG,CAACf,GAAG,IAAIA,GAAG,IAAIuI,KAAK,CAACxH,GAAG,CAACf,GAAG,IAAIuI,KAAK,CAACzH,KAAK,CAACjB,MAAM,GAAG,CAAC,EAAE;gBACvE,OAAO,IAAI;cACf;cACAG,GAAG,IAAIuI,KAAK,CAACxH,GAAG,CAACf,GAAG,GAAGuI,KAAK,CAACzH,KAAK,CAACd,GAAG;YAC1C;UACJ;QACJ;MACJ;MACA,OAAOA,GAAG;IACd,CAAC;IACD,IAAI,CAACmX,aAAa,GAAG,UAAUnX,GAAG,EAAE;MAChC,IAAI,CAAC,IAAI,CAACwI,kBAAkB,EACxB,IAAI,CAACA,kBAAkB,GAAG,EAAE;MAChC,OAAO;QAAEG,IAAI,EAAE,IAAI,CAACxJ,GAAG,CAACkB,OAAO,CAACE,OAAO,CAACP,GAAG,CAAC;QAAEA,GAAG,EAAEA;MAAI,CAAC;IAC5D,CAAC;IACD,IAAI,CAACoX,kBAAkB,GAAG,YAAY;MAClC,IAAI,CAAC5O,kBAAkB,GAAGkI,SAAS;IACvC,CAAC;IACD,IAAI,CAAC2G,cAAc,GAAG,YAAY;MAC9B,IAAIC,WAAW,GAAG,IAAI,CAACnY,GAAG,CAACkB,OAAO,CAACkC,YAAY;MAC/C,IAAI+U,WAAW,IAAIA,WAAW,CAAC9U,UAAU,EACrC,OAAO+I,OAAO,CAAC+L,WAAW,CAAC9U,UAAU,CAACzB,GAAG,CAAC;IAClD,CAAC;EACL,CAAC,EAAEwW,IAAI,CAACvS,UAAU,CAACpC,SAAS,CAAC;EAC7B,SAASoJ,QAAQA,CAACwL,KAAK,EAAE;IACrB,OAAO;MAAExX,GAAG,EAAEwX,KAAK,CAAClX,IAAI;MAAET,MAAM,EAAE2X,KAAK,CAACjU;IAAG,CAAC;EAChD;EACA,SAASgI,OAAOA,CAACsF,MAAM,EAAE;IACrB,OAAO,IAAIrL,GAAG,CAACqL,MAAM,CAAC7Q,GAAG,EAAE6Q,MAAM,CAAChR,MAAM,CAAC;EAC7C;EACA,IAAI4X,YAAY,GAAGzS,UAAU,CAACyS,YAAY,GAAG,UAAUC,MAAM,EAAEpE,OAAO,EAAE;IACpE,IAAI,CAACnI,GAAG,GAAG,IAAI,CAACrK,KAAK,GAAG,CAAC;IACzB,IAAI,CAAC4W,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACpE,OAAO,GAAGA,OAAO,IAAI,CAAC;IAC3B,IAAI,CAACqE,aAAa,GAAG,IAAI,CAACC,eAAe,GAAG,CAAC;IAC7C,IAAI,CAACC,SAAS,GAAG,CAAC;EACtB,CAAC;EACDJ,YAAY,CAAC7U,SAAS,GAAG;IACrBkV,GAAG,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAAC3M,GAAG,IAAI,IAAI,CAACuM,MAAM,CAAClX,MAAM;IAAE,CAAC;IAC3DuX,GAAG,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAAC5M,GAAG,IAAI,IAAI,CAAC0M,SAAS;IAAE,CAAC;IACvDG,IAAI,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAACN,MAAM,CAACO,MAAM,CAAC,IAAI,CAAC9M,GAAG,CAAC,IAAIuF,SAAS;IAAE,CAAC;IACvExH,IAAI,EAAE,SAAAA,CAAA,EAAY;MACd,IAAI,IAAI,CAACiC,GAAG,GAAG,IAAI,CAACuM,MAAM,CAAClX,MAAM,EAC7B,OAAO,IAAI,CAACkX,MAAM,CAACO,MAAM,CAAC,IAAI,CAAC9M,GAAG,EAAE,CAAC;IAC7C,CAAC;IACD+M,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI5U,EAAE,GAAG,IAAI,CAACmU,MAAM,CAACO,MAAM,CAAC,IAAI,CAAC9M,GAAG,CAAC;MACrC,IAAI,OAAOgN,KAAK,IAAI,QAAQ,EACxB,IAAIC,EAAE,GAAG7U,EAAE,IAAI4U,KAAK,CAAC,KAErB,IAAIC,EAAE,GAAG7U,EAAE,KAAK4U,KAAK,CAACnX,IAAI,GAAGmX,KAAK,CAACnX,IAAI,CAACuC,EAAE,CAAC,GAAG4U,KAAK,CAAC5U,EAAE,CAAC,CAAC;MAC5D,IAAI6U,EAAE,EAAE;QACJ,EAAE,IAAI,CAACjN,GAAG;QACV,OAAO5H,EAAE;MACb;IACJ,CAAC;IACD8U,QAAQ,EAAE,SAAAA,CAAUF,KAAK,EAAE;MACvB,IAAIrX,KAAK,GAAG,IAAI,CAACqK,GAAG;MACpB,OAAO,IAAI,CAAC+M,GAAG,CAACC,KAAK,CAAC,EAAE,CAAE;MAC1B,OAAO,IAAI,CAAChN,GAAG,GAAGrK,KAAK;IAC3B,CAAC;IACDwX,QAAQ,EAAE,SAAAA,CAAA,EAAY;MAClB,IAAIxX,KAAK,GAAG,IAAI,CAACqK,GAAG;MACpB,OAAO,YAAY,CAACnK,IAAI,CAAC,IAAI,CAAC0W,MAAM,CAACO,MAAM,CAAC,IAAI,CAAC9M,GAAG,CAAC,CAAC,EAClD,EAAE,IAAI,CAACA,GAAG;MACd,OAAO,IAAI,CAACA,GAAG,GAAGrK,KAAK;IAC3B,CAAC;IACDyX,SAAS,EAAE,SAAAA,CAAA,EAAY;MAAE,IAAI,CAACpN,GAAG,GAAG,IAAI,CAACuM,MAAM,CAAClX,MAAM;IAAE,CAAC;IACzDgY,MAAM,EAAE,SAAAA,CAAUjV,EAAE,EAAE;MAClB,IAAI+D,KAAK,GAAG,IAAI,CAACoQ,MAAM,CAACe,OAAO,CAAClV,EAAE,EAAE,IAAI,CAAC4H,GAAG,CAAC;MAC7C,IAAI7D,KAAK,GAAG,CAAC,CAAC,EAAE;QACZ,IAAI,CAAC6D,GAAG,GAAG7D,KAAK;QAChB,OAAO,IAAI;MACf;IACJ,CAAC;IACDoR,MAAM,EAAE,SAAAA,CAAUC,CAAC,EAAE;MAAE,IAAI,CAACxN,GAAG,IAAIwN,CAAC;IAAE,CAAC;IACvC9Y,MAAM,EAAE,SAAAA,CAAA,EAAY;MAChB,MAAM,iBAAiB;IAC3B,CAAC;IACDc,WAAW,EAAE,SAAAA,CAAA,EAAY;MACrB,MAAM,iBAAiB;IAC3B,CAAC;IACDwX,KAAK,EAAE,SAAAA,CAAUS,OAAO,EAAEC,OAAO,EAAEC,eAAe,EAAE;MAChD,IAAI,OAAOF,OAAO,IAAI,QAAQ,EAAE;QAC5B,IAAIG,KAAK,GAAG,SAAAA,CAAUC,GAAG,EAAE;UAAE,OAAOF,eAAe,GAAGE,GAAG,CAAC9R,WAAW,CAAC,CAAC,GAAG8R,GAAG;QAAE,CAAC;QAChF,IAAIC,MAAM,GAAG,IAAI,CAACvB,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC9N,GAAG,EAAEyN,OAAO,CAACpY,MAAM,CAAC;QACzD,IAAIuY,KAAK,CAACE,MAAM,CAAC,IAAIF,KAAK,CAACH,OAAO,CAAC,EAAE;UACjC,IAAIC,OAAO,KAAK,KAAK,EACjB,IAAI,CAAC1N,GAAG,IAAIyN,OAAO,CAACpY,MAAM;UAC9B,OAAO,IAAI;QACf;MACJ,CAAC,MACI;QACD,IAAI2X,KAAK,GAAG,IAAI,CAACT,MAAM,CAAClW,KAAK,CAAC,IAAI,CAAC2J,GAAG,CAAC,CAACgN,KAAK,CAACS,OAAO,CAAC;QACtD,IAAIT,KAAK,IAAIA,KAAK,CAACvW,KAAK,GAAG,CAAC,EACxB,OAAO,IAAI;QACf,IAAIuW,KAAK,IAAIU,OAAO,KAAK,KAAK,EAC1B,IAAI,CAAC1N,GAAG,IAAIgN,KAAK,CAAC,CAAC,CAAC,CAAC3X,MAAM;QAC/B,OAAO2X,KAAK;MAChB;IACJ,CAAC;IACDe,OAAO,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAACxB,MAAM,CAAClW,KAAK,CAAC,IAAI,CAACV,KAAK,EAAE,IAAI,CAACqK,GAAG,CAAC;IAAE,CAAC;IACxEgO,cAAc,EAAE,SAAAA,CAAUR,CAAC,EAAES,KAAK,EAAE;MAChC,IAAI,CAACvB,SAAS,IAAIc,CAAC;MACnB,IAAI;QACA,OAAOS,KAAK,CAAC,CAAC;MAClB,CAAC,SACO;QACJ,IAAI,CAACvB,SAAS,IAAIc,CAAC;MACvB;IACJ;EACJ,CAAC;EACD3T,UAAU,CAACqU,eAAe,GAAG,UAAUrX,IAAI,EAAE2H,EAAE,EAAE;IAC7C3E,UAAU,CAACpC,SAAS,CAACZ,IAAI,CAAC,GAAG2H,EAAE;EACnC,CAAC;EACDtF,MAAM,CAACiV,eAAe,CAAC,6pBAA6pB,EAAE,SAAS,EAAE,KAAK,CAAC;EACvsB,CAAC,YAAY;IACT,SAASC,SAASA,CAAC3T,EAAE,EAAE4T,QAAQ,EAAE3J,MAAM,EAAE;MACrC,IAAIuB,IAAI,GAAGxL,EAAE,CAACzG,GAAG,CAAC+T,SAAS;MAC3B,IAAIlJ,MAAM;MACVA,MAAM,GAAGoH,IAAI,CAACqI,WAAW,CAACC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,CAAC;MACxD,IAAI9J,MAAM,EACN7F,MAAM,CAAC4P,SAAS,GAAG,8BAA8B,CAAC,KAElD5P,MAAM,CAAC4P,SAAS,GAAG,2BAA2B;MAClD,IAAI,OAAOJ,QAAQ,IAAI,QAAQ,EAAE;QAC7BxP,MAAM,CAAC6P,SAAS,GAAGL,QAAQ;MAC/B,CAAC,MACI;QAAE;QACHxP,MAAM,CAACyP,WAAW,CAACD,QAAQ,CAAC;MAChC;MACA,OAAOxP,MAAM;IACjB;IACA,SAAS8P,iBAAiBA,CAAClU,EAAE,EAAEmU,MAAM,EAAE;MACnC,IAAInU,EAAE,CAACX,KAAK,CAAC+U,wBAAwB,EACjCpU,EAAE,CAACX,KAAK,CAAC+U,wBAAwB,CAAC,CAAC;MACvCpU,EAAE,CAACX,KAAK,CAAC+U,wBAAwB,GAAGD,MAAM;IAC9C;IACA/U,UAAU,CAACqU,eAAe,CAAC,YAAY,EAAE,UAAUG,QAAQ,EAAES,QAAQ,EAAEta,OAAO,EAAE;MAC5E,IAAI,IAAI,CAAC0I,oBAAoB,CAAC,CAAC,EAC3B;MACJ,IAAI,CAAC1I,OAAO,EACRA,OAAO,GAAG,CAAC,CAAC;MAChBma,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC;MAC7B,IAAI9P,MAAM,GAAGuP,SAAS,CAAC,IAAI,EAAEC,QAAQ,EAAE7Z,OAAO,CAACkQ,MAAM,CAAC;MACtD,IAAIqK,MAAM,GAAG,KAAK;QAAEC,EAAE,GAAG,IAAI;MAC7B,IAAI,CAAClV,KAAK,CAAC+E,MAAM,GAAGA,MAAM;MAC1B,SAAS0L,KAAKA,CAACqE,MAAM,EAAE;QACnB,IAAI,OAAOA,MAAM,IAAI,QAAQ,EAAE;UAC3BK,GAAG,CAAClX,KAAK,GAAG6W,MAAM;QACtB,CAAC,MACI;UACD,IAAIG,MAAM,EACN;UACJ,IAAIH,MAAM,IAAIA,MAAM,CAAC1E,IAAI,IAAI,MAAM,EAAE;YACjC,IAAIqE,QAAQ,CAACW,aAAa,KAAKD,GAAG,EAC9B;UACR;UACA,IAAID,EAAE,CAAClV,KAAK,CAAC+E,MAAM,IAAIA,MAAM,EAAE;YAC3BmQ,EAAE,CAAClV,KAAK,CAAC+E,MAAM,GAAG,IAAI;YACtBmQ,EAAE,CAAC/D,KAAK,CAAC,CAAC;UACd;UACA8D,MAAM,GAAG,IAAI;UACblQ,MAAM,CAAC1I,MAAM,CAAC,CAAC;UACf,IAAI3B,OAAO,CAAC2a,OAAO,EACf3a,OAAO,CAAC2a,OAAO,CAACtQ,MAAM,CAAC;UAC3B,IAAIpE,EAAE,GAAGuU,EAAE;UACX,IAAIvU,EAAE,CAACX,KAAK,CAACsV,GAAG,EAAE;YACd3U,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACC,MAAM,GAAG,IAAI;YAC1B5U,EAAE,CAACzG,GAAG,CAAC0I,OAAO,CAAC,cAAc,CAAC;YAC9BjC,EAAE,CAACzG,GAAG,CAACiD,QAAQ,CAACqY,KAAK,CAACC,QAAQ,CAAC9U,EAAE,CAACzG,GAAG,CAACiD,QAAQ,CAACuY,aAAa,CAAC;UACjE;QACJ;MACJ;MACA,IAAIP,GAAG,GAAGpQ,MAAM,CAAC4Q,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAAEC,MAAM;MACzD,IAAIT,GAAG,EAAE;QACL,IAAIza,OAAO,CAACuD,KAAK,EAAE;UACfkX,GAAG,CAAClX,KAAK,GAAGvD,OAAO,CAACuD,KAAK;UACzB,IAAIvD,OAAO,CAACmb,iBAAiB,KAAK,KAAK,EACnCV,GAAG,CAACW,MAAM,CAAC,CAAC;QACpB;QACA,IAAIpb,OAAO,CAACqb,OAAO,EACfhW,UAAU,CAAChC,EAAE,CAACoX,GAAG,EAAE,OAAO,EAAE,UAAUtY,CAAC,EAAE;UAAEnC,OAAO,CAACqb,OAAO,CAAClZ,CAAC,EAAEsY,GAAG,CAAClX,KAAK,EAAEwS,KAAK,CAAC;QAAE,CAAC,CAAC;QACvF,IAAI/V,OAAO,CAACsb,OAAO,EACfjW,UAAU,CAAChC,EAAE,CAACoX,GAAG,EAAE,OAAO,EAAE,UAAUtY,CAAC,EAAE;UAAEnC,OAAO,CAACsb,OAAO,CAACnZ,CAAC,EAAEsY,GAAG,CAAClX,KAAK,EAAEwS,KAAK,CAAC;QAAE,CAAC,CAAC;QACvF1Q,UAAU,CAAChC,EAAE,CAACoX,GAAG,EAAE,SAAS,EAAE,UAAUtY,CAAC,EAAE;UACvC,IAAInC,OAAO,IAAIA,OAAO,CAACub,SAAS,IAAIvb,OAAO,CAACub,SAAS,CAACpZ,CAAC,EAAEsY,GAAG,CAAClX,KAAK,EAAEwS,KAAK,CAAC,EAAE;YACxE;UACJ;UACA,IAAI5T,CAAC,CAAC8E,OAAO,IAAI,EAAE,EACfqT,QAAQ,CAACG,GAAG,CAAClX,KAAK,CAAC;UACvB,IAAIpB,CAAC,CAAC8E,OAAO,IAAI,EAAE,IAAKjH,OAAO,CAACwb,YAAY,KAAK,KAAK,IAAIrZ,CAAC,CAAC8E,OAAO,IAAI,EAAG,EAAE;YACxE5B,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;YACpB4T,KAAK,CAAC,CAAC;UACX;QACJ,CAAC,CAAC;QACF,IAAI/V,OAAO,CAACyb,WAAW,KAAK,KAAK,EAC7BpW,UAAU,CAAChC,EAAE,CAACoX,GAAG,EAAE,MAAM,EAAE1E,KAAK,CAAC;QACrC0E,GAAG,CAAChE,KAAK,CAAC,CAAC;MACf,CAAC,MACI,IAAIyE,MAAM,GAAG7Q,MAAM,CAAC4Q,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;QACxD5V,UAAU,CAAChC,EAAE,CAAC6X,MAAM,EAAE,OAAO,EAAE,YAAY;UACvCnF,KAAK,CAAC,CAAC;UACPyE,EAAE,CAAC/D,KAAK,CAAC,CAAC;QACd,CAAC,CAAC;QACF,IAAIzW,OAAO,CAACyb,WAAW,KAAK,KAAK,EAC7BpW,UAAU,CAAChC,EAAE,CAAC6X,MAAM,EAAE,MAAM,EAAEnF,KAAK,CAAC;QACxCmF,MAAM,CAACzE,KAAK,CAAC,CAAC;MAClB;MACA,OAAOV,KAAK;IAChB,CAAC,CAAC;IACF1Q,UAAU,CAACqU,eAAe,CAAC,kBAAkB,EAAE,UAAUG,QAAQ,EAAE7Z,OAAO,EAAE;MACxE,IAAI,IAAI,CAAC0I,oBAAoB,CAAC,CAAC,EAC3B;MACJyR,iBAAiB,CAAC,IAAI,EAAEpE,KAAK,CAAC;MAC9B,IAAI1L,MAAM,GAAGuP,SAAS,CAAC,IAAI,EAAEC,QAAQ,EAAE7Z,OAAO,IAAIA,OAAO,CAACkQ,MAAM,CAAC;MACjE,IAAIqK,MAAM,GAAG,KAAK;QAAEmB,SAAS;MAC7B,IAAIC,QAAQ,GAAG3b,OAAO,IAAI,OAAOA,OAAO,CAAC2b,QAAQ,KAAK,WAAW,GAAG3b,OAAO,CAAC2b,QAAQ,GAAG,IAAI;MAC3F,SAAS5F,KAAKA,CAAA,EAAG;QACb,IAAIwE,MAAM,EACN;QACJA,MAAM,GAAG,IAAI;QACbqB,YAAY,CAACF,SAAS,CAAC;QACvBrR,MAAM,CAAC1I,MAAM,CAAC,CAAC;MACnB;MACA0D,UAAU,CAAChC,EAAE,CAACgH,MAAM,EAAE,OAAO,EAAE,UAAUlI,CAAC,EAAE;QACxCkD,UAAU,CAACwB,gBAAgB,CAAC1E,CAAC,CAAC;QAC9B4T,KAAK,CAAC,CAAC;MACX,CAAC,CAAC;MACF,IAAI4F,QAAQ,EACRD,SAAS,GAAGG,UAAU,CAAC9F,KAAK,EAAE4F,QAAQ,CAAC;MAC3C,OAAO5F,KAAK;IAChB,CAAC,CAAC;EACN,CAAC,EAAE,CAAC;EACJ,IAAIlQ,GAAG,GAAGR,UAAU,CAACQ,GAAG;EACxB,SAASiW,qCAAqCA,CAAC7V,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,EAAE;IACjE,IAAID,QAAQ,CAACpb,IAAI,KAAKqb,MAAM,CAACrb,IAAI,IAAIob,QAAQ,CAACnY,EAAE,IAAIoY,MAAM,CAACpY,EAAE,GAAG,CAAC,EAAE;MAC/D,IAAIoF,IAAI,GAAG/C,EAAE,CAACrF,OAAO,CAACmb,QAAQ,CAACpb,IAAI,CAAC;MACpC,IAAIsb,QAAQ,GAAGjT,IAAI,CAACkT,UAAU,CAACH,QAAQ,CAACnY,EAAE,CAAC;MAC3C,IAAI,MAAM,IAAIqY,QAAQ,IAAIA,QAAQ,IAAI,MAAM,EAAE;QAC1CD,MAAM,CAACpY,EAAE,IAAI,CAAC;MAClB;IACJ;IACA,OAAO;MAAEzC,KAAK,EAAE4a,QAAQ;MAAE3a,GAAG,EAAE4a;IAAO,CAAC;EAC3C;EACA,IAAIG,aAAa,GAAG,CAChB;IAAEC,IAAI,EAAE,QAAQ;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACjD;IAAED,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAClD;IAAED,IAAI,EAAE,MAAM;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAC/C;IAAED,IAAI,EAAE,QAAQ;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACjD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAK,CAAC,EACjD;IAAED,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAK,CAAC,EACnD;IAAED,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAClD;IAAED,IAAI,EAAE,MAAM;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAC/C;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAChD;IAAED,IAAI,EAAE,WAAW;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACpD;IAAED,IAAI,EAAE,QAAQ;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACjD;IAAED,IAAI,EAAE,WAAW;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACpD;IAAED,IAAI,EAAE,QAAQ;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACjD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAChD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAChD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAQ,CAAC,EACpD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAQ,CAAC,EACpD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,OAAO;IAAEC,OAAO,EAAE;EAAS,CAAC,EACvE;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,OAAO;IAAEC,OAAO,EAAE;EAAS,CAAC,EACvE;IAAEF,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAQ,CAAC;EAAE;EACxD;IAAED,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,OAAO;IAAEC,OAAO,EAAE;EAAS,CAAC,EACzE;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,IAAI;IAAEC,OAAO,EAAE;EAAS,CAAC,EAChE;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,GAAG;IAAEC,OAAO,EAAE;EAAS,CAAC,EAC/D;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,IAAI;IAAEC,OAAO,EAAE;EAAS,CAAC,EAChE;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,KAAK;IAAEC,OAAO,EAAE;EAAS,CAAC,EACjE;IAAEF,IAAI,EAAE,QAAQ;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EACjD;IAAED,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAI,CAAC,EAChD;IAAED,IAAI,EAAE,UAAU;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAQ,CAAC,EACvD;IAAED,IAAI,EAAE,YAAY;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE;EAAQ,CAAC,EACzD;IAAED,IAAI,EAAE,MAAM;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,IAAI;IAAEC,OAAO,EAAE;EAAS,CAAC,EACnE;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,UAAU;IAAE2G,MAAM,EAAE,GAAG;IAAEC,OAAO,EAAE;EAAS,CAAC,EACnE;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEqT,OAAO,EAAE;EAAS,CAAC,EAC/E;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,eAAe;IAAEC,UAAU,EAAE;MAAEC,QAAQ,EAAE,IAAI;MAAEC,UAAU,EAAE;IAAK;EAAE,CAAC,EACxG;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEC,QAAQ,EAAE,IAAI;MAAEC,UAAU,EAAE;IAAK;EAAE,CAAC,EAC3G;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEC,QAAQ,EAAE,IAAI;MAAEC,UAAU,EAAE;IAAK;EAAE,CAAC,EAC3G;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACzF;IAAEP,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EACxF;IAAEP,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEF,QAAQ,EAAE;IAAK;EAAE,CAAC,EACnG;IAAEL,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEF,QAAQ,EAAE;IAAK;EAAE,CAAC,EACpG;IAAEL,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,oBAAoB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EAC3F;IAAEP,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,oBAAoB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EAC5F;IAAEP,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE;IAAM;EAAE,CAAC,EACnG;IAAER,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE;IAAK;EAAE,CAAC,EAClH;IAAET,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE,IAAI;MAAEE,SAAS,EAAE;IAAK;EAAE,CAAC,EACnH;IAAEV,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE,IAAI;MAAEC,SAAS,EAAE;IAAK;EAAE,CAAC,EAClI;IAAEV,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE;IAAM;EAAE,CAAC,EACpG;IAAER,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE;IAAK;EAAE,CAAC,EACnH;IAAET,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE,IAAI;MAAEE,SAAS,EAAE;IAAK;EAAE,CAAC,EACrH;IAAEV,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE,IAAI;MAAEC,OAAO,EAAE,IAAI;MAAEC,SAAS,EAAE;IAAK;EAAE,CAAC,EACpI;IAAEV,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,iBAAiB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAED,UAAU,EAAE;IAAK;EAAE,CAAC,EAC1G;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,iBAAiB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAED,UAAU,EAAE;IAAK;EAAE,CAAC,EACzG;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,gBAAgB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACvF;IAAEP,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,gBAAgB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EACtF;IAAEP,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,YAAY;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EACtF;IAAEP,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,YAAY;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACvF;IAAEP,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,cAAc;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEI,cAAc,EAAE;IAAK;EAAE,CAAC,EAC9G;IAAEX,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,cAAc;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEI,cAAc,EAAE;IAAK;EAAE,CAAC,EAC/G;IAAEX,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,4BAA4B;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEI,cAAc,EAAE,IAAI;MAAEN,QAAQ,EAAE,IAAI;MAAEC,UAAU,EAAE;IAAK;EAAE,CAAC,EAC5J;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,4BAA4B;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEI,cAAc,EAAE,IAAI;MAAEN,QAAQ,EAAE,IAAI;MAAEC,UAAU,EAAE;IAAK;EAAE,CAAC,EAC1J;IAAEN,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAAyB,CAAC,EAChE;IAAEH,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAA2B,CAAC,EAClE;IAAEH,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAA2B,CAAC,EAClE;IAAEH,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAAoB,CAAC,EAC1D;IAAEH,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAAoC,CAAC,EAC1E;IAAEH,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEK,WAAW,EAAE;IAAK;EAAE,CAAC,EACtG;IAAEZ,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEK,WAAW,EAAE;IAAK;EAAE,CAAC,EACvG;IAAEZ,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEK,WAAW,EAAE,IAAI;MAAEC,YAAY,EAAE,CAAC;IAAE;EAAE,CAAC,EACxH;IAAEb,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,WAAW;IAAEC,UAAU,EAAE;MAAEM,SAAS,EAAE;IAAK;EAAE,CAAC,EACnF;IAAEV,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,qBAAqB;IAAEC,UAAU,EAAE;MAAEM,SAAS,EAAE,IAAI;MAAEJ,UAAU,EAAE;IAAK;EAAE,CAAC,EAC/G;IAAEN,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,iBAAiB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEG,SAAS,EAAE;IAAK;EAAE,CAAC,EACnH;IAAEV,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,iBAAiB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACnG;IAAEP,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,mBAAmB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEG,SAAS,EAAE;IAAK;EAAE,CAAC,EACrH;IAAEV,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,mBAAmB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACrG;IAAEP,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,2BAA2B;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EACjG;IAAEP,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,2BAA2B;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EAClG;IAAEP,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,UAAU;IAAEC,UAAU,EAAE;MAAEE,UAAU,EAAE,IAAI;MAAED,QAAQ,EAAE;IAAK;EAAE,CAAC,EAC9G;IAAEL,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,UAAU;IAAEC,UAAU,EAAE;MAAEE,UAAU,EAAE;IAAK;EAAE,CAAC,EAC7F;IAAEN,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,YAAY;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EACnF;IAAEP,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,YAAY;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACpF;IAAEP,IAAI,EAAE,KAAK;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,YAAY;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAEF,QAAQ,EAAE;IAAK;EAAE,CAAC,EACpG;IAAEL,IAAI,EAAE,KAAK;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,YAAY;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEF,QAAQ,EAAE;IAAK;EAAE,CAAC,EACrG;IAAEL,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,OAAO;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAErb,KAAK,EAAE,IAAI;MAAEob,MAAM,EAAE,IAAI;MAAEE,WAAW,EAAE;IAAK;EAAE,CAAC,EAC3H;IAAEhB,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,OAAO;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAErb,KAAK,EAAE,KAAK;MAAEob,MAAM,EAAE,IAAI;MAAEE,WAAW,EAAE;IAAK;EAAE,CAAC,EAC5H;IAAEhB,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,cAAc;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAED,UAAU,EAAE;IAAK;EAAE,CAAC,EACjH;IAAEN,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,cAAc;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAED,UAAU,EAAE;IAAK;EAAE,CAAC,EAClH;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAAe,CAAC,EACrD;IAAEH,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,2BAA2B;IAAED,OAAO,EAAE;EAAS,CAAC,EACrF;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,2BAA2B;IAAEC,UAAU,EAAE;MAAEa,QAAQ,EAAE;IAAK,CAAC;IAAEf,OAAO,EAAE;EAAS,CAAC,EACrH;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE;EAAS,CAAC,EACnD;IAAElB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE;EAAO,CAAC,EACjD;IAAElB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE;EAAS,CAAC,EACnD;IAAElB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE;EAAa,CAAC,EACvD;IAAElB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,QAAQ;IAAEC,YAAY,EAAE;MAAEC,WAAW,EAAE;IAAK;EAAE,CAAC,EACxF;IAAEpB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,QAAQ;IAAEC,YAAY,EAAE;MAAEC,WAAW,EAAE;IAAM;EAAE,CAAC,EACzF;IAAEpB,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE;EAAa,CAAC,EACxD;IAAElB,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,YAAY;IAAEC,YAAY,EAAE;MAAEE,OAAO,EAAE;IAAK,CAAC;IAAEP,MAAM,EAAE;EAAK,CAAC,EACvG;IAAEd,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,YAAY;IAAEC,YAAY,EAAE;MAAEE,OAAO,EAAE;IAAM,CAAC;IAAEP,MAAM,EAAE;EAAK,CAAC,EACxG;IAAEd,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,UAAU;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,IAAI;MAAED,UAAU,EAAE;IAAK;EAAE,CAAC,EAClG;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,UAAU;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAED,UAAU,EAAE;IAAK;EAAE,CAAC,EACnG;IAAEN,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,4BAA4B;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK;EAAE,CAAC,EACnG;IAAEP,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,4BAA4B;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM;EAAE,CAAC,EACpG;IAAEP,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE;EAAW,CAAC,EACtD;IAAElB,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,UAAU;IAAEC,YAAY,EAAE;MAAEG,UAAU,EAAE;IAAK;EAAE,CAAC,EAC1F;IAAEtB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,QAAQ;IAAEf,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK,CAAC;IAAEgB,kBAAkB,EAAE;MAAEC,UAAU,EAAE;IAAM;EAAE,CAAC,EAC/J;IAAExB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,QAAQ;IAAEf,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAM,CAAC;IAAEgB,kBAAkB,EAAE;MAAEC,UAAU,EAAE;IAAK;EAAE,CAAC,EAC/J;IAAExB,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,QAAQ;IAAEf,MAAM,EAAE,WAAW;IAAEC,UAAU,EAAE;MAAEM,SAAS,EAAE;IAAK,CAAC;IAAER,OAAO,EAAE;EAAS,CAAC,EAClI;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,QAAQ;IAAEC,YAAY,EAAE;MAAEd,QAAQ,EAAE;IAAK,CAAC;IAAEH,OAAO,EAAE;EAAS,CAAC,EACxG;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,MAAM;IAAEf,MAAM,EAAE,cAAc;IAAEC,UAAU,EAAE;MAAEC,QAAQ,EAAE;IAAK,CAAC;IAAEH,OAAO,EAAE;EAAS,CAAC,EAClI;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,MAAM;IAAEC,YAAY,EAAE;MAAEd,QAAQ,EAAE;IAAK,CAAC;IAAEH,OAAO,EAAE;EAAS,CAAC,EACtG;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,QAAQ;IAAEf,MAAM,EAAE,WAAW;IAAEC,UAAU,EAAE;MAAEM,SAAS,EAAE;IAAK,CAAC;IAAER,OAAO,EAAE;EAAS,CAAC,EAClI;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,QAAQ;IAAEC,YAAY,EAAE;MAAEd,QAAQ,EAAE;IAAK,CAAC;IAAEH,OAAO,EAAE;EAAS,CAAC,EACxG;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,YAAY;IAAEf,MAAM,EAAE,kBAAkB;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE;IAAK,CAAC;IAAEY,YAAY,EAAE;MAAEM,gBAAgB,EAAE;IAAK,CAAC;IAAEvB,OAAO,EAAE;EAAS,CAAC,EACrL;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,YAAY;IAAEhB,OAAO,EAAE;EAAS,CAAC,EAC1E;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,QAAQ;IAAEf,MAAM,EAAE,mBAAmB;IAAED,OAAO,EAAE;EAAS,CAAC,EAC7G;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,gBAAgB;IAAE4H,QAAQ,EAAE,QAAQ;IAAEf,MAAM,EAAE,aAAa;IAAEC,UAAU,EAAE;MAAEG,OAAO,EAAE,KAAK;MAAEC,OAAO,EAAE;IAAM,CAAC;IAAEN,OAAO,EAAE;EAAS,CAAC,EACvJ;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,MAAM;IAAE4G,OAAO,EAAE;EAAS,CAAC,EAClD;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,cAAc;IAAEkU,UAAU,EAAE;MAAER,OAAO,EAAE;IAAK;EAAE,CAAC,EACxF;IAAEP,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,cAAc;IAAEkU,UAAU,EAAE;MAAER,OAAO,EAAE;IAAM;EAAE,CAAC,EACzF;IAAEP,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,QAAQ;IAAEkU,UAAU,EAAE;MAAER,OAAO,EAAE,IAAI;MAAEF,QAAQ,EAAE;IAAK;EAAE,CAAC,EAClG;IAAEL,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,QAAQ;IAAEkU,UAAU,EAAE;MAAER,OAAO,EAAE,KAAK;MAAEF,QAAQ,EAAE;IAAK;EAAE,CAAC,EACnG;IAAEL,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAY,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EAChI;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAM,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EAC1H;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAoB,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EACxI;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAU,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EAC9H;IAAEF,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAW,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EAChI;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAgB,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EACpI;IAAEF,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAM,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EAC3H;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEW,QAAQ,EAAE;IAAsB,CAAC;IAAExB,OAAO,EAAE;EAAS,CAAC,EAC1I;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,2BAA2B;IAAEiU,MAAM,EAAE,IAAI;IAAEa,qBAAqB,EAAE,IAAI;IAAEZ,UAAU,EAAE;MAAErb,KAAK,EAAE;IAAK,CAAC;IAAEwa,OAAO,EAAE;EAAS,CAAC,EAC7J;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,2BAA2B;IAAEiU,MAAM,EAAE,IAAI;IAAEa,qBAAqB,EAAE,IAAI;IAAEZ,UAAU,EAAE;MAAErb,KAAK,EAAE;IAAM,CAAC;IAAEwa,OAAO,EAAE;EAAS,CAAC,EAC9J;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAmB,CAAC,EACzD;IAAEmT,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,kBAAkB;IAAEkU,UAAU,EAAE;MAAEV,QAAQ,EAAE;IAAK;EAAE,CAAC,EACzF;IAAEL,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,kBAAkB;IAAEkU,UAAU,EAAE;MAAEa,SAAS,EAAE;IAAK;EAAE,CAAC,EAC9F;IAAE5B,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,kBAAkB;IAAEkU,UAAU,EAAE;MAAEa,SAAS,EAAE;IAAK;EAAE,CAAC,EAC9F;IAAE5B,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAwB,CAAC,EAC/D;IAAEmT,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,WAAW;IAAEiU,MAAM,EAAE;EAAK,CAAC,EAChE;IAAEd,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,WAAW;IAAEkU,UAAU,EAAE;MAAEc,UAAU,EAAE;IAAK,CAAC;IAAEf,MAAM,EAAE;EAAK,CAAC,EACnG;IAAEd,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,OAAO;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAErb,KAAK,EAAE,IAAI;MAAEob,MAAM,EAAE;IAAK;EAAE,CAAC,EACvG;IAAEd,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,OAAO;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAErb,KAAK,EAAE,KAAK;MAAEob,MAAM,EAAE;IAAK;EAAE,CAAC,EACxG;IAAEd,IAAI,EAAE,cAAc;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,SAAS;IAAEiU,MAAM,EAAE;EAAK,CAAC,EACzE;IAAEd,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAc,CAAC,EAC9D;IAAEmT,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAuB,CAAC,EACvE;IAAEmT,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,iBAAiB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEjc,OAAO,EAAE;IAAK,CAAC;IAAEob,OAAO,EAAE;EAAS,CAAC,EACxH;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,QAAQ;IAAEC,YAAY,EAAE;MAAEd,QAAQ,EAAE,IAAI;MAAEyB,QAAQ,EAAE;IAAK,CAAC;IAAE5B,OAAO,EAAE,QAAQ;IAAE6B,eAAe,EAAE;EAAK,CAAC,EAC/I;IAAE/B,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEqT,OAAO,EAAE;EAAS,CAAC,EAChE;IAAEF,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,YAAY;IAAEC,YAAY,EAAE;MAAEE,OAAO,EAAE;IAAK,CAAC;IAAEnB,OAAO,EAAE,QAAQ;IAAEY,MAAM,EAAE;EAAK,CAAC,EACzH;IAAEd,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,UAAU;IAAE4H,QAAQ,EAAE,YAAY;IAAEC,YAAY,EAAE;MAAEE,OAAO,EAAE;IAAM,CAAC;IAAEnB,OAAO,EAAE,QAAQ;IAAEY,MAAM,EAAE;EAAK,CAAC,EAC1H;IAAEd,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAO,CAAC,EACjD;IAAEmT,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAU,CAAC,EAC1D;IAAEmT,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAc,CAAC,EAC9D;IAAEmT,IAAI,EAAE,iBAAiB;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEqT,OAAO,EAAE,QAAQ;IAAEY,MAAM,EAAE;EAAK,CAAC,EACtG;IAAEd,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,kBAAkB;IAAEqT,OAAO,EAAE;EAAS,CAAC,EAChF;IAAEF,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEkU,UAAU,EAAE;MAAEiB,QAAQ,EAAE;IAAS;EAAE,CAAC,EAC5F;IAAEhC,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEkU,UAAU,EAAE;MAAEiB,QAAQ,EAAE;IAAS,CAAC;IAAE7B,MAAM,EAAE;EAAoC,CAAC,EACzI;IAAEH,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEkU,UAAU,EAAE;MAAEiB,QAAQ,EAAE;IAAM;EAAE,CAAC,EACzF;IAAEhC,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEkU,UAAU,EAAE;MAAEiB,QAAQ,EAAE;IAAM,CAAC;IAAE7B,MAAM,EAAE;EAAoC,CAAC,EACzI;IAAEH,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEkU,UAAU,EAAE;MAAEiB,QAAQ,EAAE;IAAS;EAAE,CAAC,EAC5F;IAAEhC,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,gBAAgB;IAAEkU,UAAU,EAAE;MAAEiB,QAAQ,EAAE;IAAS,CAAC;IAAE7B,MAAM,EAAE;EAAoC,CAAC,EACzI;IAAEH,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE;EAAiB,CAAC,EACvD;IAAEmT,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,sBAAsB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEkB,QAAQ,EAAE,IAAI;MAAEC,SAAS,EAAE;IAAM;EAAE,CAAC,EACjI;IAAElC,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,sBAAsB;IAAEiU,MAAM,EAAE,IAAI;IAAEC,UAAU,EAAE;MAAEkB,QAAQ,EAAE,KAAK;MAAEC,SAAS,EAAE;IAAM;EAAE,CAAC,EAClI;IAAElC,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,QAAQ;IAAEkU,UAAU,EAAE;MAAEK,WAAW,EAAE;IAAK,CAAC;IAAElB,OAAO,EAAE;EAAS,CAAC,EACzG;IAAEF,IAAI,EAAE,OAAO;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,QAAQ;IAAEkU,UAAU,EAAE;MAAEK,WAAW,EAAE;IAAM,CAAC;IAAElB,OAAO,EAAE;EAAS,CAAC,EAC1G;IAAEF,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE;EAAyB,CAAC,EACzE;IAAEH,IAAI,EAAE,aAAa;IAAE1G,IAAI,EAAE,QAAQ;IAAE6G,MAAM,EAAE,wBAAwB;IAAEC,UAAU,EAAE;MAAE+B,eAAe,EAAE;IAAK;EAAE,CAAC,EAChH;IAAEnC,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE8I,UAAU,EAAE;MAAE7B,OAAO,EAAE,IAAI;MAAE8B,QAAQ,EAAE,QAAQ;MAAE/B,UAAU,EAAE;IAAK;EAAE,CAAC,EAClG;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE8I,UAAU,EAAE;MAAE7B,OAAO,EAAE,KAAK;MAAE8B,QAAQ,EAAE,QAAQ;MAAE/B,UAAU,EAAE;IAAK;EAAE,CAAC,EACnG;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE8I,UAAU,EAAE;MAAE7B,OAAO,EAAE,IAAI;MAAE8B,QAAQ,EAAE,iBAAiB;MAAEC,aAAa,EAAE,IAAI;MAAEhC,UAAU,EAAE;IAAK;EAAE,CAAC,EAChI;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE,QAAQ;IAAE8I,UAAU,EAAE;MAAE7B,OAAO,EAAE,KAAK;MAAE8B,QAAQ,EAAE,iBAAiB;MAAEC,aAAa,EAAE,IAAI;MAAEhC,UAAU,EAAE;IAAK;EAAE,CAAC,EACjI;IAAEN,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE8I,UAAU,EAAE;MAAE7B,OAAO,EAAE,IAAI;MAAE8B,QAAQ,EAAE,iBAAiB;MAAE/B,UAAU,EAAE;IAAK;EAAE,CAAC,EAC5G;IAAEN,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAE8I,UAAU,EAAE;MAAE7B,OAAO,EAAE,KAAK;MAAE8B,QAAQ,EAAE,iBAAiB;MAAE/B,UAAU,EAAE;IAAK;EAAE,CAAC,EAC7G;IAAEN,IAAI,EAAE,GAAG;IAAE1G,IAAI,EAAE;EAAK,CAAC,CAC5B;EACD,IAAIiJ,mBAAmB,GAAGxC,aAAa,CAACtb,MAAM;EAC9C,IAAI+d,mBAAmB,GAAG,CACtB;IAAEvc,IAAI,EAAE,aAAa;IAAEwc,SAAS,EAAE;EAAO,CAAC,EAC1C;IAAExc,IAAI,EAAE;EAAM,CAAC,EACf;IAAEA,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACjC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACjC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACjC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACjC;IAAExc,IAAI,EAAE,SAAS;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACpC;IAAExc,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACrC;IAAExc,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAK,CAAC,EACrC;IAAExc,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAM,CAAC,EACtC;IAAExc,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAM,CAAC,EACtC;IAAExc,IAAI,EAAE;EAAQ,CAAC,EACjB;IAAEA,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAO,CAAC,EACvC;IAAExc,IAAI,EAAE,WAAW;IAAEwc,SAAS,EAAE;EAAQ,CAAC,EACzC;IAAExc,IAAI,EAAE,WAAW;IAAEwc,SAAS,EAAE;EAAQ,CAAC,EACzC;IAAExc,IAAI,EAAE,WAAW;IAAEwc,SAAS,EAAE;EAAQ,CAAC,EACzC;IAAExc,IAAI,EAAE,WAAW;IAAEwc,SAAS,EAAE;EAAQ,CAAC,EACzC;IAAExc,IAAI,EAAE,OAAO;IAAEwc,SAAS,EAAE;EAAI,CAAC,EACjC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAI,CAAC,EAChC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAM,CAAC,EAClC;IAAExc,IAAI,EAAE,KAAK;IAAEwc,SAAS,EAAE;EAAK,CAAC,EAChC;IAAExc,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAO,CAAC,EACvC;IAAExc,IAAI,EAAE,WAAW;IAAEwc,SAAS,EAAE;EAAO,CAAC,EACxC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAM,CAAC,EAClC;IAAExc,IAAI,EAAE,YAAY;IAAEwc,SAAS,EAAE,GAAG;IAAEC,aAAa,EAAE;EAAK,CAAC,EAC3D;IAAEzc,IAAI,EAAE,aAAa;IAAEwc,SAAS,EAAE;EAAQ,CAAC,EAC3C;IAAExc,IAAI,EAAE,YAAY;IAAEwc,SAAS,EAAE;EAAM,CAAC,EACxC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAI,CAAC,EAChC;IAAExc,IAAI,EAAE,UAAU;IAAEwc,SAAS,EAAE;EAAO,CAAC,EACvC;IAAExc,IAAI,EAAE,WAAW;IAAEwc,SAAS,EAAE,KAAK;IAAEE,yBAAyB,EAAE;EAAK,CAAC,EACxE;IAAE1c,IAAI,EAAE,SAAS;IAAEwc,SAAS,EAAE;EAAI,CAAC,EACnC;IAAExc,IAAI,EAAE,QAAQ;IAAEwc,SAAS,EAAE;EAAI,CAAC,EAClC;IAAExc,IAAI,EAAE,MAAM;IAAEwc,SAAS,EAAE;EAAI,CAAC,EAChC;IAAExc,IAAI,EAAE,QAAQ;IAAEwc,SAAS,EAAE;EAAO,CAAC,EACrC;IAAExc,IAAI,EAAE,QAAQ;IAAEwc,SAAS,EAAE;EAAI,CAAC,CACrC;EACD,IAAIG,OAAO,GAAGC,YAAY,CAAC,EAAE,CAAC;EAC9B,SAASC,YAAYA,CAACjZ,EAAE,EAAE;IACtBA,EAAE,CAAC6N,SAAS,CAAC,cAAc,EAAE,IAAI,CAAC;IAClC7N,EAAE,CAAC6N,SAAS,CAAC,yBAAyB,EAAE,KAAK,CAAC;IAC9CzO,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;MAAE0J,IAAI,EAAE;IAAS,CAAC,CAAC;IAC5D1J,EAAE,CAAC5C,EAAE,CAAC,gBAAgB,EAAE8b,gBAAgB,CAAC;IACzCC,iBAAiB,CAACnZ,EAAE,CAAC;IACrBZ,UAAU,CAAChC,EAAE,CAAC4C,EAAE,CAACkN,aAAa,CAAC,CAAC,EAAE,OAAO,EAAEkM,YAAY,CAACpZ,EAAE,CAAC,CAAC;EAChE;EACA,SAASqZ,YAAYA,CAACrZ,EAAE,EAAE;IACtBA,EAAE,CAAC6N,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;IACnC7N,EAAE,CAAC3C,GAAG,CAAC,gBAAgB,EAAE6b,gBAAgB,CAAC;IAC1C9Z,UAAU,CAAC/B,GAAG,CAAC2C,EAAE,CAACkN,aAAa,CAAC,CAAC,EAAE,OAAO,EAAEkM,YAAY,CAACpZ,EAAE,CAAC,CAAC;IAC7DA,EAAE,CAACX,KAAK,CAACsV,GAAG,GAAG,IAAI;IACnB,IAAI2E,gBAAgB,EAChB3D,YAAY,CAAC2D,gBAAgB,CAAC;EACtC;EACA,SAASF,YAAYA,CAACpZ,EAAE,EAAE;IACtB,IAAI2U,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,IAAI,CAACA,GAAG,CAAC4E,SAAS,EAAE;MAChB5E,GAAG,CAAC4E,SAAS,GAAG,YAAY;QACxB,IAAI,CAAC5E,GAAG,CAAC6E,UAAU,EAAE;UACjBxZ,EAAE,CAAC+E,SAAS,CAAC0U,YAAY,CAACzZ,EAAE,CAACqF,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;UAChDqU,OAAO,CAACC,eAAe,CAAC3Z,EAAE,EAAE,CAAC,CAAC,EAAE2U,GAAG,CAAC;QACxC;MACJ,CAAC;IACL;IACA,OAAOA,GAAG,CAAC4E,SAAS;EACxB;EACA,IAAIK,WAAW,GAAG,MAAM;EACxB,IAAIC,YAAY,GAAG,CAACza,UAAU,CAACgD,UAAU,EAAE,UAAUzE,EAAE,EAAE;MACjD,OAAOA,EAAE,IAAI,CAACyB,UAAU,CAACgD,UAAU,CAACzE,EAAE,CAAC,IAAI,CAAC,IAAI,CAACvC,IAAI,CAACuC,EAAE,CAAC;IAC7D,CAAC,CAAC;IAAEmc,eAAe,GAAG,CAAC,UAAUnc,EAAE,EAAE;MACjC,OAAO,IAAI,CAACvC,IAAI,CAACuC,EAAE,CAAC;IACxB,CAAC,CAAC;EACN,IAAIoc,UAAU,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;EAC3B,IAAIC,cAAc,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EACxD,IAAIC,cAAc,GAAG,MAAM;EAC3B,IAAIC,cAAc;EAClB,IAAI;IACAA,cAAc,GAAG,IAAIzP,MAAM,CAAC,aAAa,EAAE,GAAG,CAAC;EACnD,CAAC,CACD,OAAOoG,CAAC,EAAE;IACNqJ,cAAc,GAAG,SAAS;EAC9B;EACA,SAASC,MAAMA,CAACna,EAAE,EAAEtF,IAAI,EAAE;IACtB,OAAOA,IAAI,IAAIsF,EAAE,CAAC2E,SAAS,CAAC,CAAC,IAAIjK,IAAI,IAAIsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC;EAC1D;EACA,SAASwV,WAAWA,CAACC,CAAC,EAAE;IACpB,OAAQ,SAAS,CAAEjf,IAAI,CAACif,CAAC,CAAC;EAC9B;EACA,SAASC,iBAAiBA,CAACD,CAAC,EAAE;IAC1B,OAAO,QAAQ,CAACxH,OAAO,CAACwH,CAAC,CAAC,IAAI,CAAC,CAAC;EACpC;EACA,SAASE,QAAQA,CAACF,CAAC,EAAE;IACjB,OAAOT,WAAW,CAACxe,IAAI,CAACif,CAAC,CAAC;EAC9B;EACA,SAASG,WAAWA,CAACH,CAAC,EAAE;IACpB,OAAOH,cAAc,CAAC9e,IAAI,CAACif,CAAC,CAAC;EACjC;EACA,SAASI,kBAAkBA,CAACJ,CAAC,EAAE;IAC3B,OAAQ,OAAO,CAAEjf,IAAI,CAACif,CAAC,CAAC;EAC5B;EACA,SAASK,qBAAqBA,CAACL,CAAC,EAAE;IAC9B,OAAO,KAAK,CAACxH,OAAO,CAACwH,CAAC,CAAC,IAAI,CAAC,CAAC;EACjC;EACA,SAASM,OAAOA,CAACzd,GAAG,EAAE0d,GAAG,EAAE;IACvB,KAAK,IAAIxc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwc,GAAG,CAAChgB,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACjC,IAAIwc,GAAG,CAACxc,CAAC,CAAC,IAAIlB,GAAG,EAAE;QACf,OAAO,IAAI;MACf;IACJ;IACA,OAAO,KAAK;EAChB;EACA,IAAInD,OAAO,GAAG,CAAC,CAAC;EAChB,SAAS8F,YAAYA,CAACzD,IAAI,EAAEye,YAAY,EAAEpL,IAAI,EAAEqL,OAAO,EAAEzG,QAAQ,EAAE;IAC/D,IAAIwG,YAAY,KAAK/P,SAAS,IAAI,CAACuJ,QAAQ,EAAE;MACzC,MAAM0G,KAAK,CAAC,sDAAsD,CAAC;IACvE;IACA,IAAI,CAACtL,IAAI,EAAE;MACPA,IAAI,GAAG,QAAQ;IACnB;IACA1V,OAAO,CAACqC,IAAI,CAAC,GAAG;MACZqT,IAAI,EAAEA,IAAI;MACVoL,YAAY,EAAEA,YAAY;MAC1BxG,QAAQ,EAAEA;IACd,CAAC;IACD,IAAIyG,OAAO,EAAE;MACT,KAAK,IAAI1c,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0c,OAAO,CAAClgB,MAAM,EAAEwD,CAAC,EAAE,EAAE;QACrCrE,OAAO,CAAC+gB,OAAO,CAAC1c,CAAC,CAAC,CAAC,GAAGrE,OAAO,CAACqC,IAAI,CAAC;MACvC;IACJ;IACA,IAAIye,YAAY,EAAE;MACdhN,SAAS,CAACzR,IAAI,EAAEye,YAAY,CAAC;IACjC;EACJ;EACA,SAAShN,SAASA,CAACzR,IAAI,EAAEkB,KAAK,EAAE0C,EAAE,EAAEgb,GAAG,EAAE;IACrC,IAAIC,MAAM,GAAGlhB,OAAO,CAACqC,IAAI,CAAC;IAC1B4e,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IACf,IAAIE,KAAK,GAAGF,GAAG,CAACE,KAAK;IACrB,IAAI,CAACD,MAAM,EAAE;MACT,OAAO,IAAIF,KAAK,CAAC,kBAAkB,GAAG3e,IAAI,CAAC;IAC/C;IACA,IAAI6e,MAAM,CAACxL,IAAI,IAAI,SAAS,EAAE;MAC1B,IAAInS,KAAK,IAAIA,KAAK,KAAK,IAAI,EAAE;QACzB,OAAO,IAAIyd,KAAK,CAAC,oBAAoB,GAAG3e,IAAI,GAAG,GAAG,GAAGkB,KAAK,CAAC;MAC/D,CAAC,MACI,IAAIA,KAAK,KAAK,KAAK,EAAE;QACtBA,KAAK,GAAG,IAAI;MAChB;IACJ;IACA,IAAI2d,MAAM,CAAC5G,QAAQ,EAAE;MACjB,IAAI6G,KAAK,KAAK,OAAO,EAAE;QACnBD,MAAM,CAAC5G,QAAQ,CAAC/W,KAAK,EAAEwN,SAAS,CAAC;MACrC;MACA,IAAIoQ,KAAK,KAAK,QAAQ,IAAIlb,EAAE,EAAE;QAC1Bib,MAAM,CAAC5G,QAAQ,CAAC/W,KAAK,EAAE0C,EAAE,CAAC;MAC9B;IACJ,CAAC,MACI;MACD,IAAIkb,KAAK,KAAK,OAAO,EAAE;QACnBD,MAAM,CAAC3d,KAAK,GAAG2d,MAAM,CAACxL,IAAI,IAAI,SAAS,GAAG,CAAC,CAACnS,KAAK,GAAGA,KAAK;MAC7D;MACA,IAAI4d,KAAK,KAAK,QAAQ,IAAIlb,EAAE,EAAE;QAC1BA,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC5a,OAAO,CAACqC,IAAI,CAAC,GAAG;UAAEkB,KAAK,EAAEA;QAAM,CAAC;MACjD;IACJ;EACJ;EACA,SAASpD,SAASA,CAACkC,IAAI,EAAE4D,EAAE,EAAEgb,GAAG,EAAE;IAC9B,IAAIC,MAAM,GAAGlhB,OAAO,CAACqC,IAAI,CAAC;IAC1B4e,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IACf,IAAIE,KAAK,GAAGF,GAAG,CAACE,KAAK;IACrB,IAAI,CAACD,MAAM,EAAE;MACT,OAAO,IAAIF,KAAK,CAAC,kBAAkB,GAAG3e,IAAI,CAAC;IAC/C;IACA,IAAI6e,MAAM,CAAC5G,QAAQ,EAAE;MACjB,IAAI8G,KAAK,GAAGnb,EAAE,IAAIib,MAAM,CAAC5G,QAAQ,CAACvJ,SAAS,EAAE9K,EAAE,CAAC;MAChD,IAAIkb,KAAK,KAAK,QAAQ,IAAIC,KAAK,KAAKrQ,SAAS,EAAE;QAC3C,OAAOqQ,KAAK;MAChB;MACA,IAAID,KAAK,KAAK,OAAO,EAAE;QACnB,OAAOD,MAAM,CAAC5G,QAAQ,CAAC,CAAC;MAC5B;MACA;IACJ,CAAC,MACI;MACD,IAAI8G,KAAK,GAAID,KAAK,KAAK,QAAQ,IAAMlb,EAAE,IAAIA,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC5a,OAAO,CAACqC,IAAI,CAAE;MACtE,OAAO,CAAC+e,KAAK,IAAKD,KAAK,KAAK,OAAO,IAAKD,MAAM,IAAI,CAAC,CAAC,EAAE3d,KAAK;IAC/D;EACJ;EACAuC,YAAY,CAAC,UAAU,EAAEiL,SAAS,EAAE,QAAQ,EAAE,CAAC,IAAI,CAAC,EAAE,UAAU1O,IAAI,EAAE4D,EAAE,EAAE;IACtE,IAAIA,EAAE,KAAK8K,SAAS,EAAE;MAClB;IACJ;IACA,IAAI1O,IAAI,KAAK0O,SAAS,EAAE;MACpB,IAAIpB,IAAI,GAAG1J,EAAE,CAAC9F,SAAS,CAAC,MAAM,CAAC;MAC/B,OAAOwP,IAAI,IAAI,MAAM,GAAG,EAAE,GAAGA,IAAI;IACrC,CAAC,MACI;MACD,IAAIA,IAAI,GAAGtN,IAAI,IAAI,EAAE,GAAG,MAAM,GAAGA,IAAI;MACrC4D,EAAE,CAAC6N,SAAS,CAAC,MAAM,EAAEnE,IAAI,CAAC;IAC9B;EACJ,CAAC,CAAC;EACF7J,YAAY,CAAC,WAAW,EAAE,EAAE,EAAE,QAAQ,EAAE,CAAC,IAAI,CAAC,EAAE,UAAUyM,KAAK,EAAEtM,EAAE,EAAE;IACjE,IAAIA,EAAE,KAAK8K,SAAS,EAAE;MAClB;IACJ;IACA,IAAIwB,KAAK,KAAKxB,SAAS,EAAE;MACrB,IAAIxN,KAAK,GAAG0C,EAAE,CAAC9F,SAAS,CAAC,WAAW,CAAC;MACrC,OAAOoD,KAAK;IAChB,CAAC,MACI;MACD,IAAIrD,MAAM,GAAGI,IAAI,CAAC+gB,KAAK,CAAC9O,KAAK,CAAC;MAC9B,IAAIrS,MAAM,GAAG,CAAC,EAAE;QACZ+F,EAAE,CAAC6N,SAAS,CAAC,WAAW,EAAE5T,MAAM,CAAC;MACrC;IACJ;EACJ,CAAC,CAAC;EACF,IAAIohB,sBAAsB,GAAG,SAAAA,CAAA,EAAY;IACrC,IAAIC,IAAI,GAAG,GAAG;IACd,IAAIC,OAAO,GAAG,CAAC,CAAC;IAChB,IAAI1d,IAAI,GAAG,CAAC;IACZ,IAAI2d,IAAI,GAAG,CAAC;IACZ,IAAIC,MAAM,GAAG,IAAI3d,KAAK,CAACwd,IAAI,CAAC;IAC5B,SAASI,GAAGA,CAAC1b,EAAE,EAAE2b,MAAM,EAAEC,MAAM,EAAE;MAC7B,IAAItI,OAAO,GAAGiI,OAAO,GAAGD,IAAI;MAC5B,IAAIO,OAAO,GAAGJ,MAAM,CAACnI,OAAO,CAAC;MAC7B,SAASwI,WAAWA,CAACxf,MAAM,EAAE;QACzB,IAAIgH,IAAI,GAAG,EAAEiY,OAAO,GAAGD,IAAI;QAC3B,IAAIS,SAAS,GAAGN,MAAM,CAACnY,IAAI,CAAC;QAC5B,IAAIyY,SAAS,EAAE;UACXA,SAAS,CAACtU,KAAK,CAAC,CAAC;QACrB;QACAgU,MAAM,CAACnY,IAAI,CAAC,GAAGtD,EAAE,CAACqI,WAAW,CAAC/L,MAAM,CAAC;MACzC;MACA,IAAIuf,OAAO,EAAE;QACT,IAAIG,OAAO,GAAGH,OAAO,CAACnU,IAAI,CAAC,CAAC;QAC5B,IAAIsU,OAAO,IAAI,CAACC,WAAW,CAACD,OAAO,EAAEL,MAAM,CAAC,EAAE;UAC1CG,WAAW,CAACH,MAAM,CAAC;QACvB;MACJ,CAAC,MACI;QACDG,WAAW,CAACH,MAAM,CAAC;MACvB;MACAG,WAAW,CAACF,MAAM,CAAC;MACnB/d,IAAI,GAAG0d,OAAO;MACdC,IAAI,GAAGD,OAAO,GAAGD,IAAI,GAAG,CAAC;MACzB,IAAIE,IAAI,GAAG,CAAC,EAAE;QACVA,IAAI,GAAG,CAAC;MACZ;IACJ;IACA,SAASU,IAAIA,CAAClc,EAAE,EAAEmc,MAAM,EAAE;MACtBZ,OAAO,IAAIY,MAAM;MACjB,IAAIZ,OAAO,GAAG1d,IAAI,EAAE;QAChB0d,OAAO,GAAG1d,IAAI;MAClB,CAAC,MACI,IAAI0d,OAAO,GAAGC,IAAI,EAAE;QACrBD,OAAO,GAAGC,IAAI;MAClB;MACA,IAAIY,IAAI,GAAGX,MAAM,CAAC,CAACH,IAAI,GAAGC,OAAO,IAAID,IAAI,CAAC;MAC1C,IAAIc,IAAI,IAAI,CAACA,IAAI,CAAC1U,IAAI,CAAC,CAAC,EAAE;QACtB,IAAI2U,GAAG,GAAGF,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC7B,IAAIP,MAAM;QACV,IAAID,MAAM,GAAG3b,EAAE,CAACqF,SAAS,CAAC,CAAC;QAC3B,GAAG;UACCkW,OAAO,IAAIc,GAAG;UACdD,IAAI,GAAGX,MAAM,CAAC,CAACH,IAAI,GAAGC,OAAO,IAAID,IAAI,CAAC;UACtC,IAAIc,IAAI,KACHR,MAAM,GAAGQ,IAAI,CAAC1U,IAAI,CAAC,CAAC,CAAC,IACtB,CAACuU,WAAW,CAACN,MAAM,EAAEC,MAAM,CAAC,EAAE;YAC9B;UACJ;QACJ,CAAC,QAAQL,OAAO,GAAG1d,IAAI,IAAI0d,OAAO,GAAGC,IAAI;MAC7C;MACA,OAAOY,IAAI;IACf;IACA,SAAS1U,IAAIA,CAAC1H,EAAE,EAAEmc,MAAM,EAAE;MACtB,IAAIG,UAAU,GAAGf,OAAO;MACxB,IAAIa,IAAI,GAAGF,IAAI,CAAClc,EAAE,EAAEmc,MAAM,CAAC;MAC3BZ,OAAO,GAAGe,UAAU;MACpB,OAAOF,IAAI,IAAIA,IAAI,CAAC1U,IAAI,CAAC,CAAC;IAC9B;IACA,OAAO;MACH6U,YAAY,EAAEzR,SAAS;MAAE;MACzB4Q,GAAG,EAAEA,GAAG;MACRhU,IAAI,EAAEA,IAAI;MACVwU,IAAI,EAAEA;IACV,CAAC;EACL,CAAC;EACD,IAAIM,uBAAuB,GAAG,SAAAA,CAAUC,CAAC,EAAE;IACvC,IAAIA,CAAC,EAAE;MACH,OAAO;QACHC,OAAO,EAAED,CAAC,CAACC,OAAO;QAClBC,6BAA6B,EAAEF,CAAC,CAACE;MACrC,CAAC;IACL;IACA,OAAO;MACHD,OAAO,EAAE,EAAE;MACXC,6BAA6B,EAAE;IACnC,CAAC;EACL,CAAC;EACD,SAASC,cAAcA,CAAA,EAAG;IACtB,IAAI,CAACC,cAAc,GAAG/R,SAAS;IAC/B,IAAI,CAACgS,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,mBAAmB,GAAG,EAAE;IAC7B,IAAI,CAACC,eAAe,GAAGnS,SAAS;IAChC,IAAI,CAACoS,qBAAqB,GAAGV,uBAAuB,CAAC,CAAC;EAC1D;EACAI,cAAc,CAAC5f,SAAS,GAAG;IACvBmgB,mBAAmB,EAAE,SAAAA,CAAA,EAAY;MAC7B,IAAIC,cAAc,GAAGC,cAAc,CAACD,cAAc;MAClD,IAAIA,cAAc,CAACH,eAAe,EAAE;QAChCG,cAAc,CAACH,eAAe,CAAC,CAAC,CAAC,CAAC;MACtC;MACAG,cAAc,CAACH,eAAe,GAAGnS,SAAS;MAC1CsS,cAAc,CAACL,WAAW,GAAG,KAAK;IACtC,CAAC;IACDO,oBAAoB,EAAE,SAAAA,CAAUtd,EAAE,EAAEud,YAAY,EAAE;MAC9C,IAAIC,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACH,YAAY,CAAC;MAC1E,IAAIC,QAAQ,EAAE;QACVA,QAAQ,CAAC/V,KAAK,CAAC,CAAC;QAChB,IAAI,CAACoV,cAAc,GAAGU,YAAY;QAClC,IAAIvd,EAAE,CAAC2d,UAAU,EAAE;UACf,IAAI/J,QAAQ,GAAGgK,GAAG,CAAC,MAAM,EAAE;YAAEC,KAAK,EAAE;UAAiB,CAAC,EAAE,aAAa,GAAGN,YAAY,CAAC;UACrF,IAAI,CAACN,eAAe,GAAGjd,EAAE,CAAC2d,UAAU,CAAC/J,QAAQ,EAAE,IAAI,EAAE;YAAE3J,MAAM,EAAE;UAAK,CAAC,CAAC;QAC1E;QACA,IAAI,CAAC8S,WAAW,GAAG,IAAI;MAC3B;IACJ;EACJ,CAAC;EACD,SAAS5D,iBAAiBA,CAACnZ,EAAE,EAAE;IAC3B,IAAI,CAACA,EAAE,CAACX,KAAK,CAACsV,GAAG,EAAE;MACf3U,EAAE,CAACX,KAAK,CAACsV,GAAG,GAAG;QACXmJ,UAAU,EAAE,IAAIC,UAAU,CAAC,CAAC;QAC5BC,kBAAkB,EAAElT,SAAS;QAC7BmT,qBAAqB,EAAEnT,SAAS;QAChCoT,QAAQ,EAAE,CAAC,CAAC;QACZC,SAAS,EAAE,CAAC,CAAC;QACbC,UAAU,EAAE,IAAI;QAChB9e,KAAK,EAAE,CAAC,CAAC;QACTka,UAAU,EAAE,KAAK;QACjB6E,gBAAgB,EAAE,KAAK;QACvBC,gBAAgB,EAAExT,SAAS;QAC3ByT,UAAU,EAAE,KAAK;QACjB5G,UAAU,EAAE,KAAK;QACjB6G,WAAW,EAAE,KAAK;QAClBC,aAAa,EAAE,IAAI;QACnBC,cAAc,EAAE,IAAI;QACpBpZ,GAAG,EAAE,CAAC,CAAC;QACPvL,OAAO,EAAE,CAAC,CAAC;QACX4kB,iBAAiB,EAAE;MACvB,CAAC;IACL;IACA,OAAO3e,EAAE,CAACX,KAAK,CAACsV,GAAG;EACvB;EACA,IAAI0I,cAAc;EAClB,SAASuB,mBAAmBA,CAAA,EAAG;IAC3BvB,cAAc,GAAG;MACbwB,WAAW,EAAE,IAAI;MACjBC,gBAAgB,EAAE,KAAK;MACvBC,yBAAyB,EAAEjU,SAAS;MACpCkU,QAAQ,EAAE3D,sBAAsB,CAAC,CAAC;MAClC+B,cAAc,EAAE,IAAIR,cAAc,CAAD,CAAC;MAClCqC,mBAAmB,EAAE;QAAExW,SAAS,EAAE,CAAC;QAAEiO,OAAO,EAAE,IAAI;QAAEwI,iBAAiB,EAAE;MAAG,CAAC;MAC3EzB,kBAAkB,EAAE,IAAI0B,kBAAkB,CAAC,CAAC,CAAC,CAAC;MAC9CC,uBAAuB,EAAE,IAAIC,iBAAiB,CAAC,CAAC;MAChDC,0BAA0B,EAAE,IAAID,iBAAiB,CAAC;IACtD,CAAC;IACD,KAAK,IAAIE,UAAU,IAAIxlB,OAAO,EAAE;MAC5B,IAAIkhB,MAAM,GAAGlhB,OAAO,CAACwlB,UAAU,CAAC;MAChCtE,MAAM,CAAC3d,KAAK,GAAG2d,MAAM,CAACJ,YAAY;IACtC;EACJ;EACA,IAAI2E,sBAAsB;EAC1B,IAAIC,MAAM,GAAG;IACTxG,YAAY,EAAEA,YAAY;IAC1BI,YAAY,EAAEA,YAAY;IAC1BqG,WAAW,EAAE,SAAAA,CAAA,EAAY,CACzB,CAAC;IACDC,qBAAqB,EAAE,SAAAA,CAAA,EAAY;MAC/B,OAAOtC,cAAc,CAACI,kBAAkB;IAC5C,CAAC;IACDmC,oBAAoB,EAAEhB,mBAAmB;IACzCiB,kBAAkB,EAAE,SAAAA,CAAA,EAAY;MAC5B,OAAOxC,cAAc;IACzB,CAAC;IACDyC,kBAAkB,EAAE3G,iBAAiB;IACrC4G,oBAAoB,EAAE,KAAK;IAC3BC,aAAa,EAAEA,aAAa;IAC5BhiB,GAAG,EAAE,SAAAA,CAAUiiB,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAE;MAC1BC,mBAAmB,CAACpiB,GAAG,CAACiiB,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;IAC1C,CAAC;IACDE,KAAK,EAAE,SAAAA,CAAUJ,GAAG,EAAEE,GAAG,EAAE;MACvB,OAAOC,mBAAmB,CAACC,KAAK,CAACJ,GAAG,EAAEE,GAAG,CAAC;IAC9C,CAAC;IACDG,OAAO,EAAE,SAAAA,CAAUL,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAE;MAC9BC,mBAAmB,CAACpiB,GAAG,CAACiiB,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAE,IAAI,CAAC;IAChD,CAAC;IACDI,QAAQ,EAAE,SAAAA,CAAUJ,GAAG,EAAE;MACrB,IAAIK,YAAY,GAAGtK,aAAa,CAACtb,MAAM;QAAE6lB,UAAU,GAAG/H,mBAAmB;MACzE,IAAIgI,UAAU,GAAGxK,aAAa,CAACta,KAAK,CAAC,CAAC,EAAE4kB,YAAY,GAAGC,UAAU,CAAC;MAClEvK,aAAa,GAAGA,aAAa,CAACta,KAAK,CAAC4kB,YAAY,GAAGC,UAAU,CAAC;MAC9D,IAAIN,GAAG,EAAE;QACL,KAAK,IAAI/hB,CAAC,GAAGsiB,UAAU,CAAC9lB,MAAM,GAAG,CAAC,EAAEwD,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC7C,IAAIuiB,OAAO,GAAGD,UAAU,CAACtiB,CAAC,CAAC;UAC3B,IAAI+hB,GAAG,KAAKQ,OAAO,CAACtK,OAAO,EAAE;YACzB,IAAIsK,OAAO,CAACtK,OAAO,EAAE;cACjB,IAAI,CAACuK,WAAW,CAACD,OAAO,CAAC;YAC7B,CAAC,MACI;cACD,IAAIE,QAAQ,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC;cAC7C,KAAK,IAAIC,CAAC,IAAID,QAAQ,EAAE;gBACpB,IAAIA,QAAQ,CAACC,CAAC,CAAC,KAAKX,GAAG,EAAE;kBACrB,IAAIY,UAAU,GAAG,CAAC,CAAC;kBACnB,KAAK,IAAIhgB,GAAG,IAAI4f,OAAO,EAAE;oBACrBI,UAAU,CAAChgB,GAAG,CAAC,GAAG4f,OAAO,CAAC5f,GAAG,CAAC;kBAClC;kBACAggB,UAAU,CAAC1K,OAAO,GAAGwK,QAAQ,CAACC,CAAC,CAAC;kBAChC,IAAI,CAACF,WAAW,CAACG,UAAU,CAAC;gBAChC;cACJ;YACJ;UACJ;QACJ;MACJ;IACJ,CAAC;IACDhI,OAAO,EAAEiI,aAAa;IACtBC,eAAe,EAAEA,eAAe;IAChCpT,SAAS,EAAEA,SAAS;IACpB3T,SAAS,EAAEA,SAAS;IACpB2F,YAAY,EAAEA,YAAY;IAC1BqhB,QAAQ,EAAE,SAAAA,CAAU9kB,IAAI,EAAE+kB,MAAM,EAAEC,IAAI,EAAE;MACpC,IAAI,CAACD,MAAM,EAAE;QACTA,MAAM,GAAG/kB,IAAI;MACjB,CAAC,MACI,IAAIA,IAAI,CAACyW,OAAO,CAACsO,MAAM,CAAC,KAAK,CAAC,EAAE;QACjC,MAAM,IAAIpG,KAAK,CAAC,kBAAkB,GAAGoG,MAAM,GAAG,wBAAwB,GAAG/kB,IAAI,GAAG,2BAA2B,CAAC;MAChH;MACAilB,UAAU,CAACjlB,IAAI,CAAC,GAAGglB,IAAI;MACvBhB,mBAAmB,CAACkB,WAAW,CAACH,MAAM,CAAC,GAAG;QAAE/kB,IAAI,EAAEA,IAAI;QAAEwc,SAAS,EAAEuI,MAAM;QAAE1R,IAAI,EAAE;MAAM,CAAC;IAC5F,CAAC;IACD8R,SAAS,EAAE,SAAAA,CAAUvhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,EAAE;MAClC,IAAIhL,OAAO,GAAG,IAAI,CAACqlB,OAAO,CAACxhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,CAAC;MAC3C,IAAI,OAAOhL,OAAO,KAAK,UAAU,EAAE;QAC/B,OAAOA,OAAO,CAAC,CAAC;MACpB;IACJ,CAAC;IACDslB,oBAAoB,EAAEA,oBAAoB;IAC1CD,OAAO,EAAE,SAAAA,CAAUxhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,EAAE;MAChC,IAAIwN,GAAG,GAAGwE,iBAAiB,CAACnZ,EAAE,CAAC;MAC/B,SAAS0hB,oBAAoBA,CAAA,EAAG;QAC5B,IAAItE,cAAc,GAAGC,cAAc,CAACD,cAAc;QAClD,IAAIA,cAAc,CAACL,WAAW,EAAE;UAC5B,IAAIhc,GAAG,IAAI,GAAG,EAAE;YACZqc,cAAc,CAACD,mBAAmB,CAAC,CAAC;YACpCwE,eAAe,CAAC3hB,EAAE,CAAC;YACnB,OAAO,IAAI;UACf;UACA,IAAImH,MAAM,IAAI,SAAS,EAAE;YACrBya,MAAM,CAACxE,cAAc,EAAErc,GAAG,CAAC;UAC/B;QACJ;MACJ;MACA,SAAS8gB,SAASA,CAAA,EAAG;QACjB,IAAI9gB,GAAG,IAAI,OAAO,EAAE;UAChB,IAAI4T,GAAG,CAAC4J,UAAU,EAAE;YAChBuD,cAAc,CAAC9hB,EAAE,CAAC;UACtB,CAAC,MACI,IAAI2U,GAAG,CAAC6E,UAAU,EAAE;YACrBuI,cAAc,CAAC/hB,EAAE,CAAC;UACtB,CAAC,MACI;YACD;UACJ;UACA2hB,eAAe,CAAC3hB,EAAE,CAAC;UACnB,OAAO,IAAI;QACf;MACJ;MACA,SAASgiB,mBAAmBA,CAAA,EAAG;QAC3B,IAAIH,SAAS,CAAC,CAAC,EAAE;UACb,OAAO,IAAI;QACf;QACAlN,GAAG,CAACmJ,UAAU,CAACmE,SAAS,CAACpf,IAAI,CAAC9B,GAAG,CAAC;QAClC,IAAIoV,IAAI,GAAGxB,GAAG,CAACmJ,UAAU,CAACmE,SAAS,CAACC,IAAI,CAAC,EAAE,CAAC;QAC5C,IAAIC,YAAY,GAAGphB,GAAG,CAACnG,MAAM,IAAI,CAAC;QAClC,IAAI2X,KAAK,GAAG6P,iBAAiB,CAACC,YAAY,CAAClM,IAAI,EAAED,aAAa,EAAEvB,GAAG,CAACmJ,UAAU,EAAE,QAAQ,CAAC;QACzF,IAAIwE,WAAW,GAAG3N,GAAG,CAACmJ,UAAU,CAACwE,WAAW;QAC5C,IAAI/P,KAAK,CAAC9C,IAAI,IAAI,MAAM,EAAE;UACtBkS,eAAe,CAAC3hB,EAAE,CAAC;UACnB,OAAO,KAAK;QAChB,CAAC,MACI,IAAIuS,KAAK,CAAC9C,IAAI,IAAI,SAAS,EAAE;UAC9B,IAAI8C,KAAK,CAACoM,iBAAiB,EACvBhK,GAAG,CAACgK,iBAAiB,GAAG,IAAI;UAChC,IAAIa,sBAAsB,EAAE;YACxB+C,MAAM,CAAC5M,YAAY,CAAC6J,sBAAsB,CAAC;UAC/C;UACAA,sBAAsB,GAAG2C,YAAY,IAAII,MAAM,CAAC3M,UAAU,CAAC,YAAY;YAAE,IAAIjB,GAAG,CAAC6E,UAAU,IAAI7E,GAAG,CAACmJ,UAAU,CAACmE,SAAS,CAACrnB,MAAM,EAAE;cAC5H+mB,eAAe,CAAC3hB,EAAE,CAAC;YACvB;UAAE,CAAC,EAAE9F,SAAS,CAAC,0BAA0B,CAAC,CAAC;UAC3C,IAAIioB,YAAY,EAAE;YACd,IAAIK,UAAU,GAAGxiB,EAAE,CAAC4F,cAAc,CAAC,CAAC;YACpC,IAAI,CAAC0c,WAAW,IAAIA,WAAW,CAACG,OAAO,CAAC7nB,MAAM,IAAI4nB,UAAU,CAAC5nB,MAAM,EAC/D0nB,WAAW,GAAG3N,GAAG,CAACmJ,UAAU,CAACwE,WAAW,GAAG,IAAII,WAAW,CAAD,CAAC;YAC9DJ,WAAW,CAACK,QAAQ,IAAI5hB,GAAG;YAC3B,KAAK,IAAI3C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGokB,UAAU,CAAC5nB,MAAM,EAAEwD,CAAC,EAAE,EAAE;cACxC,IAAIuN,IAAI,GAAGiX,SAAS,CAACJ,UAAU,CAACpkB,CAAC,CAAC,CAACR,MAAM,EAAE4kB,UAAU,CAACpkB,CAAC,CAAC,CAACP,IAAI,CAAC;cAC9D,IAAI+N,EAAE,GAAGiX,SAAS,CAACL,UAAU,CAACpkB,CAAC,CAAC,CAACR,MAAM,EAAE4kB,UAAU,CAACpkB,CAAC,CAAC,CAACP,IAAI,CAAC;cAC5D,IAAIkF,IAAI,GAAG/C,EAAE,CAAC0F,QAAQ,CAACiG,IAAI,EAAE3L,EAAE,CAACX,KAAK,CAAC4O,SAAS,GAAGwL,YAAY,CAAC7N,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,GAAGA,EAAE,CAAC;cAC9E0W,WAAW,CAACG,OAAO,CAACrkB,CAAC,CAAC,GAAG,CAACkkB,WAAW,CAACG,OAAO,CAACrkB,CAAC,CAAC,IAAI,EAAE,IAAI2E,IAAI;YAClE;UACJ;UACA,OAAO,CAACof,YAAY;QACxB;QACAxN,GAAG,CAACgK,iBAAiB,GAAG,KAAK;QAC7B,IAAIa,sBAAsB,EAAE;UACxB+C,MAAM,CAAC5M,YAAY,CAAC6J,sBAAsB,CAAC;QAC/C;QACA,IAAIjN,KAAK,CAACpW,OAAO,IAAImmB,WAAW,EAAE;UAC9B,IAAIE,UAAU,GAAGxiB,EAAE,CAAC4F,cAAc,CAAC,CAAC;UACpC,KAAK,IAAIxH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGokB,UAAU,CAAC5nB,MAAM,EAAEwD,CAAC,EAAE,EAAE;YACxC,IAAI0kB,IAAI,GAAGN,UAAU,CAACpkB,CAAC,CAAC,CAACP,IAAI;YAC7BmC,EAAE,CAACvE,YAAY,CAAC6mB,WAAW,CAACG,OAAO,CAACrkB,CAAC,CAAC,IAAI,EAAE,EAAEqb,YAAY,CAACqJ,IAAI,EAAE,CAAC,EAAE,CAACR,WAAW,CAACK,QAAQ,CAAC/nB,MAAM,CAAC,EAAEkoB,IAAI,EAAE,QAAQ,CAAC;UACtH;UACAzF,cAAc,CAACD,cAAc,CAACF,qBAAqB,CAACR,OAAO,CAACqG,GAAG,CAAC,CAAC;QACrE;QACA,IAAI,CAACxQ,KAAK,CAACpW,OAAO,EACdwlB,eAAe,CAAC3hB,EAAE,CAAC;QACvB,OAAOuS,KAAK,CAACpW,OAAO;MACxB;MACA,SAAS6mB,sBAAsBA,CAAA,EAAG;QAC9B,IAAItB,oBAAoB,CAAC,CAAC,IAAIG,SAAS,CAAC,CAAC,EAAE;UACvC,OAAO,IAAI;QACf;QACAlN,GAAG,CAACmJ,UAAU,CAACmE,SAAS,CAACpf,IAAI,CAAC9B,GAAG,CAAC;QAClC,IAAIoV,IAAI,GAAGxB,GAAG,CAACmJ,UAAU,CAACmE,SAAS,CAACC,IAAI,CAAC,EAAE,CAAC;QAC5C,IAAI,YAAY,CAAC9mB,IAAI,CAAC+a,IAAI,CAAC,EAAE;UACzB,OAAO,IAAI;QACf;QACA,IAAI8M,WAAW,GAAG,aAAa,CAACjoB,IAAI,CAACmb,IAAI,CAAC;QAC1C,IAAI,CAAC8M,WAAW,EAAE;UACdtB,eAAe,CAAC3hB,EAAE,CAAC;UACnB,OAAO,KAAK;QAChB;QACA,IAAIqW,OAAO,GAAG1B,GAAG,CAAC4J,UAAU,GAAG,QAAQ,GACnC,QAAQ;QACZ,IAAI2E,OAAO,GAAGD,WAAW,CAAC,CAAC,CAAC,IAAIA,WAAW,CAAC,CAAC,CAAC;QAC9C,IAAItO,GAAG,CAACmJ,UAAU,CAACqF,gBAAgB,IAAIxO,GAAG,CAACmJ,UAAU,CAACqF,gBAAgB,CAACvnB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAIsnB,OAAO,EAAE;UACzFA,OAAO,GAAGvO,GAAG,CAACmJ,UAAU,CAACqF,gBAAgB;QAC7C;QACA,IAAI5Q,KAAK,GAAG6P,iBAAiB,CAACC,YAAY,CAACa,OAAO,EAAEhN,aAAa,EAAEvB,GAAG,CAACmJ,UAAU,EAAEzH,OAAO,CAAC;QAC3F,IAAI9D,KAAK,CAAC9C,IAAI,IAAI,MAAM,EAAE;UACtBkS,eAAe,CAAC3hB,EAAE,CAAC;UACnB,OAAO,KAAK;QAChB,CAAC,MACI,IAAIuS,KAAK,CAAC9C,IAAI,IAAI,SAAS,EAAE;UAC9B,IAAI8C,KAAK,CAACoM,iBAAiB,EACvBhK,GAAG,CAACgK,iBAAiB,GAAG,IAAI;UAChC,OAAO,IAAI;QACf,CAAC,MACI,IAAIpM,KAAK,CAAC9C,IAAI,IAAI,OAAO,EAAE;UAC5BkS,eAAe,CAAC3hB,EAAE,CAAC;UACnB,OAAO,IAAI;QACf;QACA2U,GAAG,CAACgK,iBAAiB,GAAG,KAAK;QAC7BhK,GAAG,CAACmJ,UAAU,CAACmE,SAAS,CAACrnB,MAAM,GAAG,CAAC;QACnCqoB,WAAW,GAAG,aAAa,CAACjoB,IAAI,CAACmb,IAAI,CAAC;QACtC,IAAI8M,WAAW,CAAC,CAAC,CAAC,IAAIA,WAAW,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;UACzCtO,GAAG,CAACmJ,UAAU,CAACsF,eAAe,CAACH,WAAW,CAAC,CAAC,CAAC,CAAC;QAClD;QACA,OAAO1Q,KAAK,CAACpW,OAAO;MACxB;MACA,IAAIA,OAAO;MACX,IAAIwY,GAAG,CAAC6E,UAAU,EAAE;QAChBrd,OAAO,GAAG6lB,mBAAmB,CAAC,CAAC;MACnC,CAAC,MACI;QACD7lB,OAAO,GAAG6mB,sBAAsB,CAAC,CAAC;MACtC;MACA,IAAI7mB,OAAO,KAAK,KAAK,EAAE;QACnB,OAAO,CAACwY,GAAG,CAAC6E,UAAU,IAAIzY,GAAG,CAACnG,MAAM,KAAK,CAAC,GAAG,YAAY;UAAE,OAAO,IAAI;QAAE,CAAC,GAAGkQ,SAAS;MACzF,CAAC,MACI,IAAI3O,OAAO,KAAK,IAAI,EAAE;QACvB,OAAO,YAAY;UAAE,OAAO,IAAI;QAAE,CAAC;MACvC,CAAC,MACI;QACD,OAAO,YAAY;UACf,IAAI,CAACA,OAAO,CAACkb,QAAQ,IAAIlb,OAAO,CAAC8a,MAAM,KAAKjX,EAAE,CAAC9F,SAAS,CAAC,UAAU,CAAC,EAChE,OAAO,CAAC;UACZ,OAAO8F,EAAE,CAAC8D,SAAS,CAAC,YAAY;YAC5B9D,EAAE,CAACkD,KAAK,CAACmgB,OAAO,GAAG,IAAI;YACvB,IAAI;cACA,IAAIlnB,OAAO,CAACsT,IAAI,IAAI,UAAU,EAAE;gBAC5B6T,UAAU,CAACtjB,EAAE,EAAE7D,OAAO,CAACia,MAAM,EAAEja,OAAO,CAAC;cAC3C,CAAC,MACI;gBACDimB,iBAAiB,CAACmB,cAAc,CAACvjB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;cACtD;YACJ,CAAC,CACD,OAAOD,CAAC,EAAE;cACN8D,EAAE,CAACX,KAAK,CAACsV,GAAG,GAAG7J,SAAS;cACxBqO,iBAAiB,CAACnZ,EAAE,CAAC;cACrB,IAAI,CAACyf,MAAM,CAACM,oBAAoB,EAAE;gBAC9BxhB,OAAO,CAAC,KAAK,CAAC,CAACrC,CAAC,CAAC;cACrB;cACA,MAAMA,CAAC;YACX;YACA,OAAO,IAAI;UACf,CAAC,CAAC;QACN,CAAC;MACL;IACJ,CAAC;IACDsnB,QAAQ,EAAE,SAAAA,CAAUxjB,EAAE,EAAEyjB,KAAK,EAAE;MAC3BrD,mBAAmB,CAACmD,cAAc,CAACvjB,EAAE,EAAEyjB,KAAK,CAAC;IACjD,CAAC;IACDC,YAAY,EAAEA,YAAY;IAC1BC,YAAY,EAAEA,YAAY;IAC1BC,cAAc,EAAEA,cAAc;IAC9BC,UAAU,EAAEA,UAAU;IACtBjD,WAAW,EAAEA,WAAW;IACxBkD,cAAc,EAAEA,cAAc;IAC9BhC,cAAc,EAAEA,cAAc;IAC9BC,cAAc,EAAEA;EACpB,CAAC;EACD,IAAIgC,aAAa,GAAG,EAAE;EACtB,IAAIzD,OAAO,GAAG,KAAK;EACnB,IAAI0D,aAAa;EACjB,SAASC,eAAeA,CAACljB,GAAG,EAAE;IAC1B,IAAIA,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;MACf,IAAImjB,QAAQ,GAAGnjB,GAAG,CAACO,WAAW,CAAC,CAAC,CAAC1F,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC7C,IAAIuoB,KAAK,GAAGD,QAAQ,CAACE,KAAK,CAAC,GAAG,CAAC;MAC/BF,QAAQ,GAAGC,KAAK,CAACpB,GAAG,CAAC,CAAC,IAAI,EAAE;MAC5B,IAAImB,QAAQ,IAAI,IAAI,EAChBnjB,GAAG,GAAG,GAAG,CAAC,KACT,IAAImjB,QAAQ,IAAI,OAAO,EACxBnjB,GAAG,GAAG,GAAG,CAAC,KACT,IAAImjB,QAAQ,IAAI,IAAI,EACrBnjB,GAAG,GAAG,IAAI,CAAC,KACV,IAAIsjB,aAAa,CAACH,QAAQ,CAAC,EAAE;QAC9B,IAAI5mB,KAAK,GAAG0mB,aAAa,CAAC1mB,KAAK;QAC/B,IAAIsB,KAAK,GAAG;UACRmC,GAAG,EAAEsjB,aAAa,CAACH,QAAQ,CAAC;UAC5BI,MAAM,EAAE;YACJhnB,KAAK,EAAEA,KAAK;YACZinB,YAAY,EAAEjnB,KAAK,CAAC1C,MAAM;YAC1B4pB,cAAc,EAAElnB,KAAK,CAAC1C;UAC1B;QACJ,CAAC;QACD,IAAIopB,aAAa,CAAC1O,SAAS,EAAE;UACzB0O,aAAa,CAAC1O,SAAS,CAAC1W,KAAK,EAAEolB,aAAa,CAAC1mB,KAAK,EAAEwS,KAAK,CAAC;QAC9D;QACA,IAAIkU,aAAa,IAAIA,aAAa,CAAC3O,OAAO,EAAE;UACxC2O,aAAa,CAAC3O,OAAO,CAACzW,KAAK,EAAEolB,aAAa,CAAC1mB,KAAK,EAAEwS,KAAK,CAAC;QAC5D;QACA;MACJ;IACJ;IACA,IAAI/O,GAAG,IAAI,IAAI,EAAE;MACb,IAAI0jB,MAAM,GAAGT,aAAa;MAC1BA,aAAa,GAAG,IAAI;MACpBS,MAAM,CAAC/P,OAAO,IAAI+P,MAAM,CAAC/P,OAAO,CAAC+P,MAAM,CAACnnB,KAAK,CAAC;IAClD,CAAC,MACI;MACD0mB,aAAa,CAAC1mB,KAAK,GAAG,CAAC0mB,aAAa,CAAC1mB,KAAK,IAAI,EAAE,IAAIyD,GAAG;IAC3D;IACA,SAAS+O,KAAKA,CAACxS,KAAK,EAAE;MAClB,IAAI,OAAOA,KAAK,IAAI,QAAQ,EAAE;QAC1B0mB,aAAa,CAAC1mB,KAAK,GAAGA,KAAK;MAC/B,CAAC,MACI;QACD0mB,aAAa,GAAG,IAAI;MACxB;IACJ;EACJ;EACA,SAASV,UAAUA,CAACtjB,EAAE,EAAEmW,IAAI,EAAEuO,OAAO,EAAE;IACnC,IAAIC,aAAa,GAAGrE,OAAO;IAC3B,IAAIoE,OAAO,EAAE;MACT,IAAIX,aAAa,CAAClR,OAAO,CAAC6R,OAAO,CAAC,IAAI,CAAC,CAAC,EACpC;MACJX,aAAa,CAAClhB,IAAI,CAAC6hB,OAAO,CAAC;MAC3BpE,OAAO,GAAGoE,OAAO,CAACpE,OAAO,IAAI,KAAK;IACtC;IACA,IAAI;MACA,IAAI3L,GAAG,GAAGwE,iBAAiB,CAACnZ,EAAE,CAAC;MAC/B,IAAI4kB,KAAK,GAAG,uBAAuB;MACnC,IAAIrS,KAAK;MACT,OAAQA,KAAK,GAAGqS,KAAK,CAAC5pB,IAAI,CAACmb,IAAI,CAAC,EAAG;QAC/B,IAAIpV,GAAG,GAAGwR,KAAK,CAAC,CAAC,CAAC;QAClB,IAAIsS,SAAS,GAAGlQ,GAAG,CAAC6E,UAAU;QAC9B,IAAIwK,aAAa,EAAE;UACfC,eAAe,CAACljB,GAAG,CAAC;UACpB;QACJ;QACA,IAAIa,MAAM,GAAG6d,MAAM,CAAC8B,SAAS,CAACvhB,EAAE,EAAEe,GAAG,EAAE,SAAS,CAAC;QACjD,IAAI,CAACa,MAAM,IAAIijB,SAAS,IAAIlQ,GAAG,CAAC6E,UAAU,EAAE;UACxC,IAAIzY,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;YACf,IAAImjB,QAAQ,GAAGnjB,GAAG,CAACO,WAAW,CAAC,CAAC,CAAC1F,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC7C,IAAIuoB,KAAK,GAAGD,QAAQ,CAACE,KAAK,CAAC,GAAG,CAAC;YAC/BF,QAAQ,GAAGC,KAAK,CAACpB,GAAG,CAAC,CAAC,IAAI,EAAE;YAC5B,IAAImB,QAAQ,IAAI,IAAI,EAChBnjB,GAAG,GAAG,GAAG,CAAC,KACT,IAAImjB,QAAQ,IAAI,OAAO,EACxBnjB,GAAG,GAAG,GAAG,CAAC,KACT,IAAImjB,QAAQ,IAAI,IAAI,EACrBnjB,GAAG,GAAG,IAAI,CAAC,KACV,IAAIsjB,aAAa,CAACjT,cAAc,CAAC8S,QAAQ,CAAC,EAAE;cAC7CnjB,GAAG,GAAGsjB,aAAa,CAACH,QAAQ,CAAC;cAC7BY,SAAS,CAAC9kB,EAAE,EAAEe,GAAG,CAAC;cAClB;YACJ,CAAC,MACI;cACDA,GAAG,GAAGA,GAAG,CAAC,CAAC,CAAC;cACZ6jB,KAAK,CAACviB,SAAS,GAAGkQ,KAAK,CAACvW,KAAK,GAAG,CAAC;YACrC;UACJ;UACAgE,EAAE,CAAC4M,gBAAgB,CAAC7L,GAAG,CAAC;QAC5B;MACJ;IACJ,CAAC,SACO;MACJgjB,aAAa,CAAChB,GAAG,CAAC,CAAC;MACnBzC,OAAO,GAAGyD,aAAa,CAACnpB,MAAM,GAAG+pB,aAAa,GAAG,KAAK;MACtD,IAAI,CAACZ,aAAa,CAACnpB,MAAM,IAAIopB,aAAa,EAAE;QACxC,IAAIe,aAAa,GAAGf,aAAa;QACjCA,aAAa,GAAG,IAAI;QACpBgB,UAAU,CAAChlB,EAAE,EAAE+kB,aAAa,CAAC;MACjC;IACJ;EACJ;EACA,IAAIE,UAAU,GAAG;IACbC,MAAM,EAAE,IAAI;IAAEC,SAAS,EAAE,IAAI;IAAE,QAAQ,EAAE,KAAK;IAAEC,MAAM,EAAE,KAAK;IAAEC,MAAM,EAAE,KAAK;IAC5EC,SAAS,EAAE,MAAM;IAAEC,UAAU,EAAE,OAAO;IAAEC,OAAO,EAAE,IAAI;IAAEC,SAAS,EAAE,MAAM;IACxEC,KAAK,EAAE,IAAI;IAAE,GAAG,EAAE;EACtB,CAAC;EACD,IAAIC,WAAW,GAAG;IAAEC,KAAK,EAAE,CAAC;IAAEC,GAAG,EAAE,CAAC;IAAEC,OAAO,EAAE,CAAC;IAAEC,OAAO,EAAE,CAAC;IACxDC,QAAQ,EAAE,CAAC;IAAEC,QAAQ,EAAE,CAAC;IAAEC,IAAI,EAAE,CAAC;IAAEC,YAAY,EAAE;EAAE,CAAC;EACxD,IAAI9B,aAAa,GAAG,CAAC,CAAC;EACtB,6BAA6B,CAACD,KAAK,CAAC,GAAG,CAAC,CAACgC,MAAM,CAACC,MAAM,CAAClQ,IAAI,CAAC8O,UAAU,CAAC,CAAC,CAACqB,OAAO,CAAC,UAAUroB,CAAC,EAAE;IAC1FomB,aAAa,CAAC,CAACY,UAAU,CAAChnB,CAAC,CAAC,IAAI,EAAE,EAAEqD,WAAW,CAAC,CAAC,CAAC,GAC5C+iB,aAAa,CAACpmB,CAAC,CAACqD,WAAW,CAAC,CAAC,CAAC,GAAGrD,CAAC;EAC5C,CAAC,CAAC;EACF,SAASgjB,eAAeA,CAAC/kB,CAAC,EAAEyY,GAAG,EAAE;IAC7B,IAAI5T,GAAG,GAAG7E,CAAC,CAAC6E,GAAG;IACf,IAAI4kB,WAAW,CAAC5kB,GAAG,CAAC,EAChB;IACJ,IAAIA,GAAG,CAACnG,MAAM,GAAG,CAAC,IAAImG,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;MACjCA,GAAG,GAAGA,GAAG,CAAC9F,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IACnC;IACA8F,GAAG,GAAGkkB,UAAU,CAAClkB,GAAG,CAAC,IAAIA,GAAG;IAC5B,IAAI3E,IAAI,GAAG,EAAE;IACb,IAAIF,CAAC,CAACqqB,OAAO,EAAE;MACXnqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAIF,CAAC,CAACsqB,MAAM,EAAE;MACVpqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAIF,CAAC,CAACuqB,OAAO,EAAE;MACXrqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAIgD,UAAU,CAACsnB,KAAK,IAAIxqB,CAAC,CAACsqB,MAAM,IAAI,CAACtqB,CAAC,CAACuqB,OAAO,IAAI,CAACvqB,CAAC,CAACqqB,OAAO,EAAE;MAC1DnqB,IAAI,GAAGA,IAAI,CAACR,KAAK,CAAC,CAAC,CAAC;IACxB;IACA,IAAI,CAACQ,IAAI,IAAI2E,GAAG,CAACnG,MAAM,GAAG,CAAC,KAAKsB,CAAC,CAACyqB,QAAQ,EAAE;MACxCvqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAIuY,GAAG,IAAI,CAACA,GAAG,CAACgK,iBAAiB,IAAI5d,GAAG,CAACnG,MAAM,IAAI,CAAC,EAAE;MAClD,IAAIme,OAAO,CAAC6N,MAAM,IAAI7lB,GAAG,IAAIgY,OAAO,CAAC6N,MAAM,EAAE;QACzC,IAAI7N,OAAO,CAAC8N,SAAS,IAAI,KAAK,IAAI,CAACzqB,IAAI,EACnC2E,GAAG,GAAGgY,OAAO,CAAC6N,MAAM,CAAC7lB,GAAG,CAAC;MACjC,CAAC,MACI,IAAIA,GAAG,CAACkV,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE;QAC9B,IAAI6Q,IAAI,GAAG5qB,CAAC,CAAC4qB,IAAI,IAAI5qB,CAAC,CAAC4qB,IAAI,CAAClrB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;QAC3C,IAAI,CAACM,CAAC,CAACyqB,QAAQ,EACXG,IAAI,GAAGA,IAAI,CAACxlB,WAAW,CAAC,CAAC;QAC7B,IAAIwlB,IAAI,EACJ/lB,GAAG,GAAG+lB,IAAI;MAClB;IACJ;IACA1qB,IAAI,IAAI2E,GAAG;IACX,IAAI3E,IAAI,CAACxB,MAAM,GAAG,CAAC,EAAE;MACjBwB,IAAI,GAAG,GAAG,GAAGA,IAAI,GAAG,GAAG;IAC3B;IACA,OAAOA,IAAI;EACf;EACA;EACA,SAAS4kB,aAAaA,CAAC+F,aAAa,EAAEF,SAAS,EAAE;IAC7C,IAAI9N,OAAO,CAACjH,MAAM,KAAKiV,aAAa,EAAE;MAClChO,OAAO,GAAGC,YAAY,CAAC+N,aAAa,CAAC;IACzC;IACAhO,OAAO,CAAC8N,SAAS,GAAGA,SAAS;EACjC;EACA,SAAS7N,YAAYA,CAAC+N,aAAa,EAAE;IACjC,IAAIH,MAAM,GAAG,CAAC,CAAC;IACf,IAAI,CAACG,aAAa,EACd,OAAO;MAAEH,MAAM,EAAEA,MAAM;MAAE9U,MAAM,EAAE;IAAG,CAAC;IACzC,SAASkV,UAAUA,CAACC,IAAI,EAAE;MACtB,OAAOA,IAAI,CAAC7C,KAAK,CAAC,QAAQ,CAAC,CAAC8C,MAAM,CAACC,OAAO,CAAC;IAC/C;IACAJ,aAAa,CAAC3C,KAAK,CAAC,oBAAoB,CAAC,CAACpmB,GAAG,CAAC,UAAUopB,IAAI,EAAE;MAC1D,IAAI,CAACA,IAAI,EACL;MACJ,IAAIC,SAAS,GAAGD,IAAI,CAAChD,KAAK,CAAC,oBAAoB,CAAC;MAChD,IAAIiD,SAAS,CAACzsB,MAAM,IAAI,CAAC,EAAE;QACvB,IAAI+Q,IAAI,GAAGqb,UAAU,CAACK,SAAS,CAAC,CAAC,CAAC,CAAC;QACnC,IAAIzb,EAAE,GAAGob,UAAU,CAACK,SAAS,CAAC,CAAC,CAAC,CAAC;QACjC,IAAI1b,IAAI,CAAC/Q,MAAM,KAAKgR,EAAE,CAAChR,MAAM,EACzB,OAAO,CAAC;QACZ,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuN,IAAI,CAAC/Q,MAAM,EAAE,EAAEwD,CAAC,EAChCwoB,MAAM,CAACjb,IAAI,CAACvN,CAAC,CAAC,CAAC,GAAGwN,EAAE,CAACxN,CAAC,CAAC;MAC/B,CAAC,MACI,IAAIipB,SAAS,CAACzsB,MAAM,IAAI,CAAC,EAAE;QAC5B,IAAI0sB,KAAK,GAAGN,UAAU,CAACI,IAAI,CAAC;QAC5B,IAAIE,KAAK,CAAC1sB,MAAM,GAAG,CAAC,KAAK,CAAC,EACtB,OAAO,CAAC;QACZ,KAAK,IAAIwD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkpB,KAAK,CAAC1sB,MAAM,EAAEwD,CAAC,IAAI,CAAC,EACpCwoB,MAAM,CAACU,KAAK,CAAClpB,CAAC,CAAC,CAAC,GAAGkpB,KAAK,CAAClpB,CAAC,GAAG,CAAC,CAAC;MACvC;IACJ,CAAC,CAAC;IACF,OAAO;MAAEwoB,MAAM,EAAEA,MAAM;MAAE9U,MAAM,EAAEiV;IAAc,CAAC;EACpD;EACAlnB,YAAY,CAAC,SAAS,EAAEiL,SAAS,EAAE,QAAQ,EAAE,CAAC,MAAM,CAAC,EAAE,UAAU1O,IAAI,EAAE4D,EAAE,EAAE;IACvE,IAAI5D,IAAI,KAAK0O,SAAS,EAAE;MACpB,OAAOiO,OAAO,CAACjH,MAAM;IACzB,CAAC,MACI;MACDkP,aAAa,CAAC5kB,IAAI,CAAC;IACvB;EACJ,CAAC,CAAC;EACF,SAAS2hB,UAAUA,CAAA,EAAG;IAClB,IAAI,CAACwJ,YAAY,GAAG,EAAE;IACtB,IAAI,CAACC,YAAY,GAAG,EAAE;IACtB,IAAI,CAACnQ,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAAChB,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAAC0L,SAAS,GAAG,EAAE,CAAC,CAAC;IACrB,IAAI,CAAC1E,YAAY,GAAG,IAAI,CAAC,CAAC;IAC1B,IAAI,CAAC+E,WAAW,GAAG,IAAI,CAAC,CAAC;EAC7B;EACAvE,UAAU,CAAC/gB,SAAS,CAAComB,eAAe,GAAG,UAAUrQ,CAAC,EAAE;IAChD,IAAI,CAAC,IAAI,CAACsE,QAAQ,EAAE;MAChB,IAAI,CAACkQ,YAAY,GAAG,IAAI,CAACA,YAAY,CAACnB,MAAM,CAACrT,CAAC,CAAC;IACnD,CAAC,MACI;MACD,IAAI,CAACyU,YAAY,GAAG,IAAI,CAACA,YAAY,CAACpB,MAAM,CAACrT,CAAC,CAAC;IACnD;EACJ,CAAC;EACDgL,UAAU,CAAC/gB,SAAS,CAACyqB,SAAS,GAAG,YAAY;IACzC,IAAIC,MAAM,GAAG,CAAC;IACd,IAAI,IAAI,CAACH,YAAY,CAAC3sB,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC4sB,YAAY,CAAC5sB,MAAM,GAAG,CAAC,EAAE;MAC9D8sB,MAAM,GAAG,CAAC;MACV,IAAI,IAAI,CAACH,YAAY,CAAC3sB,MAAM,GAAG,CAAC,EAAE;QAC9B8sB,MAAM,IAAIC,QAAQ,CAAC,IAAI,CAACJ,YAAY,CAACrF,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;MACtD;MACA,IAAI,IAAI,CAACsF,YAAY,CAAC5sB,MAAM,GAAG,CAAC,EAAE;QAC9B8sB,MAAM,IAAIC,QAAQ,CAAC,IAAI,CAACH,YAAY,CAACtF,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;MACtD;IACJ;IACA,OAAOwF,MAAM;EACjB,CAAC;EACD,SAAS/F,eAAeA,CAAC3hB,EAAE,EAAE4nB,MAAM,EAAE;IACjC5nB,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACmJ,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;IAC1C/d,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACgK,iBAAiB,GAAG,KAAK;IACtCvf,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,kBAAkB,EAAE4nB,MAAM,CAAC;EACrD;EACA,SAASlF,WAAWA,CAAA,EAAG;IACnB,IAAI,CAACD,OAAO,GAAG,EAAE;IACjB,IAAI,CAACE,QAAQ,GAAG,EAAE;EACtB;EACA,SAASkF,QAAQA,CAAC9kB,IAAI,EAAEyT,QAAQ,EAAEuB,SAAS,EAAE;IACzC,IAAI,CAACtQ,KAAK,CAAC,CAAC;IACZ,IAAI,CAACwa,SAAS,GAAG,CAAClf,IAAI,IAAI,EAAE,CAAC;IAC7B,IAAI,CAAC+kB,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACvR,QAAQ,GAAG,CAAC,CAACA,QAAQ;IAC1B,IAAI,CAACuB,SAAS,GAAG,CAAC,CAACA,SAAS;EAChC;EACA8P,QAAQ,CAAC7qB,SAAS,GAAG;IACjBgrB,OAAO,EAAE,SAAAA,CAAUjlB,IAAI,EAAEyT,QAAQ,EAAEuB,SAAS,EAAE;MAC1C,IAAI,CAACkK,SAAS,GAAG,CAAClf,IAAI,IAAI,EAAE,CAAC;MAC7B,IAAI,CAACyT,QAAQ,GAAG,CAAC,CAACA,QAAQ;MAC1B,IAAI,CAACuB,SAAS,GAAG,CAAC,CAACA,SAAS;IAChC,CAAC;IACDkQ,QAAQ,EAAE,SAAAA,CAAUllB,IAAI,EAAEyT,QAAQ,EAAE;MAChC,IAAIA,QAAQ,EAAE;QACV,IAAI,CAAC,IAAI,CAACA,QAAQ,EAAE;UAChB,IAAI,CAACyL,SAAS,CAACpf,IAAI,CAAC,IAAI,CAAC;QAC7B;QACA,IAAI,CAAC2T,QAAQ,GAAG,IAAI;MACxB;MACA,IAAI,CAACyL,SAAS,CAACpf,IAAI,CAACE,IAAI,CAAC;IAC7B,CAAC;IACDmlB,qBAAqB,EAAE,SAAAA,CAAUxL,OAAO,EAAE;MACtC,IAAI,CAACoL,iBAAiB,CAACjlB,IAAI,CAAC2Z,uBAAuB,CAACE,OAAO,CAAC,CAAC;IACjE,CAAC;IACDyL,eAAe,EAAE,SAAAA,CAAU9d,KAAK,EAAE;MAC9B,IAAI,CAAC0d,aAAa,CAACllB,IAAI,CAACwH,KAAK,CAAC;IAClC,CAAC;IACD5C,KAAK,EAAE,SAAAA,CAAA,EAAY;MACf,IAAI,CAACwa,SAAS,GAAG,EAAE;MACnB,IAAI,CAAC6F,iBAAiB,GAAG,EAAE;MAC3B,IAAI,CAACC,aAAa,GAAG,EAAE;MACvB,IAAI,CAACvR,QAAQ,GAAG,KAAK;IACzB,CAAC;IACD4R,QAAQ,EAAE,SAAAA,CAAA,EAAY;MAClB,OAAO,IAAI,CAACnG,SAAS,CAACC,IAAI,CAAC,EAAE,CAAC;IAClC;EACJ,CAAC;EACD,SAAS4B,cAAcA,CAAC1nB,IAAI,EAAEohB,QAAQ,EAAE;IACpC,IAAI6K,SAAS,GAAGhL,cAAc,CAACI,kBAAkB,CAAC4K,SAAS;IAC3D,IAAI,CAACjsB,IAAI,IAAIA,IAAI,CAACxB,MAAM,IAAI,CAAC,EAAE;MAC3B,MAAMmgB,KAAK,CAAC,mCAAmC,CAAC;IACpD;IACAsN,SAAS,CAACjsB,IAAI,CAAC,GAAGohB,QAAQ;IAC1BxD,cAAc,CAACnX,IAAI,CAACzG,IAAI,CAAC;EAC7B;EACA,SAAS+iB,kBAAkBA,CAACkJ,SAAS,EAAE;IACnC,IAAI,CAACA,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,eAAe,GAAGD,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC,CAAC;IACtDQ,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC,CAAC;IAC/BQ,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC,CAAC;IAC/BQ,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC,CAAC;IAC/BQ,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC,CAAC;EACnC;EACA1I,kBAAkB,CAACniB,SAAS,GAAG;IAC3BirB,QAAQ,EAAE,SAAAA,CAAU1K,YAAY,EAAElG,QAAQ,EAAEtU,IAAI,EAAEyT,QAAQ,EAAEuB,SAAS,EAAE;MACnE,IAAIwF,YAAY,KAAK,GAAG,EACpB;MACJ,IAAI/G,QAAQ,IAAIzT,IAAI,CAACsP,MAAM,CAACtP,IAAI,CAACnI,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;QACnDmI,IAAI,IAAI,IAAI;MAChB;MACA,IAAIya,QAAQ,GAAG,IAAI,CAAC+K,eAAe,CAAChL,YAAY,CAAC,GAC7C,IAAI,CAACG,WAAW,CAACH,YAAY,CAAC,GAAG,IAAI;MACzC,IAAI,CAACC,QAAQ,EAAE;QACX,QAAQnG,QAAQ;UACZ,KAAK,MAAM;YACP,IAAI,CAACgR,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC9kB,IAAI,EAAEyT,QAAQ,EAAEuB,SAAS,CAAC;YAC7D;UACJ,KAAK,QAAQ;UACb,KAAK,QAAQ;YACT,IAAIhV,IAAI,CAAC8P,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;cAC1B,IAAI,CAACwV,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC9kB,IAAI,EAAEyT,QAAQ,CAAC;YACtD,CAAC,MACI;cACD,IAAI,CAACgS,sBAAsB,CAAC,CAAC;cAC7B,IAAI,CAACH,SAAS,CAAC,GAAG,CAAC,GAAG,IAAIR,QAAQ,CAAC9kB,IAAI,EAAEyT,QAAQ,CAAC;YACtD;YACA;QACR;QACA,IAAI,CAAC8R,eAAe,CAACN,OAAO,CAACjlB,IAAI,EAAEyT,QAAQ,EAAEuB,SAAS,CAAC;QACvD;MACJ;MACA,IAAI0Q,MAAM,GAAGjO,WAAW,CAAC+C,YAAY,CAAC;MACtC,IAAIkL,MAAM,EAAE;QACRjL,QAAQ,CAACyK,QAAQ,CAACllB,IAAI,EAAEyT,QAAQ,CAAC;MACrC,CAAC,MACI;QACDgH,QAAQ,CAACwK,OAAO,CAACjlB,IAAI,EAAEyT,QAAQ,EAAEuB,SAAS,CAAC;MAC/C;MACA,IAAIwF,YAAY,KAAK,GAAG,IAAI,OAAOmL,SAAS,KAAK,WAAW,IACxD,OAAOA,SAAS,CAACC,SAAS,KAAK,WAAW,IAC1C,OAAOD,SAAS,CAACC,SAAS,CAACC,QAAQ,KAAK,UAAU,EAAE;QACpDF,SAAS,CAACC,SAAS,CAACE,SAAS,CAAC9lB,IAAI,CAAC;MACvC;MACA,IAAI,CAACulB,eAAe,CAACN,OAAO,CAACxK,QAAQ,CAAC4K,QAAQ,CAAC,CAAC,EAAE5R,QAAQ,CAAC;IAC/D,CAAC;IACDkH,WAAW,EAAE,SAAAA,CAAUthB,IAAI,EAAE;MACzB,IAAI,CAAC,IAAI,CAACmsB,eAAe,CAACnsB,IAAI,CAAC,EAAE;QAC7B,OAAO,IAAI,CAACksB,eAAe;MAC/B;MACAlsB,IAAI,GAAGA,IAAI,CAACkF,WAAW,CAAC,CAAC;MACzB,IAAI,CAAC,IAAI,CAAC+mB,SAAS,CAACjsB,IAAI,CAAC,EAAE;QACvB,IAAI,CAACisB,SAAS,CAACjsB,IAAI,CAAC,GAAG,IAAIyrB,QAAQ,CAAC,CAAC;MACzC;MACA,OAAO,IAAI,CAACQ,SAAS,CAACjsB,IAAI,CAAC;IAC/B,CAAC;IACDmsB,eAAe,EAAE,SAAAA,CAAUnsB,IAAI,EAAE;MAC7B,OAAOA,IAAI,KAAKue,OAAO,CAACve,IAAI,EAAE4d,cAAc,CAAC,IAAIC,cAAc,CAAC7e,IAAI,CAACgB,IAAI,CAAC,CAAC;IAC/E,CAAC;IACDosB,sBAAsB,EAAE,SAAAA,CAAA,EAAY;MAChC,KAAK,IAAIpqB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACzB,IAAI,CAACiqB,SAAS,CAACjqB,CAAC,CAAC,GAAG,IAAI,CAACsf,WAAW,CAAC,EAAE,IAAItf,CAAC,GAAG,CAAC,CAAC,CAAC;MACtD;IACJ;EACJ,CAAC;EACD,SAASihB,iBAAiBA,CAAA,EAAG;IACzB,IAAI,CAACyJ,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,QAAQ,GAAG,CAAC;IACjB,IAAI,CAACC,aAAa,GAAG,IAAI;EAC7B;EACA3J,iBAAiB,CAACriB,SAAS,GAAG;IAC1BisB,SAAS,EAAE,SAAAA,CAAUxF,KAAK,EAAEyF,EAAE,EAAE;MAC5B,IAAIJ,aAAa,GAAG,IAAI,CAACA,aAAa;MACtC,IAAIlY,GAAG,GAAGsY,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC;MACrB,IAAI,IAAI,CAACF,aAAa,KAAK,IAAI,EAC3B,IAAI,CAACA,aAAa,GAAGvF,KAAK;MAC9B,KAAK,IAAIrlB,CAAC,GAAG,IAAI,CAAC2qB,QAAQ,GAAGnY,GAAG,EAAEsY,EAAE,GAAG9qB,CAAC,IAAI,CAAC,GAAGA,CAAC,GAAG0qB,aAAa,CAACluB,MAAM,EAAEwD,CAAC,IAAIwS,GAAG,EAAE;QAChF,IAAIuY,OAAO,GAAGL,aAAa,CAAC1qB,CAAC,CAAC;QAC9B,KAAK,IAAI0iB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIqI,OAAO,CAACvuB,MAAM,EAAEkmB,CAAC,EAAE,EAAE;UACtC,IAAI,IAAI,CAACkI,aAAa,IAAIG,OAAO,CAACC,SAAS,CAAC,CAAC,EAAEtI,CAAC,CAAC,EAAE;YAC/C,IAAI,CAACiI,QAAQ,GAAG3qB,CAAC;YACjB,OAAO+qB,OAAO;UAClB;QACJ;MACJ;MACA,IAAI/qB,CAAC,IAAI0qB,aAAa,CAACluB,MAAM,EAAE;QAC3B,IAAI,CAACmuB,QAAQ,GAAGD,aAAa,CAACluB,MAAM;QACpC,OAAO,IAAI,CAACouB,aAAa;MAC7B;MACA,IAAI5qB,CAAC,GAAG,CAAC,EACL,OAAOqlB,KAAK;IACpB,CAAC;IACD4F,SAAS,EAAE,SAAAA,CAAU5F,KAAK,EAAE;MACxB,IAAIznB,KAAK,GAAG,IAAI,CAAC8sB,aAAa,CAACjW,OAAO,CAAC4Q,KAAK,CAAC;MAC7C,IAAIznB,KAAK,GAAG,CAAC,CAAC,EACV,IAAI,CAAC8sB,aAAa,CAACriB,MAAM,CAACzK,KAAK,EAAE,CAAC,CAAC;MACvC,IAAIynB,KAAK,CAAC7oB,MAAM,EACZ,IAAI,CAACkuB,aAAa,CAACjmB,IAAI,CAAC4gB,KAAK,CAAC;IACtC,CAAC;IACD6F,KAAK,EAAE,SAAAA,CAAA,EAAY;MACf,IAAI,CAACN,aAAa,GAAG,IAAI;MACzB,IAAI,CAACD,QAAQ,GAAG,IAAI,CAACD,aAAa,CAACluB,MAAM;IAC7C;EACJ,CAAC;EACD,IAAIwnB,iBAAiB,GAAG;IACpBC,YAAY,EAAE,SAAAA,CAAUlM,IAAI,EAAE3V,MAAM,EAAEsd,UAAU,EAAEzH,OAAO,EAAE;MACvD,IAAIkT,OAAO,GAAGC,cAAc,CAACrT,IAAI,EAAE3V,MAAM,EAAE6V,OAAO,EAAEyH,UAAU,CAAC;MAC/D,IAAI,CAACyL,OAAO,CAACE,IAAI,IAAI,CAACF,OAAO,CAACG,OAAO,EAAE;QACnC,OAAO;UAAEja,IAAI,EAAE;QAAO,CAAC;MAC3B,CAAC,MACI,IAAI,CAAC8Z,OAAO,CAACE,IAAI,IAAIF,OAAO,CAACG,OAAO,EAAE;QACvC,OAAO;UACHja,IAAI,EAAE,SAAS;UACfkP,iBAAiB,EAAE4K,OAAO,CAACG,OAAO,CAAC9uB,MAAM,IAAI,CAAC,IAAI2uB,OAAO,CAACG,OAAO,CAAC,CAAC,CAAC,CAACvT,IAAI,CAACva,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,aAAa,CAAC;QAC1G,CAAC;MACL;MACA,IAAI+tB,SAAS;MACb,KAAK,IAAIvrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmrB,OAAO,CAACE,IAAI,CAAC7uB,MAAM,EAAEwD,CAAC,EAAE,EAAE;QAC1C,IAAImU,KAAK,GAAGgX,OAAO,CAACE,IAAI,CAACrrB,CAAC,CAAC;QAC3B,IAAI,CAACurB,SAAS,EAAE;UACZA,SAAS,GAAGpX,KAAK;QACrB;MACJ;MACA,IAAIoX,SAAS,CAACxT,IAAI,CAACva,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,aAAa,IAAI+tB,SAAS,CAACxT,IAAI,CAACva,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,YAAY,EAAE;QACzF,IAAIguB,SAAS,GAAGC,QAAQ,CAAC1T,IAAI,CAAC;QAC9B,IAAI,CAACyT,SAAS,IAAIA,SAAS,CAAChvB,MAAM,GAAG,CAAC,EAClC,OAAO;UAAE6U,IAAI,EAAE;QAAQ,CAAC;QAC5BqO,UAAU,CAACoB,iBAAiB,GAAG0K,SAAS;MAC5C;MACA,OAAO;QAAEna,IAAI,EAAE,MAAM;QAAEtT,OAAO,EAAEwtB;MAAU,CAAC;IAC/C,CAAC;IACDpG,cAAc,EAAE,SAAAA,CAAUvjB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MACxCwY,GAAG,CAACmJ,UAAU,CAACgM,cAAc,GAAG3tB,OAAO,CAAC2tB,cAAc;MACtD,QAAQ3tB,OAAO,CAACsT,IAAI;QAChB,KAAK,QAAQ;UACT,IAAI,CAACsa,aAAa,CAAC/pB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;UACpC;QACJ,KAAK,UAAU;UACX,IAAI,CAAC6tB,eAAe,CAAChqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;UACtC;QACJ,KAAK,gBAAgB;UACjB,IAAI,CAAC8tB,qBAAqB,CAACjqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;UAC5C;QACJ,KAAK,QAAQ;UACT,IAAI,CAAC+tB,aAAa,CAAClqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;UACpC;QACJ,KAAK,QAAQ;UACT,IAAI,CAACguB,aAAa,CAACnqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;UACpC;QACJ,KAAK,IAAI;QACT,KAAK,SAAS;UACV,IAAI,CAACiuB,SAAS,CAACpqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;UAChC;QACJ;UACI;MACR;IACJ,CAAC;IACD4tB,aAAa,EAAE,SAAAA,CAAU/pB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MACvCwY,GAAG,CAACmJ,UAAU,CAACxH,MAAM,GAAGna,OAAO,CAACma,MAAM;MACtC3B,GAAG,CAACmJ,UAAU,CAACvH,UAAU,GAAG8T,QAAQ,CAACluB,OAAO,CAACoa,UAAU,CAAC;MACxD,IAAI,CAAC+T,SAAS,CAACtqB,EAAE,EAAE2U,GAAG,CAAC;IAC3B,CAAC;IACDqV,eAAe,EAAE,SAAAA,CAAUhqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MACzC,IAAI2hB,UAAU,GAAGnJ,GAAG,CAACmJ,UAAU;MAC/B,IAAIA,UAAU,CAACzG,QAAQ,EAAE;QACrB,IAAIyG,UAAU,CAACzG,QAAQ,IAAIlb,OAAO,CAACkb,QAAQ,EAAE;UACzCyG,UAAU,CAACxH,MAAM,GAAG,cAAc;UAClCwH,UAAU,CAACvH,UAAU,GAAG;YAAEC,QAAQ,EAAE;UAAK,CAAC;UAC1C,IAAI,CAAC8T,SAAS,CAACtqB,EAAE,EAAE2U,GAAG,CAAC;UACvB;QACJ,CAAC,MACI;UACDgN,eAAe,CAAC3hB,EAAE,CAAC;QACvB;MACJ;MACA8d,UAAU,CAACzG,QAAQ,GAAGlb,OAAO,CAACkb,QAAQ;MACtCyG,UAAU,CAACxG,YAAY,GAAG+S,QAAQ,CAACluB,OAAO,CAACmb,YAAY,CAAC;MACxD,IAAInb,OAAO,CAACga,IAAI,CAACvb,MAAM,GAAG,CAAC,EAAE;QACzBkjB,UAAU,CAACqF,gBAAgB,GAAGhnB,OAAO,CAACga,IAAI;MAC9C;MACA,IAAIha,OAAO,CAAC+b,eAAe,EAAE;QACzBvD,GAAG,CAAC6J,WAAW,GAAG,KAAK;QACvB+L,iBAAiB,CAACvqB,EAAE,CAAC;MACzB;MACA,IAAI2U,GAAG,CAAC4J,UAAU,EAAE;QAChB,IAAI,CAAC+L,SAAS,CAACtqB,EAAE,EAAE2U,GAAG,CAAC;MAC3B;IACJ,CAAC;IACDsV,qBAAqB,EAAE,SAAAA,CAAUjqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MAC/C,IAAIoiB,UAAU,GAAG5J,GAAG,CAAC4J,UAAU;MAC/B,IAAI7G,kBAAkB,GAAG2S,QAAQ,CAACluB,OAAO,CAACub,kBAAkB,CAAC;MAC7D,IAAIA,kBAAkB,EAAE;QACpB,IAAI6G,UAAU,IAAI7G,kBAAkB,CAACC,UAAU,EAAE;UAC7ChD,GAAG,CAACgD,UAAU,GAAG,IAAI;QACzB;MACJ;MACA,IAAI,CAACqS,eAAe,CAAChqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;MACtC,IAAI,CAACoiB,UAAU,EAAE;QACb,IAAI,CAACwL,aAAa,CAAC/pB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;MACxC;IACJ,CAAC;IACD+tB,aAAa,EAAE,SAAAA,CAAUlqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MACvC,IAAI2hB,UAAU,GAAGnJ,GAAG,CAACmJ,UAAU;MAC/B,IAAI4J,MAAM,GAAG5J,UAAU,CAAC2J,SAAS,CAAC,CAAC;MACnC,IAAI+C,gBAAgB,GAAG,CAAC,CAAC9C,MAAM;MAC/B,IAAIxQ,UAAU,GAAGmT,QAAQ,CAACluB,OAAO,CAAC+a,UAAU,CAAC,IAAI,CAAC,CAAC;MACnD,IAAI4G,UAAU,CAACoB,iBAAiB,EAAE;QAC9BhI,UAAU,CAACgI,iBAAiB,GAAGpB,UAAU,CAACoB,iBAAiB;MAC/D;MACA,IAAI/iB,OAAO,CAACkb,QAAQ,EAAE;QAClB,IAAI,CAAC2S,eAAe,CAAChqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;MAC1C;MACA,IAAIA,OAAO,CAACma,MAAM,EAAE;QAChB,IAAI,CAACyT,aAAa,CAAC/pB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,CAAC;MACxC;MACA,IAAIA,OAAO,CAACma,MAAM,IAAIna,OAAO,CAACkb,QAAQ,EAAE;QACpC,IAAI,CAACiT,SAAS,CAACtqB,EAAE,EAAE2U,GAAG,CAAC;MAC3B;MACAuC,UAAU,CAACwQ,MAAM,GAAGA,MAAM,IAAI,CAAC;MAC/BxQ,UAAU,CAACsT,gBAAgB,GAAGA,gBAAgB;MAC9CtT,UAAU,CAACqG,YAAY,GAAGO,UAAU,CAACP,YAAY;MACjDoE,eAAe,CAAC3hB,EAAE,CAAC;MACnB2U,GAAG,CAACyJ,UAAU,GAAG,IAAI;MACrB,IAAIjiB,OAAO,CAAC8a,MAAM,EAAE;QAChB,IAAI,CAACwT,cAAc,CAAC9V,GAAG,EAAEmJ,UAAU,EAAE3hB,OAAO,CAAC;MACjD;MACAud,OAAO,CAACvd,OAAO,CAAC6G,MAAM,CAAC,CAAChD,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,CAAC;IAChD,CAAC;IACDwV,aAAa,EAAE,SAAAA,CAAUnqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MACvC,IAAI,CAAC6D,EAAE,CAACoK,eAAe,EAAE;QACrB;MACJ;MACA,IAAIsM,OAAO,GAAGva,OAAO,CAACoc,UAAU,CAAC7B,OAAO;MACxC,IAAI+B,aAAa,GAAGtc,OAAO,CAACoc,UAAU,CAACE,aAAa;MACpDiS,cAAc,CAAC1qB,EAAE,CAAC,CAAC2qB,WAAW,CAAC,CAACjU,OAAO,CAAC;MACxC,IAAIkU,YAAY,GAAIlU,OAAO,GAAI,GAAG,GAAG,GAAG;MACxC,IAAImU,aAAa,GAAGH,cAAc,CAAC1qB,EAAE,CAAC,CAAC8qB,QAAQ,CAAC,CAAC;MACjD,IAAIC,iBAAiB,GAAG/qB,EAAE,CAAC8O,aAAa,CAAC,CAAC;MAC1C,SAASkc,WAAWA,CAAC3gB,KAAK,EAAEM,UAAU,EAAEsgB,SAAS,EAAE;QAC/C5N,cAAc,CAAC+B,uBAAuB,CAACiK,SAAS,CAAChf,KAAK,CAAC;QACvDgT,cAAc,CAAC+B,uBAAuB,CAACkK,KAAK,CAAC,CAAC;QAC9C,IAAI;UACA4B,iBAAiB,CAAClrB,EAAE,EAAEqK,KAAK,EAAEM,UAAU,EAAEsgB,SAAS,CAAC;QACvD,CAAC,CACD,OAAO/uB,CAAC,EAAE;UACNivB,WAAW,CAACnrB,EAAE,EAAE,iBAAiB,GAAGqK,KAAK,CAAC;UAC1CsX,eAAe,CAAC3hB,EAAE,CAAC;UACnB;QACJ;QACAoiB,iBAAiB,CAAC2H,aAAa,CAAC/pB,EAAE,EAAE2U,GAAG,EAAE;UACrClF,IAAI,EAAE,QAAQ;UACd6G,MAAM,EAAE,UAAU;UAClBC,UAAU,EAAE;YAAEG,OAAO,EAAE,IAAI;YAAED,UAAU,EAAEta,OAAO,CAACoc,UAAU,CAAC9B;UAAW;QAC3E,CAAC,CAAC;MACN;MACA,SAAS2U,aAAaA,CAAC/gB,KAAK,EAAE;QAC1B2gB,WAAW,CAAC3gB,KAAK,EAAE,IAAI,CAAC,mBAAmB,IAAI,CAAC,gBAAgB,CAAC;QACjE,IAAI+S,cAAc,GAAGC,cAAc,CAACD,cAAc;QAClD,IAAIA,cAAc,CAACL,WAAW,EAAE;UAC5BsO,cAAc,CAACjO,cAAc,EAAE/S,KAAK,CAAC;QACzC;MACJ;MACA,SAASihB,aAAaA,CAACpvB,CAAC,EAAEmO,KAAK,EAAEyF,KAAK,EAAE;QACpC,IAAIhP,OAAO,GAAGmgB,eAAe,CAAC/kB,CAAC,CAAC;UAAEgtB,EAAE;UAAE/M,MAAM;QAC5C,IAAIrb,OAAO,IAAI,MAAM,IAAIA,OAAO,IAAI,QAAQ,EAAE;UAC1CooB,EAAE,GAAGpoB,OAAO,IAAI,MAAM,GAAG,IAAI,GAAG,KAAK;UACrCqb,MAAM,GAAGjgB,CAAC,CAACooB,MAAM,GAAGpoB,CAAC,CAACooB,MAAM,CAACC,YAAY,GAAG,CAAC;UAC7Cla,KAAK,GAAGgT,cAAc,CAAC+B,uBAAuB,CAAC6J,SAAS,CAAC5e,KAAK,EAAE6e,EAAE,CAAC,IAAI,EAAE;UACzEpZ,KAAK,CAACzF,KAAK,CAAC;UACZ,IAAI8R,MAAM,IAAIjgB,CAAC,CAACooB,MAAM,EAClBpoB,CAAC,CAACooB,MAAM,CAACC,YAAY,GAAGroB,CAAC,CAACooB,MAAM,CAACE,cAAc,GAAGnqB,IAAI,CAACC,GAAG,CAAC6hB,MAAM,EAAEjgB,CAAC,CAACooB,MAAM,CAAChnB,KAAK,CAAC1C,MAAM,CAAC;QACjG,CAAC,MACI,IAAIkG,OAAO,IAAIA,OAAO,IAAI,QAAQ,IAAIA,OAAO,IAAI,SAAS,EAAE;UAC7Duc,cAAc,CAAC+B,uBAAuB,CAACkK,KAAK,CAAC,CAAC;QAClD;QACA,IAAIiC,WAAW;QACf,IAAI;UACAA,WAAW,GAAGL,iBAAiB,CAAClrB,EAAE,EAAEqK,KAAK,EAAE,IAAI,CAAC,mBAAmB,IAAI,CAAC,gBAAgB,CAAC;QAC7F,CAAC,CACD,OAAOnO,CAAC,EAAE,CACV;QACA,IAAIqvB,WAAW,EAAE;UACbvrB,EAAE,CAACmE,cAAc,CAACgH,QAAQ,CAACnL,EAAE,EAAE,CAAC0W,OAAO,EAAE6U,WAAW,CAAC,EAAE,EAAE,CAAC;QAC9D,CAAC,MACI;UACDC,oBAAoB,CAACxrB,EAAE,CAAC;UACxBA,EAAE,CAAC8L,QAAQ,CAACif,iBAAiB,CAACnhB,IAAI,EAAEmhB,iBAAiB,CAAClhB,GAAG,CAAC;QAC9D;MACJ;MACA,SAAS4hB,eAAeA,CAACvvB,CAAC,EAAEmO,KAAK,EAAEyF,KAAK,EAAE;QACtC,IAAIhP,OAAO,GAAGmgB,eAAe,CAAC/kB,CAAC,CAAC;QAChC,IAAI4E,OAAO,IAAI,OAAO,IAAIA,OAAO,IAAI,OAAO,IAAIA,OAAO,IAAI,OAAO,IAC7DA,OAAO,IAAI,MAAM,IAAIuJ,KAAK,IAAI,EAAG,EAAE;UACpCgT,cAAc,CAAC+B,uBAAuB,CAACiK,SAAS,CAAChf,KAAK,CAAC;UACvDgT,cAAc,CAAC+B,uBAAuB,CAACkK,KAAK,CAAC,CAAC;UAC9C4B,iBAAiB,CAAClrB,EAAE,EAAE6qB,aAAa,CAAC;UACpCW,oBAAoB,CAACxrB,EAAE,CAAC;UACxBA,EAAE,CAAC8L,QAAQ,CAACif,iBAAiB,CAACnhB,IAAI,EAAEmhB,iBAAiB,CAAClhB,GAAG,CAAC;UAC1DzK,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;UACpBylB,eAAe,CAAC3hB,EAAE,CAAC;UACnB8P,KAAK,CAAC,CAAC;UACP9P,EAAE,CAACwQ,KAAK,CAAC,CAAC;QACd,CAAC,MACI,IAAI1P,OAAO,IAAI,MAAM,IAAIA,OAAO,IAAI,QAAQ,EAAE;UAC/C1B,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;QACxB,CAAC,MACI,IAAI4E,OAAO,IAAI,OAAO,EAAE;UACzB1B,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;UACpB4T,KAAK,CAAC,EAAE,CAAC;QACb;MACJ;MACA,QAAQ3T,OAAO,CAACoc,UAAU,CAACC,QAAQ;QAC/B,KAAK,QAAQ;UACT,IAAI4E,cAAc,GAAGC,cAAc,CAACD,cAAc;UAClD,IAAIA,cAAc,CAACN,SAAS,EAAE;YAC1B,IAAIzS,KAAK,GAAG+S,cAAc,CAACJ,mBAAmB,CAAC0O,KAAK,CAAC,CAAC;YACtDV,WAAW,CAAC3gB,KAAK,EAAE,IAAI,CAAC,mBAAmB,KAAK,CAAC,gBAAgB,CAAC;UACtE,CAAC,MACI;YACD2a,UAAU,CAAChlB,EAAE,EAAE;cACX0U,OAAO,EAAE0W,aAAa;cACtBjK,MAAM,EAAEyJ,YAAY;cACpBe,IAAI,EAAE,qBAAqB;cAC3BtW,OAAO,EAAEiW,aAAa;cACtBhW,SAAS,EAAEmW;YACf,CAAC,CAAC;UACN;UACA;QACJ,KAAK,iBAAiB;UAClB,IAAIG,IAAI,GAAGC,qBAAqB,CAAC7rB,EAAE,EAAE;YAAE8rB,QAAQ,EAAE;UAAK,CAAC,CAAC;UACxD,IAAIC,SAAS,GAAG,IAAI;UACpB,IAAI,CAACH,IAAI,EAAE;YACPA,IAAI,GAAGC,qBAAqB,CAAC7rB,EAAE,EAAE;cAAE8rB,QAAQ,EAAE;YAAM,CAAC,CAAC;YACrDC,SAAS,GAAG,KAAK;UACrB;UACA,IAAI,CAACH,IAAI,EAAE;YACPT,WAAW,CAACnrB,EAAE,EAAE,sBAAsB,CAAC;YACvC2hB,eAAe,CAAC3hB,EAAE,CAAC;YACnB;UACJ;UACA,IAAIqK,KAAK,GAAGrK,EAAE,CAACrF,OAAO,CAACixB,IAAI,CAAC1wB,KAAK,CAACR,IAAI,CAAC,CAAC0uB,SAAS,CAACwC,IAAI,CAAC1wB,KAAK,CAACyC,EAAE,EAAEiuB,IAAI,CAACzwB,GAAG,CAACwC,EAAE,CAAC;UAC7E,IAAIouB,SAAS,IAAItT,aAAa,EAAE;YAC5BpO,KAAK,GAAG,KAAK,GAAGA,KAAK,GAAG,KAAK;UACjC,CAAC,MACI;YACDA,KAAK,GAAG2hB,WAAW,CAAC3hB,KAAK,CAAC;UAC9B;UACAgT,cAAc,CAAC2B,QAAQ,CAACzC,YAAY,GAAGvc,EAAE,CAACqF,SAAS,CAAC,CAAC;UACrDrF,EAAE,CAAC+E,SAAS,CAAC6mB,IAAI,CAAC1wB,KAAK,CAAC;UACxB8vB,WAAW,CAAC3gB,KAAK,EAAE,IAAI,CAAC,mBAAmB,KAAK,CAAC,gBAAgB,CAAC;UAClE;MACR;IACJ,CAAC;IACD+f,SAAS,EAAE,SAAAA,CAAUpqB,EAAE,EAAE2U,GAAG,EAAExY,OAAO,EAAE;MACnC,SAASivB,aAAaA,CAAC3H,KAAK,EAAE;QAC1BpG,cAAc,CAACiC,0BAA0B,CAAC+J,SAAS,CAAC5F,KAAK,CAAC;QAC1DpG,cAAc,CAACiC,0BAA0B,CAACgK,KAAK,CAAC,CAAC;QACjDlJ,mBAAmB,CAACmD,cAAc,CAACvjB,EAAE,EAAEyjB,KAAK,CAAC;QAC7C,IAAIzjB,EAAE,CAACX,KAAK,CAACsV,GAAG,EACZgN,eAAe,CAAC3hB,EAAE,CAAC;MAC3B;MACA,SAASyrB,eAAeA,CAACvvB,CAAC,EAAEunB,KAAK,EAAE3T,KAAK,EAAE;QACtC,IAAIhP,OAAO,GAAGmgB,eAAe,CAAC/kB,CAAC,CAAC;UAAEgtB,EAAE;UAAE/M,MAAM;QAC5C,IAAIrb,OAAO,IAAI,OAAO,IAAIA,OAAO,IAAI,OAAO,IAAIA,OAAO,IAAI,OAAO,IAC7DA,OAAO,IAAI,MAAM,IAAI2iB,KAAK,IAAI,EAAG,EAAE;UACpCpG,cAAc,CAACiC,0BAA0B,CAAC+J,SAAS,CAAC5F,KAAK,CAAC;UAC1DpG,cAAc,CAACiC,0BAA0B,CAACgK,KAAK,CAAC,CAAC;UACjDlqB,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;UACpBylB,eAAe,CAAC3hB,EAAE,CAAC;UACnB8P,KAAK,CAAC,CAAC;UACP9P,EAAE,CAACwQ,KAAK,CAAC,CAAC;QACd;QACA,IAAI1P,OAAO,IAAI,MAAM,IAAIA,OAAO,IAAI,QAAQ,EAAE;UAC1C1B,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;UACpBgtB,EAAE,GAAGpoB,OAAO,IAAI,MAAM,GAAG,IAAI,GAAG,KAAK;UACrCqb,MAAM,GAAGjgB,CAAC,CAACooB,MAAM,GAAGpoB,CAAC,CAACooB,MAAM,CAACC,YAAY,GAAG,CAAC;UAC7Cd,KAAK,GAAGpG,cAAc,CAACiC,0BAA0B,CAAC2J,SAAS,CAACxF,KAAK,EAAEyF,EAAE,CAAC,IAAI,EAAE;UAC5EpZ,KAAK,CAAC2T,KAAK,CAAC;UACZ,IAAItH,MAAM,IAAIjgB,CAAC,CAACooB,MAAM,EAClBpoB,CAAC,CAACooB,MAAM,CAACC,YAAY,GAAGroB,CAAC,CAACooB,MAAM,CAACE,cAAc,GAAGnqB,IAAI,CAACC,GAAG,CAAC6hB,MAAM,EAAEjgB,CAAC,CAACooB,MAAM,CAAChnB,KAAK,CAAC1C,MAAM,CAAC;QACjG,CAAC,MACI,IAAIkG,OAAO,IAAI,OAAO,EAAE;UACzB1B,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;UACpB4T,KAAK,CAAC,EAAE,CAAC;QACb,CAAC,MACI,IAAIhP,OAAO,IAAIA,OAAO,IAAI,QAAQ,IAAIA,OAAO,IAAI,SAAS,EAAE;UAC7Duc,cAAc,CAACiC,0BAA0B,CAACgK,KAAK,CAAC,CAAC;QACrD;MACJ;MACA,IAAIntB,OAAO,CAACsT,IAAI,IAAI,SAAS,EAAE;QAC3B2Q,mBAAmB,CAACmD,cAAc,CAACvjB,EAAE,EAAE7D,OAAO,CAAC8vB,MAAM,CAACxI,KAAK,CAAC;MAChE,CAAC,MACI;QACD,IAAI9O,GAAG,CAAC4J,UAAU,EAAE;UAChByG,UAAU,CAAChlB,EAAE,EAAE;YAAE0U,OAAO,EAAE0W,aAAa;YAAEjK,MAAM,EAAE,GAAG;YAAE7jB,KAAK,EAAE,SAAS;YAClEgY,SAAS,EAAEmW,eAAe;YAAEvW,iBAAiB,EAAE;UAAM,CAAC,CAAC;QAC/D,CAAC,MACI;UACD8P,UAAU,CAAChlB,EAAE,EAAE;YAAE0U,OAAO,EAAE0W,aAAa;YAAEjK,MAAM,EAAE,GAAG;YAChD7L,SAAS,EAAEmW;UAAgB,CAAC,CAAC;QACrC;MACJ;IACJ,CAAC;IACDnB,SAAS,EAAE,SAAAA,CAAUtqB,EAAE,EAAE2U,GAAG,EAAE;MAC1B,IAAImJ,UAAU,GAAGnJ,GAAG,CAACmJ,UAAU;MAC/B,IAAIxH,MAAM,GAAGwH,UAAU,CAACxH,MAAM;MAC9B,IAAIC,UAAU,GAAGuH,UAAU,CAACvH,UAAU,IAAI,CAAC,CAAC;MAC5C,IAAIc,QAAQ,GAAGyG,UAAU,CAACzG,QAAQ;MAClC,IAAIC,YAAY,GAAGwG,UAAU,CAACxG,YAAY,IAAI,CAAC,CAAC;MAChD,IAAIiG,YAAY,GAAGO,UAAU,CAACP,YAAY;MAC1C,IAAIjY,GAAG,GAAGqP,GAAG,CAACrP,GAAG;MACjB,IAAI4mB,QAAQ,GAAGC,UAAU,CAACxX,GAAG,CAAC4J,UAAU,GAAG6N,mBAAmB,CAACpsB,EAAE,EAAEsF,GAAG,CAACzH,IAAI,CAAC,GAAGmC,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC,CAAC;MACpG,IAAIgnB,UAAU,GAAGF,UAAU,CAACxX,GAAG,CAAC4J,UAAU,GAAG6N,mBAAmB,CAACpsB,EAAE,EAAEsF,GAAG,CAAC1H,MAAM,CAAC,GAAGoC,EAAE,CAACqF,SAAS,CAAC,QAAQ,CAAC,CAAC;MAC1G,IAAIinB,OAAO,GAAGH,UAAU,CAACD,QAAQ,CAAC;MAClC,IAAIK,SAAS,GAAGJ,UAAU,CAACE,UAAU,CAAC;MACtC,IAAIG,OAAO,EAAEC,SAAS;MACtB,IAAI/E,MAAM;MACV,IAAIrQ,QAAQ,EAAE;QACV,IAAI,CAACoT,cAAc,CAAC9V,GAAG,EAAEmJ,UAAU,CAAC;MACxC;MACA,IAAIA,UAAU,CAACgM,cAAc,KAAKhf,SAAS,EAAE;QACzC4c,MAAM,GAAG5J,UAAU,CAACgM,cAAc;MACtC,CAAC,MACI;QACDpC,MAAM,GAAG5J,UAAU,CAAC2J,SAAS,CAAC,CAAC;MACnC;MACA,IAAIC,MAAM,GAAG,CAAC,IAAInR,UAAU,CAACO,cAAc,EAAE;QACzCP,UAAU,CAACiU,gBAAgB,GAAG,IAAI;MACtC,CAAC,MACI,IAAIjU,UAAU,CAACmW,QAAQ,IACvB,CAACnW,UAAU,CAACO,cAAc,IAAI4Q,MAAM,KAAK,CAAE,EAAE;QAC9CA,MAAM,GAAG,CAAC;QACVnR,UAAU,CAACiU,gBAAgB,GAAG,KAAK;MACvC;MACA,IAAI1M,UAAU,CAACoB,iBAAiB,EAAE;QAC9B3I,UAAU,CAAC2I,iBAAiB,GAAG5H,YAAY,CAAC4H,iBAAiB,GACzDpB,UAAU,CAACoB,iBAAiB;MACpC;MACA3I,UAAU,CAACmR,MAAM,GAAGA,MAAM;MAC1B/F,eAAe,CAAC3hB,EAAE,CAAC;MACnB,IAAIsW,MAAM,EAAE;QACR,IAAIqW,YAAY,GAAGC,OAAO,CAACtW,MAAM,CAAC,CAACtW,EAAE,EAAEksB,QAAQ,EAAE3V,UAAU,EAAE5B,GAAG,EAAEmJ,UAAU,CAAC;QAC7EnJ,GAAG,CAACyJ,UAAU,GAAGwO,OAAO,CAACtW,MAAM,CAAC;QAChC,IAAI,CAACqW,YAAY,EAAE;UACf;QACJ;QACA,IAAIpW,UAAU,CAACE,UAAU,EAAE;UACvB,IAAI,CAACY,QAAQ,IAAIrX,EAAE,CAACzG,GAAG,CAAC2J,KAAK,IAAI,IAAI,EACjClD,EAAE,CAACzG,GAAG,CAAC2J,KAAK,CAAC/G,OAAO,CAACgI,cAAc,GAAG,gBAAgB,CAAC,CAAC;UAC5D,IAAI6a,QAAQ,GAAG3B,cAAc,CAAC2B,QAAQ;UACtC,IAAIzC,YAAY,GAAGyC,QAAQ,CAACzC,YAAY;UACxC,IAAIA,YAAY,EAAE;YACdsQ,kBAAkB,CAAC7sB,EAAE,EAAEuc,YAAY,EAAEoQ,YAAY,CAAC;YAClD,OAAO3N,QAAQ,CAACzC,YAAY;UAChC,CAAC,MACI;YACDsQ,kBAAkB,CAAC7sB,EAAE,EAAEksB,QAAQ,EAAES,YAAY,CAAC;UAClD;QACJ;QACA,IAAIA,YAAY,YAAY7uB,KAAK,EAAE;UAC/B2uB,SAAS,GAAGE,YAAY,CAAC,CAAC,CAAC;UAC3BH,OAAO,GAAGG,YAAY,CAAC,CAAC,CAAC;QAC7B,CAAC,MACI;UACDH,OAAO,GAAGG,YAAY;QAC1B;QACA,IAAI,CAACH,OAAO,EAAE;UACVA,OAAO,GAAGL,UAAU,CAACD,QAAQ,CAAC;QAClC;QACA,IAAIvX,GAAG,CAAC4J,UAAU,EAAE;UAChB,IAAI,EAAE5J,GAAG,CAAC6J,WAAW,IAAIgO,OAAO,CAAC7uB,EAAE,KAAKmvB,QAAQ,CAAC,EAAE;YAC/CN,OAAO,GAAGJ,mBAAmB,CAACpsB,EAAE,EAAEwsB,OAAO,EAAEF,OAAO,CAAC;UACvD;UACA,IAAIG,SAAS,EAAE;YACXA,SAAS,GAAGL,mBAAmB,CAACpsB,EAAE,EAAEysB,SAAS,CAAC;UAClD;UACAA,SAAS,GAAGA,SAAS,IAAIF,SAAS;UAClCjnB,GAAG,CAAC1H,MAAM,GAAG6uB,SAAS;UACtBnnB,GAAG,CAACzH,IAAI,GAAG2uB,OAAO;UAClBjC,iBAAiB,CAACvqB,EAAE,CAAC;UACrB+sB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEqY,cAAc,CAACP,SAAS,EAAED,OAAO,CAAC,GAAGC,SAAS,GACjED,OAAO,CAAC;UACdO,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEqY,cAAc,CAACP,SAAS,EAAED,OAAO,CAAC,GAAGA,OAAO,GAC/DC,SAAS,CAAC;QACpB,CAAC,MACI,IAAI,CAACpV,QAAQ,EAAE;UAChB,IAAIrX,EAAE,CAACzG,GAAG,CAAC2J,KAAK,EACZlD,EAAE,CAACzG,GAAG,CAAC2J,KAAK,CAACmB,eAAe,GAAG,gBAAgB,CAAC,CAAC;UACrDmoB,OAAO,GAAGJ,mBAAmB,CAACpsB,EAAE,EAAEwsB,OAAO,EAAEF,OAAO,CAAC;UACnDtsB,EAAE,CAAC+E,SAAS,CAACynB,OAAO,CAAC9xB,IAAI,EAAE8xB,OAAO,CAAC7uB,EAAE,CAAC;QAC1C;MACJ;MACA,IAAI0Z,QAAQ,EAAE;QACV,IAAIC,YAAY,CAAC2V,OAAO,EAAE;UACtBR,SAAS,GAAGF,SAAS;UACrB,IAAIU,OAAO,GAAG3V,YAAY,CAAC2V,OAAO;UAClC,IAAIC,UAAU,GAAG7yB,IAAI,CAAC8yB,GAAG,CAACF,OAAO,CAACpvB,IAAI,CAACnD,IAAI,GAAGuyB,OAAO,CAACrvB,MAAM,CAAClD,IAAI,CAAC;UAClE,IAAI0yB,QAAQ,GAAG/yB,IAAI,CAAC8yB,GAAG,CAACF,OAAO,CAACpvB,IAAI,CAACF,EAAE,GAAGsvB,OAAO,CAACrvB,MAAM,CAACD,EAAE,CAAC;UAC5D,IAAIsvB,OAAO,CAACtV,UAAU,EAAE;YACpB6U,OAAO,GAAG,IAAI5sB,GAAG,CAAC2sB,SAAS,CAAC7xB,IAAI,GAAGwyB,UAAU,EAAEX,SAAS,CAAC5uB,EAAE,CAAC;UAChE,CAAC,MACI,IAAIsvB,OAAO,CAACzO,WAAW,EAAE;YAC1BgO,OAAO,GAAG,IAAI5sB,GAAG,CAAC2sB,SAAS,CAAC7xB,IAAI,GAAGwyB,UAAU,EAAEX,SAAS,CAAC5uB,EAAE,GAAGyvB,QAAQ,CAAC;UAC3E,CAAC,MACI,IAAIH,OAAO,CAACpvB,IAAI,CAACnD,IAAI,IAAIuyB,OAAO,CAACrvB,MAAM,CAAClD,IAAI,EAAE;YAC/C8xB,OAAO,GAAG,IAAI5sB,GAAG,CAAC2sB,SAAS,CAAC7xB,IAAI,EAAE6xB,SAAS,CAAC5uB,EAAE,GAAGyvB,QAAQ,CAAC;UAC9D,CAAC,MACI;YACDZ,OAAO,GAAG,IAAI5sB,GAAG,CAAC2sB,SAAS,CAAC7xB,IAAI,GAAGwyB,UAAU,EAAEX,SAAS,CAAC5uB,EAAE,CAAC;UAChE;UACAgX,GAAG,CAAC4J,UAAU,GAAG,IAAI;UACrB5J,GAAG,CAACgD,UAAU,GAAGsV,OAAO,CAACtV,UAAU;UACnChD,GAAG,CAAC6J,WAAW,GAAGyO,OAAO,CAACzO,WAAW;UACrClZ,GAAG,GAAGqP,GAAG,CAACrP,GAAG,GAAG;YACZ1H,MAAM,EAAE6uB,SAAS;YACjB5uB,IAAI,EAAE2uB;UACV,CAAC;UACDjC,iBAAiB,CAACvqB,EAAE,CAAC;QACzB,CAAC,MACI,IAAI2U,GAAG,CAAC4J,UAAU,EAAE;UACrBjH,YAAY,CAAC2V,OAAO,GAAG;YACnBrvB,MAAM,EAAEuuB,UAAU,CAAC7mB,GAAG,CAAC1H,MAAM,CAAC;YAC9BC,IAAI,EAAEsuB,UAAU,CAAC7mB,GAAG,CAACzH,IAAI,CAAC;YAC1B2gB,WAAW,EAAE7J,GAAG,CAAC6J,WAAW;YAC5B7G,UAAU,EAAEhD,GAAG,CAACgD;UACpB,CAAC;QACL;QACA,IAAI7B,QAAQ,EAAEC,MAAM,EAAES,QAAQ,EAAE9M,IAAI;QACpC,IAAI2jB,KAAK;QACT,IAAI1Y,GAAG,CAAC4J,UAAU,EAAE;UAChBzI,QAAQ,GAAG8M,SAAS,CAACtd,GAAG,CAACzH,IAAI,EAAEyH,GAAG,CAAC1H,MAAM,CAAC;UAC1CmY,MAAM,GAAG8M,SAAS,CAACvd,GAAG,CAACzH,IAAI,EAAEyH,GAAG,CAAC1H,MAAM,CAAC;UACxC4Y,QAAQ,GAAG7B,GAAG,CAACgD,UAAU,IAAIL,YAAY,CAACd,QAAQ;UAClD9M,IAAI,GAAGiL,GAAG,CAAC6J,WAAW,GAAG,OAAO,GAC5BhI,QAAQ,GAAG,MAAM,GACb,MAAM;UACd,IAAI8W,YAAY,GAAGzX,qCAAqC,CAAC7V,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,CAAC;UAC9EsX,KAAK,GAAGE,eAAe,CAACvtB,EAAE,EAAE;YACxBpC,MAAM,EAAE0vB,YAAY,CAACpyB,KAAK;YAC1B2C,IAAI,EAAEyvB,YAAY,CAACnyB;UACvB,CAAC,EAAEuO,IAAI,CAAC;UACR,IAAI8M,QAAQ,EAAE;YACV,IAAI3Q,MAAM,GAAGwnB,KAAK,CAACxnB,MAAM;YACzB,IAAI6D,IAAI,IAAI,OAAO,EAAE;cACjB,KAAK,IAAItL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyH,MAAM,CAACjL,MAAM,EAAEwD,CAAC,EAAE,EAAE;gBACpCyH,MAAM,CAACzH,CAAC,CAAC,CAACP,IAAI,CAACF,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAE6F,MAAM,CAACzH,CAAC,CAAC,CAACP,IAAI,CAACnD,IAAI,CAAC;cAC3D;YACJ,CAAC,MACI,IAAIgP,IAAI,IAAI,MAAM,EAAE;cACrB7D,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,GAAG,IAAI+B,GAAG,CAACiG,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,CAACnD,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC;YACxD;UACJ;QACJ,CAAC,MACI;UACDob,QAAQ,GAAGqW,UAAU,CAACM,SAAS,IAAIF,SAAS,CAAC;UAC7CxW,MAAM,GAAGoW,UAAU,CAACK,OAAO,IAAIF,OAAO,CAAC;UACvC,IAAIU,cAAc,CAACjX,MAAM,EAAED,QAAQ,CAAC,EAAE;YAClC,IAAI2X,GAAG,GAAG3X,QAAQ;YAClBA,QAAQ,GAAGC,MAAM;YACjBA,MAAM,GAAG0X,GAAG;UAChB;UACAjX,QAAQ,GAAGD,UAAU,CAACC,QAAQ,IAAIc,YAAY,CAACd,QAAQ;UACvD,IAAIA,QAAQ,EAAE;YACVkX,qBAAqB,CAAC1tB,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,CAAC;UAC/C,CAAC,MACI,IAAIQ,UAAU,CAACG,OAAO,EAAE;YACzBiX,UAAU,CAAC3tB,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,CAAC;UACpC;UACArM,IAAI,GAAG,MAAM;UACb,IAAIkkB,SAAS,GAAG,CAACrX,UAAU,CAACM,SAAS,IAAIL,QAAQ;UACjD,IAAI8W,YAAY,GAAGzX,qCAAqC,CAAC7V,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,CAAC;UAC9EsX,KAAK,GAAGE,eAAe,CAACvtB,EAAE,EAAE;YACxBpC,MAAM,EAAE0vB,YAAY,CAACpyB,KAAK;YAC1B2C,IAAI,EAAEyvB,YAAY,CAACnyB;UACvB,CAAC,EAAEuO,IAAI,EAAEkkB,SAAS,CAAC;QACvB;QACA5tB,EAAE,CAACkG,aAAa,CAACmnB,KAAK,CAACxnB,MAAM,EAAEwnB,KAAK,CAACQ,OAAO,CAAC;QAC7ClZ,GAAG,CAACyJ,UAAU,GAAG,IAAI;QACrB9G,YAAY,CAACoQ,MAAM,GAAGA,MAAM,CAAC,CAAC;QAC9BpQ,YAAY,CAACiG,YAAY,GAAGA,YAAY;QACxCjG,YAAY,CAACd,QAAQ,GAAGA,QAAQ;QAChC,IAAIsX,cAAc,GAAGC,SAAS,CAAC1W,QAAQ,CAAC,CAACrX,EAAE,EAAEsX,YAAY,EAAE+V,KAAK,CAACxnB,MAAM,EAAE0mB,SAAS,EAAEC,OAAO,CAAC;QAC5F,IAAI7X,GAAG,CAAC4J,UAAU,EAAE;UAChBuD,cAAc,CAAC9hB,EAAE,EAAE8tB,cAAc,IAAI,IAAI,CAAC;QAC9C;QACA,IAAIA,cAAc,EAAE;UAChB9tB,EAAE,CAAC+E,SAAS,CAAC+oB,cAAc,CAAC;QAChC;MACJ;IACJ,CAAC;IACDrD,cAAc,EAAE,SAAAA,CAAU9V,GAAG,EAAEmJ,UAAU,EAAEkQ,aAAa,EAAE;MACtD,IAAI5Q,cAAc,GAAGC,cAAc,CAACD,cAAc;MAClD,IAAIA,cAAc,CAACN,SAAS,EAAE;QAC1B;MACJ;MACAnI,GAAG,CAACqJ,kBAAkB,GAAGF,UAAU;MACnCnJ,GAAG,CAACsJ,qBAAqB,GAAG+P,aAAa;MACzC5Q,cAAc,CAACF,qBAAqB,CAACR,OAAO,GAAG,EAAE;MACjDU,cAAc,CAACF,qBAAqB,CAACP,6BAA6B,GAAG,KAAK;MAC1ES,cAAc,CAACF,qBAAqB,CAACsB,WAAW,GAAG7J,GAAG,CAAC6J,WAAW,GAAG7J,GAAG,CAACrP,GAAG,CAACzH,IAAI,CAACnD,IAAI,GAAGia,GAAG,CAACrP,GAAG,CAAC1H,MAAM,CAAClD,IAAI,GAAG,CAAC;IACpH;EACJ,CAAC;EACD,IAAIkyB,OAAO,GAAG;IACVqB,aAAa,EAAE,SAAAA,CAAUjuB,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE;MAC5C,IAAI7b,IAAI,GAAGyzB,mBAAmB,CAACnuB,EAAE,CAAC,CAAC6J,GAAG,GAAG0M,UAAU,CAACmR,MAAM,GAAG,CAAC;MAC9D,OAAO,IAAI9nB,GAAG,CAAClF,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC,CAAC,CAAC;IAC3E,CAAC;IACD2zB,gBAAgB,EAAE,SAAAA,CAAUruB,EAAE,EAAE;MAC5B,IAAI4G,KAAK,GAAGunB,mBAAmB,CAACnuB,EAAE,CAAC;MACnC,IAAItF,IAAI,GAAGL,IAAI,CAAC6O,KAAK,CAAC,CAACtC,KAAK,CAACiD,GAAG,GAAGjD,KAAK,CAACqD,MAAM,IAAI,GAAG,CAAC;MACvD,OAAO,IAAIrK,GAAG,CAAClF,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC,CAAC,CAAC;IAC3E,CAAC;IACD4zB,gBAAgB,EAAE,SAAAA,CAAUtuB,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE;MAC/C,IAAI7b,IAAI,GAAGyzB,mBAAmB,CAACnuB,EAAE,CAAC,CAACiK,MAAM,GAAGsM,UAAU,CAACmR,MAAM,GAAG,CAAC;MACjE,OAAO,IAAI9nB,GAAG,CAAClF,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC,CAAC,CAAC;IAC3E,CAAC;IACD6zB,YAAY,EAAE,SAAAA,CAAUC,GAAG,EAAE3wB,IAAI,EAAE0Y,UAAU,EAAE;MAC3C,IAAIkY,GAAG,GAAG5wB,IAAI;MACd,OAAO,IAAI+B,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,GAAG6b,UAAU,CAACmR,MAAM,GAAG,CAAC,EAAEoF,QAAQ,CAAC;IAC9D,CAAC;IACD3hB,QAAQ,EAAE,SAAAA,CAAUnL,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE;MACvC,IAAIlX,KAAK,GAAGqrB,cAAc,CAAC1qB,EAAE,CAAC;MAC9B,IAAIqK,KAAK,GAAGhL,KAAK,CAACyrB,QAAQ,CAAC,CAAC;MAC5B,IAAI,CAACzgB,KAAK,EAAE;QACR;MACJ;MACA,IAAIqkB,IAAI,GAAG,CAACnY,UAAU,CAACG,OAAO;MAC9BgY,IAAI,GAAIrvB,KAAK,CAACsvB,UAAU,CAAC,CAAC,GAAI,CAACD,IAAI,GAAGA,IAAI;MAC1CE,sBAAsB,CAAC5uB,EAAE,EAAEqK,KAAK,CAAC;MACjC,OAAOc,QAAQ,CAACnL,EAAE,EAAE0uB,IAAI,CAAC,aAAarkB,KAAK,EAAEkM,UAAU,CAACmR,MAAM,CAAC;IACnE,CAAC;IACDmH,0BAA0B,EAAE,SAAAA,CAAU7uB,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE5B,GAAG,EAAEma,cAAc,EAAE;MAC9E,IAAIzvB,KAAK,GAAGqrB,cAAc,CAAC1qB,EAAE,CAAC;MAC9B,IAAIqK,KAAK,GAAGhL,KAAK,CAACyrB,QAAQ,CAAC,CAAC;MAC5B,IAAI,CAACzgB,KAAK,EAAE;QACR;MACJ;MACA,IAAIqkB,IAAI,GAAG,CAACnY,UAAU,CAACG,OAAO;MAC9BgY,IAAI,GAAIrvB,KAAK,CAACsvB,UAAU,CAAC,CAAC,GAAI,CAACD,IAAI,GAAGA,IAAI;MAC1C,IAAIprB,IAAI,GAAGyrB,0BAA0B,CAAC/uB,EAAE,EAAE0uB,IAAI,EAAErkB,KAAK,EAAEkM,UAAU,CAACmR,MAAM,EAAE/S,GAAG,CAAC;MAC9E,IAAI,CAACrR,IAAI,EAAE;QACP;MACJ;MACA,IAAIwrB,cAAc,CAACzX,QAAQ,EAAE;QACzB,OAAO/T,IAAI;MACf;MACA,IAAIqI,IAAI,GAAGrI,IAAI,CAAC,CAAC,CAAC;MAClB,IAAIsI,EAAE,GAAG,IAAIhM,GAAG,CAAC0D,IAAI,CAAC,CAAC,CAAC,CAAC5I,IAAI,EAAE4I,IAAI,CAAC,CAAC,CAAC,CAAC3F,EAAE,GAAG,CAAC,CAAC;MAC9C,IAAIgX,GAAG,CAAC4J,UAAU,EAAE;QAChB,IAAI5J,GAAG,CAACgD,UAAU,IAAIhD,GAAG,CAAC6J,WAAW,EAAE;UACnC7J,GAAG,CAACgD,UAAU,GAAG,KAAK;UACtBhD,GAAG,CAAC6J,WAAW,GAAG,KAAK;UACvBpf,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;YAAE0J,IAAI,EAAE,QAAQ;YAAEslB,OAAO,EAAE;UAAG,CAAC,CAAC;QAC7E;QACA,IAAIpxB,MAAM,GAAG+W,GAAG,CAACrP,GAAG,CAAC1H,MAAM;QAC3B,IAAIA,MAAM,EAAE;UACR,IAAIyB,KAAK,CAACsvB,UAAU,CAAC,CAAC,EAAE;YACpB,IAAIpY,UAAU,CAACG,OAAO,EAAE;cACpB,OAAO,CAAC9Y,MAAM,EAAE+N,IAAI,CAAC;YACzB;YACA,OAAO,CAAC/N,MAAM,EAAEgO,EAAE,CAAC;UACvB,CAAC,MACI;YACD,IAAI2K,UAAU,CAACG,OAAO,EAAE;cACpB,OAAO,CAAC9Y,MAAM,EAAEgO,EAAE,CAAC;YACvB;YACA,OAAO,CAAChO,MAAM,EAAE+N,IAAI,CAAC;UACzB;QACJ;MACJ,CAAC,MACI;QACDgJ,GAAG,CAAC4J,UAAU,GAAG,IAAI;QACrB5J,GAAG,CAACgD,UAAU,GAAG,KAAK;QACtBhD,GAAG,CAAC6J,WAAW,GAAG,KAAK;QACvBpf,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE,QAAQ;UAAEslB,OAAO,EAAE;QAAG,CAAC,CAAC;MAC7E;MACA,OAAON,IAAI,GAAG,CAAC9iB,EAAE,EAAED,IAAI,CAAC,GAAG,CAACA,IAAI,EAAEC,EAAE,CAAC;IACzC,CAAC;IACDqjB,QAAQ,EAAE,SAAAA,CAAUjvB,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE5B,GAAG,EAAE;MAC5C,IAAIpP,GAAG,GAAG2pB,UAAU,CAAClvB,EAAE,EAAE2U,GAAG,EAAE4B,UAAU,CAAC2I,iBAAiB,CAAC;MAC3D,IAAI3Z,GAAG,EAAE;QACL,OAAOgR,UAAU,CAACC,QAAQ,GAAG;UAAE9b,IAAI,EAAE6K,GAAG,CAAC7K,IAAI;UAAEiD,EAAE,EAAEywB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAAC4K,GAAG,CAAC7K,IAAI,CAAC;QAAE,CAAC,GAAG6K,GAAG;MACpH;MACA,OAAO,IAAI;IACf,CAAC;IACD4pB,yBAAyB,EAAE,SAAAA,CAAUnvB,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE5B,GAAG,EAAE;MAC7D,IAAIA,GAAG,CAAC6J,WAAW,IAAIjI,UAAU,CAACa,QAAQ,EAAE;QACxC,IAAI9R,GAAG,GAAGqP,GAAG,CAACrP,GAAG;QACjB,OAAO,CACH8mB,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAAC0F,GAAG,CAAC1H,MAAM,CAAClD,IAAI,EAAE4K,GAAG,CAACzH,IAAI,CAACF,EAAE,CAAC,CAAC,EAC9DyuB,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAAC0F,GAAG,CAACzH,IAAI,CAACnD,IAAI,EAAE4K,GAAG,CAAC1H,MAAM,CAACD,EAAE,CAAC,CAAC,CACjE;MACL,CAAC,MACI;QACD,OAAQ,CAACgX,GAAG,CAACrP,GAAG,CAACzH,IAAI,EAAE8W,GAAG,CAACrP,GAAG,CAAC1H,MAAM,CAAC;MAC1C;IACJ,CAAC;IACDwxB,UAAU,EAAE,SAAAA,CAAUpvB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MAC7C,IAAI0a,IAAI,GAAGxxB,IAAI;MACf,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmY,UAAU,CAACmR,MAAM,EAAEtpB,CAAC,EAAE,EAAE;QACxC,IAAI9B,MAAM,GAAG+yB,IAAI;QACjB,KAAK,IAAItuB,GAAG,IAAI4T,GAAG,CAACrV,KAAK,EAAE;UACvB,IAAI,CAAC8a,WAAW,CAACrZ,GAAG,CAAC,EAAE;YACnB;UACJ;UACA,IAAIqb,IAAI,GAAGzH,GAAG,CAACrV,KAAK,CAACyB,GAAG,CAAC,CAAC2G,IAAI,CAAC,CAAC;UAChC,IAAI4nB,gBAAgB,GAAI/Y,UAAU,CAACG,OAAO,GACtCsW,cAAc,CAAC5Q,IAAI,EAAE9f,MAAM,CAAC,GAAG0wB,cAAc,CAAC1wB,MAAM,EAAE8f,IAAI,CAAC;UAC/D,IAAIkT,gBAAgB,EAAE;YAClB;UACJ;UACA,IAAI/Y,UAAU,CAACC,QAAQ,IAAK4F,IAAI,CAAC1hB,IAAI,IAAI4B,MAAM,CAAC5B,IAAK,EAAE;YACnD;UACJ;UACA,IAAI60B,KAAK,GAAGtT,WAAW,CAAC3f,MAAM,EAAE+yB,IAAI,CAAC;UACrC,IAAIG,OAAO,GAAIjZ,UAAU,CAACG,OAAO,GAC7B+Y,eAAe,CAACnzB,MAAM,EAAE8f,IAAI,EAAEiT,IAAI,CAAC,GACnCI,eAAe,CAACJ,IAAI,EAAEjT,IAAI,EAAE9f,MAAM,CAAC;UACvC,IAAIizB,KAAK,IAAIC,OAAO,EAAE;YAClBH,IAAI,GAAGjT,IAAI;UACf;QACJ;MACJ;MACA,IAAI7F,UAAU,CAACC,QAAQ,EAAE;QACrB6Y,IAAI,GAAG,IAAIzvB,GAAG,CAACyvB,IAAI,CAAC30B,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAAC00B,IAAI,CAAC30B,IAAI,CAAC,CAAC,CAAC;MACrF;MACA,OAAO20B,IAAI;IACf,CAAC;IACDK,gBAAgB,EAAE,SAAAA,CAAUlB,GAAG,EAAE3wB,IAAI,EAAE0Y,UAAU,EAAE;MAC/C,IAAIkY,GAAG,GAAG5wB,IAAI;MACd,IAAI6pB,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,IAAI/pB,EAAE,GAAG4Y,UAAU,CAACG,OAAO,GAAG+X,GAAG,CAAC9wB,EAAE,GAAG+pB,MAAM,GAAG+G,GAAG,CAAC9wB,EAAE,GAAG+pB,MAAM;MAC/D,OAAO,IAAI9nB,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAEiD,EAAE,CAAC;IAChC,CAAC;IACDgyB,WAAW,EAAE,SAAAA,CAAU3vB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MAC9C,IAAI8Z,GAAG,GAAG5wB,IAAI;MACd,IAAI+xB,KAAK,GAAGnB,GAAG,CAAC9wB,EAAE;MAClB,QAAQgX,GAAG,CAACyJ,UAAU;QAClB,KAAK,IAAI,CAACuR,WAAW;QACrB,KAAK,IAAI,CAACE,kBAAkB;QAC5B,KAAK,IAAI,CAACC,YAAY;QACtB,KAAK,IAAI,CAACC,YAAY;QACtB,KAAK,IAAI,CAACC,SAAS;UACfJ,KAAK,GAAGjb,GAAG,CAACuJ,QAAQ;UACpB;QACJ;UACIvJ,GAAG,CAACuJ,QAAQ,GAAG0R,KAAK;MAC5B;MACA,IAAIlI,MAAM,GAAGnR,UAAU,CAACmR,MAAM,IAAInR,UAAU,CAACS,YAAY,IAAI,CAAC,CAAC;MAC/D,IAAItc,IAAI,GAAG6b,UAAU,CAACG,OAAO,GAAG+X,GAAG,CAAC/zB,IAAI,GAAGgtB,MAAM,GAAG+G,GAAG,CAAC/zB,IAAI,GAAGgtB,MAAM;MACrE,IAAIuI,KAAK,GAAGjwB,EAAE,CAAC2E,SAAS,CAAC,CAAC;MAC1B,IAAIuG,IAAI,GAAGlL,EAAE,CAAC4E,QAAQ,CAAC,CAAC;MACxB,IAAIlK,IAAI,GAAGu1B,KAAK,IAAIxB,GAAG,CAAC/zB,IAAI,IAAIu1B,KAAK,EAAE;QACnC,OAAO,IAAI,CAACC,iBAAiB,CAAClwB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,CAAC;MAC5D,CAAC,MACI,IAAIja,IAAI,GAAGwQ,IAAI,IAAIujB,GAAG,CAAC/zB,IAAI,IAAIwQ,IAAI,EAAE;QACtC,OAAO8kB,SAAS,CAAChwB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE,IAAI,CAAC;MACrD;MACA,IAAIwb,IAAI,GAAGnwB,EAAE,CAACzG,GAAG,CAACkB,OAAO,CAAC21B,WAAW,CAAC11B,IAAI,CAAC;MAC3C,IAAIy1B,IAAI,EAAE;QACN,IAAI5Z,UAAU,CAACG,OAAO,EAAE;UACpB,IAAIhc,IAAI,GAAGy1B,IAAI,CAACj1B,KAAK,CAACd,GAAG,EACrBM,IAAI,GAAGy1B,IAAI,CAACh1B,GAAG,CAACf,GAAG,GAAG,CAAC;QAC/B,CAAC,MACI;UACDM,IAAI,GAAGy1B,IAAI,CAACj1B,KAAK,CAACd,GAAG;QACzB;MACJ;MACA,IAAImc,UAAU,CAACQ,WAAW,EAAE;QACxB6Y,KAAK,GAAGxB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC,CAAC;QACzDia,GAAG,CAACuJ,QAAQ,GAAG0R,KAAK;MACxB;MACAjb,GAAG,CAACwJ,SAAS,GAAGne,EAAE,CAACyJ,UAAU,CAAC,IAAI7J,GAAG,CAAClF,IAAI,EAAEk1B,KAAK,CAAC,EAAE,KAAK,CAAC,CAAChmB,IAAI;MAC/D,OAAO,IAAIhK,GAAG,CAAClF,IAAI,EAAEk1B,KAAK,CAAC;IAC/B,CAAC;IACDC,kBAAkB,EAAE,SAAAA,CAAU7vB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MACrD,IAAI8Z,GAAG,GAAG5wB,IAAI;MACd,QAAQ8W,GAAG,CAACyJ,UAAU;QAClB,KAAK,IAAI,CAACyR,kBAAkB;QAC5B,KAAK,IAAI,CAACC,YAAY;QACtB,KAAK,IAAI,CAACH,WAAW;QACrB,KAAK,IAAI,CAACI,YAAY;QACtB,KAAK,IAAI,CAACC,SAAS;UACf;QACJ;UACIrb,GAAG,CAACwJ,SAAS,GAAGne,EAAE,CAACyJ,UAAU,CAACglB,GAAG,EAAE,KAAK,CAAC,CAAC7kB,IAAI;MACtD;MACA,IAAI8d,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,IAAI2I,GAAG,GAAGrwB,EAAE,CAAC6I,QAAQ,CAAC4lB,GAAG,EAAGlY,UAAU,CAACG,OAAO,GAAGgR,MAAM,GAAG,CAACA,MAAM,EAAG,MAAM,EAAE/S,GAAG,CAACwJ,SAAS,CAAC;MAC1F,IAAIkS,GAAG,CAACC,OAAO,EAAE;QACb,IAAI/Z,UAAU,CAACG,OAAO,EAAE;UACpB,IAAI6Z,cAAc,GAAGvwB,EAAE,CAACyJ,UAAU,CAAC4mB,GAAG,EAAE,KAAK,CAAC;UAC9C,IAAIG,UAAU,GAAG;YAAE3mB,GAAG,EAAE0mB,cAAc,CAAC1mB,GAAG,GAAG,CAAC;YAAED,IAAI,EAAE+K,GAAG,CAACwJ;UAAU,CAAC;UACrE,IAAIkS,GAAG,GAAGrwB,EAAE,CAACkK,UAAU,CAACsmB,UAAU,EAAE,KAAK,CAAC;QAC9C,CAAC,MACI;UACD,IAAIC,SAAS,GAAGzwB,EAAE,CAACyJ,UAAU,CAAC,IAAI7J,GAAG,CAACI,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC;UAChE8rB,SAAS,CAAC7mB,IAAI,GAAG+K,GAAG,CAACwJ,SAAS;UAC9BkS,GAAG,GAAGrwB,EAAE,CAACkK,UAAU,CAACumB,SAAS,EAAE,KAAK,CAAC;QACzC;MACJ;MACA9b,GAAG,CAACuJ,QAAQ,GAAGmS,GAAG,CAAC1yB,EAAE;MACrB,OAAO0yB,GAAG;IACd,CAAC;IACDK,UAAU,EAAE,SAAAA,CAAU1wB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MACxC,IAAIT,QAAQ,GAAGjY,IAAI;MACnB,IAAI6pB,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,OAAO1nB,EAAE,CAAC6I,QAAQ,CAACiN,QAAQ,EAAGS,UAAU,CAACG,OAAO,GAAGgR,MAAM,GAAG,CAACA,MAAM,EAAG,MAAM,CAAC;IACjF,CAAC;IACDiJ,eAAe,EAAE,SAAAA,CAAU3wB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MAC7C,IAAI3F,GAAG,GAAG2F,UAAU,CAACG,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;MACrC,OAAOka,aAAa,CAAC5wB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,CAACmR,MAAM,EAAE9W,GAAG,CAAC;IAC1D,CAAC;IACDigB,cAAc,EAAE,SAAAA,CAAU7wB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MAC5C,IAAI3F,GAAG,GAAG2F,UAAU,CAACG,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;MACrC,OAAOoa,YAAY,CAAC9wB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,CAACmR,MAAM,EAAE9W,GAAG,CAAC;IACzD,CAAC;IACDkf,YAAY,EAAE,SAAAA,CAAU9vB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MAC/C,IAAIoc,SAAS,GAAG/wB,EAAE,CAAC8O,aAAa,CAAC,CAAC;MAClC,IAAIiH,MAAM,GAAG,IAAI;MACjB,IAAI2R,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,IAAI,CAACA,MAAM,EAAE;QACTA,MAAM,GAAGqJ,SAAS,CAAC9hB,YAAY,IAAI,CAAC,GAAGjP,EAAE,CAAC0Q,iBAAiB,CAAC,CAAC,CAAC;MAClE;MACA,IAAIsgB,IAAI,GAAGhxB,EAAE,CAACyJ,UAAU,CAAC5L,IAAI,EAAE,OAAO,CAAC;MACvC0Y,UAAU,CAACmR,MAAM,GAAGA,MAAM;MAC1B3R,MAAM,GAAG6W,OAAO,CAACiD,kBAAkB,CAAC7vB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,CAAC;MAC9D,IAAI,CAACoB,MAAM,EAAE;QACT,OAAO,IAAI;MACf;MACA,IAAIkb,IAAI,GAAGjxB,EAAE,CAACyJ,UAAU,CAACsM,MAAM,EAAE,OAAO,CAAC;MACzC/V,EAAE,CAAC8L,QAAQ,CAAC,IAAI,EAAEilB,SAAS,CAAClnB,GAAG,GAAGonB,IAAI,CAACpnB,GAAG,GAAGmnB,IAAI,CAACnnB,GAAG,CAAC;MACtD,OAAOkM,MAAM;IACjB,CAAC;IACDmb,WAAW,EAAE,SAAAA,CAAUlxB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MACzC,OAAO4a,UAAU,CAACnxB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,CAACmR,MAAM,EAAE,CAAC,CAACnR,UAAU,CAACG,OAAO,EAAE,CAAC,CAACH,UAAU,CAACI,OAAO,EAAE,CAAC,CAACJ,UAAU,CAACK,OAAO,CAAC;IACpH,CAAC;IACDwa,iBAAiB,EAAE,SAAAA,CAAUpxB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MAC/C,IAAImR,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,IAAI3R,MAAM,GAAGsb,eAAe,CAACrxB,EAAE,EAAE0nB,MAAM,EAAEnR,UAAU,CAACG,OAAO,EAAEH,UAAU,CAAC2I,iBAAiB,EAAErhB,IAAI,CAAC;MAChG,IAAI4K,SAAS,GAAG8N,UAAU,CAACG,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC;MAC3C4a,yBAAyB,CAAC7oB,SAAS,EAAE8N,UAAU,CAAC;MAChD,IAAI,CAACR,MAAM,EACP,OAAO,IAAI;MACfA,MAAM,CAACpY,EAAE,IAAI8K,SAAS;MACtB,OAAOsN,MAAM;IACjB,CAAC;IACDsb,eAAe,EAAE,SAAAA,CAAUrxB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MAC7C,IAAImR,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B4J,yBAAyB,CAAC,CAAC,EAAE/a,UAAU,CAAC;MACxC,OAAO8a,eAAe,CAACrxB,EAAE,EAAE0nB,MAAM,EAAEnR,UAAU,CAACG,OAAO,EAAEH,UAAU,CAAC2I,iBAAiB,EAAErhB,IAAI,CAAC,IAAIA,IAAI;IACtG,CAAC;IACD0zB,YAAY,EAAE,SAAAA,CAAUvxB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MAC1C,IAAImR,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,OAAO8J,UAAU,CAACxxB,EAAE,EAAE0nB,MAAM,EAAEnR,UAAU,CAACG,OAAO,EAAEH,UAAU,CAAC2I,iBAAiB,CAAC,IAAIrhB,IAAI;IAC3F,CAAC;IACDkyB,YAAY,EAAE,SAAAA,CAAU/vB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MAC/C,IAAI+S,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B/S,GAAG,CAACuJ,QAAQ,GAAGwJ,MAAM,GAAG,CAAC;MACzB/S,GAAG,CAACwJ,SAAS,GAAGne,EAAE,CAACyJ,UAAU,CAAC5L,IAAI,EAAE,KAAK,CAAC,CAAC+L,IAAI;MAC/C,OAAOmmB,YAAY,CAAC/vB,EAAE,EAAE0nB,MAAM,CAAC;IACnC,CAAC;IACDsI,SAAS,EAAE,SAAAA,CAAUhwB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MAC5C,OAAOqb,SAAS,CAAChwB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE,KAAK,CAAC;IACtD,CAAC;IACD8c,iCAAiC,EAAE,SAAAA,CAAUzxB,EAAE,EAAEnC,IAAI,EAAE;MACnD,IAAIvB,MAAM,GAAGuB,IAAI;MACjB,OAAO,IAAI+B,GAAG,CAACtD,MAAM,CAAC5B,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAAC2B,MAAM,CAAC5B,IAAI,CAAC,CAAC,CAAC;IACzF,CAAC;IACDg3B,mBAAmB,EAAE,SAAAA,CAAU1xB,EAAE,EAAEnC,IAAI,EAAE;MACrC,IAAIvB,MAAM,GAAGuB,IAAI;MACjB,IAAInD,IAAI,GAAG4B,MAAM,CAAC5B,IAAI;MACtB,IAAIiD,EAAE,GAAGrB,MAAM,CAACqB,EAAE;MAClB,IAAIg0B,QAAQ,GAAG3xB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC;MAC/B,IAAIk3B,MAAM;MACV,OAAOj0B,EAAE,GAAGg0B,QAAQ,CAAC/2B,MAAM,EAAE+C,EAAE,EAAE,EAAE;QAC/Bi0B,MAAM,GAAGD,QAAQ,CAACtf,MAAM,CAAC1U,EAAE,CAAC;QAC5B,IAAIi0B,MAAM,IAAItX,iBAAiB,CAACsX,MAAM,CAAC,EAAE;UACrC,IAAIC,KAAK,GAAG7xB,EAAE,CAACsP,cAAc,CAAC,IAAI1P,GAAG,CAAClF,IAAI,EAAEiD,EAAE,GAAG,CAAC,CAAC,CAAC;UACpD,IAAIk0B,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,SAAS,EAAE;YAC3C;UACJ;QACJ;MACJ;MACA,IAAIl0B,EAAE,GAAGg0B,QAAQ,CAAC/2B,MAAM,EAAE;QACtB,IAAI+T,EAAE,GAAG,MAAM,CAACvT,IAAI,CAACu2B,QAAQ,CAACh0B,EAAE,CAAC,CAAC,GAAG,aAAa,GAAG,WAAW,CAAC,CAAC;QAClE,IAAIm0B,OAAO,GAAG9xB,EAAE,CAAC0P,mBAAmB,CAAC,IAAI9P,GAAG,CAAClF,IAAI,EAAEiD,EAAE,GAAG,CAAC,CAAC,EAAE;UAAEmT,YAAY,EAAEnC;QAAG,CAAC,CAAC;QACjF,OAAOmjB,OAAO,CAAClmB,EAAE;MACrB,CAAC,MACI;QACD,OAAOtP,MAAM;MACjB;IACJ,CAAC;IACD4zB,iBAAiB,EAAE,SAAAA,CAAU1B,GAAG,EAAE3wB,IAAI,EAAE;MACpC,OAAO,IAAI+B,GAAG,CAAC/B,IAAI,CAACnD,IAAI,EAAE,CAAC,CAAC;IAChC,CAAC;IACDq3B,0BAA0B,EAAE,SAAAA,CAAU/xB,EAAE,EAAEkuB,KAAK,EAAE3X,UAAU,EAAE;MACzD,IAAIyb,OAAO,GAAGzb,UAAU,CAACG,OAAO,GAAG1W,EAAE,CAAC4E,QAAQ,CAAC,CAAC,GAAG5E,EAAE,CAAC2E,SAAS,CAAC,CAAC;MACjE,IAAI4R,UAAU,CAACiU,gBAAgB,EAAE;QAC7BwH,OAAO,GAAGzb,UAAU,CAACmR,MAAM,GAAG1nB,EAAE,CAAC9F,SAAS,CAAC,iBAAiB,CAAC;MACjE;MACA,OAAO,IAAI0F,GAAG,CAACoyB,OAAO,EAAE5D,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACq3B,OAAO,CAAC,CAAC,CAAC;IACjF,CAAC;IACDC,wBAAwB,EAAE,SAAAA,CAAUjyB,EAAE,EAAE;MACpCA,EAAE,CAACuB,WAAW,CAAC,YAAY,CAAC;MAC5B,OAAOvB,EAAE,CAACqF,SAAS,CAAC,CAAC;IACzB,CAAC;IACD6sB,sBAAsB,EAAE,SAAAA,CAAUlyB,EAAE,EAAE;MAClCA,EAAE,CAACuB,WAAW,CAAC,aAAa,CAAC;MAC7B,IAAI1D,IAAI,GAAGmC,EAAE,CAACqF,SAAS,CAAC,CAAC;MACzB,IAAIxH,IAAI,CAACs0B,MAAM,IAAI,QAAQ,EACvBt0B,IAAI,CAACF,EAAE,EAAE;MACb,OAAOE,IAAI;IACf,CAAC;IACDu0B,sBAAsB,EAAE,SAAAA,CAAUpyB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE;MACzD,IAAI0d,aAAa,GAAG;QAAE,GAAG,EAAE,GAAG;QAAE,GAAG,EAAE,GAAG;QACpC,GAAG,EAAE,GAAG;QAAE,GAAG,EAAE,GAAG;QAClB,GAAG,EAAE,GAAG;QAAE,GAAG,EAAE,GAAG;QAClB,GAAG,EAAE,GAAG;QAAE,GAAG,EAAE;MAAI,CAAC;MACxB,IAAIC,UAAU,GAAG;QAAE,IAAI,EAAE,IAAI;QAAE,GAAG,EAAE,IAAI;QAAE,GAAG,EAAE;MAAK,CAAC;MACrD,IAAI1I,SAAS,GAAGrT,UAAU,CAAC2I,iBAAiB;MAC5C,IAAI0K,SAAS,IAAI,GAAG,EAAE;QAClBA,SAAS,GAAG,GAAG;MACnB,CAAC,MACI,IAAIA,SAAS,IAAI,GAAG,EAAE;QACvBA,SAAS,GAAG,GAAG;MACnB;MACA,IAAI/S,SAAS,GAAG,CAACN,UAAU,CAAC+B,eAAe;MAC3C,IAAImV,GAAG,EAAEvR,IAAI;MACb,IAAImW,aAAa,CAACzI,SAAS,CAAC,EAAE;QAC1B1N,IAAI,GAAG,IAAI;QACXuR,GAAG,GAAG8E,qBAAqB,CAACvyB,EAAE,EAAEnC,IAAI,EAAE+rB,SAAS,EAAE/S,SAAS,CAAC;QAC3D,IAAI,CAAC4W,GAAG,EAAE;UACN,IAAI9jB,EAAE,GAAG3J,EAAE,CAACoK,eAAe,CAAC,IAAIK,MAAM,CAAC,IAAI,GAAGmf,SAAS,EAAE,GAAG,CAAC,EAAE/rB,IAAI,CAAC;UACpE,IAAI8L,EAAE,CAACjC,IAAI,CAAC,CAAC,EAAE;YACX+lB,GAAG,GAAG8E,qBAAqB,CAACvyB,EAAE,EAAE2J,EAAE,CAACgC,IAAI,CAAC,CAAC,EAAEie,SAAS,EAAE/S,SAAS,CAAC;UACpE;QACJ;MACJ,CAAC,MACI,IAAIyb,UAAU,CAAC1I,SAAS,CAAC,EAAE;QAC5B1N,IAAI,GAAG,IAAI;QACXuR,GAAG,GAAG+E,mBAAmB,CAACxyB,EAAE,EAAEnC,IAAI,EAAE+rB,SAAS,EAAE/S,SAAS,CAAC;MAC7D,CAAC,MACI,IAAI+S,SAAS,KAAK,GAAG,IAAIA,SAAS,KAAK,GAAG,EAAE;QAC7C,IAAIlC,MAAM,GAAGnR,UAAU,CAACmR,MAAM,IAAI,CAAC;QACnC,OAAOA,MAAM,EAAE,GAAG,CAAC,EAAE;UACjB,IAAI+K,QAAQ,GAAG5G,qBAAqB,CAAC7rB,EAAE,EAAE;YACrC6W,SAAS,EAAEA,SAAS;YACpB6b,SAAS,EAAE,CAAC7b,SAAS;YACrBD,OAAO,EAAEgT,SAAS,KAAK,GAAG;YAC1BkC,QAAQ,EAAElC,SAAS,KAAK,GAAG;YAC3B+I,SAAS,EAAE;UACf,CAAC,EAAElF,GAAG,IAAIA,GAAG,CAACtyB,GAAG,CAAC;UAClB,IAAIs3B,QAAQ,EAAE;YACV,IAAI,CAAChF,GAAG,EACJA,GAAG,GAAGgF,QAAQ;YAClBhF,GAAG,CAACtyB,GAAG,GAAGs3B,QAAQ,CAACt3B,GAAG;UAC1B;QACJ;MACJ,CAAC,MACI,IAAIyuB,SAAS,KAAK,GAAG,EAAE;QACxB6D,GAAG,GAAGmD,aAAa,CAAC5wB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,CAACmR,MAAM,EAAE,CAAC,EAAE7Q,SAAS,CAAC;QAC9DN,UAAU,CAACC,QAAQ,GAAG,IAAI;QAC1B,IAAI7B,GAAG,CAAC4J,UAAU,EAAE;UAChB,IAAI,CAAC5J,GAAG,CAACgD,UAAU,EAAE;YACjBhD,GAAG,CAACgD,UAAU,GAAG,IAAI;UACzB;QACJ,CAAC,MACI;UACD,IAAIL,YAAY,GAAG3C,GAAG,CAACmJ,UAAU,CAACxG,YAAY;UAC9C,IAAIA,YAAY,EAAE;YACdA,YAAY,CAACd,QAAQ,GAAG,IAAI;UAChC;UACAiX,GAAG,CAACtyB,GAAG,CAACT,IAAI,EAAE;QAClB;MACJ,CAAC,MACI,IAAIkvB,SAAS,KAAK,GAAG,EAAE;QACxB6D,GAAG,GAAGmF,oBAAoB,CAAC5yB,EAAE,EAAEnC,IAAI,EAAEgZ,SAAS,CAAC;MACnD,CAAC,MACI,IAAI+S,SAAS,KAAK,GAAG,EAAE;QACxB,IAAIiJ,OAAO,GAAG7yB,EAAE,CAACrF,OAAO,CAACkD,IAAI,CAACnD,IAAI,CAAC;QACnC,IAAImD,IAAI,CAACF,EAAE,GAAG,CAAC,IAAI+c,qBAAqB,CAACmY,OAAO,CAACh1B,IAAI,CAACF,EAAE,CAAC,CAAC,EAAE;UACxDE,IAAI,CAACF,EAAE,IAAI,CAAC;QAChB;QACA,IAAIxC,GAAG,GAAG23B,WAAW,CAAC9yB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,CAACmR,MAAM,EAAE,CAAC,EAAE7Q,SAAS,CAAC;QAChE,IAAI3b,KAAK,GAAG43B,WAAW,CAAC9yB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,CAACmR,MAAM,EAAE,CAAC,CAAC,EAAE7Q,SAAS,CAAC;QACnE,IAAI4D,kBAAkB,CAACza,EAAE,CAACrF,OAAO,CAACO,KAAK,CAACR,IAAI,CAAC,CAACQ,KAAK,CAACyC,EAAE,CAAC,CAAC,IACjD8c,kBAAkB,CAACza,EAAE,CAACrF,OAAO,CAACQ,GAAG,CAACT,IAAI,CAAC,CAACS,GAAG,CAACwC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;UACzDzC,KAAK,GAAG;YAAER,IAAI,EAAEQ,KAAK,CAACR,IAAI;YAAEiD,EAAE,EAAEzC,KAAK,CAACyC,EAAE,GAAG;UAAE,CAAC;QAClD;QACA8vB,GAAG,GAAG;UAAEvyB,KAAK,EAAEA,KAAK;UAAEC,GAAG,EAAEA;QAAI,CAAC;MACpC;MACA,IAAI,CAACsyB,GAAG,EAAE;QACN,OAAO,IAAI;MACf;MACA,IAAI,CAACztB,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC4J,UAAU,EAAE;QAC1B,OAAO,CAACkP,GAAG,CAACvyB,KAAK,EAAEuyB,GAAG,CAACtyB,GAAG,CAAC;MAC/B,CAAC,MACI;QACD,OAAO43B,eAAe,CAAC/yB,EAAE,EAAEytB,GAAG,CAACvyB,KAAK,EAAEuyB,GAAG,CAACtyB,GAAG,EAAE+gB,IAAI,CAAC;MACxD;IACJ,CAAC;IACD8W,yBAAyB,EAAE,SAAAA,CAAUhzB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE;MACvD,IAAI0c,UAAU,GAAG5V,cAAc,CAAC4B,mBAAmB;MACnD,IAAIyI,MAAM,GAAGnR,UAAU,CAACmR,MAAM;MAC9B,IAAIhR,OAAO,GAAGH,UAAU,CAACG,OAAO,KAAKuc,UAAU,CAACvc,OAAO;MACvD,IAAIjO,SAAS,GAAG,CAACwqB,UAAU,CAACxqB,SAAS,GAAG,CAAC,GAAG,CAAC,KAAKiO,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;MACnE1W,EAAE,CAACwI,KAAK,CAAC,CAACC,SAAS,EAAE,MAAM,CAAC;MAC5B8N,UAAU,CAACM,SAAS,GAAGH,OAAO,GAAG,IAAI,GAAG,KAAK;MAC7C,IAAIX,MAAM,GAAGsb,eAAe,CAACrxB,EAAE,EAAE0nB,MAAM,EAAEhR,OAAO,EAAEuc,UAAU,CAAC/T,iBAAiB,CAAC;MAC/E,IAAI,CAACnJ,MAAM,EAAE;QACT/V,EAAE,CAACwI,KAAK,CAACC,SAAS,EAAE,MAAM,CAAC;QAC3B,OAAO5K,IAAI;MACf;MACAkY,MAAM,CAACpY,EAAE,IAAI8K,SAAS;MACtB,OAAOsN,MAAM;IACjB;EACJ,CAAC;EACD,SAAS2N,YAAYA,CAACtnB,IAAI,EAAE2H,EAAE,EAAE;IAC5B6oB,OAAO,CAACxwB,IAAI,CAAC,GAAG2H,EAAE;EACtB;EACA,SAASmvB,SAASA,CAACh2B,GAAG,EAAEi2B,KAAK,EAAE;IAC3B,IAAIvY,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIxc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+0B,KAAK,EAAE/0B,CAAC,EAAE,EAAE;MAC5Bwc,GAAG,CAAC/X,IAAI,CAAC3F,GAAG,CAAC;IACjB;IACA,OAAO0d,GAAG;EACd;EACA,IAAImT,SAAS,GAAG;IACZjrB,MAAM,EAAE,SAAAA,CAAU9C,EAAE,EAAE3D,IAAI,EAAEwJ,MAAM,EAAE;MAChC,IAAIutB,SAAS,EAAErwB,IAAI;MACnB,IAAI4R,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;MACtB,IAAI/W,MAAM,GAAGiI,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM;QAAEC,IAAI,GAAGgI,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI;MACpD,IAAI,CAAC8W,GAAG,CAAC4J,UAAU,EAAE;QACjBxb,IAAI,GAAG/C,EAAE,CAAC0F,QAAQ,CAAC9H,MAAM,EAAEC,IAAI,CAAC;QAChC,IAAIw1B,SAAS,GAAG1e,GAAG,CAACqJ,kBAAkB,IAAI,CAAC,CAAC;QAC5C,IAAIqV,SAAS,CAAC/c,MAAM,IAAI,aAAa,IAAI,CAACmE,kBAAkB,CAAC1X,IAAI,CAAC,EAAE;UAChE,IAAIwP,KAAK,GAAI,MAAM,CAAEvX,IAAI,CAAC+H,IAAI,CAAC;UAC/B,IAAIwP,KAAK,IAAI8gB,SAAS,CAAC9c,UAAU,IAAI8c,SAAS,CAAC9c,UAAU,CAACG,OAAO,EAAE;YAC/D7Y,IAAI,GAAG4b,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAE,CAAC0U,KAAK,CAAC,CAAC,CAAC,CAAC3X,MAAM,CAAC;YAC9CmI,IAAI,GAAGA,IAAI,CAACnH,KAAK,CAAC,CAAC,EAAE,CAAC2W,KAAK,CAAC,CAAC,CAAC,CAAC3X,MAAM,CAAC;UAC1C;QACJ;QACA,IAAIyB,IAAI,CAACma,QAAQ,EAAE;UACf5Y,MAAM,GAAG,IAAIgC,GAAG,CAAChC,MAAM,CAAClD,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACiD,MAAM,CAAClD,IAAI,CAAC,CAAC,CAAC;UACvF,IAAImD,IAAI,CAACnD,IAAI,GAAGkD,MAAM,CAAClD,IAAI,EAAE;YACzBmD,IAAI,GAAG,IAAI+B,GAAG,CAAC/B,IAAI,CAACnD,IAAI,GAAG,CAAC,EAAEqQ,MAAM,CAACC,SAAS,CAAC;UACnD;QACJ;QACAhL,EAAE,CAACvE,YAAY,CAAC,EAAE,EAAEmC,MAAM,EAAEC,IAAI,CAAC;QACjCu1B,SAAS,GAAGx1B,MAAM;MACtB,CAAC,MACI,IAAIvB,IAAI,CAAC4b,QAAQ,EAAE;QACpBpa,IAAI,CAACF,EAAE,GAAGoN,MAAM,CAACC,SAAS;QAC1BnN,IAAI,CAACnD,IAAI,EAAE;QACXsF,EAAE,CAAC+G,YAAY,CAACnJ,MAAM,EAAEC,IAAI,CAAC;QAC7BkF,IAAI,GAAG/C,EAAE,CAAC+M,YAAY,CAAC,CAAC;QACxB/M,EAAE,CAAC4M,gBAAgB,CAAC,EAAE,CAAC;QACvBwmB,SAAS,GAAGx1B,MAAM;MACtB,CAAC,MACI;QACDmF,IAAI,GAAG/C,EAAE,CAAC+M,YAAY,CAAC,CAAC;QACxB,IAAIumB,WAAW,GAAGJ,SAAS,CAAC,EAAE,EAAErtB,MAAM,CAACjL,MAAM,CAAC;QAC9CoF,EAAE,CAAC6M,iBAAiB,CAACymB,WAAW,CAAC;QACjCF,SAAS,GAAGxQ,SAAS,CAAC/c,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,EAAEgI,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAC;MAC3D;MACAyf,cAAc,CAACI,kBAAkB,CAACwK,QAAQ,CAAC5rB,IAAI,CAACkhB,YAAY,EAAE,QAAQ,EAAExa,IAAI,EAAE1G,IAAI,CAACma,QAAQ,EAAE3Q,MAAM,CAACjL,MAAM,GAAG,CAAC,CAAC;MAC/G8e,OAAO,CAACC,eAAe,CAAC3Z,EAAE,EAAE;QAAEnC,IAAI,EAAEu1B;MAAU,CAAC,EAAEpzB,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC;IAClE,CAAC;IACD,QAAQ,EAAE,SAAA4e,CAAUvzB,EAAE,EAAE3D,IAAI,EAAEwJ,MAAM,EAAE;MAClC,IAAIutB,SAAS,EAAErwB,IAAI;MACnB,IAAI4R,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;MACtB,IAAI,CAACA,GAAG,CAAC6J,WAAW,EAAE;QAClB,IAAI5gB,MAAM,GAAGiI,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM;UAAEC,IAAI,GAAGgI,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI;QACpD,IAAIxB,IAAI,CAACma,QAAQ,IACb3Y,IAAI,CAACnD,IAAI,IAAIsF,EAAE,CAAC2E,SAAS,CAAC,CAAC,IAC3B/G,MAAM,CAAClD,IAAI,IAAIsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC,IAC5BhH,MAAM,CAAClD,IAAI,IAAImD,IAAI,CAACnD,IAAI,GAAG,CAAC,EAAE;UAC9B,IAAIkD,MAAM,CAAClD,IAAI,IAAIsF,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE;YAC/B/G,MAAM,CAACD,EAAE,GAAG,CAAC;UACjB,CAAC,MACI;YACDC,MAAM,GAAG,IAAIgC,GAAG,CAAChC,MAAM,CAAClD,IAAI,GAAG,CAAC,EAAE8yB,UAAU,CAACxtB,EAAE,EAAEpC,MAAM,CAAClD,IAAI,GAAG,CAAC,CAAC,CAAC;UACtE;QACJ;QACAqI,IAAI,GAAG/C,EAAE,CAAC0F,QAAQ,CAAC9H,MAAM,EAAEC,IAAI,CAAC;QAChCmC,EAAE,CAACvE,YAAY,CAAC,EAAE,EAAEmC,MAAM,EAAEC,IAAI,CAAC;QACjCu1B,SAAS,GAAGx1B,MAAM;QAClB,IAAIvB,IAAI,CAACma,QAAQ,EAAE;UACf4c,SAAS,GAAGxG,OAAO,CAAC6E,iCAAiC,CAACzxB,EAAE,EAAEpC,MAAM,CAAC;QACrE;MACJ,CAAC,MACI;QACDmF,IAAI,GAAG/C,EAAE,CAAC+M,YAAY,CAAC,CAAC;QACxB,IAAIumB,WAAW,GAAGJ,SAAS,CAAC,EAAE,EAAErtB,MAAM,CAACjL,MAAM,CAAC;QAC9CoF,EAAE,CAAC6M,iBAAiB,CAACymB,WAAW,CAAC;QACjCF,SAAS,GAAGxQ,SAAS,CAAC/c,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,EAAEgI,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAC;MAC3D;MACAyf,cAAc,CAACI,kBAAkB,CAACwK,QAAQ,CAAC5rB,IAAI,CAACkhB,YAAY,EAAE,QAAQ,EAAExa,IAAI,EAAE1G,IAAI,CAACma,QAAQ,EAAE7B,GAAG,CAAC6J,WAAW,CAAC;MAC7G,OAAO4N,mBAAmB,CAACpsB,EAAE,EAAEozB,SAAS,CAAC;IAC7C,CAAC;IACDI,MAAM,EAAE,SAAAA,CAAUxzB,EAAE,EAAE3D,IAAI,EAAEwJ,MAAM,EAAE;MAChC,IAAI8O,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;MACtB,IAAI3U,EAAE,CAACyzB,UAAU,EAAE;QACf,IAAI/L,MAAM,GAAI/S,GAAG,CAAC4J,UAAU,GAAIliB,IAAI,CAACqrB,MAAM,GAAG,CAAC;QAC/C,KAAK,IAAI5G,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4G,MAAM,EAAE5G,CAAC,EAAE,EAAE;UAC7B,IAAIzkB,IAAI,CAACkb,WAAW,EAChBvX,EAAE,CAACyzB,UAAU,CAAC,CAAC,CAAC,KAEhBzzB,EAAE,CAAC0zB,UAAU,CAAC,CAAC;QACvB;MACJ,CAAC,MACI;QACD,IAAIC,SAAS,GAAG9tB,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAClD,IAAI;QACrC,IAAIk5B,OAAO,GAAGjf,GAAG,CAAC6J,WAAW,GACzB3Y,MAAM,CAACA,MAAM,CAACjL,MAAM,GAAG,CAAC,CAAC,CAACgD,MAAM,CAAClD,IAAI,GACrCmL,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,CAACnD,IAAI;QACvB,IAAIgtB,MAAM,GAAI/S,GAAG,CAAC4J,UAAU,GAAIliB,IAAI,CAACqrB,MAAM,GAAG,CAAC;QAC/C,IAAIrrB,IAAI,CAACma,QAAQ,EAAE;UACfod,OAAO,EAAE;QACb;QACA,KAAK,IAAIx1B,CAAC,GAAGu1B,SAAS,EAAEv1B,CAAC,IAAIw1B,OAAO,EAAEx1B,CAAC,EAAE,EAAE;UACvC,KAAK,IAAI0iB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4G,MAAM,EAAE5G,CAAC,EAAE,EAAE;YAC7B9gB,EAAE,CAACgQ,UAAU,CAAC5R,CAAC,EAAE/B,IAAI,CAACkb,WAAW,CAAC;UACtC;QACJ;MACJ;MACA,OAAOqV,OAAO,CAAC6E,iCAAiC,CAACzxB,EAAE,EAAE6F,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAC;IAC1E,CAAC;IACDi2B,UAAU,EAAE,SAAAA,CAAU7zB,EAAE,EAAE8zB,KAAK,EAAEjuB,MAAM,EAAE;MACrC7F,EAAE,CAACuB,WAAW,CAAC,YAAY,CAAC;MAC5B,OAAOqrB,OAAO,CAAC6E,iCAAiC,CAACzxB,EAAE,EAAE6F,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAC;IAC1E,CAAC;IACD/D,QAAQ,EAAE,SAAAA,CAAUmG,EAAE,EAAEsX,YAAY,EAAEzR,MAAM,EAAE0mB,SAAS,EAAEC,OAAO,EAAE;MAC9D,IAAI,CAACxsB,EAAE,CAACnG,QAAQ,EACZ;MACJ,IAAI8R,IAAI,GAAG9F,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAClD,IAAI;MAChC,IAAIkR,EAAE,GAAG/F,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,CAACnD,IAAI;MAC5B,IAAI4c,YAAY,CAACd,QAAQ,EACrB5K,EAAE,EAAE;MACR,IAAIpR,MAAM,GAAGwF,EAAE,CAACnG,QAAQ,CAAC;QAAE8R,IAAI,EAAEA,IAAI;QAAEC,EAAE,EAAEA;MAAG,CAAC,CAAC;MAChD,IAAIpR,MAAM,GAAGmR,IAAI,IAAI2L,YAAY,CAACd,QAAQ,EACtChc,MAAM,EAAE;MACZ,OAAO8c,YAAY,CAACG,UAAU,GAAG8U,SAAS,GAAG,IAAI3sB,GAAG,CAACpF,MAAM,EAAE,CAAC,CAAC;IACnE,CAAC;IACDu5B,UAAU,EAAE,SAAAA,CAAU/zB,EAAE,EAAE3D,IAAI,EAAEwJ,MAAM,EAAE0mB,SAAS,EAAEC,OAAO,EAAE;MACxD,IAAIhK,UAAU,GAAGxiB,EAAE,CAACiN,aAAa,CAAC,CAAC;MACnC,IAAI+mB,OAAO,GAAG,EAAE;MAChB,IAAIxc,OAAO,GAAGnb,IAAI,CAACmb,OAAO;MAC1B,KAAK,IAAIsJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,UAAU,CAAC5nB,MAAM,EAAEkmB,CAAC,EAAE,EAAE;QACxC,IAAImT,MAAM,GAAGzR,UAAU,CAAC1B,CAAC,CAAC;QAC1B,IAAI/d,IAAI,GAAG,EAAE;QACb,IAAIyU,OAAO,KAAK,IAAI,EAAE;UAClBzU,IAAI,GAAGkxB,MAAM,CAAC3yB,WAAW,CAAC,CAAC;QAC/B,CAAC,MACI,IAAIkW,OAAO,KAAK,KAAK,EAAE;UACxBzU,IAAI,GAAGkxB,MAAM,CAAChzB,WAAW,CAAC,CAAC;QAC/B,CAAC,MACI;UACD,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG61B,MAAM,CAACr5B,MAAM,EAAEwD,CAAC,EAAE,EAAE;YACpC,IAAIwrB,SAAS,GAAGqK,MAAM,CAAC5hB,MAAM,CAACjU,CAAC,CAAC;YAChC2E,IAAI,IAAIyX,WAAW,CAACoP,SAAS,CAAC,GAAGA,SAAS,CAACtoB,WAAW,CAAC,CAAC,GACpDsoB,SAAS,CAAC3oB,WAAW,CAAC,CAAC;UAC/B;QACJ;QACA+yB,OAAO,CAACnxB,IAAI,CAACE,IAAI,CAAC;MACtB;MACA/C,EAAE,CAAC6M,iBAAiB,CAACmnB,OAAO,CAAC;MAC7B,IAAI33B,IAAI,CAACub,gBAAgB,EAAE;QACvB,OAAO4U,OAAO;MAClB,CAAC,MACI,IAAI,CAACxsB,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC4J,UAAU,IAAIliB,IAAI,CAACma,QAAQ,IAAI3Q,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAClD,IAAI,GAAG,CAAC,IAAImL,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,CAACnD,IAAI,EAAE;QACpG,OAAOkyB,OAAO,CAAC6E,iCAAiC,CAACzxB,EAAE,EAAEusB,SAAS,CAAC;MACnE,CAAC,MACI,IAAIlwB,IAAI,CAACma,QAAQ,EAAE;QACpB,OAAO+V,SAAS;MACpB,CAAC,MACI;QACD,OAAO3J,SAAS,CAAC/c,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,EAAEiI,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,CAAC;MACtD;IACJ,CAAC;IACDq2B,IAAI,EAAE,SAAAA,CAAUl0B,EAAE,EAAE3D,IAAI,EAAEwJ,MAAM,EAAE0mB,SAAS,EAAE;MACzC,IAAI5X,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;MACtB,IAAI5R,IAAI,GAAG/C,EAAE,CAAC+M,YAAY,CAAC,CAAC;MAC5B,IAAIonB,MAAM,GAAGxf,GAAG,CAAC4J,UAAU,GACrBqE,SAAS,CAACjO,GAAG,CAACrP,GAAG,CAAC1H,MAAM,EAAE+W,GAAG,CAACrP,GAAG,CAACzH,IAAI,EAAEgI,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,EAAEgI,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAC,GACzE2uB,SAAS;MACflP,cAAc,CAACI,kBAAkB,CAACwK,QAAQ,CAAC5rB,IAAI,CAACkhB,YAAY,EAAE,MAAM,EAAExa,IAAI,EAAE1G,IAAI,CAACma,QAAQ,EAAE7B,GAAG,CAAC6J,WAAW,CAAC;MAC3G,OAAO2V,MAAM;IACjB;EACJ,CAAC;EACD,SAASvQ,cAAcA,CAACxnB,IAAI,EAAE2H,EAAE,EAAE;IAC9BgqB,SAAS,CAAC3xB,IAAI,CAAC,GAAG2H,EAAE;EACxB;EACA,IAAI2V,OAAO,GAAG;IACV0a,YAAY,EAAE,SAAAA,CAAUp0B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACzC,IAAIA,GAAG,CAAC4J,UAAU,EAAE;QAChB;MACJ;MACA,IAAImJ,MAAM,GAAGxQ,UAAU,CAACwQ,MAAM;MAC9B,IAAIhR,OAAO,GAAGQ,UAAU,CAACR,OAAO;MAChC,IAAIsI,QAAQ,GAAG3B,cAAc,CAAC2B,QAAQ;MACtC,IAAI5C,IAAI,GAAG4C,QAAQ,CAAC9C,IAAI,CAAClc,EAAE,EAAE0W,OAAO,GAAGgR,MAAM,GAAG,CAACA,MAAM,CAAC;MACxD,IAAI1L,OAAO,GAAGI,IAAI,GAAGA,IAAI,CAAC1U,IAAI,CAAC,CAAC,GAAGoD,SAAS;MAC5CkR,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAGhc,EAAE,CAACqF,SAAS,CAAC,CAAC;MAC5CrF,EAAE,CAAC+E,SAAS,CAACiX,OAAO,CAAC;MACrBhc,EAAE,CAACzG,GAAG,CAAC2J,KAAK,CAAC/G,OAAO,CAACgI,cAAc,GAAG,gBAAgB,CAAC,CAAC;IAC5D,CAAC;IACDkwB,MAAM,EAAE,SAAAA,CAAUr0B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACnC,IAAIA,GAAG,CAAC4J,UAAU,EAAE;QAChB;MACJ;MACA,IAAImJ,MAAM,GAAGxQ,UAAU,CAACwQ,MAAM,IAAI,CAAC;MACnC,IAAIte,UAAU,GAAGpJ,EAAE,CAAC0Q,iBAAiB,CAAC,CAAC;MACvC,IAAI7G,GAAG,GAAG7J,EAAE,CAAC8O,aAAa,CAAC,CAAC,CAACjF,GAAG;MAChC,IAAIlH,KAAK,GAAGyG,UAAU,GAAGse,MAAM;MAC/B,IAAI4M,MAAM,GAAGpd,UAAU,CAACR,OAAO,GAAG7M,GAAG,GAAGlH,KAAK,GAAGkH,GAAG,GAAGlH,KAAK;MAC3D,IAAIrG,MAAM,GAAG6vB,UAAU,CAACnsB,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;MACvC,IAAIkvB,YAAY,GAAGv0B,EAAE,CAACyJ,UAAU,CAACnN,MAAM,EAAE,OAAO,CAAC;MACjD,IAAI4a,UAAU,CAACR,OAAO,EAAE;QACpB,IAAI4d,MAAM,GAAGC,YAAY,CAAC1qB,GAAG,EAAE;UAC3BvN,MAAM,CAAC5B,IAAI,IAAI,CAAC45B,MAAM,GAAGC,YAAY,CAAC1qB,GAAG,IAAIT,UAAU;UACvD9M,MAAM,CAAC5B,IAAI,GAAGL,IAAI,CAACm6B,IAAI,CAACl4B,MAAM,CAAC5B,IAAI,CAAC;UACpCsF,EAAE,CAAC+E,SAAS,CAACzI,MAAM,CAAC;UACpBi4B,YAAY,GAAGv0B,EAAE,CAACyJ,UAAU,CAACnN,MAAM,EAAE,OAAO,CAAC;UAC7C0D,EAAE,CAAC8L,QAAQ,CAAC,IAAI,EAAEyoB,YAAY,CAAC1qB,GAAG,CAAC;QACvC,CAAC,MACI;UACD7J,EAAE,CAAC8L,QAAQ,CAAC,IAAI,EAAEwoB,MAAM,CAAC;QAC7B;MACJ,CAAC,MACI;QACD,IAAIG,SAAS,GAAGH,MAAM,GAAGt0B,EAAE,CAAC8O,aAAa,CAAC,CAAC,CAACG,YAAY;QACxD,IAAIwlB,SAAS,GAAGF,YAAY,CAACtqB,MAAM,EAAE;UACjC3N,MAAM,CAAC5B,IAAI,IAAI,CAAC65B,YAAY,CAACtqB,MAAM,GAAGwqB,SAAS,IAAIrrB,UAAU;UAC7D9M,MAAM,CAAC5B,IAAI,GAAGL,IAAI,CAAC6O,KAAK,CAAC5M,MAAM,CAAC5B,IAAI,CAAC;UACrCsF,EAAE,CAAC+E,SAAS,CAACzI,MAAM,CAAC;UACpBi4B,YAAY,GAAGv0B,EAAE,CAACyJ,UAAU,CAACnN,MAAM,EAAE,OAAO,CAAC;UAC7C0D,EAAE,CAAC8L,QAAQ,CAAC,IAAI,EAAEyoB,YAAY,CAACtqB,MAAM,GAAGjK,EAAE,CAAC8O,aAAa,CAAC,CAAC,CAACG,YAAY,CAAC;QAC5E,CAAC,MACI;UACDjP,EAAE,CAAC8L,QAAQ,CAAC,IAAI,EAAEwoB,MAAM,CAAC;QAC7B;MACJ;IACJ,CAAC;IACDI,cAAc,EAAE,SAAAA,CAAU10B,EAAE,EAAEkX,UAAU,EAAE;MACtC,IAAI8a,OAAO,GAAGhyB,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI;MACjC,IAAI+O,UAAU,GAAGzJ,EAAE,CAACyJ,UAAU,CAAC,IAAI7J,GAAG,CAACoyB,OAAO,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC;MAC5D,IAAI7oB,MAAM,GAAGnJ,EAAE,CAAC8O,aAAa,CAAC,CAAC,CAACG,YAAY;MAC5C,IAAIlD,CAAC,GAAGtC,UAAU,CAACI,GAAG;MACtB,QAAQqN,UAAU,CAACiB,QAAQ;QACvB,KAAK,QAAQ;UACTpM,CAAC,GAAGtC,UAAU,CAACQ,MAAM,GAAGd,MAAM,GAAG,CAAC;UAClC;QACJ,KAAK,QAAQ;UACT,IAAIwrB,eAAe,GAAG,IAAI/0B,GAAG,CAACoyB,OAAO,EAAEhyB,EAAE,CAACrF,OAAO,CAACq3B,OAAO,CAAC,CAACp3B,MAAM,GAAG,CAAC,CAAC;UACtE,IAAIg6B,kBAAkB,GAAG50B,EAAE,CAACyJ,UAAU,CAACkrB,eAAe,EAAE,OAAO,CAAC;UAChE,IAAIvrB,UAAU,GAAGwrB,kBAAkB,CAAC3qB,MAAM,GAAG8B,CAAC;UAC9CA,CAAC,GAAGA,CAAC,GAAG5C,MAAM,GAAGC,UAAU;UAC3B;MACR;MACApJ,EAAE,CAAC8L,QAAQ,CAAC,IAAI,EAAEC,CAAC,CAAC;IACxB,CAAC;IACD8oB,WAAW,EAAE,SAAAA,CAAU70B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACxC,IAAI4I,YAAY,GAAGrG,UAAU,CAACgI,iBAAiB;MAC/C,IAAIwI,MAAM,GAAGxQ,UAAU,CAACwQ,MAAM;MAC9B,IAAItK,cAAc,GAAGC,cAAc,CAACD,cAAc;MAClD,IAAIG,YAAY,IAAI,GAAG,EAAE;QACrBA,YAAY,GAAGH,cAAc,CAACP,cAAc;MAChD,CAAC,MACI;QACDO,cAAc,CAACP,cAAc,GAAGU,YAAY;MAChD;MACA,OAAOmK,MAAM,EAAE,EAAE;QACboN,oBAAoB,CAAC90B,EAAE,EAAE2U,GAAG,EAAEyI,cAAc,EAAEG,YAAY,CAAC;MAC/D;IACJ,CAAC;IACDD,oBAAoB,EAAE,SAAAA,CAAUtd,EAAE,EAAEkX,UAAU,EAAE;MAC5C,IAAIkG,cAAc,GAAGC,cAAc,CAACD,cAAc;MAClD,IAAIG,YAAY,GAAGrG,UAAU,CAACgI,iBAAiB;MAC/C,IAAI7B,cAAc,CAACI,kBAAkB,CAAC8K,eAAe,CAAChL,YAAY,CAAC,EAAE;QACjEH,cAAc,CAACE,oBAAoB,CAACtd,EAAE,EAAEud,YAAY,CAAC;MACzD;IACJ,CAAC;IACDvP,eAAe,EAAE,SAAAA,CAAUhO,EAAE,EAAE;MAC3B,IAAI,CAACA,EAAE,CAACX,KAAK,CAAC4O,SAAS,EAAE;QACrBjO,EAAE,CAACgO,eAAe,CAAC,IAAI,CAAC;QACxBhO,EAAE,CAAC6N,SAAS,CAAC,QAAQ,EAAE,aAAa,CAAC;QACrCzO,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE;QAAU,CAAC,CAAC;MACjE,CAAC,MACI;QACD1J,EAAE,CAACgO,eAAe,CAAC,KAAK,CAAC;QACzBhO,EAAE,CAAC6N,SAAS,CAAC,QAAQ,EAAE,YAAY,CAAC;QACpCzO,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE;QAAS,CAAC,CAAC;MAChE;IACJ,CAAC;IACDiQ,eAAe,EAAE,SAAAA,CAAU3Z,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MAC5C,IAAI3U,EAAE,CAAC9F,SAAS,CAAC,UAAU,CAAC,EAAE;QAC1B;MACJ;MACAya,GAAG,CAAC6E,UAAU,GAAG,IAAI;MACrB7E,GAAG,CAAC2J,gBAAgB,GAAGpH,UAAU,IAAIA,UAAU,CAACwQ,MAAM,IAAI,CAAC;MAC3D,IAAI7P,QAAQ,GAAIX,UAAU,GAAIA,UAAU,CAACW,QAAQ,GAAG,IAAI;MACxD,IAAIvS,GAAG,GAAGqP,GAAG,CAACrP,GAAG;MACjB,IAAIzH,IAAI,GAAGqZ,UAAU,CAACrZ,IAAI,IAAImC,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;MAClD,IAAI8D,MAAM,GAAGnJ,EAAE,CAAC4F,cAAc,CAAC,CAAC,CAAChL,MAAM;MACvC,IAAIid,QAAQ,IAAI,KAAK,EAAE;QACnBha,IAAI,GAAG,IAAI+B,GAAG,CAAC/B,IAAI,CAACnD,IAAI,EAAE8yB,UAAU,CAACxtB,EAAE,EAAEnC,IAAI,CAACnD,IAAI,CAAC,CAAC;MACxD,CAAC,MACI,IAAImd,QAAQ,IAAI,KAAK,EAAE;QACxBha,IAAI,GAAG,IAAI+B,GAAG,CAAC/B,IAAI,CAACnD,IAAI,EAAE,CAAC,CAAC;MAChC,CAAC,MACI,IAAImd,QAAQ,IAAI,WAAW,EAAE;QAC9B,IAAIkd,WAAW,GAAGlf,qCAAqC,CAAC7V,EAAE,EAAEnC,IAAI,EAAE4b,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC3FA,IAAI,GAAGk3B,WAAW,CAAC55B,GAAG;MAC1B,CAAC,MACI,IAAI0c,QAAQ,IAAI,eAAe,EAAE;QAClC,IAAIkd,WAAW,GAAGlf,qCAAqC,CAAC7V,EAAE,EAAEnC,IAAI,EAAE+uB,OAAO,CAAC6E,iCAAiC,CAACzxB,EAAE,EAAEnC,IAAI,CAAC,CAAC;QACtHA,IAAI,GAAGk3B,WAAW,CAAC55B,GAAG;MAC1B,CAAC,MACI,IAAI0c,QAAQ,IAAI,qBAAqB,EAAE;QACxC,IAAI,CAAClD,GAAG,CAAC4J,UAAU,EACf;QACJ,IAAI,CAAC5J,GAAG,CAAC6J,WAAW,EAAE;UAClB,IAAIlZ,GAAG,CAACzH,IAAI,CAACnD,IAAI,GAAG4K,GAAG,CAAC1H,MAAM,CAAClD,IAAI,EAAE;YACjCmD,IAAI,GAAGyH,GAAG,CAACzH,IAAI;UACnB,CAAC,MACI;YACDA,IAAI,GAAG,IAAI+B,GAAG,CAAC0F,GAAG,CAAC1H,MAAM,CAAClD,IAAI,EAAE,CAAC,CAAC;UACtC;QACJ,CAAC,MACI;UACDmD,IAAI,GAAG,IAAI+B,GAAG,CAACvF,IAAI,CAACC,GAAG,CAACgL,GAAG,CAACzH,IAAI,CAACnD,IAAI,EAAE4K,GAAG,CAAC1H,MAAM,CAAClD,IAAI,CAAC,EAAEL,IAAI,CAACC,GAAG,CAACgL,GAAG,CAACzH,IAAI,CAACF,EAAE,EAAE2H,GAAG,CAAC1H,MAAM,CAACD,EAAE,CAAC,CAAC;UAC9FwL,MAAM,GAAG9O,IAAI,CAAC8yB,GAAG,CAAC7nB,GAAG,CAACzH,IAAI,CAACnD,IAAI,GAAG4K,GAAG,CAAC1H,MAAM,CAAClD,IAAI,CAAC,GAAG,CAAC;QAC1D;MACJ,CAAC,MACI,IAAImd,QAAQ,IAAI,mBAAmB,EAAE;QACtC,IAAI,CAAClD,GAAG,CAAC4J,UAAU,EACf;QACJ,IAAI,CAAC5J,GAAG,CAAC6J,WAAW,EAAE;UAClB,IAAIlZ,GAAG,CAACzH,IAAI,CAACnD,IAAI,IAAI4K,GAAG,CAAC1H,MAAM,CAAClD,IAAI,EAAE;YAClCmD,IAAI,GAAG4b,YAAY,CAACnU,GAAG,CAACzH,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;UACvC,CAAC,MACI;YACDA,IAAI,GAAG,IAAI+B,GAAG,CAAC0F,GAAG,CAAC1H,MAAM,CAAClD,IAAI,EAAE,CAAC,CAAC;UACtC;QACJ,CAAC,MACI;UACDmD,IAAI,GAAG,IAAI+B,GAAG,CAACvF,IAAI,CAACC,GAAG,CAACgL,GAAG,CAACzH,IAAI,CAACnD,IAAI,EAAE4K,GAAG,CAAC1H,MAAM,CAAClD,IAAI,CAAC,EAAEL,IAAI,CAACL,GAAG,CAACsL,GAAG,CAACzH,IAAI,CAACF,EAAE,EAAE2H,GAAG,CAAC1H,MAAM,CAACD,EAAE,CAAC,GAAG,CAAC,CAAC;UAClGwL,MAAM,GAAG9O,IAAI,CAAC8yB,GAAG,CAAC7nB,GAAG,CAACzH,IAAI,CAACnD,IAAI,GAAG4K,GAAG,CAAC1H,MAAM,CAAClD,IAAI,CAAC,GAAG,CAAC;QAC1D;MACJ,CAAC,MACI,IAAImd,QAAQ,IAAI,SAAS,EAAE;QAC5B,IAAIlD,GAAG,CAAC4J,UAAU,EAAE;UAChB;QACJ;MACJ,CAAC,MACI,IAAI1G,QAAQ,IAAI,UAAU,EAAE;QAC7Bha,IAAI,GAAGm3B,cAAc,CAACh1B,EAAE,CAAC,IAAInC,IAAI;MACrC;MACAmC,EAAE,CAAC6N,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;MACnC,IAAIqJ,UAAU,IAAIA,UAAU,CAACjc,OAAO,EAAE;QAClC+E,EAAE,CAACgO,eAAe,CAAC,IAAI,CAAC;QACxBhO,EAAE,CAAC6N,SAAS,CAAC,QAAQ,EAAE,aAAa,CAAC;QACrCzO,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE;QAAU,CAAC,CAAC;MACjE,CAAC,MACI;QACD1J,EAAE,CAACgO,eAAe,CAAC,KAAK,CAAC;QACzBhO,EAAE,CAAC6N,SAAS,CAAC,QAAQ,EAAE,YAAY,CAAC;QACpCzO,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE;QAAS,CAAC,CAAC;MAChE;MACA,IAAI,CAAC2T,cAAc,CAACD,cAAc,CAACN,SAAS,EAAE;QAC1C9c,EAAE,CAAC5C,EAAE,CAAC,QAAQ,EAAEoC,QAAQ,CAAC;QACzB,IAAImV,GAAG,CAACsgB,SAAS,EACbtgB,GAAG,CAACsgB,SAAS,CAACxtB,KAAK,CAAC,CAAC;QACzBkN,GAAG,CAACsgB,SAAS,GAAGj1B,EAAE,CAACqI,WAAW,CAACxK,IAAI,EAAE;UAAE0K,UAAU,EAAE;QAAK,CAAC,CAAC;QAC1DnJ,UAAU,CAAChC,EAAE,CAAC4C,EAAE,CAACkN,aAAa,CAAC,CAAC,EAAE,SAAS,EAAEgoB,uBAAuB,CAAC;MACzE;MACA,IAAIvgB,GAAG,CAAC4J,UAAU,EAAE;QAChBuD,cAAc,CAAC9hB,EAAE,CAAC;MACtB;MACAm1B,eAAe,CAACn1B,EAAE,EAAEnC,IAAI,EAAEsL,MAAM,CAAC;IACrC,CAAC;IACDisB,gBAAgB,EAAE,SAAAA,CAAUp1B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MAC7C,IAAI+S,MAAM,GAAGxQ,UAAU,CAACwQ,MAAM;MAC9B,IAAI9pB,MAAM,GAAGoC,EAAE,CAACqF,SAAS,CAAC,CAAC;MAC3B,IAAIxH,IAAI;MACR,IAAI,CAAC8W,GAAG,CAAC4J,UAAU,EAAE;QACjB5J,GAAG,CAAC4J,UAAU,GAAG,IAAI;QACrB5J,GAAG,CAACgD,UAAU,GAAG,CAAC,CAACT,UAAU,CAACV,QAAQ;QACtC7B,GAAG,CAAC6J,WAAW,GAAG,CAAC,CAACtH,UAAU,CAACa,SAAS;QACxCla,IAAI,GAAGuuB,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAAChC,MAAM,CAAClD,IAAI,EAAEkD,MAAM,CAACD,EAAE,GAAG+pB,MAAM,GAAG,CAAC,CAAC,CAAC;QAC5E,IAAIqN,WAAW,GAAGlf,qCAAqC,CAAC7V,EAAE,EAAEpC,MAAM,EAAEC,IAAI,CAAC;QACzE8W,GAAG,CAACrP,GAAG,GAAG;UACN1H,MAAM,EAAEm3B,WAAW,CAAC75B,KAAK;UACzB2C,IAAI,EAAEk3B,WAAW,CAAC55B;QACtB,CAAC;QACDiE,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE,QAAQ;UAAEslB,OAAO,EAAEra,GAAG,CAACgD,UAAU,GAAG,UAAU,GAAGhD,GAAG,CAAC6J,WAAW,GAAG,WAAW,GAAG;QAAG,CAAC,CAAC;QACvI+L,iBAAiB,CAACvqB,EAAE,CAAC;QACrB+sB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEiO,SAAS,CAAChlB,MAAM,EAAEC,IAAI,CAAC,CAAC;QACjDkvB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEkO,SAAS,CAACjlB,MAAM,EAAEC,IAAI,CAAC,CAAC;MACrD,CAAC,MACI,IAAI8W,GAAG,CAACgD,UAAU,GAAGT,UAAU,CAACV,QAAQ,IACzC7B,GAAG,CAAC6J,WAAW,GAAGtH,UAAU,CAACa,SAAS,EAAE;QACxCpD,GAAG,CAACgD,UAAU,GAAG,CAAC,CAACT,UAAU,CAACV,QAAQ;QACtC7B,GAAG,CAAC6J,WAAW,GAAG,CAAC,CAACtH,UAAU,CAACa,SAAS;QACxC3Y,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UAAE0J,IAAI,EAAE,QAAQ;UAAEslB,OAAO,EAAEra,GAAG,CAACgD,UAAU,GAAG,UAAU,GAAGhD,GAAG,CAAC6J,WAAW,GAAG,WAAW,GAAG;QAAG,CAAC,CAAC;QACvI+L,iBAAiB,CAACvqB,EAAE,CAAC;MACzB,CAAC,MACI;QACD8hB,cAAc,CAAC9hB,EAAE,CAAC;MACtB;IACJ,CAAC;IACDq1B,qBAAqB,EAAE,SAAAA,CAAUr1B,EAAE,EAAEs1B,WAAW,EAAE3gB,GAAG,EAAE;MACnD,IAAI8J,aAAa,GAAG9J,GAAG,CAAC8J,aAAa;MACrC,IAAI9J,GAAG,CAAC4J,UAAU,EAAE;QAChBgX,mBAAmB,CAACv1B,EAAE,EAAE2U,GAAG,CAAC;MAChC;MACA,IAAI8J,aAAa,EAAE;QACf,IAAI7gB,MAAM,GAAG6gB,aAAa,CAAC+W,UAAU,CAAC9tB,IAAI,CAAC,CAAC;QAC5C,IAAI7J,IAAI,GAAG4gB,aAAa,CAACgX,QAAQ,CAAC/tB,IAAI,CAAC,CAAC;QACxC,IAAI,CAAC9J,MAAM,IAAI,CAACC,IAAI,EAAE;UAClB;QACJ;QACA8W,GAAG,CAACrP,GAAG,GAAG;UACN1H,MAAM,EAAEA,MAAM;UACdC,IAAI,EAAEA;QACV,CAAC;QACD8W,GAAG,CAAC4J,UAAU,GAAG,IAAI;QACrB5J,GAAG,CAACgD,UAAU,GAAG8G,aAAa,CAAC9G,UAAU;QACzChD,GAAG,CAAC6J,WAAW,GAAGC,aAAa,CAACD,WAAW;QAC3C+L,iBAAiB,CAACvqB,EAAE,CAAC;QACrB+sB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEiO,SAAS,CAAChlB,MAAM,EAAEC,IAAI,CAAC,CAAC;QACjDkvB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEkO,SAAS,CAACjlB,MAAM,EAAEC,IAAI,CAAC,CAAC;QACjDuB,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;UACrC0J,IAAI,EAAE,QAAQ;UACdslB,OAAO,EAAEra,GAAG,CAACgD,UAAU,GAAG,UAAU,GAChChD,GAAG,CAAC6J,WAAW,GAAG,WAAW,GAAG;QACxC,CAAC,CAAC;MACN;IACJ,CAAC;IACDkX,SAAS,EAAE,SAAAA,CAAU11B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACtC,IAAImB,QAAQ,EAAEC,MAAM;MACpB,IAAIpB,GAAG,CAAC4J,UAAU,EAAE;QAChBzI,QAAQ,GAAG9V,EAAE,CAACqF,SAAS,CAAC,QAAQ,CAAC;QACjC0Q,MAAM,GAAG/V,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;QAC7B,IAAI2nB,cAAc,CAACjX,MAAM,EAAED,QAAQ,CAAC,EAAE;UAClC,IAAI2X,GAAG,GAAG1X,MAAM;UAChBA,MAAM,GAAGD,QAAQ;UACjBA,QAAQ,GAAG2X,GAAG;QAClB;QACA1X,MAAM,CAACpY,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAE+V,MAAM,CAACrb,IAAI,CAAC,GAAG,CAAC;MAC/C,CAAC,MACI;QACD,IAAIgtB,MAAM,GAAGrtB,IAAI,CAACL,GAAG,CAACkd,UAAU,CAACwQ,MAAM,EAAE,CAAC,CAAC;QAC3C5R,QAAQ,GAAG9V,EAAE,CAACqF,SAAS,CAAC,CAAC;QACzB0Q,MAAM,GAAGqW,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAACkW,QAAQ,CAACpb,IAAI,GAAGgtB,MAAM,GAAG,CAAC,EAAEoF,QAAQ,CAAC,CAAC;MACnF;MACA,IAAI6I,OAAO,GAAG,CAAC;MACf,KAAK,IAAIv3B,CAAC,GAAG0X,QAAQ,CAACpb,IAAI,EAAE0D,CAAC,GAAG2X,MAAM,CAACrb,IAAI,EAAE0D,CAAC,EAAE,EAAE;QAC9Cu3B,OAAO,GAAGnI,UAAU,CAACxtB,EAAE,EAAE8V,QAAQ,CAACpb,IAAI,CAAC;QACvC,IAAIqI,IAAI,GAAG,EAAE;QACb,IAAI6yB,WAAW,GAAG,CAAC;QACnB,IAAI,CAAC1e,UAAU,CAACc,UAAU,EAAE;UACxB,IAAI3c,QAAQ,GAAG2E,EAAE,CAACrF,OAAO,CAACmb,QAAQ,CAACpb,IAAI,GAAG,CAAC,CAAC;UAC5Ck7B,WAAW,GAAGv6B,QAAQ,CAACwP,MAAM,CAAC,IAAI,CAAC;UACnC,IAAI+qB,WAAW,IAAI,CAAC,CAAC,EAAE;YACnBA,WAAW,GAAGv6B,QAAQ,CAACT,MAAM;UACjC,CAAC,MACI;YACDmI,IAAI,GAAG,GAAG;UACd;QACJ;QACA/C,EAAE,CAACvE,YAAY,CAACsH,IAAI,EAAE,IAAInD,GAAG,CAACkW,QAAQ,CAACpb,IAAI,EAAEi7B,OAAO,CAAC,EAAE,IAAI/1B,GAAG,CAACkW,QAAQ,CAACpb,IAAI,GAAG,CAAC,EAAEk7B,WAAW,CAAC,CAAC;MACnG;MACA,IAAIC,WAAW,GAAGzJ,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAACkW,QAAQ,CAACpb,IAAI,EAAEi7B,OAAO,CAAC,CAAC;MAC1E,IAAIhhB,GAAG,CAAC4J,UAAU,EAAE;QAChBuD,cAAc,CAAC9hB,EAAE,EAAE,KAAK,CAAC;MAC7B;MACAA,EAAE,CAAC+E,SAAS,CAAC8wB,WAAW,CAAC;IAC7B,CAAC;IACDC,yBAAyB,EAAE,SAAAA,CAAU91B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACtDA,GAAG,CAAC6E,UAAU,GAAG,IAAI;MACrB,IAAI3B,QAAQ,GAAGsU,UAAU,CAACnsB,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;MACzC,IAAIwS,QAAQ,CAACnd,IAAI,KAAKsF,EAAE,CAAC2E,SAAS,CAAC,CAAC,IAAI,CAACuS,UAAU,CAACrb,KAAK,EAAE;QACvDmE,EAAE,CAACvE,YAAY,CAAC,IAAI,EAAE,IAAImE,GAAG,CAACI,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACjD3E,EAAE,CAAC+E,SAAS,CAAC/E,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;MACnC,CAAC,MACI;QACDkT,QAAQ,CAACnd,IAAI,GAAIwc,UAAU,CAACrb,KAAK,GAAIgc,QAAQ,CAACnd,IAAI,GAC9Cmd,QAAQ,CAACnd,IAAI,GAAG,CAAC;QACrBmd,QAAQ,CAACla,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAE6X,QAAQ,CAACnd,IAAI,CAAC;QAC3CsF,EAAE,CAAC+E,SAAS,CAAC8S,QAAQ,CAAC;QACtB,IAAIke,SAAS,GAAG32B,UAAU,CAACjC,QAAQ,CAAC64B,+BAA+B,IAC/D52B,UAAU,CAACjC,QAAQ,CAAC+C,gBAAgB;QACxC61B,SAAS,CAAC/1B,EAAE,CAAC;MACjB;MACA,IAAI,CAAC2Z,eAAe,CAAC3Z,EAAE,EAAE;QAAE0nB,MAAM,EAAExQ,UAAU,CAACwQ;MAAO,CAAC,EAAE/S,GAAG,CAAC;IAChE,CAAC;IACDshB,KAAK,EAAE,SAAAA,CAAUj2B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MAClC,IAAIuhB,KAAK,GAAG,IAAI;MAChB,IAAI1Y,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACxG,UAAU,CAACqG,YAAY,CAAC;MACrF,IAAI4Y,QAAQ,GAAG,SAAAA,CAAA,EAAY;QACvB,IAAIpzB,IAAI,GAAGya,QAAQ,CAAC4K,QAAQ,CAAC,CAAC;QAC9B8N,KAAK,CAACE,aAAa,CAACp2B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE5R,IAAI,EAAEya,QAAQ,CAAC;MAC5D,CAAC;MACD,IAAItG,UAAU,CAACqG,YAAY,KAAK,GAAG,IAC/B,OAAOmL,SAAS,KAAK,WAAW,IAChC,OAAOA,SAAS,CAACC,SAAS,KAAK,WAAW,IAC1C,OAAOD,SAAS,CAACC,SAAS,CAACC,QAAQ,KAAK,UAAU,EAAE;QACpDF,SAAS,CAACC,SAAS,CAACC,QAAQ,CAAC,CAAC,CAACyN,IAAI,CAAC,UAAU/4B,KAAK,EAAE;UACjD44B,KAAK,CAACE,aAAa,CAACp2B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAErX,KAAK,EAAEkgB,QAAQ,CAAC;QAC7D,CAAC,EAAE,YAAY;UAAE2Y,QAAQ,CAAC,CAAC;QAAE,CAAC,CAAC;MACnC,CAAC,MACI;QACDA,QAAQ,CAAC,CAAC;MACd;IACJ,CAAC;IACDC,aAAa,EAAE,SAAAA,CAAUp2B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE5R,IAAI,EAAEya,QAAQ,EAAE;MAC1D,IAAIiR,GAAG,GAAGtC,UAAU,CAACnsB,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;MACpC,IAAI,CAACtC,IAAI,EAAE;QACP;MACJ;MACA,IAAImU,UAAU,CAACC,WAAW,EAAE;QACxB,IAAIzJ,OAAO,GAAG1N,EAAE,CAAC9F,SAAS,CAAC,SAAS,CAAC;QACrC,IAAIo8B,gBAAgB,GAAG,SAAAA,CAAUljB,GAAG,EAAE;UAClC,IAAImjB,IAAI,GAAInjB,GAAG,CAACgR,KAAK,CAAC,IAAI,CAAC,CAACxpB,MAAM,GAAG,CAAE;UACvC,IAAI47B,MAAM,GAAIpjB,GAAG,CAACgR,KAAK,CAAC,GAAG,CAAC,CAACxpB,MAAM,GAAG,CAAE;UACxC,OAAO27B,IAAI,GAAG7oB,OAAO,GAAG8oB,MAAM,GAAG,CAAC;QACtC,CAAC;QACD,IAAIC,WAAW,GAAGz2B,EAAE,CAACrF,OAAO,CAACqF,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI,CAAC;QACjD,IAAI84B,MAAM,GAAG8C,gBAAgB,CAACG,WAAW,CAAClkB,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3D,IAAImkB,WAAW,GAAG3zB,IAAI,CAAC9H,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;QACzC,IAAI07B,UAAU,GAAG5zB,IAAI,KAAK2zB,WAAW;QACrC,IAAIE,WAAW,GAAGN,gBAAgB,CAACvzB,IAAI,CAACwP,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QACzD,IAAIxP,IAAI,GAAG2zB,WAAW,CAACz7B,OAAO,CAAC,QAAQ,EAAE,UAAU47B,MAAM,EAAE;UACvD,IAAIC,SAAS,GAAGtD,MAAM,IAAI8C,gBAAgB,CAACO,MAAM,CAAC,GAAGD,WAAW,CAAC;UACjE,IAAIE,SAAS,GAAG,CAAC,EAAE;YACf,OAAO,EAAE;UACb,CAAC,MACI,IAAI92B,EAAE,CAAC9F,SAAS,CAAC,gBAAgB,CAAC,EAAE;YACrC,IAAI68B,QAAQ,GAAG18B,IAAI,CAAC6O,KAAK,CAAC4tB,SAAS,GAAGppB,OAAO,CAAC;YAC9C,OAAO5P,KAAK,CAACi5B,QAAQ,GAAG,CAAC,CAAC,CAAC7U,IAAI,CAAC,IAAI,CAAC;UACzC,CAAC,MACI;YACD,OAAOpkB,KAAK,CAACg5B,SAAS,GAAG,CAAC,CAAC,CAAC5U,IAAI,CAAC,GAAG,CAAC;UACzC;QACJ,CAAC,CAAC;QACFnf,IAAI,IAAI4zB,UAAU,GAAG,IAAI,GAAG,EAAE;MAClC;MACA,IAAIzf,UAAU,CAACwQ,MAAM,GAAG,CAAC,EAAE;QACvB,IAAI3kB,IAAI,GAAGjF,KAAK,CAACoZ,UAAU,CAACwQ,MAAM,GAAG,CAAC,CAAC,CAACxF,IAAI,CAACnf,IAAI,CAAC;MACtD;MACA,IAAIyT,QAAQ,GAAGgH,QAAQ,CAAChH,QAAQ;MAChC,IAAIuB,SAAS,GAAGyF,QAAQ,CAACzF,SAAS;MAClC,IAAIA,SAAS,EAAE;QACXhV,IAAI,GAAGA,IAAI,CAACqhB,KAAK,CAAC,IAAI,CAAC;QACvB,IAAI5N,QAAQ,EAAE;UACVzT,IAAI,CAACggB,GAAG,CAAC,CAAC;QACd;QACA,KAAK,IAAI3kB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2E,IAAI,CAACnI,MAAM,EAAEwD,CAAC,EAAE,EAAE;UAClC2E,IAAI,CAAC3E,CAAC,CAAC,GAAI2E,IAAI,CAAC3E,CAAC,CAAC,IAAI,EAAE,GAAI,GAAG,GAAG2E,IAAI,CAAC3E,CAAC,CAAC;QAC7C;QACAqwB,GAAG,CAAC9wB,EAAE,IAAIuZ,UAAU,CAACrb,KAAK,GAAG,CAAC,GAAG,CAAC;QAClC4yB,GAAG,CAAC9wB,EAAE,GAAGtD,IAAI,CAACC,GAAG,CAACkzB,UAAU,CAACxtB,EAAE,EAAEyuB,GAAG,CAAC/zB,IAAI,CAAC,EAAE+zB,GAAG,CAAC9wB,EAAE,CAAC;MACvD,CAAC,MACI,IAAI6Y,QAAQ,EAAE;QACf,IAAI7B,GAAG,CAAC4J,UAAU,EAAE;UAChBxb,IAAI,GAAG4R,GAAG,CAACgD,UAAU,GAAG5U,IAAI,CAACnH,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGmH,IAAI,CAACnH,KAAK,CAAC,CAAC,EAAEmH,IAAI,CAACnI,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI;QAC5F,CAAC,MACI,IAAIsc,UAAU,CAACrb,KAAK,EAAE;UACvBkH,IAAI,GAAG,IAAI,GAAGA,IAAI,CAACnH,KAAK,CAAC,CAAC,EAAEmH,IAAI,CAACnI,MAAM,GAAG,CAAC,CAAC;UAC5C6zB,GAAG,CAAC9wB,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAEyuB,GAAG,CAAC/zB,IAAI,CAAC;QACrC,CAAC,MACI;UACD+zB,GAAG,CAAC9wB,EAAE,GAAG,CAAC;QACd;MACJ,CAAC,MACI;QACD8wB,GAAG,CAAC9wB,EAAE,IAAIuZ,UAAU,CAACrb,KAAK,GAAG,CAAC,GAAG,CAAC;MACtC;MACA,IAAIm7B,WAAW;MACf,IAAIriB,GAAG,CAAC4J,UAAU,EAAE;QAChB5J,GAAG,CAAC+J,cAAc,GAAG3b,IAAI;QACzB,IAAIk0B,mBAAmB;QACvB,IAAIC,YAAY,GAAGC,oBAAoB,CAACn3B,EAAE,EAAE2U,GAAG,CAAC;QAChD,IAAI6P,cAAc,GAAG0S,YAAY,CAAC,CAAC,CAAC;QACpC,IAAI3S,YAAY,GAAG2S,YAAY,CAAC,CAAC,CAAC;QAClC,IAAIE,YAAY,GAAGp3B,EAAE,CAAC+M,YAAY,CAAC,CAAC;QACpC,IAAIyV,UAAU,GAAGxiB,EAAE,CAAC4F,cAAc,CAAC,CAAC;QACpC,IAAIyxB,YAAY,GAAG,IAAIv5B,KAAK,CAAC0kB,UAAU,CAAC5nB,MAAM,CAAC,CAACsnB,IAAI,CAAC,GAAG,CAAC,CAACkC,KAAK,CAAC,GAAG,CAAC;QACpE,IAAIzP,GAAG,CAAC8J,aAAa,EAAE;UACnBwY,mBAAmB,GAAGtiB,GAAG,CAAC8J,aAAa,CAACgX,QAAQ,CAAC/tB,IAAI,CAAC,CAAC;QAC3D;QACA2V,cAAc,CAACI,kBAAkB,CAAC6K,eAAe,CAACN,OAAO,CAACoP,YAAY,CAAC;QACvE,IAAIrf,SAAS,EAAE;UACX/X,EAAE,CAAC6M,iBAAiB,CAACwqB,YAAY,CAAC;UAClC9S,YAAY,GAAG,IAAI3kB,GAAG,CAAC4kB,cAAc,CAAC9pB,IAAI,GAAGqI,IAAI,CAACnI,MAAM,GAAG,CAAC,EAAE4pB,cAAc,CAAC7mB,EAAE,CAAC;UAChFqC,EAAE,CAAC+E,SAAS,CAACyf,cAAc,CAAC;UAC5B8S,WAAW,CAACt3B,EAAE,EAAEukB,YAAY,CAAC;UAC7BvkB,EAAE,CAAC6M,iBAAiB,CAAC9J,IAAI,CAAC;UAC1Bi0B,WAAW,GAAGxS,cAAc;QAChC,CAAC,MACI,IAAI7P,GAAG,CAAC6J,WAAW,EAAE;UACtBxe,EAAE,CAAC6M,iBAAiB,CAACwqB,YAAY,CAAC;UAClCr3B,EAAE,CAAC+E,SAAS,CAACyf,cAAc,CAAC;UAC5BxkB,EAAE,CAACvE,YAAY,CAACsH,IAAI,EAAEyhB,cAAc,EAAEA,cAAc,CAAC;UACrDwS,WAAW,GAAGxS,cAAc;QAChC,CAAC,MACI;UACDxkB,EAAE,CAACvE,YAAY,CAACsH,IAAI,EAAEyhB,cAAc,EAAED,YAAY,CAAC;UACnDyS,WAAW,GAAGh3B,EAAE,CAACsQ,YAAY,CAACtQ,EAAE,CAACoQ,YAAY,CAACoU,cAAc,CAAC,GAAGzhB,IAAI,CAACnI,MAAM,GAAG,CAAC,CAAC;QACpF;QACA,IAAIq8B,mBAAmB,EAAE;UACrBtiB,GAAG,CAAC8J,aAAa,CAACgX,QAAQ,GAAGz1B,EAAE,CAACqI,WAAW,CAAC4uB,mBAAmB,CAAC;QACpE;QACA,IAAIzgB,QAAQ,EAAE;UACVwgB,WAAW,CAACr5B,EAAE,GAAG,CAAC;QACtB;MACJ,CAAC,MACI;QACD,IAAIoa,SAAS,EAAE;UACX/X,EAAE,CAAC+E,SAAS,CAAC0pB,GAAG,CAAC;UACjB,KAAK,IAAIrwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2E,IAAI,CAACnI,MAAM,EAAEwD,CAAC,EAAE,EAAE;YAClC,IAAI1D,IAAI,GAAG+zB,GAAG,CAAC/zB,IAAI,GAAG0D,CAAC;YACvB,IAAI1D,IAAI,GAAGsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC,EAAE;cACtB5E,EAAE,CAACvE,YAAY,CAAC,IAAI,EAAE,IAAImE,GAAG,CAAClF,IAAI,EAAE,CAAC,CAAC,CAAC;YAC3C;YACA,IAAI68B,MAAM,GAAG/J,UAAU,CAACxtB,EAAE,EAAEtF,IAAI,CAAC;YACjC,IAAI68B,MAAM,GAAG9I,GAAG,CAAC9wB,EAAE,EAAE;cACjB65B,kBAAkB,CAACx3B,EAAE,EAAEtF,IAAI,EAAE+zB,GAAG,CAAC9wB,EAAE,CAAC;YACxC;UACJ;UACAqC,EAAE,CAAC+E,SAAS,CAAC0pB,GAAG,CAAC;UACjB6I,WAAW,CAACt3B,EAAE,EAAE,IAAIJ,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,GAAGqI,IAAI,CAACnI,MAAM,GAAG,CAAC,EAAE6zB,GAAG,CAAC9wB,EAAE,CAAC,CAAC;UAC5DqC,EAAE,CAAC6M,iBAAiB,CAAC9J,IAAI,CAAC;UAC1Bi0B,WAAW,GAAGvI,GAAG;QACrB,CAAC,MACI;UACDzuB,EAAE,CAACvE,YAAY,CAACsH,IAAI,EAAE0rB,GAAG,CAAC;UAC1B,IAAIjY,QAAQ,EAAE;YACV,IAAI9b,IAAI,GAAGwc,UAAU,CAACrb,KAAK,GAAG4yB,GAAG,CAAC/zB,IAAI,GAAG,CAAC,GAAG+zB,GAAG,CAAC/zB,IAAI;YACrDs8B,WAAW,GAAG,IAAIp3B,GAAG,CAAClF,IAAI,EAAE0zB,+BAA+B,CAACpuB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC,CAAC,CAAC;UAClF,CAAC,MACI;YACDs8B,WAAW,GAAG7K,UAAU,CAACsC,GAAG,CAAC;YAC7B,IAAI,CAAC,IAAI,CAACrzB,IAAI,CAAC2H,IAAI,CAAC,EAAE;cAClBi0B,WAAW,CAACr5B,EAAE,IAAIoF,IAAI,CAACnI,MAAM,IAAIsc,UAAU,CAACrb,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;YAC9D;UACJ;QACJ;MACJ;MACA,IAAI8Y,GAAG,CAAC4J,UAAU,EAAE;QAChBuD,cAAc,CAAC9hB,EAAE,EAAE,KAAK,CAAC;MAC7B;MACAA,EAAE,CAAC+E,SAAS,CAACiyB,WAAW,CAAC;IAC7B,CAAC;IACD/2B,IAAI,EAAE,SAAAA,CAAUD,EAAE,EAAEkX,UAAU,EAAE;MAC5BlX,EAAE,CAAC8D,SAAS,CAAC,YAAY;QACrB2zB,QAAQ,CAACz3B,EAAE,EAAEZ,UAAU,CAACjC,QAAQ,CAAC8C,IAAI,EAAEiX,UAAU,CAACwQ,MAAM,CAAC,CAAC,CAAC;QAC3D1nB,EAAE,CAAC+E,SAAS,CAACqnB,mBAAmB,CAACpsB,EAAE,EAAEA,EAAE,CAACqF,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;MAChE,CAAC,CAAC;IACN,CAAC;IACDtF,IAAI,EAAE,SAAAA,CAAUC,EAAE,EAAEkX,UAAU,EAAE;MAC5BugB,QAAQ,CAACz3B,EAAE,EAAEZ,UAAU,CAACjC,QAAQ,CAAC4C,IAAI,EAAEmX,UAAU,CAACwQ,MAAM,CAAC,CAAC,CAAC;IAC/D,CAAC;IACDgQ,WAAW,EAAE,SAAAA,CAAUlJ,GAAG,EAAEtX,UAAU,EAAEvC,GAAG,EAAE;MACzCA,GAAG,CAACmJ,UAAU,CAACP,YAAY,GAAGrG,UAAU,CAACgI,iBAAiB;IAC9D,CAAC;IACDyY,cAAc,EAAE,SAAAA,CAAU33B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MAC3C,IAAI4I,YAAY,GAAGrG,UAAU,CAACgI,iBAAiB;MAC/C,IAAI1B,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACH,YAAY,CAAC;MAC1E,IAAIxa,IAAI,GAAGya,QAAQ,IAAIA,QAAQ,CAAC4K,QAAQ,CAAC,CAAC;MAC1C,IAAIrlB,IAAI,EAAE;QACN/C,EAAE,CAAC4M,gBAAgB,CAAC7J,IAAI,CAAC;MAC7B;IACJ,CAAC;IACD60B,gBAAgB,EAAE,SAAAA,CAAU53B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MAC7CoN,cAAc,CAAC/hB,EAAE,EAAE,IAAI,CAAC;MACxB2U,GAAG,CAAC0J,gBAAgB,GAAG,IAAI;MAC3Bjf,UAAU,CAAChC,EAAE,CAAC4C,EAAE,EAAE,kBAAkB,EAAE,SAAS63B,OAAOA,CAAA,EAAG;QACrD,IAAIljB,GAAG,CAAC4J,UAAU,EACd;QACJ,IAAI5J,GAAG,CAAC0J,gBAAgB,EAAE;UACtB1J,GAAG,CAAC0J,gBAAgB,GAAG,KAAK;UAC5B,IAAI,CAAC1J,GAAG,CAAC6E,UAAU,EAAE;YACjBE,OAAO,CAACC,eAAe,CAAC3Z,EAAE,EAAE,CAAC,CAAC,EAAE2U,GAAG,CAAC;UACxC;QACJ;QACAvV,UAAU,CAAC/B,GAAG,CAAC2C,EAAE,EAAE,kBAAkB,EAAE63B,OAAO,CAAC;MACnD,CAAC,CAAC;IACN,CAAC;IACDC,OAAO,EAAE,SAAAA,CAAU93B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACpC,IAAIojB,QAAQ,GAAG7gB,UAAU,CAACgI,iBAAiB;MAC3C6N,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAEojB,QAAQ,EAAE/3B,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;IACjD,CAAC;IACDpK,OAAO,EAAE,SAAAA,CAAU+E,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MACpC,IAAIqjB,WAAW,GAAG9gB,UAAU,CAACgI,iBAAiB;MAC9C,IAAIpJ,QAAQ,GAAG9V,EAAE,CAACqF,SAAS,CAAC,CAAC;MAC7B,IAAI4yB,SAAS;MACb,IAAIliB,MAAM;MACV,IAAIyM,UAAU,GAAGxiB,EAAE,CAAC4F,cAAc,CAAC,CAAC;MACpC,IAAI+O,GAAG,CAAC4J,UAAU,EAAE;QAChBzI,QAAQ,GAAG9V,EAAE,CAACqF,SAAS,CAAC,OAAO,CAAC;QAChC0Q,MAAM,GAAG/V,EAAE,CAACqF,SAAS,CAAC,KAAK,CAAC;MAChC,CAAC,MACI;QACD,IAAI3K,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACmb,QAAQ,CAACpb,IAAI,CAAC;QACpCu9B,SAAS,GAAGniB,QAAQ,CAACnY,EAAE,GAAGuZ,UAAU,CAACwQ,MAAM;QAC3C,IAAIuQ,SAAS,GAAGv9B,IAAI,CAACE,MAAM,EAAE;UACzBq9B,SAAS,GAAGv9B,IAAI,CAACE,MAAM;QAC3B;QACAmb,MAAM,GAAG,IAAInW,GAAG,CAACkW,QAAQ,CAACpb,IAAI,EAAEu9B,SAAS,CAAC;MAC9C;MACA,IAAI3K,YAAY,GAAGzX,qCAAqC,CAAC7V,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,CAAC;MAC9ED,QAAQ,GAAGwX,YAAY,CAACpyB,KAAK;MAC7B6a,MAAM,GAAGuX,YAAY,CAACnyB,GAAG;MACzB,IAAI68B,WAAW,IAAI,IAAI,EAAE;QACrB,IAAI,CAACrjB,GAAG,CAAC4J,UAAU,EACfve,EAAE,CAACvE,YAAY,CAAC,EAAE,EAAEqa,QAAQ,EAAEC,MAAM,CAAC;QACzC,CAAC3W,UAAU,CAACjC,QAAQ,CAAC64B,+BAA+B,IAAI52B,UAAU,CAACjC,QAAQ,CAAC+C,gBAAgB,EAAEF,EAAE,CAAC;MACrG,CAAC,MACI;QACD,IAAIk4B,cAAc,GAAGl4B,EAAE,CAAC0F,QAAQ,CAACoQ,QAAQ,EAAEC,MAAM,CAAC;QAClDmiB,cAAc,GAAGA,cAAc,CAACj9B,OAAO,CAAC,iCAAiC,EAAE+8B,WAAW,CAAC;QACvFE,cAAc,GAAGA,cAAc,CAACj9B,OAAO,CAAC,QAAQ,EAAE+8B,WAAW,CAAC;QAC9D,IAAIrjB,GAAG,CAAC6J,WAAW,EAAE;UACjB,IAAIgY,MAAM,GAAG,IAAI14B,KAAK,CAACkC,EAAE,CAAC9F,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAACgoB,IAAI,CAAC,GAAG,CAAC;UAC7DgW,cAAc,GAAGl4B,EAAE,CAAC+M,YAAY,CAAC,CAAC;UAClCmrB,cAAc,GAAGA,cAAc,CAACj9B,OAAO,CAAC,iCAAiC,EAAE+8B,WAAW,CAAC;UACvFE,cAAc,GAAGA,cAAc,CAACj9B,OAAO,CAAC,KAAK,EAAEu7B,MAAM,CAAC,CAACv7B,OAAO,CAAC,QAAQ,EAAE+8B,WAAW,CAAC,CAAC5T,KAAK,CAAC,IAAI,CAAC;UACjGpkB,EAAE,CAAC6M,iBAAiB,CAACqrB,cAAc,CAAC;QACxC,CAAC,MACI;UACDl4B,EAAE,CAACvE,YAAY,CAACy8B,cAAc,EAAEpiB,QAAQ,EAAEC,MAAM,CAAC;QACrD;QACA,IAAIpB,GAAG,CAAC4J,UAAU,EAAE;UAChBzI,QAAQ,GAAGkX,cAAc,CAACxK,UAAU,CAAC,CAAC,CAAC,CAAC5kB,MAAM,EAAE4kB,UAAU,CAAC,CAAC,CAAC,CAAC3kB,IAAI,CAAC,GAC/D2kB,UAAU,CAAC,CAAC,CAAC,CAAC5kB,MAAM,GAAG4kB,UAAU,CAAC,CAAC,CAAC,CAAC3kB,IAAI;UAC7CmC,EAAE,CAAC+E,SAAS,CAAC+Q,QAAQ,CAAC;UACtBgM,cAAc,CAAC9hB,EAAE,EAAE,KAAK,CAAC;QAC7B,CAAC,MACI;UACDA,EAAE,CAAC+E,SAAS,CAAC0U,YAAY,CAAC1D,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7C;MACJ;IACJ,CAAC;IACDoiB,oBAAoB,EAAE,SAAAA,CAAUn4B,EAAE,EAAEkX,UAAU,EAAE;MAC5C,IAAIuX,GAAG,GAAGzuB,EAAE,CAACqF,SAAS,CAAC,CAAC;MACxB,IAAI+yB,OAAO,GAAGp4B,EAAE,CAACrF,OAAO,CAAC8zB,GAAG,CAAC/zB,IAAI,CAAC;MAClC,IAAIiU,EAAE,GAAG,uCAAuC;MAChD,IAAI4D,KAAK;MACT,IAAIrX,KAAK;MACT,IAAIC,GAAG;MACP,IAAIk9B,SAAS;MACb,OAAO,CAAC9lB,KAAK,GAAG5D,EAAE,CAAC3T,IAAI,CAACo9B,OAAO,CAAC,MAAM,IAAI,EAAE;QACxCl9B,KAAK,GAAGqX,KAAK,CAACvW,KAAK;QACnBb,GAAG,GAAGD,KAAK,GAAGqX,KAAK,CAAC,CAAC,CAAC,CAAC3X,MAAM;QAC7B,IAAI6zB,GAAG,CAAC9wB,EAAE,GAAGxC,GAAG,EACZ;MACR;MACA,IAAI,CAAC+b,UAAU,CAACmB,SAAS,IAAKld,GAAG,IAAIszB,GAAG,CAAC9wB,EAAG,EACxC;MACJ,IAAI4U,KAAK,EAAE;QACP,IAAI+lB,OAAO,GAAG/lB,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC;QAClC,IAAIgmB,MAAM,GAAGhmB,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC;QACjC,IAAI9J,SAAS,GAAGyO,UAAU,CAACkB,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;QAC5C,IAAIogB,IAAI,GAAG;UAAE,IAAI,EAAE,CAAC;UAAE,GAAG,EAAE,CAAC;UAAE,EAAE,EAAE,EAAE;UAAE,IAAI,EAAE;QAAG,CAAC,CAACF,OAAO,CAACh3B,WAAW,CAAC,CAAC,CAAC;QACvE,IAAIm3B,MAAM,GAAG9Q,QAAQ,CAACpV,KAAK,CAAC,CAAC,CAAC,GAAGgmB,MAAM,EAAEC,IAAI,CAAC,GAAI/vB,SAAS,GAAGyO,UAAU,CAACwQ,MAAO;QAChF2Q,SAAS,GAAGI,MAAM,CAACrQ,QAAQ,CAACoQ,IAAI,CAAC;QACjC,IAAIE,WAAW,GAAGJ,OAAO,GAAG,IAAIx6B,KAAK,CAACy6B,MAAM,CAAC39B,MAAM,GAAGy9B,SAAS,CAACz9B,MAAM,GAAG,CAAC,GAAG2X,KAAK,CAAC,CAAC,CAAC,CAAC3X,MAAM,CAAC,CAACsnB,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;QAC5G,IAAImW,SAAS,CAAChmB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC7BgmB,SAAS,GAAG,GAAG,GAAGC,OAAO,GAAGI,WAAW,GAAGL,SAAS,CAAChlB,MAAM,CAAC,CAAC,CAAC;QACjE,CAAC,MACI;UACDglB,SAAS,GAAGC,OAAO,GAAGI,WAAW,GAAGL,SAAS;QACjD;QACA,IAAI1sB,IAAI,GAAG,IAAI/L,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAEQ,KAAK,CAAC;QACnC,IAAI0Q,EAAE,GAAG,IAAIhM,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAES,GAAG,CAAC;QAC/B6E,EAAE,CAACvE,YAAY,CAAC48B,SAAS,EAAE1sB,IAAI,EAAEC,EAAE,CAAC;MACxC,CAAC,MACI;QACD;MACJ;MACA5L,EAAE,CAAC+E,SAAS,CAAC,IAAInF,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAEQ,KAAK,GAAGm9B,SAAS,CAACz9B,MAAM,GAAG,CAAC,CAAC,CAAC;IACjE,CAAC;IACD+9B,cAAc,EAAE,SAAAA,CAAU34B,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;MAC3C,IAAIqJ,kBAAkB,GAAGrJ,GAAG,CAACqJ,kBAAkB;MAC/C,IAAI,CAACA,kBAAkB,EAAE;QACrB;MACJ;MACA,IAAI0J,MAAM,GAAGxQ,UAAU,CAACwQ,MAAM;MAC9B,IAAIA,MAAM,IAAIxQ,UAAU,CAACsT,gBAAgB,EAAE;QACvC7V,GAAG,CAACqJ,kBAAkB,CAAC8L,cAAc,GAAGpC,MAAM;MAClD,CAAC,MACI;QACDA,MAAM,GAAG/S,GAAG,CAACqJ,kBAAkB,CAAC8L,cAAc,IAAIpC,MAAM;MAC5D;MACAiR,cAAc,CAAC34B,EAAE,EAAE2U,GAAG,EAAE+S,MAAM,EAAE,KAAK,CAAC,sBAAsB,CAAC;IACjE,CAAC;IACD8L,MAAM,EAAE,SAAAA,CAAUxzB,EAAE,EAAEkX,UAAU,EAAE;MAC9BlX,EAAE,CAACgQ,UAAU,CAAChQ,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI,EAAEwc,UAAU,CAACK,WAAW,CAAC;IAC9D,CAAC;IACDwK,cAAc,EAAEA;EACpB,CAAC;EACD,SAAS4B,YAAYA,CAACvnB,IAAI,EAAE2H,EAAE,EAAE;IAC5B2V,OAAO,CAACtd,IAAI,CAAC,GAAG2H,EAAE;EACtB;EACA,SAASqoB,mBAAmBA,CAACpsB,EAAE,EAAEyuB,GAAG,EAAE9S,MAAM,EAAE;IAC1C,IAAIhH,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,IAAIikB,gBAAgB,GAAGjkB,GAAG,CAAC6E,UAAU,IAAI7E,GAAG,CAAC4J,UAAU;IACvD,IAAI7jB,IAAI,GAAGL,IAAI,CAACC,GAAG,CAACD,IAAI,CAACL,GAAG,CAACgG,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE8pB,GAAG,CAAC/zB,IAAI,CAAC,EAAEsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC,CAAC;IACtE,IAAI7B,IAAI,GAAG/C,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC;IAC3B,IAAIm+B,KAAK,GAAG91B,IAAI,CAACnI,MAAM,GAAG,CAAC,GAAGmQ,MAAM,CAAC,CAAC,CAAC6tB,gBAAgB,CAAC;IACxD,IAAIj7B,EAAE,GAAGtD,IAAI,CAACC,GAAG,CAACD,IAAI,CAACL,GAAG,CAAC,CAAC,EAAEy0B,GAAG,CAAC9wB,EAAE,CAAC,EAAEk7B,KAAK,CAAC;IAC7C,IAAI7iB,QAAQ,GAAGjT,IAAI,CAACkT,UAAU,CAACtY,EAAE,CAAC;IAClC,IAAI,MAAM,IAAIqY,QAAQ,IAAIA,QAAQ,IAAI,MAAM,EAAE;MAC1C,IAAI8iB,SAAS,GAAG,CAAC;MACjB,IAAInd,MAAM,IAAIA,MAAM,CAACjhB,IAAI,IAAIA,IAAI,IAAIihB,MAAM,CAAChe,EAAE,GAAGA,EAAE,EAAE;QACjDm7B,SAAS,GAAG,CAAC,CAAC;MAClB;MACAn7B,EAAE,IAAIm7B,SAAS;MACf,IAAIn7B,EAAE,GAAGk7B,KAAK,EACVl7B,EAAE,IAAI,CAAC;IACf;IACA,OAAO,IAAIiC,GAAG,CAAClF,IAAI,EAAEiD,EAAE,CAAC;EAC5B;EACA,SAAS0sB,QAAQA,CAAChuB,IAAI,EAAE;IACpB,IAAI08B,GAAG,GAAG,CAAC,CAAC;IACZ,KAAK,IAAIC,IAAI,IAAI38B,IAAI,EAAE;MACnB,IAAIA,IAAI,CAAC+U,cAAc,CAAC4nB,IAAI,CAAC,EAAE;QAC3BD,GAAG,CAACC,IAAI,CAAC,GAAG38B,IAAI,CAAC28B,IAAI,CAAC;MAC1B;IACJ;IACA,OAAOD,GAAG;EACd;EACA,SAAStf,YAAYA,CAACgV,GAAG,EAAEwK,UAAU,EAAEC,QAAQ,EAAE;IAC7C,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE;MAChCC,QAAQ,GAAGD,UAAU,CAACt7B,EAAE;MACxBs7B,UAAU,GAAGA,UAAU,CAACv+B,IAAI;IAChC;IACA,OAAO,IAAIkF,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,GAAGu+B,UAAU,EAAExK,GAAG,CAAC9wB,EAAE,GAAGu7B,QAAQ,CAAC;EAC5D;EACA,SAAS1P,cAAcA,CAACrT,IAAI,EAAE3V,MAAM,EAAE6V,OAAO,EAAEyH,UAAU,EAAE;IACvD,IAAIA,UAAU,CAACzG,QAAQ,EACnBhB,OAAO,GAAG,iBAAiB;IAC/B,IAAI9D,KAAK;MAAEmX,OAAO,GAAG,EAAE;MAAED,IAAI,GAAG,EAAE;IAClC,IAAI0P,UAAU,GAAG7Y,OAAO,GAAG9f,MAAM,CAAC5F,MAAM,GAAG8d,mBAAmB,GAAG,CAAC;IAClE,KAAK,IAAIta,CAAC,GAAG+6B,UAAU,EAAE/6B,CAAC,GAAGoC,MAAM,CAAC5F,MAAM,EAAEwD,CAAC,EAAE,EAAE;MAC7C,IAAIjC,OAAO,GAAGqE,MAAM,CAACpC,CAAC,CAAC;MACvB,IAAIiY,OAAO,IAAI,QAAQ,IAAIla,OAAO,CAACka,OAAO,IAAI,QAAQ,IACjDla,OAAO,CAACka,OAAO,IAAIla,OAAO,CAACka,OAAO,IAAIA,OAAQ,IAC/CyH,UAAU,CAACzG,QAAQ,IAAIlb,OAAO,CAACsT,IAAI,IAAI,QAAQ,IAC/C,EAAE8C,KAAK,GAAG6mB,YAAY,CAACjjB,IAAI,EAAEha,OAAO,CAACga,IAAI,CAAC,CAAC,EAAE;QAC7C;MACJ;MACA,IAAI5D,KAAK,IAAI,SAAS,EAAE;QACpBmX,OAAO,CAAC7mB,IAAI,CAAC1G,OAAO,CAAC;MACzB;MACA,IAAIoW,KAAK,IAAI,MAAM,EAAE;QACjBkX,IAAI,CAAC5mB,IAAI,CAAC1G,OAAO,CAAC;MACtB;IACJ;IACA,OAAO;MACHutB,OAAO,EAAEA,OAAO,CAAC9uB,MAAM,IAAI8uB,OAAO;MAClCD,IAAI,EAAEA,IAAI,CAAC7uB,MAAM,IAAI6uB;IACzB,CAAC;EACL;EACA,SAAS2P,YAAYA,CAACC,OAAO,EAAEC,MAAM,EAAE;IACnC,IAAIC,eAAe,GAAGD,MAAM,CAAC19B,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,aAAa;IACxD,IAAI49B,cAAc,GAAGF,MAAM,CAAC19B,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,YAAY;IACtD,IAAI29B,eAAe,IAAIC,cAAc,EAAE;MACnC,IAAIC,SAAS,GAAGH,MAAM,CAAC1+B,MAAM,IAAI2+B,eAAe,GAAG,EAAE,GAAG,EAAE,CAAC;MAC3D,IAAIG,aAAa,GAAGL,OAAO,CAACz9B,KAAK,CAAC,CAAC,EAAE69B,SAAS,CAAC;MAC/C,IAAIE,YAAY,GAAGL,MAAM,CAAC19B,KAAK,CAAC,CAAC,EAAE69B,SAAS,CAAC;MAC7C,OAAOC,aAAa,IAAIC,YAAY,IAAIN,OAAO,CAACz+B,MAAM,GAAG6+B,SAAS,GAAG,MAAM,GACvEE,YAAY,CAAC9mB,OAAO,CAAC6mB,aAAa,CAAC,IAAI,CAAC,GAAG,SAAS,GAAG,KAAK;IACpE,CAAC,MACI;MACD,OAAOL,OAAO,IAAIC,MAAM,GAAG,MAAM,GAC7BA,MAAM,CAACzmB,OAAO,CAACwmB,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS,GAAG,KAAK;IACxD;EACJ;EACA,SAASxP,QAAQA,CAAC1T,IAAI,EAAE;IACpB,IAAI5D,KAAK,GAAG,eAAe,CAACvX,IAAI,CAACmb,IAAI,CAAC;IACtC,IAAI+I,iBAAiB,GAAG3M,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG4D,IAAI,CAACva,KAAK,CAAC,CAAC,CAAC,CAAC;IACzD,IAAIsjB,iBAAiB,CAACtkB,MAAM,GAAG,CAAC,EAAE;MAC9B,QAAQskB,iBAAiB;QACrB,KAAK,MAAM;UACPA,iBAAiB,GAAG,IAAI;UACxB;QACJ,KAAK,SAAS;UACVA,iBAAiB,GAAG,GAAG;UACvB;QACJ;UACIA,iBAAiB,GAAG,EAAE;UACtB;MACR;IACJ;IACA,OAAOA,iBAAiB;EAC5B;EACA,SAASuY,QAAQA,CAACz3B,EAAE,EAAE+D,EAAE,EAAE2jB,MAAM,EAAE;IAC9B,OAAO,YAAY;MACf,KAAK,IAAItpB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;QAC7B2F,EAAE,CAAC/D,EAAE,CAAC;MACV;IACJ,CAAC;EACL;EACA,SAASmsB,UAAUA,CAACsC,GAAG,EAAE;IACrB,OAAO,IAAI7uB,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAE+zB,GAAG,CAAC9wB,EAAE,CAAC;EACpC;EACA,SAASse,WAAWA,CAAC2d,IAAI,EAAEC,IAAI,EAAE;IAC7B,OAAOD,IAAI,CAACj8B,EAAE,IAAIk8B,IAAI,CAACl8B,EAAE,IAAIi8B,IAAI,CAACl/B,IAAI,IAAIm/B,IAAI,CAACn/B,IAAI;EACvD;EACA,SAASsyB,cAAcA,CAAC4M,IAAI,EAAEC,IAAI,EAAE;IAChC,IAAID,IAAI,CAACl/B,IAAI,GAAGm/B,IAAI,CAACn/B,IAAI,EAAE;MACvB,OAAO,IAAI;IACf;IACA,IAAIk/B,IAAI,CAACl/B,IAAI,IAAIm/B,IAAI,CAACn/B,IAAI,IAAIk/B,IAAI,CAACj8B,EAAE,GAAGk8B,IAAI,CAACl8B,EAAE,EAAE;MAC7C,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA,SAASilB,SAASA,CAACgX,IAAI,EAAEC,IAAI,EAAE;IAC3B,IAAIx7B,SAAS,CAACzD,MAAM,GAAG,CAAC,EAAE;MACtBi/B,IAAI,GAAGjX,SAAS,CAACkX,KAAK,CAAChvB,SAAS,EAAEhN,KAAK,CAACd,SAAS,CAACpB,KAAK,CAAC+V,IAAI,CAACtT,SAAS,EAAE,CAAC,CAAC,CAAC;IAC/E;IACA,OAAO2uB,cAAc,CAAC4M,IAAI,EAAEC,IAAI,CAAC,GAAGD,IAAI,GAAGC,IAAI;EACnD;EACA,SAAShX,SAASA,CAAC+W,IAAI,EAAEC,IAAI,EAAE;IAC3B,IAAIx7B,SAAS,CAACzD,MAAM,GAAG,CAAC,EAAE;MACtBi/B,IAAI,GAAGhX,SAAS,CAACiX,KAAK,CAAChvB,SAAS,EAAEhN,KAAK,CAACd,SAAS,CAACpB,KAAK,CAAC+V,IAAI,CAACtT,SAAS,EAAE,CAAC,CAAC,CAAC;IAC/E;IACA,OAAO2uB,cAAc,CAAC4M,IAAI,EAAEC,IAAI,CAAC,GAAGA,IAAI,GAAGD,IAAI;EACnD;EACA,SAASnK,eAAeA,CAACmK,IAAI,EAAEC,IAAI,EAAEE,IAAI,EAAE;IACvC,IAAIC,WAAW,GAAGhN,cAAc,CAAC4M,IAAI,EAAEC,IAAI,CAAC;IAC5C,IAAII,WAAW,GAAGjN,cAAc,CAAC6M,IAAI,EAAEE,IAAI,CAAC;IAC5C,OAAOC,WAAW,IAAIC,WAAW;EACrC;EACA,SAASzM,UAAUA,CAACxtB,EAAE,EAAEgyB,OAAO,EAAE;IAC7B,OAAOhyB,EAAE,CAACrF,OAAO,CAACq3B,OAAO,CAAC,CAACp3B,MAAM;EACrC;EACA,SAASs/B,IAAIA,CAACxtB,CAAC,EAAE;IACb,IAAIA,CAAC,CAACwtB,IAAI,EAAE;MACR,OAAOxtB,CAAC,CAACwtB,IAAI,CAAC,CAAC;IACnB;IACA,OAAOxtB,CAAC,CAACzR,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;EACtC;EACA,SAAS+wB,WAAWA,CAACtf,CAAC,EAAE;IACpB,OAAOA,CAAC,CAACzR,OAAO,CAAC,2BAA2B,EAAE,MAAM,CAAC;EACzD;EACA,SAASu8B,kBAAkBA,CAACx3B,EAAE,EAAEgyB,OAAO,EAAE/3B,MAAM,EAAE;IAC7C,IAAI21B,KAAK,GAAGpC,UAAU,CAACxtB,EAAE,EAAEgyB,OAAO,CAAC;IACnC,IAAIwE,MAAM,GAAG,IAAI14B,KAAK,CAAC7D,MAAM,GAAG21B,KAAK,GAAG,CAAC,CAAC,CAAC1N,IAAI,CAAC,GAAG,CAAC;IACpDliB,EAAE,CAAC+E,SAAS,CAAC,IAAInF,GAAG,CAACoyB,OAAO,EAAEpC,KAAK,CAAC,CAAC;IACrC5vB,EAAE,CAACvE,YAAY,CAAC+6B,MAAM,EAAEx2B,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;EAC3C;EACA,SAASiyB,WAAWA,CAACt3B,EAAE,EAAEukB,YAAY,EAAE;IACnC,IAAI/B,UAAU,GAAG,EAAE;MAAE3c,MAAM,GAAG7F,EAAE,CAAC4F,cAAc,CAAC,CAAC;IACjD,IAAI/H,IAAI,GAAGsuB,UAAU,CAACnsB,EAAE,CAACiG,OAAO,CAACse,YAAY,CAAC,CAAC;IAC/C,IAAI4V,SAAS,GAAG,CAACle,WAAW,CAACsI,YAAY,EAAE1mB,IAAI,CAAC;IAChD,IAAIu8B,OAAO,GAAGp6B,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;IAClC,IAAIc,SAAS,GAAGk0B,QAAQ,CAACx0B,MAAM,EAAEu0B,OAAO,CAAC;IACzC,IAAIE,UAAU,GAAGre,WAAW,CAACpW,MAAM,CAACM,SAAS,CAAC,CAACtI,IAAI,EAAEgI,MAAM,CAACM,SAAS,CAAC,CAACvI,MAAM,CAAC;IAC9E,IAAI5D,GAAG,GAAG6L,MAAM,CAACjL,MAAM,GAAG,CAAC;IAC3B,IAAIoB,KAAK,GAAGhC,GAAG,GAAGmM,SAAS,GAAGA,SAAS,GAAGnM,GAAG,GAAG,CAAC;IACjD,IAAIw+B,IAAI,GAAG3yB,MAAM,CAAC7J,KAAK,CAAC,CAAC4B,MAAM;IAC/B,IAAI+G,SAAS,GAAGtK,IAAI,CAACC,GAAG,CAACk+B,IAAI,CAAC99B,IAAI,EAAEmD,IAAI,CAACnD,IAAI,CAAC;IAC9C,IAAIkK,QAAQ,GAAGvK,IAAI,CAACL,GAAG,CAACw+B,IAAI,CAAC99B,IAAI,EAAEmD,IAAI,CAACnD,IAAI,CAAC;IAC7C,IAAI6/B,MAAM,GAAG/B,IAAI,CAAC76B,EAAE;MAAE68B,MAAM,GAAG38B,IAAI,CAACF,EAAE;IACtC,IAAIiT,GAAG,GAAG/K,MAAM,CAAC7J,KAAK,CAAC,CAAC6B,IAAI,CAACF,EAAE,GAAG48B,MAAM;IACxC,IAAIE,MAAM,GAAGD,MAAM,GAAGD,MAAM;IAC5B,IAAI3pB,GAAG,GAAG,CAAC,IAAI6pB,MAAM,IAAI,CAAC,EAAE;MACxBF,MAAM,EAAE;MACR,IAAI,CAACJ,SAAS,EAAE;QACZK,MAAM,EAAE;MACZ;IACJ,CAAC,MACI,IAAI5pB,GAAG,GAAG,CAAC,IAAI6pB,MAAM,IAAI,CAAC,EAAE;MAC7BF,MAAM,EAAE;MACR,IAAI,CAACD,UAAU,EAAE;QACbE,MAAM,EAAE;MACZ;IACJ,CAAC,MACI,IAAI5pB,GAAG,GAAG,CAAC,IAAI6pB,MAAM,IAAI,CAAC,CAAC,EAAE;MAC9BF,MAAM,EAAE;MACRC,MAAM,EAAE;IACZ;IACA,KAAK,IAAI9/B,IAAI,GAAGiK,SAAS,EAAEjK,IAAI,IAAIkK,QAAQ,EAAElK,IAAI,EAAE,EAAE;MACjD,IAAIkM,KAAK,GAAG;QAAEhJ,MAAM,EAAE,IAAIgC,GAAG,CAAClF,IAAI,EAAE6/B,MAAM,CAAC;QAAE18B,IAAI,EAAE,IAAI+B,GAAG,CAAClF,IAAI,EAAE8/B,MAAM;MAAE,CAAC;MAC1EhY,UAAU,CAAC3f,IAAI,CAAC+D,KAAK,CAAC;IAC1B;IACA5G,EAAE,CAACkG,aAAa,CAACsc,UAAU,CAAC;IAC5B+B,YAAY,CAAC5mB,EAAE,GAAG68B,MAAM;IACxBhC,IAAI,CAAC76B,EAAE,GAAG48B,MAAM;IAChB,OAAO/B,IAAI;EACf;EACA,SAASrD,eAAeA,CAACn1B,EAAE,EAAEnC,IAAI,EAAEsL,MAAM,EAAE;IACvC,IAAI7D,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIlH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+K,MAAM,EAAE/K,CAAC,EAAE,EAAE;MAC7B,IAAIs8B,QAAQ,GAAGjhB,YAAY,CAAC5b,IAAI,EAAEO,CAAC,EAAE,CAAC,CAAC;MACvCkH,GAAG,CAACzC,IAAI,CAAC;QAAEjF,MAAM,EAAE88B,QAAQ;QAAE78B,IAAI,EAAE68B;MAAS,CAAC,CAAC;IAClD;IACA16B,EAAE,CAACkG,aAAa,CAACZ,GAAG,EAAE,CAAC,CAAC;EAC5B;EACA,SAAS+0B,QAAQA,CAACx0B,MAAM,EAAEvJ,MAAM,EAAEnB,GAAG,EAAE;IACnC,KAAK,IAAIiD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyH,MAAM,CAACjL,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACpC,IAAIu8B,QAAQ,GAAGx/B,GAAG,IAAI,MAAM,IAAI8gB,WAAW,CAACpW,MAAM,CAACzH,CAAC,CAAC,CAACR,MAAM,EAAEtB,MAAM,CAAC;MACrE,IAAIs+B,MAAM,GAAGz/B,GAAG,IAAI,QAAQ,IAAI8gB,WAAW,CAACpW,MAAM,CAACzH,CAAC,CAAC,CAACP,IAAI,EAAEvB,MAAM,CAAC;MACnE,IAAIq+B,QAAQ,IAAIC,MAAM,EAAE;QACpB,OAAOx8B,CAAC;MACZ;IACJ;IACA,OAAO,CAAC,CAAC;EACb;EACA,SAAS+4B,oBAAoBA,CAACn3B,EAAE,EAAE2U,GAAG,EAAE;IACnC,IAAI8J,aAAa,GAAG9J,GAAG,CAAC8J,aAAa;IACrC,IAAIoc,2BAA2B,GAAG,SAAAA,CAAA,EAAY;MAC1C,IAAIrY,UAAU,GAAGxiB,EAAE,CAAC4F,cAAc,CAAC,CAAC;MACpC,IAAI1K,KAAK,GAAGsnB,UAAU,CAAC,CAAC,CAAC;MACzB,IAAIrnB,GAAG,GAAGqnB,UAAU,CAACA,UAAU,CAAC5nB,MAAM,GAAG,CAAC,CAAC;MAC3C,IAAI4pB,cAAc,GAAGwI,cAAc,CAAC9xB,KAAK,CAAC0C,MAAM,EAAE1C,KAAK,CAAC2C,IAAI,CAAC,GAAG3C,KAAK,CAAC0C,MAAM,GAAG1C,KAAK,CAAC2C,IAAI;MACzF,IAAI0mB,YAAY,GAAGyI,cAAc,CAAC7xB,GAAG,CAACyC,MAAM,EAAEzC,GAAG,CAAC0C,IAAI,CAAC,GAAG1C,GAAG,CAAC0C,IAAI,GAAG1C,GAAG,CAACyC,MAAM;MAC/E,OAAO,CAAC4mB,cAAc,EAAED,YAAY,CAAC;IACzC,CAAC;IACD,IAAIuW,wBAAwB,GAAG,SAAAA,CAAA,EAAY;MACvC,IAAItW,cAAc,GAAGxkB,EAAE,CAACqF,SAAS,CAAC,CAAC;MACnC,IAAIkf,YAAY,GAAGvkB,EAAE,CAACqF,SAAS,CAAC,CAAC;MACjC,IAAI01B,KAAK,GAAGtc,aAAa,CAACD,WAAW;MACrC,IAAIuc,KAAK,EAAE;QACP,IAAIzuB,KAAK,GAAGyuB,KAAK,CAACzuB,KAAK;QACvB,IAAInD,MAAM,GAAG4xB,KAAK,CAAC5xB,MAAM;QACzBob,YAAY,GAAG,IAAI3kB,GAAG,CAAC4kB,cAAc,CAAC9pB,IAAI,GAAGyO,MAAM,EAAEqb,cAAc,CAAC7mB,EAAE,GAAG2O,KAAK,CAAC;QAC/E,IAAIkW,UAAU,GAAG,EAAE;QACnB,KAAK,IAAIpkB,CAAC,GAAGomB,cAAc,CAAC9pB,IAAI,EAAE0D,CAAC,GAAGmmB,YAAY,CAAC7pB,IAAI,EAAE0D,CAAC,EAAE,EAAE;UAC1D,IAAIR,MAAM,GAAG,IAAIgC,GAAG,CAACxB,CAAC,EAAEomB,cAAc,CAAC7mB,EAAE,CAAC;UAC1C,IAAIE,IAAI,GAAG,IAAI+B,GAAG,CAACxB,CAAC,EAAEmmB,YAAY,CAAC5mB,EAAE,CAAC;UACtC,IAAIiJ,KAAK,GAAG;YAAEhJ,MAAM,EAAEA,MAAM;YAAEC,IAAI,EAAEA;UAAK,CAAC;UAC1C2kB,UAAU,CAAC3f,IAAI,CAAC+D,KAAK,CAAC;QAC1B;QACA5G,EAAE,CAACkG,aAAa,CAACsc,UAAU,CAAC;MAChC,CAAC,MACI;QACD,IAAItnB,KAAK,GAAGujB,aAAa,CAAC+W,UAAU,CAAC9tB,IAAI,CAAC,CAAC;QAC3C,IAAIvM,GAAG,GAAGsjB,aAAa,CAACgX,QAAQ,CAAC/tB,IAAI,CAAC,CAAC;QACvC,IAAIhN,IAAI,GAAGS,GAAG,CAACT,IAAI,GAAGQ,KAAK,CAACR,IAAI;QAChC,IAAIiD,EAAE,GAAGxC,GAAG,CAACwC,EAAE,GAAGzC,KAAK,CAACyC,EAAE;QAC1B4mB,YAAY,GAAG;UAAE7pB,IAAI,EAAE6pB,YAAY,CAAC7pB,IAAI,GAAGA,IAAI;UAAEiD,EAAE,EAAEjD,IAAI,GAAG6pB,YAAY,CAAC5mB,EAAE,GAAGA,EAAE,GAAG4mB,YAAY,CAAC5mB;QAAG,CAAC;QACpG,IAAI8gB,aAAa,CAAC9G,UAAU,EAAE;UAC1B6M,cAAc,GAAG,IAAI5kB,GAAG,CAAC4kB,cAAc,CAAC9pB,IAAI,EAAE,CAAC,CAAC;UAChD6pB,YAAY,GAAG,IAAI3kB,GAAG,CAAC2kB,YAAY,CAAC7pB,IAAI,EAAE8yB,UAAU,CAACxtB,EAAE,EAAEukB,YAAY,CAAC7pB,IAAI,CAAC,CAAC;QAChF;QACAsF,EAAE,CAAC+G,YAAY,CAACyd,cAAc,EAAED,YAAY,CAAC;MACjD;MACA,OAAO,CAACC,cAAc,EAAED,YAAY,CAAC;IACzC,CAAC;IACD,IAAI,CAAC5P,GAAG,CAAC4J,UAAU,EAAE;MACjB,OAAOuc,wBAAwB,CAAC,CAAC;IACrC,CAAC,MACI;MACD,OAAOD,2BAA2B,CAAC,CAAC;IACxC;EACJ;EACA,SAAStF,mBAAmBA,CAACv1B,EAAE,EAAE2U,GAAG,EAAE;IAClC,IAAI/W,MAAM,GAAG+W,GAAG,CAACrP,GAAG,CAAC1H,MAAM;IAC3B,IAAIC,IAAI,GAAG8W,GAAG,CAACrP,GAAG,CAACzH,IAAI;IACvB,IAAI8W,GAAG,CAAC+J,cAAc,EAAE;MACpB7gB,IAAI,GAAGmC,EAAE,CAACsQ,YAAY,CAACtQ,EAAE,CAACoQ,YAAY,CAACxS,MAAM,CAAC,GAAG+W,GAAG,CAAC+J,cAAc,CAAC9jB,MAAM,CAAC;MAC3E+Z,GAAG,CAAC+J,cAAc,GAAG,IAAI;IAC7B;IACA/J,GAAG,CAAC8J,aAAa,GAAG;MAAE,YAAY,EAAEze,EAAE,CAACqI,WAAW,CAACzK,MAAM,CAAC;MACtD,UAAU,EAAEoC,EAAE,CAACqI,WAAW,CAACxK,IAAI,CAAC;MAChC,QAAQ,EAAEsuB,UAAU,CAACvuB,MAAM,CAAC;MAC5B,MAAM,EAAEuuB,UAAU,CAACtuB,IAAI,CAAC;MACxB,YAAY,EAAE8W,GAAG,CAAC4J,UAAU;MAC5B,YAAY,EAAE5J,GAAG,CAACgD,UAAU;MAC5B,aAAa,EAAEhD,GAAG,CAAC6J;IAAY,CAAC;EACxC;EACA,SAASuU,eAAeA,CAAC/yB,EAAE,EAAE9E,KAAK,EAAEC,GAAG,EAAE+gB,IAAI,EAAE;IAC3C,IAAI5W,GAAG,GAAGtF,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACrP,GAAG;IAC1B,IAAIzH,IAAI,GAAGqe,IAAI,GAAGhhB,KAAK,GAAGoK,GAAG,CAACzH,IAAI;IAClC,IAAID,MAAM,GAAGse,IAAI,GAAGhhB,KAAK,GAAGoK,GAAG,CAAC1H,MAAM;IACtC,IAAI6vB,GAAG;IACP,IAAIT,cAAc,CAAC7xB,GAAG,EAAED,KAAK,CAAC,EAAE;MAC5BuyB,GAAG,GAAGtyB,GAAG;MACTA,GAAG,GAAGD,KAAK;MACXA,KAAK,GAAGuyB,GAAG;IACf;IACA,IAAIT,cAAc,CAACnvB,IAAI,EAAED,MAAM,CAAC,EAAE;MAC9BC,IAAI,GAAG+kB,SAAS,CAAC1nB,KAAK,EAAE2C,IAAI,CAAC;MAC7BD,MAAM,GAAGilB,SAAS,CAACjlB,MAAM,EAAEzC,GAAG,CAAC;IACnC,CAAC,MACI;MACDyC,MAAM,GAAGglB,SAAS,CAAC1nB,KAAK,EAAE0C,MAAM,CAAC;MACjCC,IAAI,GAAGglB,SAAS,CAAChlB,IAAI,EAAE1C,GAAG,CAAC;MAC3B0C,IAAI,GAAG4b,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAChC,IAAIA,IAAI,CAACF,EAAE,IAAI,CAAC,CAAC,IAAIE,IAAI,CAACnD,IAAI,IAAIsF,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE;QAC9C9G,IAAI,GAAG,IAAI+B,GAAG,CAAC/B,IAAI,CAACnD,IAAI,GAAG,CAAC,EAAE8yB,UAAU,CAACxtB,EAAE,EAAEnC,IAAI,CAACnD,IAAI,GAAG,CAAC,CAAC,CAAC;MAChE;IACJ;IACA,OAAO,CAACkD,MAAM,EAAEC,IAAI,CAAC;EACzB;EACA,SAAS0sB,iBAAiBA,CAACvqB,EAAE,EAAEsF,GAAG,EAAEoE,IAAI,EAAE;IACtC,IAAIiL,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtBrP,GAAG,GAAGA,GAAG,IAAIqP,GAAG,CAACrP,GAAG;IACpB,IAAIoE,IAAI,GAAGA,IAAI,IACXiL,GAAG,CAACgD,UAAU,GAAG,MAAM,GAAGhD,GAAG,CAAC6J,WAAW,GAAG,OAAO,GAAG,MAAM;IAChE,IAAI6O,KAAK,GAAGE,eAAe,CAACvtB,EAAE,EAAEsF,GAAG,EAAEoE,IAAI,CAAC;IAC1C1J,EAAE,CAACkG,aAAa,CAACmnB,KAAK,CAACxnB,MAAM,EAAEwnB,KAAK,CAACQ,OAAO,CAAC;EACjD;EACA,SAASN,eAAeA,CAACvtB,EAAE,EAAEsF,GAAG,EAAEoE,IAAI,EAAEkkB,SAAS,EAAE;IAC/C,IAAI/vB,IAAI,GAAGsuB,UAAU,CAAC7mB,GAAG,CAACzH,IAAI,CAAC;IAC/B,IAAID,MAAM,GAAGuuB,UAAU,CAAC7mB,GAAG,CAAC1H,MAAM,CAAC;IACnC,IAAI8L,IAAI,IAAI,MAAM,EAAE;MAChB,IAAIsxB,UAAU,GAAG,CAACpN,SAAS,IAAI,CAACZ,cAAc,CAAC1nB,GAAG,CAACzH,IAAI,EAAEyH,GAAG,CAAC1H,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;MAC5E,IAAIq9B,YAAY,GAAGjO,cAAc,CAAC1nB,GAAG,CAACzH,IAAI,EAAEyH,GAAG,CAAC1H,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;MAC/DC,IAAI,GAAG4b,YAAY,CAACnU,GAAG,CAACzH,IAAI,EAAE,CAAC,EAAEm9B,UAAU,CAAC;MAC5Cp9B,MAAM,GAAG6b,YAAY,CAACnU,GAAG,CAAC1H,MAAM,EAAE,CAAC,EAAEq9B,YAAY,CAAC;MAClD,OAAO;QACHp1B,MAAM,EAAE,CAAC;UAAEjI,MAAM,EAAEA,MAAM;UAAEC,IAAI,EAAEA;QAAK,CAAC,CAAC;QACxCgwB,OAAO,EAAE;MACb,CAAC;IACL,CAAC,MACI,IAAInkB,IAAI,IAAI,MAAM,EAAE;MACrB,IAAI,CAACsjB,cAAc,CAAC1nB,GAAG,CAACzH,IAAI,EAAEyH,GAAG,CAAC1H,MAAM,CAAC,EAAE;QACvCA,MAAM,CAACD,EAAE,GAAG,CAAC;QACb,IAAIiH,QAAQ,GAAG5E,EAAE,CAAC4E,QAAQ,CAAC,CAAC;QAC5B,IAAI/G,IAAI,CAACnD,IAAI,GAAGkK,QAAQ,EAAE;UACtB/G,IAAI,CAACnD,IAAI,GAAGkK,QAAQ;QACxB;QACA/G,IAAI,CAACF,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAEnC,IAAI,CAACnD,IAAI,CAAC;MACvC,CAAC,MACI;QACDmD,IAAI,CAACF,EAAE,GAAG,CAAC;QACXC,MAAM,CAACD,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAEpC,MAAM,CAAClD,IAAI,CAAC;MAC3C;MACA,OAAO;QACHmL,MAAM,EAAE,CAAC;UAAEjI,MAAM,EAAEA,MAAM;UAAEC,IAAI,EAAEA;QAAK,CAAC,CAAC;QACxCgwB,OAAO,EAAE;MACb,CAAC;IACL,CAAC,MACI,IAAInkB,IAAI,IAAI,OAAO,EAAE;MACtB,IAAIG,GAAG,GAAGxP,IAAI,CAACC,GAAG,CAACsD,MAAM,CAAClD,IAAI,EAAEmD,IAAI,CAACnD,IAAI,CAAC;QAAEwgC,MAAM,GAAGt9B,MAAM,CAACD,EAAE;QAAEsM,MAAM,GAAG5P,IAAI,CAACL,GAAG,CAAC4D,MAAM,CAAClD,IAAI,EAAEmD,IAAI,CAACnD,IAAI,CAAC;QAAEygC,IAAI,GAAGt9B,IAAI,CAACF,EAAE;MACzH,IAAIu9B,MAAM,GAAGC,IAAI,EAAE;QACfA,IAAI,IAAI,CAAC;MACb,CAAC,MACI;QACDD,MAAM,IAAI,CAAC;MACf;MACA;MACA,IAAI/xB,MAAM,GAAGc,MAAM,GAAGJ,GAAG,GAAG,CAAC;MAC7B,IAAIgkB,OAAO,GAAGhwB,IAAI,CAACnD,IAAI,IAAImP,GAAG,GAAG,CAAC,GAAGV,MAAM,GAAG,CAAC;MAC/C,IAAItD,MAAM,GAAG,EAAE;MACf,KAAK,IAAIzH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+K,MAAM,EAAE/K,CAAC,EAAE,EAAE;QAC7ByH,MAAM,CAAChD,IAAI,CAAC;UACRjF,MAAM,EAAE,IAAIgC,GAAG,CAACiK,GAAG,GAAGzL,CAAC,EAAE88B,MAAM,CAAC;UAChCr9B,IAAI,EAAE,IAAI+B,GAAG,CAACiK,GAAG,GAAGzL,CAAC,EAAE+8B,IAAI;QAC/B,CAAC,CAAC;MACN;MACA,OAAO;QACHt1B,MAAM,EAAEA,MAAM;QACdgoB,OAAO,EAAEA;MACb,CAAC;IACL;EACJ;EACA,SAASuN,OAAOA,CAACp7B,EAAE,EAAE;IACjB,IAAIyuB,GAAG,GAAGzuB,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;IAC9B,IAAIrF,EAAE,CAAC+M,YAAY,CAAC,CAAC,CAACnS,MAAM,IAAI,CAAC,EAAE;MAC/B6zB,GAAG,GAAG7L,SAAS,CAAC6L,GAAG,EAAEzuB,EAAE,CAACqF,SAAS,CAAC,QAAQ,CAAC,CAAC;IAChD;IACA,OAAOopB,GAAG;EACd;EACA,SAAS3M,cAAcA,CAAC9hB,EAAE,EAAEq7B,QAAQ,EAAE;IAClC,IAAI1mB,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,IAAI0mB,QAAQ,KAAK,KAAK,EAAE;MACpBr7B,EAAE,CAAC+E,SAAS,CAACqnB,mBAAmB,CAACpsB,EAAE,EAAE2U,GAAG,CAACrP,GAAG,CAACzH,IAAI,CAAC,CAAC;IACvD;IACA03B,mBAAmB,CAACv1B,EAAE,EAAE2U,GAAG,CAAC;IAC5BA,GAAG,CAAC4J,UAAU,GAAG,KAAK;IACtB5J,GAAG,CAACgD,UAAU,GAAG,KAAK;IACtBhD,GAAG,CAAC6J,WAAW,GAAG,KAAK;IACvB,IAAI,CAAC7J,GAAG,CAAC6E,UAAU,EACfpa,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;MAAE0J,IAAI,EAAE;IAAS,CAAC,CAAC;EACpE;EACA,SAASikB,UAAUA,CAAC3tB,EAAE,EAAE8V,QAAQ,EAAEC,MAAM,EAAE;IACtC,IAAIxZ,SAAS,GAAGyD,EAAE,CAAC0F,QAAQ,CAACoQ,QAAQ,EAAEC,MAAM,CAAC;IAC7C,IAAI,QAAQ,CAAC3a,IAAI,CAACmB,SAAS,CAAC,EAAE;MAC1B,IAAI0G,KAAK,GAAG1G,SAAS,CAAC6nB,KAAK,CAAC,IAAI,CAAC;MACjCnhB,KAAK,CAAC8f,GAAG,CAAC,CAAC;MACX,IAAIroB,IAAI;MACR,KAAK,IAAIA,IAAI,GAAGuI,KAAK,CAAC8f,GAAG,CAAC,CAAC,EAAE9f,KAAK,CAACrI,MAAM,GAAG,CAAC,IAAIF,IAAI,IAAI+f,kBAAkB,CAAC/f,IAAI,CAAC,EAAEA,IAAI,GAAGuI,KAAK,CAAC8f,GAAG,CAAC,CAAC,EAAE;QACnGhN,MAAM,CAACrb,IAAI,EAAE;QACbqb,MAAM,CAACpY,EAAE,GAAG,CAAC;MACjB;MACA,IAAIjD,IAAI,EAAE;QACNqb,MAAM,CAACrb,IAAI,EAAE;QACbqb,MAAM,CAACpY,EAAE,GAAG6vB,UAAU,CAACxtB,EAAE,EAAE+V,MAAM,CAACrb,IAAI,CAAC;MAC3C,CAAC,MACI;QACDqb,MAAM,CAACpY,EAAE,GAAG,CAAC;MACjB;IACJ;EACJ;EACA,SAAS+vB,qBAAqBA,CAACc,GAAG,EAAE1Y,QAAQ,EAAEC,MAAM,EAAE;IAClDD,QAAQ,CAACnY,EAAE,GAAG,CAAC;IACfoY,MAAM,CAACpY,EAAE,GAAG,CAAC;IACboY,MAAM,CAACrb,IAAI,EAAE;EACjB;EACA,SAAS0zB,+BAA+BA,CAACrrB,IAAI,EAAE;IAC3C,IAAI,CAACA,IAAI,EAAE;MACP,OAAO,CAAC;IACZ;IACA,IAAIu4B,UAAU,GAAGv4B,IAAI,CAAC8H,MAAM,CAAC,IAAI,CAAC;IAClC,OAAOywB,UAAU,IAAI,CAAC,CAAC,GAAGv4B,IAAI,CAACnI,MAAM,GAAG0gC,UAAU;EACtD;EACA,SAASzP,qBAAqBA,CAAC7rB,EAAE,EAAEu7B,EAAE,EAAEj/B,MAAM,EAAE;IAC3C,IAAIua,SAAS,GAAG0kB,EAAE,CAAC1kB,SAAS;MAAE6b,SAAS,GAAG6I,EAAE,CAAC7I,SAAS;MAAE9b,OAAO,GAAG2kB,EAAE,CAAC3kB,OAAO;MAAEkV,QAAQ,GAAGyP,EAAE,CAACzP,QAAQ;MAAE6G,SAAS,GAAG4I,EAAE,CAAC5I,SAAS;IAC9H,IAAIlE,GAAG,GAAGnyB,MAAM,IAAI8+B,OAAO,CAACp7B,EAAE,CAAC;IAC/B,IAAItF,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAAC8zB,GAAG,CAAC/zB,IAAI,CAAC;IAC/B,IAAIk5B,OAAO,GAAGl5B,IAAI;IAClB,IAAI8gC,eAAe,GAAG/M,GAAG,CAAC/zB,IAAI;IAC9B,IAAI+gC,aAAa,GAAGD,eAAe;IACnC,IAAIE,GAAG,GAAGjN,GAAG,CAAC9wB,EAAE;IAChB,IAAIg+B,cAAc;IAClB,IAAIvgC,IAAI,GAAG0wB,QAAQ,GAAGjS,YAAY,CAAC,CAAC,CAAC,GAAGC,eAAe,CAAC,CAAC,CAAC;IAC1D,IAAI4Y,SAAS,IAAI,IAAI,CAACt3B,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAACqpB,GAAG,CAAC,CAAC,EAAE;MAC1CtgC,IAAI,GAAG,SAAAA,CAAUuC,EAAE,EAAE;QAAE,OAAO,IAAI,CAACvC,IAAI,CAACuC,EAAE,CAAC;MAAE,CAAC;IAClD,CAAC,MACI;MACD,OAAO,CAACvC,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAACqpB,GAAG,CAAC,CAAC,EAAE;QAC5BA,GAAG,EAAE;QACL,IAAIA,GAAG,IAAIhhC,IAAI,CAACE,MAAM,EAAE;UACpB,IAAI,CAAC+3B,SAAS,EACV,OAAO,IAAI;UACf+I,GAAG,EAAE;UACLC,cAAc,GAAGC,QAAQ,CAAC57B,EAAE,EAAEyuB,GAAG,EAAE,IAAI,EAAE7X,OAAO,EAAE,IAAI,CAAC;UACvD;QACJ;MACJ;MACA,IAAIA,OAAO,EAAE;QACTxb,IAAI,GAAG0e,eAAe,CAAC,CAAC,CAAC;MAC7B,CAAC,MACI;QACD1e,IAAI,GAAGye,YAAY,CAAC,CAAC,CAAC;QACtB,IAAI,CAACze,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAACqpB,GAAG,CAAC,CAAC,EAAE;UACzBtgC,IAAI,GAAGye,YAAY,CAAC,CAAC,CAAC;QAC1B;MACJ;IACJ;IACA,IAAI1e,GAAG,GAAGugC,GAAG;MAAExgC,KAAK,GAAGwgC,GAAG;IAC1B,OAAOtgC,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAACnX,KAAK,CAAC,CAAC,IAAIA,KAAK,IAAI,CAAC,EAAE;MAC3CA,KAAK,EAAE;IACX;IACAA,KAAK,EAAE;IACP,IAAIygC,cAAc,EAAE;MAChBxgC,GAAG,GAAGwgC,cAAc,CAAC/vB,EAAE;MACvB6vB,aAAa,GAAGE,cAAc,CAACjhC,IAAI;MACnCk5B,OAAO,GAAG5zB,EAAE,CAACrF,OAAO,CAAC8gC,aAAa,CAAC;MACnC,IAAI,CAAC7H,OAAO,IAAIz4B,GAAG,IAAI,CAAC,EACpBA,GAAG,EAAE;IACb,CAAC,MACI;MACD,OAAOC,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAAClX,GAAG,CAAC,CAAC,IAAIA,GAAG,GAAGT,IAAI,CAACE,MAAM,EAAE;QAChDO,GAAG,EAAE;MACT;IACJ;IACA,IAAI0b,SAAS,EAAE;MACX,IAAIF,OAAO,GAAGxb,GAAG;MACjB,IAAI0gC,eAAe,GAAGpN,GAAG,CAAC9wB,EAAE,IAAIzC,KAAK,IAAI,IAAI,CAACE,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAACoc,GAAG,CAAC9wB,EAAE,CAAC,CAAC;MACvE,IAAI,CAACk+B,eAAe,EAAE;QAClB,OAAO,IAAI,CAACzgC,IAAI,CAACw4B,OAAO,CAACvhB,MAAM,CAAClX,GAAG,CAAC,CAAC,IAAIA,GAAG,GAAGy4B,OAAO,CAACh5B,MAAM,EAAE;UAC3DO,GAAG,EAAE;QACT;MACJ;MACA,IAAIwb,OAAO,IAAIxb,GAAG,IAAI0gC,eAAe,EAAE;QACnC,IAAIC,SAAS,GAAG5gC,KAAK;QACrB,OAAO,IAAI,CAACE,IAAI,CAACV,IAAI,CAAC2X,MAAM,CAACnX,KAAK,GAAG,CAAC,CAAC,CAAC,IAAIA,KAAK,GAAG,CAAC,EAAE;UACnDA,KAAK,EAAE;QACX;QACA,IAAI,CAACA,KAAK,IAAI,CAAC2gC,eAAe,EAAE;UAC5B3gC,KAAK,GAAG4gC,SAAS;QACrB;MACJ;IACJ;IACA,OAAO;MAAE5gC,KAAK,EAAE,IAAI0E,GAAG,CAAC47B,eAAe,EAAEtgC,KAAK,CAAC;MAAEC,GAAG,EAAE,IAAIyE,GAAG,CAAC67B,aAAa,EAAEtgC,GAAG;IAAE,CAAC;EACvF;EACA,SAASy3B,oBAAoBA,CAAC5yB,EAAE,EAAEnC,IAAI,EAAEgZ,SAAS,EAAE;IAC/C,IAAI4X,GAAG,GAAG5wB,IAAI;IACd,IAAI,CAACuB,UAAU,CAACyC,eAAe,IAAI,CAACzC,UAAU,CAAC0C,gBAAgB,EAAE;MAC7D,OAAO;QAAE5G,KAAK,EAAEuzB,GAAG;QAAEtzB,GAAG,EAAEszB;MAAI,CAAC;IACnC;IACA,IAAIsN,IAAI,GAAG38B,UAAU,CAACyC,eAAe,CAAC7B,EAAE,EAAEnC,IAAI,CAAC,IAAIuB,UAAU,CAAC0C,gBAAgB,CAAC9B,EAAE,EAAEnC,IAAI,CAAC;IACxF,IAAI,CAACk+B,IAAI,IAAI,CAACA,IAAI,CAACnsB,IAAI,IAAI,CAACmsB,IAAI,CAACjsB,KAAK,EAAE;MACpC,OAAO;QAAE5U,KAAK,EAAEuzB,GAAG;QAAEtzB,GAAG,EAAEszB;MAAI,CAAC;IACnC;IACA,IAAI5X,SAAS,EAAE;MACX,OAAO;QAAE3b,KAAK,EAAE6gC,IAAI,CAACnsB,IAAI,CAACjE,IAAI;QAAExQ,GAAG,EAAE4gC,IAAI,CAACjsB,KAAK,CAAClE;MAAG,CAAC;IACxD;IACA,OAAO;MAAE1Q,KAAK,EAAE6gC,IAAI,CAACnsB,IAAI,CAAChE,EAAE;MAAEzQ,GAAG,EAAE4gC,IAAI,CAACjsB,KAAK,CAACnE;IAAK,CAAC;EACxD;EACA,SAASkhB,kBAAkBA,CAAC7sB,EAAE,EAAE2b,MAAM,EAAEC,MAAM,EAAE;IAC5C,IAAI,CAACK,WAAW,CAACN,MAAM,EAAEC,MAAM,CAAC,EAAE;MAC9ByB,cAAc,CAAC2B,QAAQ,CAACtD,GAAG,CAAC1b,EAAE,EAAE2b,MAAM,EAAEC,MAAM,CAAC;IACnD;EACJ;EACA,SAAS0V,yBAAyBA,CAAC7oB,SAAS,EAAEpM,IAAI,EAAE;IAChDghB,cAAc,CAAC4B,mBAAmB,CAACxW,SAAS,GAAGA,SAAS;IACxD4U,cAAc,CAAC4B,mBAAmB,CAACvI,OAAO,GAAGra,IAAI,CAACqa,OAAO;IACzD2G,cAAc,CAAC4B,mBAAmB,CAACC,iBAAiB,GAAG7iB,IAAI,CAAC6iB,iBAAiB;EACjF;EACA,IAAI8c,YAAY,GAAG;IACf,GAAG,EAAE,SAAS;IAAE,GAAG,EAAE,SAAS;IAAE,GAAG,EAAE,SAAS;IAAE,GAAG,EAAE,SAAS;IAC9D,GAAG,EAAE,SAAS;IAAE,GAAG,EAAE,SAAS;IAC9B,GAAG,EAAE,SAAS;IAAE,GAAG,EAAE,SAAS;IAC9B,GAAG,EAAE,QAAQ;IAAE,GAAG,EAAE,QAAQ;IAC5B,GAAG,EAAE;EACT,CAAC;EACD,IAAIC,eAAe,GAAG;IAClBC,OAAO,EAAE;MACLC,UAAU,EAAE,SAAAA,CAAU98B,KAAK,EAAE;QACzB,IAAIA,KAAK,CAAC+8B,MAAM,KAAK/8B,KAAK,CAACg9B,IAAI,EAAE;UAC7Bh9B,KAAK,CAACi9B,KAAK,EAAE;UACb,IAAIj9B,KAAK,CAACi9B,KAAK,IAAI,CAAC,EAChB,OAAO,IAAI;QACnB,CAAC,MACI,IAAIj9B,KAAK,CAAC+8B,MAAM,KAAK/8B,KAAK,CAACk9B,WAAW,EAAE;UACzCl9B,KAAK,CAACi9B,KAAK,EAAE;QACjB;QACA,OAAO,KAAK;MAChB;IACJ,CAAC;IACDE,OAAO,EAAE;MACLC,IAAI,EAAE,SAAAA,CAAUp9B,KAAK,EAAE;QACnBA,KAAK,CAACq9B,cAAc,GAAG,IAAI;QAC3Br9B,KAAK,CAACg9B,IAAI,GAAG,CAACh9B,KAAK,CAACqX,OAAO,GAAG,GAAG,GAAG,GAAG,MAAMrX,KAAK,CAACg9B,IAAI,GAAG,GAAG,GAAG,GAAG;MACvE,CAAC;MACDF,UAAU,EAAE,SAAAA,CAAU98B,KAAK,EAAE;QACzB,OAAOA,KAAK,CAACrD,KAAK,KAAK,CAAC,IAAIqD,KAAK,CAAC+8B,MAAM,KAAK/8B,KAAK,CAACg9B,IAAI;MAC3D;IACJ,CAAC;IACDM,OAAO,EAAE;MACLR,UAAU,EAAE,SAAAA,CAAU98B,KAAK,EAAE;QACzB,IAAIqC,KAAK,GAAGrC,KAAK,CAACk4B,MAAM,KAAK,GAAG,IAAIl4B,KAAK,CAAC+8B,MAAM,KAAK,GAAG;QACxD/8B,KAAK,CAACk4B,MAAM,GAAGl4B,KAAK,CAAC+8B,MAAM;QAC3B,OAAO16B,KAAK;MAChB;IACJ,CAAC;IACDuO,MAAM,EAAE;MACJwsB,IAAI,EAAE,SAAAA,CAAUp9B,KAAK,EAAE;QACnBA,KAAK,CAACg9B,IAAI,GAAIh9B,KAAK,CAACg9B,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAI;QAC7Ch9B,KAAK,CAACk9B,WAAW,GAAGl9B,KAAK,CAACg9B,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;MACtD,CAAC;MACDF,UAAU,EAAE,SAAAA,CAAU98B,KAAK,EAAE;QACzB,IAAIA,KAAK,CAAC+8B,MAAM,KAAK/8B,KAAK,CAACg9B,IAAI,EAC3B,OAAO,IAAI;QACf,OAAO,KAAK;MAChB;IACJ,CAAC;IACDO,UAAU,EAAE;MACRH,IAAI,EAAE,SAAAA,CAAUp9B,KAAK,EAAE;QACnBA,KAAK,CAACrD,KAAK,GAAG,CAAC;MACnB,CAAC;MACDmgC,UAAU,EAAE,SAAAA,CAAU98B,KAAK,EAAE;QACzB,IAAIA,KAAK,CAAC+8B,MAAM,KAAK,GAAG,EAAE;UACtB,IAAI7sB,KAAK,GAAGlQ,KAAK,CAACsyB,QAAQ,CAACpf,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;UAC9C,IAAIhD,KAAK,KAAK,OAAO,EAAE;YACnB,IAAIlQ,KAAK,CAACqX,OAAO,IAAIrX,KAAK,CAACi9B,KAAK,KAAK,CAAC,EAAE;cACpC,OAAO,IAAI;YACf;YACAj9B,KAAK,CAACi9B,KAAK,EAAE;UACjB,CAAC,MACI,IAAI/sB,KAAK,KAAK,IAAI,EAAE;YACrB,IAAI,CAAClQ,KAAK,CAACqX,OAAO,IAAIrX,KAAK,CAACi9B,KAAK,KAAK,CAAC,EAAE;cACrC,OAAO,IAAI;YACf;YACAj9B,KAAK,CAACi9B,KAAK,EAAE;UACjB;UACA,IAAI/sB,KAAK,KAAK,MAAM,IAAIlQ,KAAK,CAACi9B,KAAK,KAAK,CAAC,EACrC,OAAO,IAAI;QACnB;QACA,OAAO,KAAK;MAChB;IACJ;EACJ,CAAC;EACD,SAAS9K,UAAUA,CAACxxB,EAAE,EAAE0nB,MAAM,EAAEhR,OAAO,EAAE2lB,IAAI,EAAE;IAC3C,IAAI5N,GAAG,GAAGtC,UAAU,CAACnsB,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;IACpC,IAAIoD,SAAS,GAAGiO,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;IAChC,IAAIkd,OAAO,GAAGld,OAAO,GAAG1W,EAAE,CAAC8E,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3C,IAAI+3B,KAAK,GAAGpO,GAAG,CAAC9wB,EAAE;IAClB,IAAIjD,IAAI,GAAG+zB,GAAG,CAAC/zB,IAAI;IACnB,IAAIi3B,QAAQ,GAAG3xB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC;IAC/B,IAAI2E,KAAK,GAAG;MACRsyB,QAAQ,EAAEA,QAAQ;MAClByK,MAAM,EAAEzK,QAAQ,CAACtf,MAAM,CAACwqB,KAAK,CAAC;MAC9BtF,MAAM,EAAE,IAAI;MACZv7B,KAAK,EAAE6gC,KAAK;MACZR,IAAI,EAAEA,IAAI;MACVE,WAAW,EAAE,CAAC7lB,OAAO,GAAG;QAAE,GAAG,EAAE,GAAG;QAAE,GAAG,EAAE;MAAI,CAAC,GAAG;QAAE,GAAG,EAAE,GAAG;QAAE,GAAG,EAAE;MAAI,CAAC,EAAE2lB,IAAI,CAAC;MAC9E3lB,OAAO,EAAEA,OAAO;MAChB4lB,KAAK,EAAE,CAAC;MACRI,cAAc,EAAE;IACpB,CAAC;IACD,IAAIhzB,IAAI,GAAGsyB,YAAY,CAACK,IAAI,CAAC;IAC7B,IAAI,CAAC3yB,IAAI,EACL,OAAO+kB,GAAG;IACd,IAAIgO,IAAI,GAAGR,eAAe,CAACvyB,IAAI,CAAC,CAAC+yB,IAAI;IACrC,IAAIN,UAAU,GAAGF,eAAe,CAACvyB,IAAI,CAAC,CAACyyB,UAAU;IACjD,IAAIM,IAAI,EAAE;MACNA,IAAI,CAACp9B,KAAK,CAAC;IACf;IACA,OAAO3E,IAAI,KAAKk5B,OAAO,IAAIlM,MAAM,EAAE;MAC/BroB,KAAK,CAACrD,KAAK,IAAIyM,SAAS;MACxBpJ,KAAK,CAAC+8B,MAAM,GAAG/8B,KAAK,CAACsyB,QAAQ,CAACtf,MAAM,CAAChT,KAAK,CAACrD,KAAK,CAAC;MACjD,IAAI,CAACqD,KAAK,CAAC+8B,MAAM,EAAE;QACf1hC,IAAI,IAAI+N,SAAS;QACjBpJ,KAAK,CAACsyB,QAAQ,GAAG3xB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC,IAAI,EAAE;QACvC,IAAI+N,SAAS,GAAG,CAAC,EAAE;UACfpJ,KAAK,CAACrD,KAAK,GAAG,CAAC;QACnB,CAAC,MACI;UACD,IAAI8gC,OAAO,GAAGz9B,KAAK,CAACsyB,QAAQ,CAAC/2B,MAAM;UACnCyE,KAAK,CAACrD,KAAK,GAAI8gC,OAAO,GAAG,CAAC,GAAKA,OAAO,GAAG,CAAC,GAAI,CAAC;QACnD;QACAz9B,KAAK,CAAC+8B,MAAM,GAAG/8B,KAAK,CAACsyB,QAAQ,CAACtf,MAAM,CAAChT,KAAK,CAACrD,KAAK,CAAC;MACrD;MACA,IAAImgC,UAAU,CAAC98B,KAAK,CAAC,EAAE;QACnBovB,GAAG,CAAC/zB,IAAI,GAAGA,IAAI;QACf+zB,GAAG,CAAC9wB,EAAE,GAAG0B,KAAK,CAACrD,KAAK;QACpB0rB,MAAM,EAAE;MACZ;IACJ;IACA,IAAIroB,KAAK,CAAC+8B,MAAM,IAAI/8B,KAAK,CAACq9B,cAAc,EAAE;MACtC,OAAO,IAAI98B,GAAG,CAAClF,IAAI,EAAE2E,KAAK,CAACrD,KAAK,CAAC;IACrC;IACA,OAAOyyB,GAAG;EACd;EACA,SAASmN,QAAQA,CAAC57B,EAAE,EAAEyuB,GAAG,EAAE/X,OAAO,EAAEE,OAAO,EAAEmmB,eAAe,EAAE;IAC1D,IAAI/K,OAAO,GAAGvD,GAAG,CAAC/zB,IAAI;IACtB,IAAI6K,GAAG,GAAGkpB,GAAG,CAAC9wB,EAAE;IAChB,IAAIjD,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACq3B,OAAO,CAAC;IAC9B,IAAIphB,GAAG,GAAG8F,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;IAC1B,IAAIsmB,SAAS,GAAGpmB,OAAO,GAAGkD,eAAe,GAAGD,YAAY;IACxD,IAAIkjB,eAAe,IAAIriC,IAAI,IAAI,EAAE,EAAE;MAC/Bs3B,OAAO,IAAIphB,GAAG;MACdlW,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACq3B,OAAO,CAAC;MAC1B,IAAI,CAAC7X,MAAM,CAACna,EAAE,EAAEgyB,OAAO,CAAC,EAAE;QACtB,OAAO,IAAI;MACf;MACAzsB,GAAG,GAAImR,OAAO,GAAI,CAAC,GAAGhc,IAAI,CAACE,MAAM;IACrC;IACA,OAAO,IAAI,EAAE;MACT,IAAImiC,eAAe,IAAIriC,IAAI,IAAI,EAAE,EAAE;QAC/B,OAAO;UAAEiR,IAAI,EAAE,CAAC;UAAEC,EAAE,EAAE,CAAC;UAAElR,IAAI,EAAEs3B;QAAQ,CAAC;MAC5C;MACA,IAAIiL,IAAI,GAAIrsB,GAAG,GAAG,CAAC,GAAIlW,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC;MACvC,IAAIkhC,SAAS,GAAGmB,IAAI;QAAEtmB,OAAO,GAAGsmB,IAAI;MACpC,OAAO13B,GAAG,IAAI03B,IAAI,EAAE;QAChB,IAAIC,SAAS,GAAG,KAAK;QACrB,KAAK,IAAI9+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4+B,SAAS,CAACpiC,MAAM,IAAI,CAACsiC,SAAS,EAAE,EAAE9+B,CAAC,EAAE;UACrD,IAAI4+B,SAAS,CAAC5+B,CAAC,CAAC,CAAC1D,IAAI,CAAC2X,MAAM,CAAC9M,GAAG,CAAC,CAAC,EAAE;YAChCu2B,SAAS,GAAGv2B,GAAG;YACf,OAAOA,GAAG,IAAI03B,IAAI,IAAID,SAAS,CAAC5+B,CAAC,CAAC,CAAC1D,IAAI,CAAC2X,MAAM,CAAC9M,GAAG,CAAC,CAAC,EAAE;cAClDA,GAAG,IAAIqL,GAAG;YACd;YACA+F,OAAO,GAAGpR,GAAG;YACb23B,SAAS,GAAGpB,SAAS,IAAInlB,OAAO;YAChC,IAAImlB,SAAS,IAAIrN,GAAG,CAAC9wB,EAAE,IAAIq0B,OAAO,IAAIvD,GAAG,CAAC/zB,IAAI,IAC1Cic,OAAO,IAAImlB,SAAS,GAAGlrB,GAAG,EAAE;cAC5B;YACJ,CAAC,MACI;cACD,OAAO;gBACHjF,IAAI,EAAEtR,IAAI,CAACC,GAAG,CAACwhC,SAAS,EAAEnlB,OAAO,GAAG,CAAC,CAAC;gBACtC/K,EAAE,EAAEvR,IAAI,CAACL,GAAG,CAAC8hC,SAAS,EAAEnlB,OAAO,CAAC;gBAChCjc,IAAI,EAAEs3B;cACV,CAAC;YACL;UACJ;QACJ;QACA,IAAI,CAACkL,SAAS,EAAE;UACZ33B,GAAG,IAAIqL,GAAG;QACd;MACJ;MACAohB,OAAO,IAAIphB,GAAG;MACd,IAAI,CAACuJ,MAAM,CAACna,EAAE,EAAEgyB,OAAO,CAAC,EAAE;QACtB,OAAO,IAAI;MACf;MACAt3B,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACq3B,OAAO,CAAC;MAC1BzsB,GAAG,GAAIqL,GAAG,GAAG,CAAC,GAAI,CAAC,GAAGlW,IAAI,CAACE,MAAM;IACrC;EACJ;EACA,SAASu2B,UAAUA,CAACnxB,EAAE,EAAEyuB,GAAG,EAAE/G,MAAM,EAAEhR,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC5D,IAAId,QAAQ,GAAGqW,UAAU,CAACsC,GAAG,CAAC;IAC9B,IAAI0O,KAAK,GAAG,EAAE;IACd,IAAIzmB,OAAO,IAAI,CAACC,OAAO,IAAI,CAACD,OAAO,IAAIC,OAAO,EAAE;MAC5C+Q,MAAM,EAAE;IACZ;IACA,IAAIqV,eAAe,GAAG,EAAErmB,OAAO,IAAIC,OAAO,CAAC;IAC3C,KAAK,IAAIvY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;MAC7B,IAAIwtB,IAAI,GAAGgQ,QAAQ,CAAC57B,EAAE,EAAEyuB,GAAG,EAAE/X,OAAO,EAAEE,OAAO,EAAEmmB,eAAe,CAAC;MAC/D,IAAI,CAACnR,IAAI,EAAE;QACP,IAAIwR,KAAK,GAAG5P,UAAU,CAACxtB,EAAE,EAAEA,EAAE,CAAC4E,QAAQ,CAAC,CAAC,CAAC;QACzCu4B,KAAK,CAACt6B,IAAI,CAAC6T,OAAO,GACZ;UAAEhc,IAAI,EAAEsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC;UAAE+G,IAAI,EAAEyxB,KAAK;UAAExxB,EAAE,EAAEwxB;QAAM,CAAC,GAC/C;UAAE1iC,IAAI,EAAE,CAAC;UAAEiR,IAAI,EAAE,CAAC;UAAEC,EAAE,EAAE;QAAE,CAAC,CAAC;QAClC;MACJ;MACAuxB,KAAK,CAACt6B,IAAI,CAAC+oB,IAAI,CAAC;MAChB6C,GAAG,GAAG,IAAI7uB,GAAG,CAACgsB,IAAI,CAAClxB,IAAI,EAAEgc,OAAO,GAAIkV,IAAI,CAAChgB,EAAE,GAAG,CAAC,GAAIggB,IAAI,CAACjgB,IAAI,CAAC;IACjE;IACA,IAAI0xB,YAAY,GAAGF,KAAK,CAACviC,MAAM,IAAI8sB,MAAM;IACzC,IAAI4V,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC;IACxB,IAAII,QAAQ,GAAGJ,KAAK,CAACpa,GAAG,CAAC,CAAC;IAC1B,IAAIrM,OAAO,IAAI,CAACC,OAAO,EAAE;MACrB,IAAI,CAAC0mB,YAAY,KAAKC,SAAS,CAAC3xB,IAAI,IAAImK,QAAQ,CAACnY,EAAE,IAAI2/B,SAAS,CAAC5iC,IAAI,IAAIob,QAAQ,CAACpb,IAAI,CAAC,EAAE;QACrF6iC,QAAQ,GAAGJ,KAAK,CAACpa,GAAG,CAAC,CAAC;MAC1B;MACA,OAAO,IAAInjB,GAAG,CAAC29B,QAAQ,CAAC7iC,IAAI,EAAE6iC,QAAQ,CAAC5xB,IAAI,CAAC;IAChD,CAAC,MACI,IAAI+K,OAAO,IAAIC,OAAO,EAAE;MACzB,OAAO,IAAI/W,GAAG,CAAC29B,QAAQ,CAAC7iC,IAAI,EAAE6iC,QAAQ,CAAC3xB,EAAE,GAAG,CAAC,CAAC;IAClD,CAAC,MACI,IAAI,CAAC8K,OAAO,IAAIC,OAAO,EAAE;MAC1B,IAAI,CAAC0mB,YAAY,KAAKC,SAAS,CAAC1xB,EAAE,IAAIkK,QAAQ,CAACnY,EAAE,IAAI2/B,SAAS,CAAC5iC,IAAI,IAAIob,QAAQ,CAACpb,IAAI,CAAC,EAAE;QACnF6iC,QAAQ,GAAGJ,KAAK,CAACpa,GAAG,CAAC,CAAC;MAC1B;MACA,OAAO,IAAInjB,GAAG,CAAC29B,QAAQ,CAAC7iC,IAAI,EAAE6iC,QAAQ,CAAC3xB,EAAE,CAAC;IAC9C,CAAC,MACI;MACD,OAAO,IAAIhM,GAAG,CAAC29B,QAAQ,CAAC7iC,IAAI,EAAE6iC,QAAQ,CAAC5xB,IAAI,CAAC;IAChD;EACJ;EACA,SAASqkB,SAASA,CAAChwB,EAAE,EAAEnC,IAAI,EAAE0Y,UAAU,EAAE5B,GAAG,EAAE6oB,QAAQ,EAAE;IACpD,IAAI/O,GAAG,GAAG5wB,IAAI;IACd,IAAI4/B,MAAM,GAAG,IAAI79B,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,GAAG6b,UAAU,CAACmR,MAAM,GAAG,CAAC,EAAEoF,QAAQ,CAAC;IAChE,IAAI3xB,GAAG,GAAG6E,EAAE,CAACiG,OAAO,CAACw3B,MAAM,CAAC;IAC5BtiC,GAAG,CAACwC,EAAE,EAAE;IACR,IAAI,CAAC6/B,QAAQ,EAAE;MACX7oB,GAAG,CAACuJ,QAAQ,GAAG4O,QAAQ;MACvBnY,GAAG,CAACwJ,SAAS,GAAGne,EAAE,CAACyJ,UAAU,CAACtO,GAAG,EAAE,KAAK,CAAC,CAACyO,IAAI;IAClD;IACA,OAAO6zB,MAAM;EACjB;EACA,SAASpM,eAAeA,CAACrxB,EAAE,EAAE0nB,MAAM,EAAEhR,OAAO,EAAEkT,SAAS,EAAE/rB,IAAI,EAAE;IAC3D,IAAI4wB,GAAG,GAAG5wB,IAAI,IAAImC,EAAE,CAACqF,SAAS,CAAC,CAAC;IAChC,IAAInK,KAAK,GAAGuzB,GAAG,CAAC9wB,EAAE;IAClB,IAAI+9B,GAAG;IACP,KAAK,IAAIt9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;MAC7B,IAAI1D,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAAC8zB,GAAG,CAAC/zB,IAAI,CAAC;MAC/BghC,GAAG,GAAGgC,aAAa,CAACxiC,KAAK,EAAER,IAAI,EAAEkvB,SAAS,EAAElT,OAAO,EAAE,IAAI,CAAC;MAC1D,IAAIglB,GAAG,IAAI,CAAC,CAAC,EAAE;QACX,OAAO,IAAI;MACf;MACAxgC,KAAK,GAAGwgC,GAAG;IACf;IACA,OAAO,IAAI97B,GAAG,CAACI,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI,EAAEghC,GAAG,CAAC;EAC5C;EACA,SAAS3L,YAAYA,CAAC/vB,EAAE,EAAE0nB,MAAM,EAAE;IAC9B,IAAIhtB,IAAI,GAAGsF,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI;IAC9B,OAAO0xB,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAAClF,IAAI,EAAEgtB,MAAM,GAAG,CAAC,CAAC,CAAC;EAC7D;EACA,SAASqF,UAAUA,CAAC/sB,EAAE,EAAE2U,GAAG,EAAEojB,QAAQ,EAAExyB,GAAG,EAAE;IACxC,IAAI,CAACoV,OAAO,CAACod,QAAQ,EAAEhe,UAAU,CAAC,IAAI,CAACE,cAAc,CAAC7e,IAAI,CAAC28B,QAAQ,CAAC,EAAE;MAClE;IACJ;IACA,IAAIpjB,GAAG,CAACrV,KAAK,CAACy4B,QAAQ,CAAC,EAAE;MACrBpjB,GAAG,CAACrV,KAAK,CAACy4B,QAAQ,CAAC,CAACtwB,KAAK,CAAC,CAAC;IAC/B;IACAkN,GAAG,CAACrV,KAAK,CAACy4B,QAAQ,CAAC,GAAG/3B,EAAE,CAACqI,WAAW,CAAC9C,GAAG,CAAC;EAC7C;EACA,SAASm4B,aAAaA,CAACxiC,KAAK,EAAER,IAAI,EAAEkvB,SAAS,EAAElT,OAAO,EAAEinB,WAAW,EAAE;IACjE,IAAIjC,GAAG;IACP,IAAIhlB,OAAO,EAAE;MACTglB,GAAG,GAAGhhC,IAAI,CAACmY,OAAO,CAAC+W,SAAS,EAAE1uB,KAAK,GAAG,CAAC,CAAC;MACxC,IAAIwgC,GAAG,IAAI,CAAC,CAAC,IAAI,CAACiC,WAAW,EAAE;QAC3BjC,GAAG,IAAI,CAAC;MACZ;IACJ,CAAC,MACI;MACDA,GAAG,GAAGhhC,IAAI,CAACkjC,WAAW,CAAChU,SAAS,EAAE1uB,KAAK,GAAG,CAAC,CAAC;MAC5C,IAAIwgC,GAAG,IAAI,CAAC,CAAC,IAAI,CAACiC,WAAW,EAAE;QAC3BjC,GAAG,IAAI,CAAC;MACZ;IACJ;IACA,OAAOA,GAAG;EACd;EACA,SAAS9K,aAAaA,CAAC5wB,EAAE,EAAEnC,IAAI,EAAE6pB,MAAM,EAAE9W,GAAG,EAAEiG,SAAS,EAAE;IACrD,IAAInc,IAAI,GAAGmD,IAAI,CAACnD,IAAI;IACpB,IAAIJ,GAAG,GAAG0F,EAAE,CAAC2E,SAAS,CAAC,CAAC;IACxB,IAAI3K,GAAG,GAAGgG,EAAE,CAAC4E,QAAQ,CAAC,CAAC;IACvB,IAAI1J,KAAK;MAAEC,GAAG;MAAEiD,CAAC,GAAG1D,IAAI;IACxB,SAAS8K,OAAOA,CAACpH,CAAC,EAAE;MAAE,OAAO,CAAC,IAAI,CAAChD,IAAI,CAAC4E,EAAE,CAACrF,OAAO,CAACyD,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC;IAC1D,SAASy/B,UAAUA,CAACz/B,CAAC,EAAEwS,GAAG,EAAEktB,GAAG,EAAE;MAC7B,IAAIA,GAAG,EAAE;QACL,OAAOt4B,OAAO,CAACpH,CAAC,CAAC,IAAIoH,OAAO,CAACpH,CAAC,GAAGwS,GAAG,CAAC;MACzC;MACA,OAAO,CAACpL,OAAO,CAACpH,CAAC,CAAC,IAAIoH,OAAO,CAACpH,CAAC,GAAGwS,GAAG,CAAC;IAC1C;IACA,SAASmtB,QAAQA,CAAC3/B,CAAC,EAAE;MACjBwS,GAAG,GAAGA,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MACtB,IAAIotB,QAAQ,GAAGh+B,EAAE,CAACzG,GAAG,CAACkB,OAAO,CAAC21B,WAAW,CAAChyB,CAAC,CAAC;MAC5C,IAAI4/B,QAAQ,EAAE;QACV,IAAI5/B,CAAC,GAAGwS,GAAG,GAAGotB,QAAQ,CAAC9iC,KAAK,CAACd,GAAG,IAAIgE,CAAC,GAAGwS,GAAG,GAAGotB,QAAQ,CAAC7iC,GAAG,CAACf,GAAG,EAC1DwW,GAAG,GAAG,CAACA,GAAG,GAAG,CAAC,GAAGotB,QAAQ,CAAC7iC,GAAG,CAACf,GAAG,GAAG4jC,QAAQ,CAAC9iC,KAAK,CAACd,GAAG,IAAIgE,CAAC;MACnE;IACJ;IACA,IAAIwS,GAAG,EAAE;MACL,OAAOtW,GAAG,IAAI8D,CAAC,IAAIA,CAAC,IAAIpE,GAAG,IAAI0tB,MAAM,GAAG,CAAC,EAAE;QACvCqW,QAAQ,CAAC3/B,CAAC,CAAC;QACX,IAAIy/B,UAAU,CAACz/B,CAAC,EAAEwS,GAAG,CAAC,EAAE;UACpB8W,MAAM,EAAE;QACZ;QACAtpB,CAAC,IAAIwS,GAAG;MACZ;MACA,OAAO,IAAIhR,GAAG,CAACxB,CAAC,EAAE,CAAC,CAAC;IACxB;IACA,IAAIuW,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,IAAIA,GAAG,CAACgD,UAAU,IAAIkmB,UAAU,CAACnjC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE;MAC7C,IAAIkD,MAAM,GAAG+W,GAAG,CAACrP,GAAG,CAAC1H,MAAM;MAC3B,IAAIigC,UAAU,CAACjgC,MAAM,CAAClD,IAAI,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;QACnC,IAAI,CAACmc,SAAS,IAAIjZ,MAAM,CAAClD,IAAI,IAAIA,IAAI,EAAE;UACnCA,IAAI,IAAI,CAAC;QACb;MACJ;IACJ;IACA,IAAIujC,UAAU,GAAGz4B,OAAO,CAAC9K,IAAI,CAAC;IAC9B,KAAK0D,CAAC,GAAG1D,IAAI,EAAE0D,CAAC,IAAIpE,GAAG,IAAI0tB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;MACpC,IAAIy/B,UAAU,CAACz/B,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE;QACxB,IAAI,CAACyY,SAAS,IAAIrR,OAAO,CAACpH,CAAC,CAAC,IAAI6/B,UAAU,EAAE;UACxCvW,MAAM,EAAE;QACZ;MACJ;IACJ;IACAvsB,GAAG,GAAG,IAAIyE,GAAG,CAACxB,CAAC,EAAE,CAAC,CAAC;IACnB,IAAIA,CAAC,GAAGpE,GAAG,IAAI,CAACikC,UAAU,EAAE;MACxBA,UAAU,GAAG,IAAI;IACrB,CAAC,MACI;MACDpnB,SAAS,GAAG,KAAK;IACrB;IACA,KAAKzY,CAAC,GAAG1D,IAAI,EAAE0D,CAAC,GAAG9D,GAAG,EAAE8D,CAAC,EAAE,EAAE;MACzB,IAAI,CAACyY,SAAS,IAAIrR,OAAO,CAACpH,CAAC,CAAC,IAAI6/B,UAAU,IAAI7/B,CAAC,IAAI1D,IAAI,EAAE;QACrD,IAAImjC,UAAU,CAACz/B,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;UACzB;QACJ;MACJ;IACJ;IACAlD,KAAK,GAAG,IAAI0E,GAAG,CAACxB,CAAC,EAAE,CAAC,CAAC;IACrB,OAAO;MAAElD,KAAK,EAAEA,KAAK;MAAEC,GAAG,EAAEA;IAAI,CAAC;EACrC;EACA,SAAS23B,WAAWA,CAAC9yB,EAAE,EAAEyuB,GAAG,EAAE/G,MAAM,EAAE9W,GAAG,EAAEiG,SAAS,CAAC,yBAAyB;IAC1E,SAASqnB,QAAQA,CAACC,IAAI,EAAE;MACpB,IAAIA,IAAI,CAAC54B,GAAG,GAAG44B,IAAI,CAACvtB,GAAG,GAAG,CAAC,IAAIutB,IAAI,CAAC54B,GAAG,GAAG44B,IAAI,CAACvtB,GAAG,IAAIutB,IAAI,CAACzjC,IAAI,CAACE,MAAM,EAAE;QACpEujC,IAAI,CAACzjC,IAAI,GAAG,IAAI;MACpB,CAAC,MACI;QACDyjC,IAAI,CAAC54B,GAAG,IAAI44B,IAAI,CAACvtB,GAAG;MACxB;IACJ;IACA,SAAS8F,OAAOA,CAAC1W,EAAE,EAAEo+B,EAAE,EAAE74B,GAAG,EAAEqL,GAAG,EAAE;MAC/B,IAAIlW,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACyjC,EAAE,CAAC;MACzB,IAAID,IAAI,GAAG;QACPzjC,IAAI,EAAEA,IAAI;QACV0jC,EAAE,EAAEA,EAAE;QACN74B,GAAG,EAAEA,GAAG;QACRqL,GAAG,EAAEA;MACT,CAAC;MACD,IAAIutB,IAAI,CAACzjC,IAAI,KAAK,EAAE,EAAE;QAClB,OAAO;UAAE0jC,EAAE,EAAED,IAAI,CAACC,EAAE;UAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;QAAI,CAAC;MACzC;MACA,IAAI84B,eAAe,GAAGF,IAAI,CAAC54B,GAAG;MAC9B24B,QAAQ,CAACC,IAAI,CAAC;MACd,OAAOA,IAAI,CAACzjC,IAAI,KAAK,IAAI,EAAE;QACvB2jC,eAAe,GAAGF,IAAI,CAAC54B,GAAG;QAC1B,IAAImV,qBAAqB,CAACyjB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;UAC5C,IAAI,CAACsR,SAAS,EAAE;YACZ,OAAO;cAAEunB,EAAE,EAAED,IAAI,CAACC,EAAE;cAAE74B,GAAG,EAAE44B,IAAI,CAAC54B,GAAG,GAAG;YAAE,CAAC;UAC7C,CAAC,MACI;YACD24B,QAAQ,CAACC,IAAI,CAAC;YACd,OAAOA,IAAI,CAACzjC,IAAI,KAAK,IAAI,EAAE;cACvB,IAAI+f,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;gBACzC84B,eAAe,GAAGF,IAAI,CAAC54B,GAAG;gBAC1B24B,QAAQ,CAACC,IAAI,CAAC;cAClB,CAAC,MACI;gBACD;cACJ;YACJ;YACA,OAAO;cAAEC,EAAE,EAAED,IAAI,CAACC,EAAE;cAAE74B,GAAG,EAAE84B,eAAe,GAAG;YAAE,CAAC;UACpD;QACJ;QACAH,QAAQ,CAACC,IAAI,CAAC;MAClB;MACA,OAAO;QAAEC,EAAE,EAAED,IAAI,CAACC,EAAE;QAAE74B,GAAG,EAAE84B,eAAe,GAAG;MAAE,CAAC;IACpD;IACA,SAAS73B,OAAOA,CAACxG,EAAE,EAAEo+B,EAAE,EAAE74B,GAAG,EAAEqL,GAAG,EAAE;MAC/B,IAAIlW,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACyjC,EAAE,CAAC;MACzB,IAAID,IAAI,GAAG;QACPzjC,IAAI,EAAEA,IAAI;QACV0jC,EAAE,EAAEA,EAAE;QACN74B,GAAG,EAAEA,GAAG;QACRqL,GAAG,EAAEA;MACT,CAAC;MACD,IAAIutB,IAAI,CAACzjC,IAAI,KAAK,EAAE,EAAE;QAClB,OAAO;UAAE0jC,EAAE,EAAED,IAAI,CAACC,EAAE;UAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;QAAI,CAAC;MACzC;MACA,IAAI84B,eAAe,GAAGF,IAAI,CAAC54B,GAAG;MAC9B24B,QAAQ,CAACC,IAAI,CAAC;MACd,OAAOA,IAAI,CAACzjC,IAAI,KAAK,IAAI,EAAE;QACvB,IAAI,CAAC+f,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,IAAI,CAACmV,qBAAqB,CAACyjB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;UACzF84B,eAAe,GAAGF,IAAI,CAAC54B,GAAG;QAC9B,CAAC,MACI,IAAImV,qBAAqB,CAACyjB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;UACjD,IAAI,CAACsR,SAAS,EAAE;YACZ,OAAO;cAAEunB,EAAE,EAAED,IAAI,CAACC,EAAE;cAAE74B,GAAG,EAAE84B;YAAgB,CAAC;UAChD,CAAC,MACI;YACD,IAAI5jB,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE;cAC7C,OAAO;gBAAE64B,EAAE,EAAED,IAAI,CAACC,EAAE;gBAAE74B,GAAG,EAAE44B,IAAI,CAAC54B,GAAG,GAAG;cAAE,CAAC;YAC7C,CAAC,MACI;cACD,OAAO;gBAAE64B,EAAE,EAAED,IAAI,CAACC,EAAE;gBAAE74B,GAAG,EAAE84B;cAAgB,CAAC;YAChD;UACJ;QACJ;QACAH,QAAQ,CAACC,IAAI,CAAC;MAClB;MACAA,IAAI,CAACzjC,IAAI,GAAGA,IAAI;MAChB,IAAImc,SAAS,IAAI4D,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;QACtD,OAAO;UAAE64B,EAAE,EAAED,IAAI,CAACC,EAAE;UAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;QAAI,CAAC;MACzC,CAAC,MACI;QACD,OAAO;UAAE64B,EAAE,EAAED,IAAI,CAACC,EAAE;UAAE74B,GAAG,EAAE84B;QAAgB,CAAC;MAChD;IACJ;IACA,IAAIC,UAAU,GAAG;MACbF,EAAE,EAAE3P,GAAG,CAAC/zB,IAAI;MACZ6K,GAAG,EAAEkpB,GAAG,CAAC9wB;IACb,CAAC;IACD,OAAO+pB,MAAM,GAAG,CAAC,EAAE;MACf,IAAI9W,GAAG,GAAG,CAAC,EAAE;QACT0tB,UAAU,GAAG93B,OAAO,CAACxG,EAAE,EAAEs+B,UAAU,CAACF,EAAE,EAAEE,UAAU,CAAC/4B,GAAG,EAAEqL,GAAG,CAAC;MAChE,CAAC,MACI;QACD0tB,UAAU,GAAG5nB,OAAO,CAAC1W,EAAE,EAAEs+B,UAAU,CAACF,EAAE,EAAEE,UAAU,CAAC/4B,GAAG,EAAEqL,GAAG,CAAC;MAChE;MACA8W,MAAM,EAAE;IACZ;IACA,OAAO,IAAI9nB,GAAG,CAAC0+B,UAAU,CAACF,EAAE,EAAEE,UAAU,CAAC/4B,GAAG,CAAC;EACjD;EACA,SAASurB,YAAYA,CAAC9wB,EAAE,EAAEyuB,GAAG,EAAE/G,MAAM,EAAE9W,GAAG,EAAE;IACxC,SAASstB,QAAQA,CAACl+B,EAAE,EAAE07B,GAAG,EAAE;MACvB,IAAIA,GAAG,CAACn2B,GAAG,GAAGm2B,GAAG,CAAC9qB,GAAG,GAAG,CAAC,IAAI8qB,GAAG,CAACn2B,GAAG,GAAGm2B,GAAG,CAAC9qB,GAAG,IAAI8qB,GAAG,CAAChhC,IAAI,CAACE,MAAM,EAAE;QAC/D8gC,GAAG,CAAC0C,EAAE,IAAI1C,GAAG,CAAC9qB,GAAG;QACjB,IAAI,CAACuJ,MAAM,CAACna,EAAE,EAAE07B,GAAG,CAAC0C,EAAE,CAAC,EAAE;UACrB1C,GAAG,CAAChhC,IAAI,GAAG,IAAI;UACfghC,GAAG,CAAC0C,EAAE,GAAG,IAAI;UACb1C,GAAG,CAACn2B,GAAG,GAAG,IAAI;UACd;QACJ;QACAm2B,GAAG,CAAChhC,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAAC+gC,GAAG,CAAC0C,EAAE,CAAC;QAC7B1C,GAAG,CAACn2B,GAAG,GAAIm2B,GAAG,CAAC9qB,GAAG,GAAG,CAAC,GAAI,CAAC,GAAG8qB,GAAG,CAAChhC,IAAI,CAACE,MAAM,GAAG,CAAC;MACrD,CAAC,MACI;QACD8gC,GAAG,CAACn2B,GAAG,IAAIm2B,GAAG,CAAC9qB,GAAG;MACtB;IACJ;IACA,SAAS8F,OAAOA,CAAC1W,EAAE,EAAEo+B,EAAE,EAAE74B,GAAG,EAAEqL,GAAG,EAAE;MAC/B,IAAIlW,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACyjC,EAAE,CAAC;MACzB,IAAInB,IAAI,GAAIviC,IAAI,KAAK,EAAG;MACxB,IAAIyjC,IAAI,GAAG;QACPzjC,IAAI,EAAEA,IAAI;QACV0jC,EAAE,EAAEA,EAAE;QACN74B,GAAG,EAAEA,GAAG;QACRqL,GAAG,EAAEA;MACT,CAAC;MACD,IAAI2tB,UAAU,GAAG;QACbH,EAAE,EAAED,IAAI,CAACC,EAAE;QACX74B,GAAG,EAAE44B,IAAI,CAAC54B;MACd,CAAC;MACD,IAAIi5B,gBAAgB,GAAIL,IAAI,CAACzjC,IAAI,KAAK,EAAG;MACzCwjC,QAAQ,CAACl+B,EAAE,EAAEm+B,IAAI,CAAC;MAClB,OAAOA,IAAI,CAACzjC,IAAI,KAAK,IAAI,EAAE;QACvB6jC,UAAU,CAACH,EAAE,GAAGD,IAAI,CAACC,EAAE;QACvBG,UAAU,CAACh5B,GAAG,GAAG44B,IAAI,CAAC54B,GAAG;QACzB,IAAI44B,IAAI,CAACzjC,IAAI,KAAK,EAAE,IAAI,CAAC8jC,gBAAgB,EAAE;UACvC,OAAO;YAAEJ,EAAE,EAAED,IAAI,CAACC,EAAE;YAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;UAAK,CAAC;QAC1C,CAAC,MACI,IAAI03B,IAAI,IAAIkB,IAAI,CAACzjC,IAAI,KAAK,EAAE,IAAI,CAAC+f,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;UAC3E,OAAO;YAAE64B,EAAE,EAAED,IAAI,CAACC,EAAE;YAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;UAAK,CAAC;QAC1C,CAAC,MACI,IAAImV,qBAAqB,CAACyjB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,IAC5C,CAAC03B,IAAI,KACJkB,IAAI,CAAC54B,GAAG,KAAK44B,IAAI,CAACzjC,IAAI,CAACE,MAAM,GAAG,CAAC,IAC9B6f,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;UACrD03B,IAAI,GAAG,IAAI;QACf;QACAiB,QAAQ,CAACl+B,EAAE,EAAEm+B,IAAI,CAAC;MACtB;MACA,IAAIzjC,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAAC4jC,UAAU,CAACH,EAAE,CAAC;MACpCG,UAAU,CAACh5B,GAAG,GAAG,CAAC;MAClB,KAAK,IAAInH,CAAC,GAAG1D,IAAI,CAACE,MAAM,GAAG,CAAC,EAAEwD,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QACvC,IAAI,CAACqc,kBAAkB,CAAC/f,IAAI,CAAC0D,CAAC,CAAC,CAAC,EAAE;UAC9BmgC,UAAU,CAACh5B,GAAG,GAAGnH,CAAC;UAClB;QACJ;MACJ;MACA,OAAOmgC,UAAU;IACrB;IACA,SAAS/3B,OAAOA,CAACxG,EAAE,EAAEo+B,EAAE,EAAE74B,GAAG,EAAEqL,GAAG,EAAE;MAC/B,IAAIlW,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACyjC,EAAE,CAAC;MACzB,IAAID,IAAI,GAAG;QACPzjC,IAAI,EAAEA,IAAI;QACV0jC,EAAE,EAAEA,EAAE;QACN74B,GAAG,EAAEA,GAAG;QACRqL,GAAG,EAAEA;MACT,CAAC;MACD,IAAI2tB,UAAU,GAAG;QACbH,EAAE,EAAED,IAAI,CAACC,EAAE;QACX74B,GAAG,EAAE;MACT,CAAC;MACD,IAAIi5B,gBAAgB,GAAIL,IAAI,CAACzjC,IAAI,KAAK,EAAG;MACzCwjC,QAAQ,CAACl+B,EAAE,EAAEm+B,IAAI,CAAC;MAClB,OAAOA,IAAI,CAACzjC,IAAI,KAAK,IAAI,EAAE;QACvB,IAAIyjC,IAAI,CAACzjC,IAAI,KAAK,EAAE,IAAI,CAAC8jC,gBAAgB,EAAE;UACvC,IAAID,UAAU,CAACh5B,GAAG,KAAK,IAAI,EAAE;YACzB,OAAOg5B,UAAU;UACrB,CAAC,MACI;YACD,OAAO;cAAEH,EAAE,EAAED,IAAI,CAACC,EAAE;cAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;YAAI,CAAC;UACzC;QACJ,CAAC,MACI,IAAImV,qBAAqB,CAACyjB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,IAC5Cg5B,UAAU,CAACh5B,GAAG,KAAK,IAAI,IACvB,EAAE44B,IAAI,CAACC,EAAE,KAAKG,UAAU,CAACH,EAAE,IAAID,IAAI,CAAC54B,GAAG,GAAG,CAAC,KAAKg5B,UAAU,CAACh5B,GAAG,CAAC,EAAE;UACpE,OAAOg5B,UAAU;QACrB,CAAC,MACI,IAAIJ,IAAI,CAACzjC,IAAI,KAAK,EAAE,IAAI,CAAC+f,kBAAkB,CAAC0jB,IAAI,CAACzjC,IAAI,CAACyjC,IAAI,CAAC54B,GAAG,CAAC,CAAC,EAAE;UACnEi5B,gBAAgB,GAAG,KAAK;UACxBD,UAAU,GAAG;YAAEH,EAAE,EAAED,IAAI,CAACC,EAAE;YAAE74B,GAAG,EAAE44B,IAAI,CAAC54B;UAAI,CAAC;QAC/C;QACA24B,QAAQ,CAACl+B,EAAE,EAAEm+B,IAAI,CAAC;MACtB;MACA,IAAIzjC,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAAC4jC,UAAU,CAACH,EAAE,CAAC;MACpCG,UAAU,CAACh5B,GAAG,GAAG,CAAC;MAClB,KAAK,IAAInH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1D,IAAI,CAACE,MAAM,EAAE,EAAEwD,CAAC,EAAE;QAClC,IAAI,CAACqc,kBAAkB,CAAC/f,IAAI,CAAC0D,CAAC,CAAC,CAAC,EAAE;UAC9BmgC,UAAU,CAACh5B,GAAG,GAAGnH,CAAC;UAClB;QACJ;MACJ;MACA,OAAOmgC,UAAU;IACrB;IACA,IAAID,UAAU,GAAG;MACbF,EAAE,EAAE3P,GAAG,CAAC/zB,IAAI;MACZ6K,GAAG,EAAEkpB,GAAG,CAAC9wB;IACb,CAAC;IACD,OAAO+pB,MAAM,GAAG,CAAC,EAAE;MACf,IAAI9W,GAAG,GAAG,CAAC,EAAE;QACT0tB,UAAU,GAAG93B,OAAO,CAACxG,EAAE,EAAEs+B,UAAU,CAACF,EAAE,EAAEE,UAAU,CAAC/4B,GAAG,EAAEqL,GAAG,CAAC;MAChE,CAAC,MACI;QACD0tB,UAAU,GAAG5nB,OAAO,CAAC1W,EAAE,EAAEs+B,UAAU,CAACF,EAAE,EAAEE,UAAU,CAAC/4B,GAAG,EAAEqL,GAAG,CAAC;MAChE;MACA8W,MAAM,EAAE;IACZ;IACA,OAAO,IAAI9nB,GAAG,CAAC0+B,UAAU,CAACF,EAAE,EAAEE,UAAU,CAAC/4B,GAAG,CAAC;EACjD;EACA,SAASgtB,qBAAqBA,CAACvyB,EAAE,EAAEnC,IAAI,EAAEw+B,IAAI,EAAExlB,SAAS,EAAE;IACtD,IAAI4X,GAAG,GAAG5wB,IAAI;MAAE3C,KAAK;MAAEC,GAAG;IAC1B,IAAIsjC,aAAa,GAAI;MACjB,GAAG,EAAE,MAAM;MAAE,GAAG,EAAE,MAAM;MACxB,GAAG,EAAE,OAAO;MAAE,GAAG,EAAE,OAAO;MAC1B,GAAG,EAAE,MAAM;MAAE,GAAG,EAAE,MAAM;MACxB,GAAG,EAAE,MAAM;MAAE,GAAG,EAAE;IACtB,CAAC,CAAEpC,IAAI,CAAC;IACR,IAAIqC,OAAO,GAAI;MACX,GAAG,EAAE,GAAG;MAAE,GAAG,EAAE,GAAG;MAClB,GAAG,EAAE,GAAG;MAAE,GAAG,EAAE,GAAG;MAClB,GAAG,EAAE,GAAG;MAAE,GAAG,EAAE,GAAG;MAClB,GAAG,EAAE,GAAG;MAAE,GAAG,EAAE;IACnB,CAAC,CAAErC,IAAI,CAAC;IACR,IAAIsC,OAAO,GAAG3+B,EAAE,CAACrF,OAAO,CAAC8zB,GAAG,CAAC/zB,IAAI,CAAC,CAAC2X,MAAM,CAACoc,GAAG,CAAC9wB,EAAE,CAAC;IACjD,IAAIwe,MAAM,GAAGwiB,OAAO,KAAKD,OAAO,GAAG,CAAC,GAAG,CAAC;IACxCxjC,KAAK,GAAG8E,EAAE,CAAC2Q,cAAc,CAAC,IAAI/Q,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAE+zB,GAAG,CAAC9wB,EAAE,GAAGwe,MAAM,CAAC,EAAE,CAAC,CAAC,EAAErR,SAAS,EAAE;MAAE,cAAc,EAAE2zB;IAAc,CAAC,CAAC;IAC/GtjC,GAAG,GAAG6E,EAAE,CAAC2Q,cAAc,CAAC,IAAI/Q,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAE+zB,GAAG,CAAC9wB,EAAE,GAAGwe,MAAM,CAAC,EAAE,CAAC,EAAErR,SAAS,EAAE;MAAE,cAAc,EAAE2zB;IAAc,CAAC,CAAC;IAC5G,IAAI,CAACvjC,KAAK,IAAI,CAACC,GAAG,EACd,OAAO,IAAI;IACfD,KAAK,GAAGA,KAAK,CAACqK,GAAG;IACjBpK,GAAG,GAAGA,GAAG,CAACoK,GAAG;IACb,IAAKrK,KAAK,CAACR,IAAI,IAAIS,GAAG,CAACT,IAAI,IAAIQ,KAAK,CAACyC,EAAE,GAAGxC,GAAG,CAACwC,EAAE,IACxCzC,KAAK,CAACR,IAAI,GAAGS,GAAG,CAACT,IAAK,EAAE;MAC5B,IAAI+yB,GAAG,GAAGvyB,KAAK;MACfA,KAAK,GAAGC,GAAG;MACXA,GAAG,GAAGsyB,GAAG;IACb;IACA,IAAI5W,SAAS,EAAE;MACX1b,GAAG,CAACwC,EAAE,IAAI,CAAC;IACf,CAAC,MACI;MACDzC,KAAK,CAACyC,EAAE,IAAI,CAAC;IACjB;IACA,OAAO;MAAEzC,KAAK,EAAEA,KAAK;MAAEC,GAAG,EAAEA;IAAI,CAAC;EACrC;EACA,SAASq3B,mBAAmBA,CAACxyB,EAAE,EAAEnC,IAAI,EAAEw+B,IAAI,EAAExlB,SAAS,EAAE;IACpD,IAAI4X,GAAG,GAAGtC,UAAU,CAACtuB,IAAI,CAAC;IAC1B,IAAInD,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAAC8zB,GAAG,CAAC/zB,IAAI,CAAC;IAC/B,IAAIkkC,KAAK,GAAGlkC,IAAI,CAAC0pB,KAAK,CAAC,EAAE,CAAC;IAC1B,IAAIlpB,KAAK,EAAEC,GAAG,EAAEiD,CAAC,EAAEygC,GAAG;IACtB,IAAIC,UAAU,GAAGF,KAAK,CAAC/rB,OAAO,CAACwpB,IAAI,CAAC;IACpC,IAAI5N,GAAG,CAAC9wB,EAAE,GAAGmhC,UAAU,EAAE;MACrBrQ,GAAG,CAAC9wB,EAAE,GAAGmhC,UAAU;IACvB,CAAC,MACI,IAAIA,UAAU,GAAGrQ,GAAG,CAAC9wB,EAAE,IAAIihC,KAAK,CAACnQ,GAAG,CAAC9wB,EAAE,CAAC,IAAI0+B,IAAI,EAAE;MACnD,IAAI0C,WAAW,GAAG,QAAQ,CAAC3jC,IAAI,CAAC4E,EAAE,CAACsP,cAAc,CAACmK,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MAC5E,IAAImhC,YAAY,GAAG,QAAQ,CAAC5jC,IAAI,CAAC4E,EAAE,CAACsP,cAAc,CAACzR,IAAI,CAAC,CAAC;MACzD,IAAIohC,aAAa,GAAGF,WAAW,IAAI,CAACC,YAAY;MAChD,IAAI,CAACC,aAAa,EAAE;QAChB9jC,GAAG,GAAGszB,GAAG,CAAC9wB,EAAE,CAAC,CAAC;QACd,EAAE8wB,GAAG,CAAC9wB,EAAE,CAAC,CAAC;MACd;IACJ;IACA,IAAIihC,KAAK,CAACnQ,GAAG,CAAC9wB,EAAE,CAAC,IAAI0+B,IAAI,IAAI,CAAClhC,GAAG,EAAE;MAC/BD,KAAK,GAAGuzB,GAAG,CAAC9wB,EAAE,GAAG,CAAC,CAAC,CAAC;IACxB,CAAC,MACI;MACD,KAAKS,CAAC,GAAGqwB,GAAG,CAAC9wB,EAAE,EAAES,CAAC,GAAG,CAAC,CAAC,IAAI,CAAClD,KAAK,EAAEkD,CAAC,EAAE,EAAE;QACpC,IAAIwgC,KAAK,CAACxgC,CAAC,CAAC,IAAIi+B,IAAI,EAAE;UAClBnhC,KAAK,GAAGkD,CAAC,GAAG,CAAC;QACjB;MACJ;IACJ;IACA,IAAIlD,KAAK,IAAI,CAACC,GAAG,EAAE;MACf,KAAKiD,CAAC,GAAGlD,KAAK,EAAE2jC,GAAG,GAAGD,KAAK,CAAChkC,MAAM,EAAEwD,CAAC,GAAGygC,GAAG,IAAI,CAAC1jC,GAAG,EAAEiD,CAAC,EAAE,EAAE;QACtD,IAAIwgC,KAAK,CAACxgC,CAAC,CAAC,IAAIi+B,IAAI,EAAE;UAClBlhC,GAAG,GAAGiD,CAAC;QACX;MACJ;IACJ;IACA,IAAI,CAAClD,KAAK,IAAI,CAACC,GAAG,EAAE;MAChB,OAAO;QAAED,KAAK,EAAEuzB,GAAG;QAAEtzB,GAAG,EAAEszB;MAAI,CAAC;IACnC;IACA,IAAI5X,SAAS,EAAE;MACX,EAAE3b,KAAK;MACP,EAAEC,GAAG;IACT;IACA,OAAO;MACHD,KAAK,EAAE,IAAI0E,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAEQ,KAAK,CAAC;MAC/BC,GAAG,EAAE,IAAIyE,GAAG,CAAC6uB,GAAG,CAAC/zB,IAAI,EAAES,GAAG;IAC9B,CAAC;EACL;EACA0E,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC;EACrC,SAASq/B,WAAWA,CAAA,EAAG,CAAE;EACzBA,WAAW,CAACliC,SAAS,GAAG;IACpB8tB,QAAQ,EAAE,SAAAA,CAAA,EAAY;MAClB,OAAOzN,cAAc,CAAChT,KAAK;IAC/B,CAAC;IACD80B,QAAQ,EAAE,SAAAA,CAAU90B,KAAK,EAAE;MACvBgT,cAAc,CAAChT,KAAK,GAAGA,KAAK;IAChC,CAAC;IACD+0B,UAAU,EAAE,SAAAA,CAAA,EAAY;MACpB,OAAO,IAAI,CAACC,aAAa;IAC7B,CAAC;IACDC,UAAU,EAAE,SAAAA,CAAUC,OAAO,EAAE;MAC3B,IAAI,CAACF,aAAa,GAAGE,OAAO;IAChC,CAAC;IACD5Q,UAAU,EAAE,SAAAA,CAAA,EAAY;MACpB,OAAOtR,cAAc,CAACsR,UAAU;IACpC,CAAC;IACDhE,WAAW,EAAE,SAAAA,CAAU6U,QAAQ,EAAE;MAC7BniB,cAAc,CAACsR,UAAU,GAAG6Q,QAAQ;IACxC,CAAC;IACDC,oBAAoB,EAAE,SAAAA,CAAA,EAAY;MAC9B,OAAO,IAAI,CAACC,QAAQ;IACxB,CAAC;IACDC,oBAAoB,EAAE,SAAAA,CAAUD,QAAQ,EAAE;MACtC,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAC5B;EACJ,CAAC;EACD,SAAShV,cAAcA,CAAC1qB,EAAE,EAAE;IACxB,IAAI2U,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,OAAOA,GAAG,CAACirB,YAAY,KAAKjrB,GAAG,CAACirB,YAAY,GAAG,IAAIV,WAAW,CAAC,CAAC,CAAC;EACrE;EACA,SAASW,YAAYA,CAACC,SAAS,EAAE;IAC7B,OAAOC,gBAAgB,CAACD,SAAS,EAAE,GAAG,CAAC;EAC3C;EACA,SAASE,oBAAoBA,CAACF,SAAS,EAAE;IACrC,OAAOG,uBAAuB,CAACH,SAAS,EAAE,GAAG,CAAC;EAClD;EACA,SAASC,gBAAgBA,CAACD,SAAS,EAAEI,SAAS,EAAE;IAC5C,IAAIC,OAAO,GAAGF,uBAAuB,CAACH,SAAS,EAAEI,SAAS,CAAC,IAAI,EAAE;IACjE,IAAI,CAACC,OAAO,CAACvlC,MAAM,EACf,OAAO,EAAE;IACb,IAAIwlC,MAAM,GAAG,EAAE;IACf,IAAID,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,EAChB;IACJ,KAAK,IAAI/hC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+hC,OAAO,CAACvlC,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACrC,IAAI,OAAO+hC,OAAO,CAAC/hC,CAAC,CAAC,IAAI,QAAQ,EAC7BgiC,MAAM,CAACv9B,IAAI,CAACi9B,SAAS,CAAC1W,SAAS,CAAC+W,OAAO,CAAC/hC,CAAC,CAAC,GAAG,CAAC,EAAE+hC,OAAO,CAAC/hC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACxE;IACA,OAAOgiC,MAAM;EACjB;EACA,SAASH,uBAAuBA,CAAC7sB,GAAG,EAAE8sB,SAAS,EAAE;IAC7C,IAAI,CAACA,SAAS,EACVA,SAAS,GAAG,GAAG;IACnB,IAAIG,cAAc,GAAG,KAAK;IAC1B,IAAIF,OAAO,GAAG,EAAE;IAChB,KAAK,IAAI/hC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgV,GAAG,CAACxY,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACjC,IAAIqe,CAAC,GAAGrJ,GAAG,CAACf,MAAM,CAACjU,CAAC,CAAC;MACrB,IAAI,CAACiiC,cAAc,IAAI5jB,CAAC,IAAIyjB,SAAS,EAAE;QACnCC,OAAO,CAACt9B,IAAI,CAACzE,CAAC,CAAC;MACnB;MACAiiC,cAAc,GAAG,CAACA,cAAc,IAAK5jB,CAAC,IAAI,IAAK;IACnD;IACA,OAAO0jB,OAAO;EAClB;EACA,SAASG,cAAcA,CAACltB,GAAG,EAAE;IACzB,IAAImtB,QAAQ,GAAG,MAAM;IACrB,IAAIC,QAAQ,GAAG,GAAG;IAClB,IAAIH,cAAc,GAAG,KAAK;IAC1B,IAAII,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIriC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAGgV,GAAG,CAACxY,MAAM,EAAEwD,CAAC,EAAE,EAAE;MAClC,IAAIqe,CAAC,GAAGrJ,GAAG,CAACf,MAAM,CAACjU,CAAC,CAAC,IAAI,EAAE;MAC3B,IAAI2U,CAAC,GAAGK,GAAG,CAACf,MAAM,CAACjU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE;MAC/B,IAAIsiC,gBAAgB,GAAI3tB,CAAC,IAAIwtB,QAAQ,CAAC1tB,OAAO,CAACE,CAAC,CAAC,IAAI,CAAC,CAAE;MACvD,IAAIstB,cAAc,EAAE;QAChB,IAAI5jB,CAAC,KAAK,IAAI,IAAI,CAACikB,gBAAgB,EAAE;UACjCD,GAAG,CAAC59B,IAAI,CAAC4Z,CAAC,CAAC;QACf;QACA4jB,cAAc,GAAG,KAAK;MAC1B,CAAC,MACI;QACD,IAAI5jB,CAAC,KAAK,IAAI,EAAE;UACZ4jB,cAAc,GAAG,IAAI;UACrB,IAAIttB,CAAC,IAAIytB,QAAQ,CAAC3tB,OAAO,CAACE,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;YAChC2tB,gBAAgB,GAAG,IAAI;UAC3B;UACA,IAAI,CAACA,gBAAgB,IAAI3tB,CAAC,KAAK,IAAI,EAAE;YACjC0tB,GAAG,CAAC59B,IAAI,CAAC4Z,CAAC,CAAC;UACf;QACJ,CAAC,MACI;UACDgkB,GAAG,CAAC59B,IAAI,CAAC4Z,CAAC,CAAC;UACX,IAAIikB,gBAAgB,IAAI3tB,CAAC,KAAK,IAAI,EAAE;YAChC0tB,GAAG,CAAC59B,IAAI,CAAC,IAAI,CAAC;UAClB;QACJ;MACJ;IACJ;IACA,OAAO49B,GAAG,CAACve,IAAI,CAAC,EAAE,CAAC;EACvB;EACA,IAAIye,aAAa,GAAG;IAAE,KAAK,EAAE,IAAI;IAAE,KAAK,EAAE,IAAI;IAAE,KAAK,EAAE;EAAK,CAAC;EAC7D,SAASC,qBAAqBA,CAACxtB,GAAG,EAAE;IAChC,IAAIitB,cAAc,GAAG,KAAK;IAC1B,IAAII,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIriC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAGgV,GAAG,CAACxY,MAAM,EAAEwD,CAAC,EAAE,EAAE;MAClC,IAAIqe,CAAC,GAAGrJ,GAAG,CAACf,MAAM,CAACjU,CAAC,CAAC,IAAI,EAAE;MAC3B,IAAI2U,CAAC,GAAGK,GAAG,CAACf,MAAM,CAACjU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE;MAC/B,IAAIuiC,aAAa,CAAClkB,CAAC,GAAG1J,CAAC,CAAC,EAAE;QACtB0tB,GAAG,CAAC59B,IAAI,CAAC89B,aAAa,CAAClkB,CAAC,GAAG1J,CAAC,CAAC,CAAC;QAC9B3U,CAAC,EAAE;MACP,CAAC,MACI,IAAIiiC,cAAc,EAAE;QACrBI,GAAG,CAAC59B,IAAI,CAAC4Z,CAAC,CAAC;QACX4jB,cAAc,GAAG,KAAK;MAC1B,CAAC,MACI;QACD,IAAI5jB,CAAC,KAAK,IAAI,EAAE;UACZ4jB,cAAc,GAAG,IAAI;UACrB,IAAK9lB,QAAQ,CAACxH,CAAC,CAAC,IAAIA,CAAC,KAAK,GAAG,EAAG;YAC5B0tB,GAAG,CAAC59B,IAAI,CAAC,GAAG,CAAC;UACjB,CAAC,MACI,IAAIkQ,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,IAAI,EAAE;YAC9B0tB,GAAG,CAAC59B,IAAI,CAAC,IAAI,CAAC;UAClB;QACJ,CAAC,MACI;UACD,IAAI4Z,CAAC,KAAK,GAAG,EAAE;YACXgkB,GAAG,CAAC59B,IAAI,CAAC,GAAG,CAAC;UACjB;UACA49B,GAAG,CAAC59B,IAAI,CAAC4Z,CAAC,CAAC;UACX,IAAI1J,CAAC,KAAK,GAAG,EAAE;YACX0tB,GAAG,CAAC59B,IAAI,CAAC,IAAI,CAAC;UAClB;QACJ;MACJ;IACJ;IACA,OAAO49B,GAAG,CAACve,IAAI,CAAC,EAAE,CAAC;EACvB;EACA,IAAI2e,SAAS,GAAG;IAAE,KAAK,EAAE,GAAG;IAAE,MAAM,EAAE,IAAI;IAAE,KAAK,EAAE,IAAI;IAAE,KAAK,EAAE,IAAI;IAAE,KAAK,EAAE,IAAI;IAAE,KAAK,EAAE;EAAI,CAAC;EAC/F,SAASC,oBAAoBA,CAAC1tB,GAAG,EAAE;IAC/B,IAAI2tB,MAAM,GAAG,IAAI3hC,UAAU,CAACyS,YAAY,CAACuB,GAAG,CAAC;IAC7C,IAAI4tB,MAAM,GAAG,EAAE;IACf,OAAO,CAACD,MAAM,CAAC7uB,GAAG,CAAC,CAAC,EAAE;MAClB,OAAO6uB,MAAM,CAAC3uB,IAAI,CAAC,CAAC,IAAI2uB,MAAM,CAAC3uB,IAAI,CAAC,CAAC,IAAI,IAAI,EAAE;QAC3C4uB,MAAM,CAACn+B,IAAI,CAACk+B,MAAM,CAACz9B,IAAI,CAAC,CAAC,CAAC;MAC9B;MACA,IAAIwuB,OAAO,GAAG,KAAK;MACnB,KAAK,IAAImP,OAAO,IAAIJ,SAAS,EAAE;QAC3B,IAAIE,MAAM,CAACxuB,KAAK,CAAC0uB,OAAO,EAAE,IAAI,CAAC,EAAE;UAC7BnP,OAAO,GAAG,IAAI;UACdkP,MAAM,CAACn+B,IAAI,CAACg+B,SAAS,CAACI,OAAO,CAAC,CAAC;UAC/B;QACJ;MACJ;MACA,IAAI,CAACnP,OAAO,EAAE;QACVkP,MAAM,CAACn+B,IAAI,CAACk+B,MAAM,CAACz9B,IAAI,CAAC,CAAC,CAAC;MAC9B;IACJ;IACA,OAAO09B,MAAM,CAAC9e,IAAI,CAAC,EAAE,CAAC;EAC1B;EACA,SAASgf,UAAUA,CAAC72B,KAAK,EAAEM,UAAU,EAAEsgB,SAAS,EAAE;IAC9C,IAAIkW,kBAAkB,GAAG9jB,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAAC,GAAG,CAAC;IAC3EyjB,kBAAkB,CAACnZ,OAAO,CAAC3d,KAAK,CAAC;IACjC,IAAIA,KAAK,YAAYI,MAAM,EAAE;MACzB,OAAOJ,KAAK;IAChB;IACA,IAAI81B,OAAO,GAAGH,oBAAoB,CAAC31B,KAAK,CAAC;IACzC,IAAI+2B,SAAS;IACb,IAAIC,eAAe;IACnB,IAAI,CAAClB,OAAO,CAACvlC,MAAM,EAAE;MACjBwmC,SAAS,GAAG/2B,KAAK;IACrB,CAAC,MACI;MACD+2B,SAAS,GAAG/2B,KAAK,CAAC+e,SAAS,CAAC,CAAC,EAAE+W,OAAO,CAAC,CAAC,CAAC,CAAC;MAC1C,IAAImB,SAAS,GAAGj3B,KAAK,CAAC+e,SAAS,CAAC+W,OAAO,CAAC,CAAC,CAAC,CAAC;MAC3CkB,eAAe,GAAIC,SAAS,CAACzuB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAE;IACpD;IACA,IAAI,CAACuuB,SAAS,EAAE;MACZ,OAAO,IAAI;IACf;IACA,IAAI,CAAClnC,SAAS,CAAC,MAAM,CAAC,EAAE;MACpBknC,SAAS,GAAGd,cAAc,CAACc,SAAS,CAAC;IACzC;IACA,IAAInW,SAAS,EAAE;MACXtgB,UAAU,GAAI,WAAW,CAAEvP,IAAI,CAACgmC,SAAS,CAAC;IAC9C;IACA,IAAIG,MAAM,GAAG,IAAI92B,MAAM,CAAC22B,SAAS,EAAGz2B,UAAU,IAAI02B,eAAe,GAAI,IAAI,GAAG,GAAG,CAAC;IAChF,OAAOE,MAAM;EACjB;EACA,SAAS3jB,GAAGA,CAAC7K,CAAC,EAAE;IACZ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EACrBA,CAAC,GAAGe,QAAQ,CAACC,aAAa,CAAChB,CAAC,CAAC;IACjC,KAAK,IAAI/L,CAAC,EAAE5I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACzD,MAAM,EAAEwD,CAAC,EAAE,EAAE;MAC1C,IAAI,EAAE4I,CAAC,GAAG3I,SAAS,CAACD,CAAC,CAAC,CAAC,EACnB;MACJ,IAAI,OAAO4I,CAAC,KAAK,QAAQ,EACrBA,CAAC,GAAG8M,QAAQ,CAAC0tB,cAAc,CAACx6B,CAAC,CAAC;MAClC,IAAIA,CAAC,CAACy6B,QAAQ,EACV1uB,CAAC,CAACc,WAAW,CAAC7M,CAAC,CAAC,CAAC,KAEjB,KAAK,IAAIjG,GAAG,IAAIiG,CAAC,EAAE;QACf,IAAI,CAACqf,MAAM,CAACrpB,SAAS,CAACoU,cAAc,CAACO,IAAI,CAAC3K,CAAC,EAAEjG,GAAG,CAAC,EAC7C;QACJ,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EACdgS,CAAC,CAAC8e,KAAK,CAAC9wB,GAAG,CAACnF,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGoL,CAAC,CAACjG,GAAG,CAAC,CAAC,KAE/BgS,CAAC,CAAC2uB,YAAY,CAAC3gC,GAAG,EAAEiG,CAAC,CAACjG,GAAG,CAAC,CAAC;MACnC;IACR;IACA,OAAOgS,CAAC;EACZ;EACA,SAASoY,WAAWA,CAACnrB,EAAE,EAAE4T,QAAQ,EAAE;IAC/B,IAAI+tB,GAAG,GAAG/jB,GAAG,CAAC,KAAK,EAAE;MAAEgkB,MAAM,EAAE,KAAK;MAAEC,WAAW,EAAE,KAAK;MAAEhkB,KAAK,EAAE;IAAiB,CAAC,EAAEjK,QAAQ,CAAC;IAC9F,IAAI5T,EAAE,CAAC8hC,gBAAgB,EAAE;MACrB9hC,EAAE,CAAC8hC,gBAAgB,CAACH,GAAG,EAAE;QAAE13B,MAAM,EAAE,IAAI;QAAEyL,QAAQ,EAAE;MAAK,CAAC,CAAC;IAC9D,CAAC,MACI;MACDqsB,KAAK,CAACJ,GAAG,CAACK,SAAS,CAAC;IACxB;EACJ;EACA,SAASC,UAAUA,CAAC9gB,MAAM,EAAEwK,IAAI,EAAE;IAC9B,OAAO/N,GAAG,CAAC,KAAK,EAAE;MAAEskB,QAAQ,EAAE;IAAO,CAAC,EAAEtkB,GAAG,CAAC,MAAM,EAAE;MAAEukB,WAAW,EAAE,WAAW;MAAEN,WAAW,EAAE,KAAK;MAAEO,KAAK,EAAE;IAAE,CAAC,EAAEjhB,MAAM,EAAEvD,GAAG,CAAC,OAAO,EAAE;MAAEnO,IAAI,EAAE,MAAM;MAAE4yB,WAAW,EAAE,KAAK;MACnKC,cAAc,EAAE,KAAK;MAAEC,UAAU,EAAE,OAAO;MAAEC,MAAM,EAAE;IAAO,CAAC,CAAC,CAAC,EAAE7W,IAAI,IAAI/N,GAAG,CAAC,MAAM,EAAE;MAAEgkB,MAAM,EAAE;IAAO,CAAC,EAAEjW,IAAI,CAAC,CAAC;EACtH;EACA,SAAS3G,UAAUA,CAAChlB,EAAE,EAAEjG,OAAO,EAAE;IAC7B,IAAIgqB,aAAa,CAACnpB,MAAM,EAAE;MACtB,IAAI,CAACb,OAAO,CAACuD,KAAK,EACdvD,OAAO,CAACuD,KAAK,GAAG,EAAE;MACtB0mB,aAAa,GAAGjqB,OAAO;MACvB;IACJ;IACA,IAAI6Z,QAAQ,GAAGquB,UAAU,CAACloC,OAAO,CAAConB,MAAM,EAAEpnB,OAAO,CAAC4xB,IAAI,CAAC;IACvD,IAAI3rB,EAAE,CAAC2d,UAAU,EAAE;MACf3d,EAAE,CAAC2d,UAAU,CAAC/J,QAAQ,EAAE7Z,OAAO,CAAC2a,OAAO,EAAE;QACrCY,SAAS,EAAEvb,OAAO,CAACub,SAAS;QAAED,OAAO,EAAEtb,OAAO,CAACsb,OAAO;QACtDpL,MAAM,EAAE,IAAI;QAAEiL,iBAAiB,EAAE,KAAK;QAAE5X,KAAK,EAAEvD,OAAO,CAACuD;MAC3D,CAAC,CAAC;IACN,CAAC,MACI;MACD,IAAImlC,SAAS,GAAG,EAAE;MAClB,IAAI,OAAO1oC,OAAO,CAAConB,MAAM,IAAI,QAAQ,IAAIpnB,OAAO,CAAConB,MAAM,EACnDshB,SAAS,IAAI1oC,OAAO,CAAConB,MAAM,CAACuhB,WAAW;MAC3C,IAAI3oC,OAAO,CAAC4xB,IAAI,EACZ8W,SAAS,IAAI,GAAG,GAAG1oC,OAAO,CAAC4xB,IAAI;MACnC5xB,OAAO,CAAC2a,OAAO,CAAC+P,MAAM,CAACge,SAAS,EAAE,EAAE,CAAC,CAAC;IAC1C;EACJ;EACA,SAASE,UAAUA,CAACC,EAAE,EAAEC,EAAE,EAAE;IACxB,IAAID,EAAE,YAAYn4B,MAAM,IAAIo4B,EAAE,YAAYp4B,MAAM,EAAE;MAC9C,IAAIq4B,KAAK,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,YAAY,EAAE,QAAQ,CAAC;MAC3D,KAAK,IAAI1kC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0kC,KAAK,CAACloC,MAAM,EAAEwD,CAAC,EAAE,EAAE;QACnC,IAAI46B,IAAI,GAAG8J,KAAK,CAAC1kC,CAAC,CAAC;QACnB,IAAIwkC,EAAE,CAAC5J,IAAI,CAAC,KAAK6J,EAAE,CAAC7J,IAAI,CAAC,EAAE;UACvB,OAAO,KAAK;QAChB;MACJ;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACA,SAAS9N,iBAAiBA,CAAClrB,EAAE,EAAE+iC,QAAQ,EAAEp4B,UAAU,EAAEsgB,SAAS,EAAE;IAC5D,IAAI,CAAC8X,QAAQ,EAAE;MACX;IACJ;IACA,IAAI1jC,KAAK,GAAGqrB,cAAc,CAAC1qB,EAAE,CAAC;IAC9B,IAAIqK,KAAK,GAAG62B,UAAU,CAAC6B,QAAQ,EAAE,CAAC,CAACp4B,UAAU,EAAE,CAAC,CAACsgB,SAAS,CAAC;IAC3D,IAAI,CAAC5gB,KAAK,EAAE;MACR;IACJ;IACAukB,sBAAsB,CAAC5uB,EAAE,EAAEqK,KAAK,CAAC;IACjC,IAAIs4B,UAAU,CAACt4B,KAAK,EAAEhL,KAAK,CAACyrB,QAAQ,CAAC,CAAC,CAAC,EAAE;MACrC,OAAOzgB,KAAK;IAChB;IACAhL,KAAK,CAAC8/B,QAAQ,CAAC90B,KAAK,CAAC;IACrB,OAAOA,KAAK;EAChB;EACA,SAASg1B,aAAaA,CAACh1B,KAAK,EAAE;IAC1B,IAAIA,KAAK,CAACO,MAAM,CAACyH,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;MAC/B,IAAI2wB,QAAQ,GAAG,IAAI;IACvB;IACA,OAAO;MACHzzB,KAAK,EAAE,SAAAA,CAAUwxB,MAAM,EAAE;QACrB,IAAIiC,QAAQ,IAAI,CAACjC,MAAM,CAAC5uB,GAAG,CAAC,CAAC,EAAE;UAC3B4uB,MAAM,CAACpuB,SAAS,CAAC,CAAC;UAClB;QACJ;QACA,IAAIJ,KAAK,GAAGwuB,MAAM,CAACxuB,KAAK,CAAClI,KAAK,EAAE,KAAK,CAAC;QACtC,IAAIkI,KAAK,EAAE;UACP,IAAIA,KAAK,CAAC,CAAC,CAAC,CAAC3X,MAAM,IAAI,CAAC,EAAE;YACtBmmC,MAAM,CAACz9B,IAAI,CAAC,CAAC;YACb,OAAO,WAAW;UACtB;UACA,IAAI,CAACy9B,MAAM,CAAC5uB,GAAG,CAAC,CAAC,EAAE;YACf4uB,MAAM,CAACjuB,MAAM,CAAC,CAAC,CAAC;YAChB,IAAI,CAACzI,KAAK,CAACrP,IAAI,CAAC+lC,MAAM,CAACz9B,IAAI,CAAC,CAAC,GAAGiP,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;cACvCwuB,MAAM,CAACz9B,IAAI,CAAC,CAAC;cACb,OAAO,IAAI;YACf;UACJ;UACAy9B,MAAM,CAACxuB,KAAK,CAAClI,KAAK,CAAC;UACnB,OAAO,WAAW;QACtB;QACA,OAAO,CAAC02B,MAAM,CAAC7uB,GAAG,CAAC,CAAC,EAAE;UAClB6uB,MAAM,CAACz9B,IAAI,CAAC,CAAC;UACb,IAAIy9B,MAAM,CAACxuB,KAAK,CAAClI,KAAK,EAAE,KAAK,CAAC,EAC1B;QACR;MACJ,CAAC;MACDA,KAAK,EAAEA;IACX,CAAC;EACL;EACA,IAAIiP,gBAAgB,GAAG,CAAC;EACxB,SAASsV,sBAAsBA,CAAC5uB,EAAE,EAAEqK,KAAK,EAAE;IACvCsL,YAAY,CAAC2D,gBAAgB,CAAC;IAC9B,IAAI2pB,WAAW,GAAGvY,cAAc,CAAC1qB,EAAE,CAAC;IACpCijC,WAAW,CAAC3pB,gBAAgB,GAAGA,gBAAgB;IAC/CA,gBAAgB,GAAG1D,UAAU,CAAC,YAAY;MACtC,IAAI,CAAC5V,EAAE,CAACX,KAAK,CAACsV,GAAG,EACb;MACJ,IAAIsuB,WAAW,GAAGvY,cAAc,CAAC1qB,EAAE,CAAC;MACpCijC,WAAW,CAAC3pB,gBAAgB,GAAG,IAAI;MACnC,IAAIimB,OAAO,GAAG0D,WAAW,CAAC7D,UAAU,CAAC,CAAC;MACtC,IAAI,CAACG,OAAO,IAAIl1B,KAAK,IAAIk1B,OAAO,CAACl1B,KAAK,EAAE;QACpC,IAAIk1B,OAAO,EAAE;UACTv/B,EAAE,CAACwC,aAAa,CAAC+8B,OAAO,CAAC;QAC7B;QACAA,OAAO,GAAGF,aAAa,CAACh1B,KAAK,CAAC;QAC9BrK,EAAE,CAACmO,UAAU,CAACoxB,OAAO,CAAC;QACtB,IAAIv/B,EAAE,CAACkjC,sBAAsB,EAAE;UAC3B,IAAID,WAAW,CAACxD,oBAAoB,CAAC,CAAC,EAAE;YACpCwD,WAAW,CAACxD,oBAAoB,CAAC,CAAC,CAACh4B,KAAK,CAAC,CAAC;UAC9C;UACAw7B,WAAW,CAACtD,oBAAoB,CAAC3/B,EAAE,CAACkjC,sBAAsB,CAAC74B,KAAK,CAAC,CAAC;QACtE;QACA44B,WAAW,CAAC3D,UAAU,CAACC,OAAO,CAAC;MACnC;IACJ,CAAC,EAAE,EAAE,CAAC;EACV;EACA,SAASp0B,QAAQA,CAACnL,EAAE,EAAE0uB,IAAI,EAAErkB,KAAK,EAAEqd,MAAM,EAAE;IACvC,IAAIA,MAAM,KAAK5c,SAAS,EAAE;MACtB4c,MAAM,GAAG,CAAC;IACd;IACA,OAAO1nB,EAAE,CAAC8D,SAAS,CAAC,YAAY;MAC5B,IAAIyB,GAAG,GAAGvF,EAAE,CAACqF,SAAS,CAAC,CAAC;MACxB,IAAI/I,MAAM,GAAG0D,EAAE,CAACoK,eAAe,CAACC,KAAK,EAAE9E,GAAG,CAAC;MAC3C,KAAK,IAAInH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;QAC7B,IAAIsD,KAAK,GAAGpF,MAAM,CAACoL,IAAI,CAACgnB,IAAI,CAAC;QAC7B,IAAItwB,CAAC,IAAI,CAAC,IAAIsD,KAAK,IAAIua,WAAW,CAAC3f,MAAM,CAACqP,IAAI,CAAC,CAAC,EAAEpG,GAAG,CAAC,EAAE;UACpD,IAAI49B,UAAU,GAAGzU,IAAI,GAAGpyB,MAAM,CAACqP,IAAI,CAAC,CAAC,GAAGrP,MAAM,CAACsP,EAAE,CAAC,CAAC;UACnDlK,KAAK,GAAGpF,MAAM,CAACoL,IAAI,CAACgnB,IAAI,CAAC;UACzB,IAAIhtB,KAAK,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,IAAIua,WAAW,CAAC3f,MAAM,CAACqP,IAAI,CAAC,CAAC,EAAEw3B,UAAU,CAAC,EAAE;YAC9D,IAAInjC,EAAE,CAACrF,OAAO,CAACwoC,UAAU,CAACzoC,IAAI,CAAC,CAACE,MAAM,IAAIuoC,UAAU,CAACxlC,EAAE,EACnD+D,KAAK,GAAGpF,MAAM,CAACoL,IAAI,CAACgnB,IAAI,CAAC;UACjC;QACJ;QACA,IAAI,CAAChtB,KAAK,EAAE;UACRpF,MAAM,GAAG0D,EAAE,CAACoK,eAAe,CAACC,KAAK,EAAGqkB,IAAI,GAAI,IAAI9uB,GAAG,CAACI,EAAE,CAAC4E,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAIhF,GAAG,CAACI,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UAChG,IAAI,CAACrI,MAAM,CAACoL,IAAI,CAACgnB,IAAI,CAAC,EAAE;YACpB;UACJ;QACJ;MACJ;MACA,OAAOpyB,MAAM,CAACqP,IAAI,CAAC,CAAC;IACxB,CAAC,CAAC;EACN;EACA,SAASojB,0BAA0BA,CAAC/uB,EAAE,EAAE0uB,IAAI,EAAErkB,KAAK,EAAEqd,MAAM,EAAE/S,GAAG,EAAE;IAC9D,IAAI+S,MAAM,KAAK5c,SAAS,EAAE;MACtB4c,MAAM,GAAG,CAAC;IACd;IACA,OAAO1nB,EAAE,CAAC8D,SAAS,CAAC,YAAY;MAC5B,IAAIyB,GAAG,GAAGvF,EAAE,CAACqF,SAAS,CAAC,CAAC;MACxB,IAAI/I,MAAM,GAAG0D,EAAE,CAACoK,eAAe,CAACC,KAAK,EAAE9E,GAAG,CAAC;MAC3C,IAAI7D,KAAK,GAAGpF,MAAM,CAACoL,IAAI,CAAC,CAACgnB,IAAI,CAAC;MAC9B,IAAI,CAAC/Z,GAAG,CAAC4J,UAAU,IAAI7c,KAAK,IAAIua,WAAW,CAAC3f,MAAM,CAACqP,IAAI,CAAC,CAAC,EAAEpG,GAAG,CAAC,EAAE;QAC7DjJ,MAAM,CAACoL,IAAI,CAAC,CAACgnB,IAAI,CAAC;MACtB;MACA,KAAK,IAAItwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;QAC7BsD,KAAK,GAAGpF,MAAM,CAACoL,IAAI,CAACgnB,IAAI,CAAC;QACzB,IAAI,CAAChtB,KAAK,EAAE;UACRpF,MAAM,GAAG0D,EAAE,CAACoK,eAAe,CAACC,KAAK,EAAGqkB,IAAI,GAAI,IAAI9uB,GAAG,CAACI,EAAE,CAAC4E,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAIhF,GAAG,CAACI,EAAE,CAAC2E,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UAChG,IAAI,CAACrI,MAAM,CAACoL,IAAI,CAACgnB,IAAI,CAAC,EAAE;YACpB;UACJ;QACJ;MACJ;MACA,OAAO,CAACpyB,MAAM,CAACqP,IAAI,CAAC,CAAC,EAAErP,MAAM,CAACsP,EAAE,CAAC,CAAC,CAAC;IACvC,CAAC,CAAC;EACN;EACA,SAAS4f,oBAAoBA,CAACxrB,EAAE,EAAE;IAC9B,IAAIX,KAAK,GAAGqrB,cAAc,CAAC1qB,EAAE,CAAC;IAC9B,IAAIX,KAAK,CAACia,gBAAgB,EAAE;MACxB3D,YAAY,CAACtW,KAAK,CAACia,gBAAgB,CAAC;MACpCja,KAAK,CAACia,gBAAgB,GAAG,IAAI;IACjC;IACAtZ,EAAE,CAACwC,aAAa,CAACkoB,cAAc,CAAC1qB,EAAE,CAAC,CAACo/B,UAAU,CAAC,CAAC,CAAC;IACjD//B,KAAK,CAACigC,UAAU,CAAC,IAAI,CAAC;IACtB,IAAIjgC,KAAK,CAACogC,oBAAoB,CAAC,CAAC,EAAE;MAC9BpgC,KAAK,CAACogC,oBAAoB,CAAC,CAAC,CAACh4B,KAAK,CAAC,CAAC;MACpCpI,KAAK,CAACsgC,oBAAoB,CAAC,IAAI,CAAC;IACpC;EACJ;EACA,SAASyD,SAASA,CAAC79B,GAAG,EAAErK,KAAK,EAAEC,GAAG,EAAE;IAChC,IAAI,OAAOoK,GAAG,IAAI,QAAQ,EAAE;MACxBA,GAAG,GAAGA,GAAG,CAAC7K,IAAI;IAClB;IACA,IAAIQ,KAAK,YAAY4C,KAAK,EAAE;MACxB,OAAO6c,OAAO,CAACpV,GAAG,EAAErK,KAAK,CAAC;IAC9B,CAAC,MACI;MACD,IAAI,OAAOC,GAAG,IAAI,QAAQ,EAAE;QACxB,OAAQoK,GAAG,IAAIrK,KAAK,IAAIqK,GAAG,IAAIpK,GAAG;MACtC,CAAC,MACI;QACD,OAAOoK,GAAG,IAAIrK,KAAK;MACvB;IACJ;EACJ;EACA,SAASizB,mBAAmBA,CAACnuB,EAAE,EAAE;IAC7B,IAAIxD,QAAQ,GAAGwD,EAAE,CAACzG,GAAG,CAACiD,QAAQ;IAC9B,OAAO;MACHqN,GAAG,EAAErN,QAAQ,CAAC6mC,uBAAuB,CAAC,CAAC;MACvCp5B,MAAM,EAAEzN,QAAQ,CAAC8mC,sBAAsB,CAAC;IAC5C,CAAC;EACL;EACA,SAASpU,UAAUA,CAAClvB,EAAE,EAAE2U,GAAG,EAAEojB,QAAQ,EAAE;IACnC,IAAIA,QAAQ,IAAI,IAAI,IAAIA,QAAQ,IAAI,GAAG,EAAE;MACrC,OAAO1a,cAAc,CAAC2B,QAAQ,CAACtX,IAAI,CAAC1H,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,IAAIJ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IAChE,CAAC,MACI,IAAIm4B,QAAQ,IAAI,GAAG,EAAE;MACtB,OAAO/C,cAAc,CAACh1B,EAAE,CAAC;IAC7B;IACA,IAAIoc,IAAI,GAAGzH,GAAG,CAACrV,KAAK,CAACy4B,QAAQ,CAAC;IAC9B,OAAO3b,IAAI,IAAIA,IAAI,CAAC1U,IAAI,CAAC,CAAC;EAC9B;EACA,SAASstB,cAAcA,CAACh1B,EAAE,EAAE;IACxB,IAAIA,EAAE,CAACyR,cAAc,EAAE;MACnB,OAAOzR,EAAE,CAACyR,cAAc,CAAC,CAAC;IAC9B;IACA,IAAI8xB,IAAI,GAAGvjC,EAAE,CAAC6L,GAAG,CAAC23B,OAAO,CAACD,IAAI;IAC9B,KAAK,IAAInlC,CAAC,GAAGmlC,IAAI,CAAC3oC,MAAM,EAAEwD,CAAC,EAAE,GAAG;MAC5B,IAAImlC,IAAI,CAACnlC,CAAC,CAAC,CAACse,OAAO,EAAE;QACjB,OAAOyP,UAAU,CAACoX,IAAI,CAACnlC,CAAC,CAAC,CAACse,OAAO,CAAC,CAAC,CAAC,CAAC9Q,EAAE,CAAC;MAC5C;IACJ;EACJ;EACA,IAAI63B,mBAAmB,GAAG,SAAAA,CAAA,EAAY;IAClC,IAAI,CAACC,gBAAgB,CAAC,CAAC;EAC3B,CAAC;EACDD,mBAAmB,CAACzmC,SAAS,GAAG;IAC5BumB,cAAc,EAAE,SAAAA,CAAUvjB,EAAE,EAAEyjB,KAAK,EAAEkgB,UAAU,EAAE;MAC7C,IAAIC,IAAI,GAAG,IAAI;MACf5jC,EAAE,CAAC8D,SAAS,CAAC,YAAY;QACrB9D,EAAE,CAACkD,KAAK,CAACmgB,OAAO,GAAG,IAAI;QACvBugB,IAAI,CAACC,eAAe,CAAC7jC,EAAE,EAAEyjB,KAAK,EAAEkgB,UAAU,CAAC;MAC/C,CAAC,CAAC;IACN,CAAC;IACDE,eAAe,EAAE,SAAAA,CAAU7jC,EAAE,EAAEyjB,KAAK,EAAEkgB,UAAU,EAAE;MAC9C,IAAIhvB,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;MACtB,IAAImvB,sBAAsB,GAAGzmB,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAAC,GAAG,CAAC;MAC/E,IAAIqmB,eAAe,GAAGD,sBAAsB,CAAC1b,QAAQ,CAAC,CAAC;MACvD,IAAI4b,WAAW,GAAG,IAAI5kC,UAAU,CAACyS,YAAY,CAAC4R,KAAK,CAAC;MACpDqgB,sBAAsB,CAAC9b,OAAO,CAACvE,KAAK,CAAC;MACrC,IAAIwgB,MAAM,GAAGN,UAAU,IAAI,CAAC,CAAC;MAC7BM,MAAM,CAACxgB,KAAK,GAAGA,KAAK;MACpB,IAAI;QACA,IAAI,CAACygB,WAAW,CAAClkC,EAAE,EAAEgkC,WAAW,EAAEC,MAAM,CAAC;MAC7C,CAAC,CACD,OAAO/nC,CAAC,EAAE;QACNivB,WAAW,CAACnrB,EAAE,EAAE9D,CAAC,CAACksB,QAAQ,CAAC,CAAC,CAAC;QAC7B,MAAMlsB,CAAC;MACX;MACA,IAAIyY,GAAG,CAAC4J,UAAU,EAAE;QAChBuD,cAAc,CAAC9hB,EAAE,CAAC;MACtB;MACA,IAAI7D,OAAO;MACX,IAAIgoC,WAAW;MACf,IAAI,CAACF,MAAM,CAACE,WAAW,EAAE;QACrB,IAAIF,MAAM,CAACvpC,IAAI,KAAKoQ,SAAS,EAAE;UAC3Bq5B,WAAW,GAAG,MAAM;QACxB;MACJ,CAAC,MACI;QACDhoC,OAAO,GAAG,IAAI,CAACioC,aAAa,CAACH,MAAM,CAACE,WAAW,CAAC;QAChD,IAAIhoC,OAAO,EAAE;UACTgoC,WAAW,GAAGhoC,OAAO,CAACC,IAAI;UAC1B,IAAID,OAAO,CAAC2c,yBAAyB,EAAE;YACnCgrB,sBAAsB,CAAC9b,OAAO,CAAC+b,eAAe,CAAC;UACnD;UACA,IAAI,CAACM,iBAAiB,CAACL,WAAW,EAAEC,MAAM,EAAE9nC,OAAO,CAAC;UACpD,IAAIA,OAAO,CAACsT,IAAI,IAAI,SAAS,EAAE;YAC3B6T,UAAU,CAACtjB,EAAE,EAAE7D,OAAO,CAACia,MAAM,EAAEja,OAAO,CAAC;YACvC;UACJ,CAAC,MACI,IAAIA,OAAO,CAACsT,IAAI,IAAI,QAAQ,EAAE;YAC/B,IAAI,CAAC8T,cAAc,CAACvjB,EAAE,EAAE7D,OAAO,CAACmoC,OAAO,CAAC;YACxC;UACJ;QACJ;MACJ;MACA,IAAI,CAACH,WAAW,EAAE;QACdhZ,WAAW,CAACnrB,EAAE,EAAE,0BAA0B,GAAGyjB,KAAK,GAAG,GAAG,CAAC;QACzD;MACJ;MACA,IAAI;QACApC,UAAU,CAAC8iB,WAAW,CAAC,CAACnkC,EAAE,EAAEikC,MAAM,CAAC;QACnC,IAAI,CAAC,CAAC9nC,OAAO,IAAI,CAACA,OAAO,CAAC0c,aAAa,KAAKorB,MAAM,CAAC5vB,QAAQ,EAAE;UACzD4vB,MAAM,CAAC5vB,QAAQ,CAAC,CAAC;QACrB;MACJ,CAAC,CACD,OAAOnY,CAAC,EAAE;QACNivB,WAAW,CAACnrB,EAAE,EAAE9D,CAAC,CAACksB,QAAQ,CAAC,CAAC,CAAC;QAC7B,MAAMlsB,CAAC;MACX;IACJ,CAAC;IACDgoC,WAAW,EAAE,SAAAA,CAAUlkC,EAAE,EAAEgkC,WAAW,EAAEpiC,MAAM,EAAE;MAC5CoiC,WAAW,CAACvxB,QAAQ,CAAC,GAAG,CAAC;MACzB,IAAIuxB,WAAW,CAAC1xB,GAAG,CAAC,GAAG,CAAC,EAAE;QACtB1Q,MAAM,CAAClH,IAAI,GAAGsF,EAAE,CAAC2E,SAAS,CAAC,CAAC;QAC5B/C,MAAM,CAAC2iC,OAAO,GAAGvkC,EAAE,CAAC4E,QAAQ,CAAC,CAAC;MAClC,CAAC,MACI;QACDhD,MAAM,CAAClH,IAAI,GAAG,IAAI,CAAC8pC,cAAc,CAACxkC,EAAE,EAAEgkC,WAAW,CAAC;QAClD,IAAIpiC,MAAM,CAAClH,IAAI,KAAKoQ,SAAS,IAAIk5B,WAAW,CAAC1xB,GAAG,CAAC,GAAG,CAAC,EAAE;UACnD1Q,MAAM,CAAC2iC,OAAO,GAAG,IAAI,CAACC,cAAc,CAACxkC,EAAE,EAAEgkC,WAAW,CAAC;QACzD;MACJ;MACA,IAAIpiC,MAAM,CAAClH,IAAI,IAAIoQ,SAAS,EAAE;QAC1B,IAAI9K,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC4J,UAAU,EAAE;UACzB,IAAIhZ,GAAG,GAAG2pB,UAAU,CAAClvB,EAAE,EAAEA,EAAE,CAACX,KAAK,CAACsV,GAAG,EAAE,GAAG,CAAC;UAC3C/S,MAAM,CAAC6iC,aAAa,GAAGl/B,GAAG,IAAIA,GAAG,CAAC7K,IAAI;UACtC6K,GAAG,GAAG2pB,UAAU,CAAClvB,EAAE,EAAEA,EAAE,CAACX,KAAK,CAACsV,GAAG,EAAE,GAAG,CAAC;UACvC/S,MAAM,CAAC8iC,gBAAgB,GAAGn/B,GAAG,IAAIA,GAAG,CAAC7K,IAAI;QAC7C,CAAC,MACI;UACDkH,MAAM,CAAC6iC,aAAa,GAAGzkC,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI;QAC9C;MACJ,CAAC,MACI;QACDkH,MAAM,CAAC6iC,aAAa,GAAG7iC,MAAM,CAAClH,IAAI;QAClCkH,MAAM,CAAC8iC,gBAAgB,GAAG9iC,MAAM,CAAC2iC,OAAO;MAC5C;MACA,IAAInL,YAAY,GAAG4K,WAAW,CAACzxB,KAAK,CAAC,0BAA0B,CAAC;MAChE,IAAI6mB,YAAY,EAAE;QACdx3B,MAAM,CAACuiC,WAAW,GAAG/K,YAAY,CAAC,CAAC,CAAC;MACxC,CAAC,MACI;QACDx3B,MAAM,CAACuiC,WAAW,GAAGH,WAAW,CAACzxB,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;MACnD;MACA,OAAO3Q,MAAM;IACjB,CAAC;IACD4iC,cAAc,EAAE,SAAAA,CAAUxkC,EAAE,EAAEgkC,WAAW,EAAE;MACvC,IAAIW,WAAW,GAAGX,WAAW,CAACzxB,KAAK,CAAC,QAAQ,CAAC;MAC7C,IAAIoyB,WAAW,EAAE;QACb,OAAOhd,QAAQ,CAACgd,WAAW,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;MAC3C;MACA,QAAQX,WAAW,CAAC1gC,IAAI,CAAC,CAAC;QACtB,KAAK,GAAG;UACJ,OAAO,IAAI,CAACshC,oBAAoB,CAACZ,WAAW,EAAEhkC,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI,CAAC;QACtE,KAAK,GAAG;UACJ,OAAO,IAAI,CAACkqC,oBAAoB,CAACZ,WAAW,EAAEhkC,EAAE,CAAC4E,QAAQ,CAAC,CAAC,CAAC;QAChE,KAAK,IAAI;UACL,IAAImzB,QAAQ,GAAGiM,WAAW,CAAC1gC,IAAI,CAAC,CAAC;UACjC,IAAI0Y,OAAO,GAAGkT,UAAU,CAAClvB,EAAE,EAAEA,EAAE,CAACX,KAAK,CAACsV,GAAG,EAAEojB,QAAQ,CAAC;UACpD,IAAI,CAAC/b,OAAO,EACR,MAAM,IAAIjB,KAAK,CAAC,cAAc,CAAC;UACnC,OAAO,IAAI,CAAC6pB,oBAAoB,CAACZ,WAAW,EAAEhoB,OAAO,CAACthB,IAAI,CAAC;QAC/D,KAAK,GAAG;QACR,KAAK,GAAG;UACJspC,WAAW,CAAClxB,MAAM,CAAC,CAAC,CAAC;UACrB,OAAO,IAAI,CAAC8xB,oBAAoB,CAACZ,WAAW,EAAEhkC,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI,CAAC;QACtE;UACIspC,WAAW,CAAClxB,MAAM,CAAC,CAAC,CAAC;UACrB,OAAOhI,SAAS;MACxB;IACJ,CAAC;IACD85B,oBAAoB,EAAE,SAAAA,CAAUZ,WAAW,EAAEtpC,IAAI,EAAE;MAC/C,IAAImqC,WAAW,GAAGb,WAAW,CAACzxB,KAAK,CAAC,eAAe,CAAC;MACpD,IAAIsyB,WAAW,EAAE;QACb,IAAI1oB,MAAM,GAAGwL,QAAQ,CAACkd,WAAW,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACzC,IAAIA,WAAW,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;UACvBnqC,IAAI,IAAIyhB,MAAM;QAClB,CAAC,MACI;UACDzhB,IAAI,IAAIyhB,MAAM;QAClB;MACJ;MACA,OAAOzhB,IAAI;IACf,CAAC;IACD2pC,iBAAiB,EAAE,SAAAA,CAAUL,WAAW,EAAEC,MAAM,EAAE9nC,OAAO,EAAE;MACvD,IAAI6nC,WAAW,CAAC9xB,GAAG,CAAC,CAAC,EAAE;QACnB;MACJ;MACA+xB,MAAM,CAACnE,SAAS,GAAGkE,WAAW,CAACzxB,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;MAC7C,IAAIuyB,KAAK,GAAG3oC,OAAO,CAAC4oC,YAAY,IAAI,KAAK;MACzC,IAAI1oC,IAAI,GAAG69B,IAAI,CAAC+J,MAAM,CAACnE,SAAS,CAAC,CAAC1b,KAAK,CAAC0gB,KAAK,CAAC;MAC9C,IAAIzoC,IAAI,CAACzB,MAAM,IAAIyB,IAAI,CAAC,CAAC,CAAC,EAAE;QACxB4nC,MAAM,CAAC5nC,IAAI,GAAGA,IAAI;MACtB;IACJ,CAAC;IACD+nC,aAAa,EAAE,SAAAA,CAAUD,WAAW,EAAE;MAClC,KAAK,IAAI/lC,CAAC,GAAG+lC,WAAW,CAACvpC,MAAM,EAAEwD,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACzC,IAAI+iB,MAAM,GAAGgjB,WAAW,CAAC/a,SAAS,CAAC,CAAC,EAAEhrB,CAAC,CAAC;QACxC,IAAI,IAAI,CAACkjB,WAAW,CAACH,MAAM,CAAC,EAAE;UAC1B,IAAIhlB,OAAO,GAAG,IAAI,CAACmlB,WAAW,CAACH,MAAM,CAAC;UACtC,IAAIhlB,OAAO,CAACC,IAAI,CAACyW,OAAO,CAACsxB,WAAW,CAAC,KAAK,CAAC,EAAE;YACzC,OAAOhoC,OAAO;UAClB;QACJ;MACJ;MACA,OAAO,IAAI;IACf,CAAC;IACDunC,gBAAgB,EAAE,SAAAA,CAAA,EAAY;MAC1B,IAAI,CAACpiB,WAAW,GAAG,CAAC,CAAC;MACrB,KAAK,IAAIljB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGua,mBAAmB,CAAC/d,MAAM,EAAEwD,CAAC,EAAE,EAAE;QACjD,IAAIjC,OAAO,GAAGwc,mBAAmB,CAACva,CAAC,CAAC;QACpC,IAAI2C,GAAG,GAAG5E,OAAO,CAACyc,SAAS,IAAIzc,OAAO,CAACC,IAAI;QAC3C,IAAI,CAACklB,WAAW,CAACvgB,GAAG,CAAC,GAAG5E,OAAO;MACnC;IACJ,CAAC;IACD6B,GAAG,EAAE,SAAAA,CAAUiiB,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEG,OAAO,EAAE;MACnC,IAAIL,GAAG,IAAI,GAAG,IAAIA,GAAG,CAAC5N,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;QACpC,IAAI8N,GAAG,EAAE;UACL,MAAMpF,KAAK,CAAC,oCAAoC,CAAC;QACrD;QACA,IAAIopB,WAAW,GAAGlkB,GAAG,CAACmJ,SAAS,CAAC,CAAC,CAAC;QAClC,IAAIlJ,GAAG,IAAI,GAAG,IAAIA,GAAG,CAAC7N,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;UACpC,IAAI,CAACiP,WAAW,CAAC6iB,WAAW,CAAC,GAAG;YAC5B/nC,IAAI,EAAE+nC,WAAW;YACjB10B,IAAI,EAAE,QAAQ;YACd60B,OAAO,EAAEpkB,GAAG,CAACkJ,SAAS,CAAC,CAAC,CAAC;YACzB4b,IAAI,EAAE;UACV,CAAC;QACL,CAAC,MACI;UACD,IAAI,CAAC1jB,WAAW,CAAC6iB,WAAW,CAAC,GAAG;YAC5B/nC,IAAI,EAAE+nC,WAAW;YACjB10B,IAAI,EAAE,SAAS;YACf2G,MAAM,EAAE8J,GAAG;YACX8kB,IAAI,EAAE;UACV,CAAC;QACL;MACJ,CAAC,MACI;QACD,IAAIrkB,OAAO,GAAG;UACVxK,IAAI,EAAE8J,GAAG;UACTxQ,IAAI,EAAE,UAAU;UAChB2G,MAAM,EAAE8J,GAAG;UACXI,OAAO,EAAE,CAAC,CAACA;QACf,CAAC;QACD,IAAIH,GAAG,EAAE;UACLQ,OAAO,CAACtK,OAAO,GAAG8J,GAAG;QACzB;QACAjK,aAAa,CAAC+uB,OAAO,CAACtkB,OAAO,CAAC;MAClC;IACJ,CAAC;IACDN,KAAK,EAAE,SAAAA,CAAUJ,GAAG,EAAEE,GAAG,EAAE;MACvB,IAAIF,GAAG,IAAI,GAAG,IAAIA,GAAG,CAAC5N,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;QACpC,IAAI8N,GAAG,EAAE;UACL,MAAMpF,KAAK,CAAC,oCAAoC,CAAC;QACrD;QACA,IAAIopB,WAAW,GAAGlkB,GAAG,CAACmJ,SAAS,CAAC,CAAC,CAAC;QAClC,IAAI,IAAI,CAAC9H,WAAW,CAAC6iB,WAAW,CAAC,IAAI,IAAI,CAAC7iB,WAAW,CAAC6iB,WAAW,CAAC,CAACa,IAAI,EAAE;UACrE,OAAO,IAAI,CAAC1jB,WAAW,CAAC6iB,WAAW,CAAC;UACpC,OAAO,IAAI;QACf;MACJ,CAAC,MACI;QACD,IAAIhuB,IAAI,GAAG8J,GAAG;QACd,KAAK,IAAI7hB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8X,aAAa,CAACtb,MAAM,EAAEwD,CAAC,EAAE,EAAE;UAC3C,IAAI+X,IAAI,IAAID,aAAa,CAAC9X,CAAC,CAAC,CAAC+X,IAAI,IAC1BD,aAAa,CAAC9X,CAAC,CAAC,CAACiY,OAAO,KAAK8J,GAAG,EAAE;YACrCjK,aAAa,CAACzP,MAAM,CAACrI,CAAC,EAAE,CAAC,CAAC;YAC1B,OAAO,IAAI;UACf;QACJ;MACJ;IACJ;EACJ,CAAC;EACD,IAAIijB,UAAU,GAAG;IACb6jB,WAAW,EAAE,SAAAA,CAAUllC,EAAE,EAAEikC,MAAM,EAAE;MAC/B,IAAI,CAACA,MAAM,CAAC5nC,IAAI,IAAI4nC,MAAM,CAAC5nC,IAAI,CAACzB,MAAM,GAAG,CAAC,EAAE;QACxCuwB,WAAW,CAACnrB,EAAE,EAAEA,EAAE,CAAC9F,SAAS,CAAC,OAAO,CAAC,CAAC;QACtC;MACJ;MACA8F,EAAE,CAAC6N,SAAS,CAAC,OAAO,EAAEo2B,MAAM,CAAC5nC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzC,CAAC;IACD2B,GAAG,EAAE,SAAAA,CAAUgC,EAAE,EAAEikC,MAAM,EAAE9jB,GAAG,EAAEglB,WAAW,EAAE;MACzC,IAAIC,OAAO,GAAGnB,MAAM,CAAC5nC,IAAI;MACzB,IAAI,CAAC+oC,OAAO,IAAIA,OAAO,CAACxqC,MAAM,GAAG,CAAC,EAAE;QAChC,IAAIoF,EAAE,EAAE;UACJmrB,WAAW,CAACnrB,EAAE,EAAE,mBAAmB,GAAGikC,MAAM,CAACxgB,KAAK,CAAC;QACvD;QACA;MACJ;MACArD,mBAAmB,CAACpiB,GAAG,CAAConC,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,EAAEjlB,GAAG,EAAEglB,WAAW,CAAC;IACrE,CAAC;IACDE,IAAI,EAAE,SAAAA,CAAUrlC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,QAAQ,CAAC;IAAE,CAAC;IAC/DqB,IAAI,EAAE,SAAAA,CAAUtlC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,QAAQ,CAAC;IAAE,CAAC;IAC/DsB,IAAI,EAAE,SAAAA,CAAUvlC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,QAAQ,CAAC;IAAE,CAAC;IAC/DuB,IAAI,EAAE,SAAAA,CAAUxlC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,iBAAiB,CAAC;IAAE,CAAC;IACxE3jB,OAAO,EAAE,SAAAA,CAAUtgB,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAEn5B,SAAS,EAAE,IAAI,CAAC;IAAE,CAAC;IACzE26B,QAAQ,EAAE,SAAAA,CAAUzlC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC;IAAE,CAAC;IACzEyB,QAAQ,EAAE,SAAAA,CAAU1lC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC;IAAE,CAAC;IACzE0B,QAAQ,EAAE,SAAAA,CAAU3lC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC;IAAE,CAAC;IACzE2B,QAAQ,EAAE,SAAAA,CAAU5lC,EAAE,EAAEikC,MAAM,EAAE;MAAE,IAAI,CAACjmC,GAAG,CAACgC,EAAE,EAAEikC,MAAM,EAAE,iBAAiB,EAAE,IAAI,CAAC;IAAE,CAAC;IAClF5jB,KAAK,EAAE,SAAAA,CAAUrgB,EAAE,EAAEikC,MAAM,EAAE9jB,GAAG,EAAE;MAC9B,IAAIilB,OAAO,GAAGnB,MAAM,CAAC5nC,IAAI;MACzB,IAAI,CAAC+oC,OAAO,IAAIA,OAAO,CAACxqC,MAAM,GAAG,CAAC,IAAI,CAACwlB,mBAAmB,CAACC,KAAK,CAAC+kB,OAAO,CAAC,CAAC,CAAC,EAAEjlB,GAAG,CAAC,EAAE;QAC/E,IAAIngB,EAAE,EAAE;UACJmrB,WAAW,CAACnrB,EAAE,EAAE,mBAAmB,GAAGikC,MAAM,CAACxgB,KAAK,CAAC;QACvD;MACJ;IACJ,CAAC;IACDlD,QAAQ,EAAE,SAAAA,CAAUvgB,EAAE,EAAEikC,MAAM,EAAE;MAAExkB,MAAM,CAACc,QAAQ,CAAC,CAAC;IAAE,CAAC;IACtDslB,SAAS,EAAE,SAAAA,CAAU7lC,EAAE,EAAEikC,MAAM,EAAE;MAAExkB,MAAM,CAACc,QAAQ,CAAC,QAAQ,CAAC;IAAE,CAAC;IAC/DulB,SAAS,EAAE,SAAAA,CAAU9lC,EAAE,EAAEikC,MAAM,EAAE;MAAExkB,MAAM,CAACc,QAAQ,CAAC,QAAQ,CAAC;IAAE,CAAC;IAC/DwlB,SAAS,EAAE,SAAAA,CAAU/lC,EAAE,EAAEikC,MAAM,EAAE;MAAExkB,MAAM,CAACc,QAAQ,CAAC,QAAQ,CAAC;IAAE,CAAC;IAC/DylB,SAAS,EAAE,SAAAA,CAAUhmC,EAAE,EAAEikC,MAAM,EAAE;MAAExkB,MAAM,CAACc,QAAQ,CAAC,iBAAiB,CAAC;IAAE,CAAC;IACxErE,IAAI,EAAE,SAAAA,CAAUlc,EAAE,EAAEikC,MAAM,EAAE;MACxB7hB,iBAAiB,CAACmB,cAAc,CAACvjB,EAAE,EAAEA,EAAE,CAACX,KAAK,CAACsV,GAAG,EAAE;QAC/ClF,IAAI,EAAE,QAAQ;QACd6G,MAAM,EAAE,4BAA4B;QACpCC,UAAU,EAAE;UAAEG,OAAO,EAAE,KAAK;UAAEI,cAAc,EAAE,IAAI;UAC9CN,QAAQ,EAAE;QAAK,CAAC;QACpBsT,cAAc,EAAEma,MAAM,CAACvpC,IAAI,GAAG;MAClC,CAAC,CAAC;IACN,CAAC;IACDuC,GAAG,EAAE,SAAAA,CAAU+C,EAAE,EAAEikC,MAAM,EAAE;MACvB,IAAIgC,OAAO,GAAGhC,MAAM,CAAC5nC,IAAI;MACzB,IAAI6pC,MAAM,GAAGjC,MAAM,CAACiC,MAAM,IAAI,CAAC,CAAC;MAChC,IAAI,CAACD,OAAO,IAAIA,OAAO,CAACrrC,MAAM,GAAG,CAAC,EAAE;QAChC,IAAIoF,EAAE,EAAE;UACJmrB,WAAW,CAACnrB,EAAE,EAAE,mBAAmB,GAAGikC,MAAM,CAACxgB,KAAK,CAAC;QACvD;QACA;MACJ;MACA,IAAI0iB,IAAI,GAAGF,OAAO,CAAC,CAAC,CAAC,CAAC7hB,KAAK,CAAC,GAAG,CAAC;MAChC,IAAI7E,UAAU,GAAG4mB,IAAI,CAAC,CAAC,CAAC;MACxB,IAAI7oC,KAAK,GAAG6oC,IAAI,CAAC,CAAC,CAAC;MACnB,IAAIC,QAAQ,GAAG,KAAK;MACpB,IAAIC,WAAW,GAAG,KAAK;MACvB,IAAI9mB,UAAU,CAAClN,MAAM,CAACkN,UAAU,CAAC3kB,MAAM,GAAG,CAAC,CAAC,IAAI,GAAG,EAAE;QACjD,IAAI0C,KAAK,EAAE;UACP,MAAMyd,KAAK,CAAC,uBAAuB,GAAGkpB,MAAM,CAACnE,SAAS,CAAC;QAC3D;QACAvgB,UAAU,GAAGA,UAAU,CAAC6J,SAAS,CAAC,CAAC,EAAE7J,UAAU,CAAC3kB,MAAM,GAAG,CAAC,CAAC;QAC3DwrC,QAAQ,GAAG,IAAI;MACnB,CAAC,MACI,IAAI7mB,UAAU,CAAClN,MAAM,CAACkN,UAAU,CAAC3kB,MAAM,GAAG,CAAC,CAAC,IAAI,GAAG,EAAE;QACtD2kB,UAAU,GAAGA,UAAU,CAAC6J,SAAS,CAAC,CAAC,EAAE7J,UAAU,CAAC3kB,MAAM,GAAG,CAAC,CAAC;QAC3DyrC,WAAW,GAAG,IAAI;MACtB;MACA,IAAI/oC,KAAK,KAAKwN,SAAS,IAAIyU,UAAU,CAAC6J,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,EAAE;QAC3D7J,UAAU,GAAGA,UAAU,CAAC6J,SAAS,CAAC,CAAC,CAAC;QACpC9rB,KAAK,GAAG,KAAK;MACjB;MACA,IAAIgpC,eAAe,GAAGvsC,OAAO,CAACwlB,UAAU,CAAC,IAAIxlB,OAAO,CAACwlB,UAAU,CAAC,CAAC9P,IAAI,IAAI,SAAS;MAClF,IAAI62B,eAAe,EAAE;QACjB,IAAID,WAAW,EAAE;UACb/oC,KAAK,GAAG,CAACpD,SAAS,CAACqlB,UAAU,EAAEvf,EAAE,EAAEkmC,MAAM,CAAC;QAC9C,CAAC,MACI,IAAI5oC,KAAK,IAAIwN,SAAS,EAAE;UACzBxN,KAAK,GAAG,IAAI;QAChB;MACJ;MACA,IAAI,CAACgpC,eAAe,IAAIhpC,KAAK,KAAKwN,SAAS,IAAIs7B,QAAQ,EAAE;QACrD,IAAIG,QAAQ,GAAGrsC,SAAS,CAACqlB,UAAU,EAAEvf,EAAE,EAAEkmC,MAAM,CAAC;QAChD,IAAIK,QAAQ,YAAYxrB,KAAK,EAAE;UAC3BoQ,WAAW,CAACnrB,EAAE,EAAEumC,QAAQ,CAACC,OAAO,CAAC;QACrC,CAAC,MACI,IAAID,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,EAAE;UAC9Cpb,WAAW,CAACnrB,EAAE,EAAE,GAAG,IAAIumC,QAAQ,GAAG,EAAE,GAAG,IAAI,CAAC,GAAGhnB,UAAU,CAAC;QAC9D,CAAC,MACI;UACD4L,WAAW,CAACnrB,EAAE,EAAE,IAAI,GAAGuf,UAAU,GAAG,GAAG,GAAGgnB,QAAQ,CAAC;QACvD;MACJ,CAAC,MACI;QACD,IAAIE,eAAe,GAAG54B,SAAS,CAAC0R,UAAU,EAAEjiB,KAAK,EAAE0C,EAAE,EAAEkmC,MAAM,CAAC;QAC9D,IAAIO,eAAe,YAAY1rB,KAAK,EAAE;UAClCoQ,WAAW,CAACnrB,EAAE,EAAEymC,eAAe,CAACD,OAAO,CAAC;QAC5C;MACJ;IACJ,CAAC;IACDE,QAAQ,EAAE,SAAAA,CAAU1mC,EAAE,EAAEikC,MAAM,EAAE;MAC5BA,MAAM,CAACiC,MAAM,GAAG;QAAEhrB,KAAK,EAAE;MAAQ,CAAC;MAClC,IAAI,CAACje,GAAG,CAAC+C,EAAE,EAAEikC,MAAM,CAAC;IACxB,CAAC;IACD0C,SAAS,EAAE,SAAAA,CAAU3mC,EAAE,EAAEikC,MAAM,EAAE;MAC7BA,MAAM,CAACiC,MAAM,GAAG;QAAEhrB,KAAK,EAAE;MAAS,CAAC;MACnC,IAAI,CAACje,GAAG,CAAC+C,EAAE,EAAEikC,MAAM,CAAC;IACxB,CAAC;IACD5b,SAAS,EAAE,SAAAA,CAAUroB,EAAE,EAAEikC,MAAM,EAAE;MAC7B,IAAI2C,OAAO,GAAG3C,MAAM,CAAC5nC,IAAI;MACzB,IAAIgsB,SAAS,GAAGhL,cAAc,CAACI,kBAAkB,CAAC4K,SAAS;MAC3D,IAAIwe,OAAO,GAAG,mCAAmC;MACjD,IAAI,CAACD,OAAO,EAAE;QACV,KAAK,IAAIrpB,YAAY,IAAI8K,SAAS,EAAE;UAChC,IAAItlB,IAAI,GAAGslB,SAAS,CAAC9K,YAAY,CAAC,CAAC6K,QAAQ,CAAC,CAAC;UAC7C,IAAIrlB,IAAI,CAACnI,MAAM,EAAE;YACbisC,OAAO,IAAI,GAAG,GAAGtpB,YAAY,GAAG,MAAM,GAAGxa,IAAI,GAAG,IAAI;UACxD;QACJ;MACJ,CAAC,MACI;QACD,IAAIwa,YAAY;QAChBqpB,OAAO,GAAGA,OAAO,CAAC1kB,IAAI,CAAC,EAAE,CAAC;QAC1B,KAAK,IAAI9jB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwoC,OAAO,CAAChsC,MAAM,EAAEwD,CAAC,EAAE,EAAE;UACrCmf,YAAY,GAAGqpB,OAAO,CAACv0B,MAAM,CAACjU,CAAC,CAAC;UAChC,IAAI,CAACif,cAAc,CAACI,kBAAkB,CAAC8K,eAAe,CAAChL,YAAY,CAAC,EAAE;YAClE;UACJ;UACA,IAAIC,QAAQ,GAAG6K,SAAS,CAAC9K,YAAY,CAAC,IAAI,IAAIsK,QAAQ,CAAC,CAAC;UACxDgf,OAAO,IAAI,GAAG,GAAGtpB,YAAY,GAAG,MAAM,GAAGC,QAAQ,CAAC4K,QAAQ,CAAC,CAAC,GAAG,IAAI;QACvE;MACJ;MACA+C,WAAW,CAACnrB,EAAE,EAAE6mC,OAAO,CAAC;IAC5B,CAAC;IACDC,IAAI,EAAE,SAAAA,CAAU9mC,EAAE,EAAEikC,MAAM,EAAE;MACxB,IAAIz9B,OAAO,EAAEmE,UAAU,EAAEo8B,MAAM,EAAEtO,MAAM,EAAEzlB,OAAO;MAChD,SAASg0B,SAASA,CAAA,EAAG;QACjB,IAAI/C,MAAM,CAACnE,SAAS,EAAE;UAClB,IAAIzjC,IAAI,GAAG,IAAI+C,UAAU,CAACyS,YAAY,CAACoyB,MAAM,CAACnE,SAAS,CAAC;UACxD,IAAIzjC,IAAI,CAACiW,GAAG,CAAC,GAAG,CAAC,EAAE;YACf9L,OAAO,GAAG,IAAI;UAClB;UACA,IAAInK,IAAI,CAAC6V,GAAG,CAAC,CAAC,EAAE;YACZ;UACJ;UACA,IAAI,CAAC7V,IAAI,CAACqW,QAAQ,CAAC,CAAC,EAAE;YAClB,OAAO,mBAAmB;UAC9B;UACA,IAAIu0B,IAAI,GAAG5qC,IAAI,CAACkW,KAAK,CAAC,6BAA6B,CAAC;UACpD,IAAI,CAAC00B,IAAI,IAAI,CAAC5qC,IAAI,CAAC6V,GAAG,CAAC,CAAC,EAAE;YACtB,OAAO,mBAAmB;UAC9B;UACA,IAAI+0B,IAAI,CAAC,CAAC,CAAC,EAAE;YACTt8B,UAAU,GAAGs8B,IAAI,CAAC,CAAC,CAAC,CAACp0B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACvCk0B,MAAM,GAAGE,IAAI,CAAC,CAAC,CAAC,CAACp0B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACnC,IAAIq0B,OAAO,GAAGD,IAAI,CAAC,CAAC,CAAC,CAACp0B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAIo0B,IAAI,CAAC,CAAC,CAAC,CAACp0B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;YAC3E,IAAIs0B,GAAG,GAAGF,IAAI,CAAC,CAAC,CAAC,CAACp0B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;YACzC,IAAIu0B,KAAK,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACp0B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;YAC3C,IAAIq0B,OAAO,GAAGC,GAAG,GAAGC,KAAK,GAAG,CAAC,EAAE;cAC3B,OAAO,mBAAmB;YAC9B;YACA3O,MAAM,GAAGyO,OAAO,IAAI,SAAS,IAAIC,GAAG,IAAI,KAAK,IAAIC,KAAK,IAAI,OAAO;UACrE;UACA,IAAIH,IAAI,CAAC,CAAC,CAAC,EAAE;YACTj0B,OAAO,GAAG,IAAIvI,MAAM,CAACw8B,IAAI,CAAC,CAAC,CAAC,CAAC5zB,MAAM,CAAC,CAAC,EAAE4zB,IAAI,CAAC,CAAC,CAAC,CAACrsC,MAAM,GAAG,CAAC,CAAC,EAAE+P,UAAU,GAAG,GAAG,GAAG,EAAE,CAAC;UACtF;QACJ;MACJ;MACA,IAAI08B,GAAG,GAAGL,SAAS,CAAC,CAAC;MACrB,IAAIK,GAAG,EAAE;QACLlc,WAAW,CAACnrB,EAAE,EAAEqnC,GAAG,GAAG,IAAI,GAAGpD,MAAM,CAACnE,SAAS,CAAC;QAC9C;MACJ;MACA,IAAI7tB,SAAS,GAAGgyB,MAAM,CAACvpC,IAAI,IAAIsF,EAAE,CAAC2E,SAAS,CAAC,CAAC;MAC7C,IAAI4/B,OAAO,GAAGN,MAAM,CAACM,OAAO,IAAIN,MAAM,CAACvpC,IAAI,IAAIsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC;MAC5D,IAAIqN,SAAS,IAAIsyB,OAAO,EAAE;QACtB;MACJ;MACA,IAAIzuB,QAAQ,GAAG,IAAIlW,GAAG,CAACqS,SAAS,EAAE,CAAC,CAAC;MACpC,IAAI8D,MAAM,GAAG,IAAInW,GAAG,CAAC2kC,OAAO,EAAE/W,UAAU,CAACxtB,EAAE,EAAEukC,OAAO,CAAC,CAAC;MACtD,IAAIxhC,IAAI,GAAG/C,EAAE,CAAC0F,QAAQ,CAACoQ,QAAQ,EAAEC,MAAM,CAAC,CAACqO,KAAK,CAAC,IAAI,CAAC;MACpD,IAAIxK,WAAW,GAAG5G,OAAO,GAAGA,OAAO,GAC9BylB,MAAM,IAAI,SAAS,GAAI,aAAa,GAChCA,MAAM,IAAI,KAAK,GAAI,yBAAyB,GACxCA,MAAM,IAAI,OAAO,GAAI,UAAU,GAAG,IAAI;MACnD,IAAI6O,KAAK,GAAI7O,MAAM,IAAI,SAAS,GAAI,EAAE,GAAIA,MAAM,IAAI,KAAK,GAAI,EAAE,GAAIA,MAAM,IAAI,OAAO,GAAI,CAAC,GAAG,IAAI;MAChG,IAAI8O,OAAO,GAAG,EAAE;QAAEC,QAAQ,GAAG,EAAE;MAC/B,IAAI/O,MAAM,IAAIzlB,OAAO,EAAE;QACnB,KAAK,IAAI5U,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2E,IAAI,CAACnI,MAAM,EAAEwD,CAAC,EAAE,EAAE;UAClC,IAAIqpC,SAAS,GAAGz0B,OAAO,GAAGjQ,IAAI,CAAC3E,CAAC,CAAC,CAACmU,KAAK,CAACS,OAAO,CAAC,GAAG,IAAI;UACvD,IAAIy0B,SAAS,IAAIA,SAAS,CAAC,CAAC,CAAC,IAAI,EAAE,EAAE;YACjCF,OAAO,CAAC1kC,IAAI,CAAC4kC,SAAS,CAAC;UAC3B,CAAC,MACI,IAAI,CAACz0B,OAAO,IAAI4G,WAAW,CAAC5e,IAAI,CAAC+H,IAAI,CAAC3E,CAAC,CAAC,CAAC,EAAE;YAC5CmpC,OAAO,CAAC1kC,IAAI,CAACE,IAAI,CAAC3E,CAAC,CAAC,CAAC;UACzB,CAAC,MACI;YACDopC,QAAQ,CAAC3kC,IAAI,CAACE,IAAI,CAAC3E,CAAC,CAAC,CAAC;UAC1B;QACJ;MACJ,CAAC,MACI;QACDopC,QAAQ,GAAGzkC,IAAI;MACnB;MACA,SAAS2kC,SAASA,CAAC1gC,CAAC,EAAE2gC,CAAC,EAAE;QACrB,IAAInhC,OAAO,EAAE;UACT,IAAIinB,GAAG;UACPA,GAAG,GAAGzmB,CAAC;UACPA,CAAC,GAAG2gC,CAAC;UACLA,CAAC,GAAGla,GAAG;QACX;QACA,IAAI9iB,UAAU,EAAE;UACZ3D,CAAC,GAAGA,CAAC,CAAC1F,WAAW,CAAC,CAAC;UACnBqmC,CAAC,GAAGA,CAAC,CAACrmC,WAAW,CAAC,CAAC;QACvB;QACA,IAAIsmC,IAAI,GAAGnP,MAAM,IAAI7e,WAAW,CAAC5e,IAAI,CAACgM,CAAC,CAAC;QACxC,IAAI6gC,IAAI,GAAGpP,MAAM,IAAI7e,WAAW,CAAC5e,IAAI,CAAC2sC,CAAC,CAAC;QACxC,IAAI,CAACC,IAAI,EAAE;UACP,OAAO5gC,CAAC,GAAG2gC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;QACzB;QACAC,IAAI,GAAGjgB,QAAQ,CAAC,CAACigB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,EAAEtmC,WAAW,CAAC,CAAC,EAAEgmC,KAAK,CAAC;QACzDO,IAAI,GAAGlgB,QAAQ,CAAC,CAACkgB,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,EAAEvmC,WAAW,CAAC,CAAC,EAAEgmC,KAAK,CAAC;QACzD,OAAOM,IAAI,GAAGC,IAAI;MACtB;MACA,SAASC,gBAAgBA,CAAC9gC,CAAC,EAAE2gC,CAAC,EAAE;QAC5B,IAAInhC,OAAO,EAAE;UACT,IAAIinB,GAAG;UACPA,GAAG,GAAGzmB,CAAC;UACPA,CAAC,GAAG2gC,CAAC;UACLA,CAAC,GAAGla,GAAG;QACX;QACA,IAAI9iB,UAAU,EAAE;UACZ3D,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAAC1F,WAAW,CAAC,CAAC;UACzBqmC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAACrmC,WAAW,CAAC,CAAC;QAC7B;QACA,OAAQ0F,CAAC,CAAC,CAAC,CAAC,GAAG2gC,CAAC,CAAC,CAAC,CAAC,GAAI,CAAC,CAAC,GAAG,CAAC;MACjC;MACAJ,OAAO,CAACT,IAAI,CAAC9zB,OAAO,GAAG80B,gBAAgB,GAAGJ,SAAS,CAAC;MACpD,IAAI10B,OAAO,EAAE;QACT,KAAK,IAAI5U,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmpC,OAAO,CAAC3sC,MAAM,EAAEwD,CAAC,EAAE,EAAE;UACrCmpC,OAAO,CAACnpC,CAAC,CAAC,GAAGmpC,OAAO,CAACnpC,CAAC,CAAC,CAACqlB,KAAK;QACjC;MACJ,CAAC,MACI,IAAI,CAACgV,MAAM,EAAE;QACd+O,QAAQ,CAACV,IAAI,CAACY,SAAS,CAAC;MAC5B;MACA3kC,IAAI,GAAI,CAACyD,OAAO,GAAIghC,QAAQ,CAACphB,MAAM,CAACmhB,OAAO,CAAC,GAAGA,OAAO,CAACnhB,MAAM,CAACohB,QAAQ,CAAC;MACvE,IAAIT,MAAM,EAAE;QAAE;QACV,IAAIgB,OAAO,GAAGhlC,IAAI;QAClB,IAAI6B,QAAQ;QACZ7B,IAAI,GAAG,EAAE;QACT,KAAK,IAAI3E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2pC,OAAO,CAACntC,MAAM,EAAEwD,CAAC,EAAE,EAAE;UACrC,IAAI2pC,OAAO,CAAC3pC,CAAC,CAAC,IAAIwG,QAAQ,EAAE;YACxB7B,IAAI,CAACF,IAAI,CAACklC,OAAO,CAAC3pC,CAAC,CAAC,CAAC;UACzB;UACAwG,QAAQ,GAAGmjC,OAAO,CAAC3pC,CAAC,CAAC;QACzB;MACJ;MACA4B,EAAE,CAACvE,YAAY,CAACsH,IAAI,CAACmf,IAAI,CAAC,IAAI,CAAC,EAAEpM,QAAQ,EAAEC,MAAM,CAAC;IACtD,CAAC;IACDiyB,OAAO,EAAE,SAAAA,CAAUhoC,EAAE,EAAEikC,MAAM,EAAE;MAC3B,IAAI,CAACv5B,MAAM,CAAC1K,EAAE,EAAEikC,MAAM,CAAC;IAC3B,CAAC;IACDgE,MAAM,EAAE,SAAAA,CAAUjoC,EAAE,EAAEikC,MAAM,EAAE;MAC1B,IAAInE,SAAS,GAAGmE,MAAM,CAACnE,SAAS;MAChC,IAAIA,SAAS,IAAIA,SAAS,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;QAClCA,SAAS,GAAGA,SAAS,CAAClkC,KAAK,CAAC,CAAC,CAAC;QAC9B0kB,OAAO,GAAG,IAAI;MAClB;MACAwf,SAAS,GAAGA,SAAS,CAACoI,SAAS,CAAC,CAAC;MACjC,IAAI,CAACpI,SAAS,EAAE;QACZ3U,WAAW,CAACnrB,EAAE,EAAE,uBAAuB,CAAC;QACxC;MACJ;MACA,IAAItF,IAAI,GAAGupC,MAAM,CAACvpC,IAAI;MACtB,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;QACzB,IAAI6pC,OAAO,GAAG4D,KAAK,CAAClE,MAAM,CAACM,OAAO,CAAC,GAAG7pC,IAAI,GAAGupC,MAAM,CAACM,OAAO;QAC3D,KAAK,IAAInmC,CAAC,GAAG1D,IAAI,EAAE0D,CAAC,IAAImmC,OAAO,EAAEnmC,CAAC,EAAE,EAAE;UAClC4B,EAAE,CAAC+E,SAAS,CAAC3G,CAAC,EAAE,CAAC,CAAC;UAClBklB,UAAU,CAACtjB,EAAE,EAAEikC,MAAM,CAACnE,SAAS,CAACoI,SAAS,CAAC,CAAC,CAAC;UAC5C,IAAIloC,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC6E,UAAU,EAAE;YACzBuI,cAAc,CAAC/hB,EAAE,EAAE,IAAI,CAAC;UAC5B;QACJ;MACJ,CAAC,MACI;QACDsjB,UAAU,CAACtjB,EAAE,EAAEikC,MAAM,CAACnE,SAAS,CAACoI,SAAS,CAAC,CAAC,CAAC;QAC5C,IAAIloC,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC6E,UAAU,EAAE;UACzBuI,cAAc,CAAC/hB,EAAE,EAAE,IAAI,CAAC;QAC5B;MACJ;IACJ,CAAC;IACD0K,MAAM,EAAE,SAAAA,CAAU1K,EAAE,EAAEikC,MAAM,EAAE;MAC1B,IAAInE,SAAS,GAAGmE,MAAM,CAACnE,SAAS;MAChC,IAAI,CAACA,SAAS,EAAE;QACZ3U,WAAW,CAACnrB,EAAE,EAAE,wCAAwC,CAAC;QACzD;MACJ;MACA,IAAIooC,QAAQ,GAAGnE,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG;MAC5C,IAAIrE,SAAS,CAAC,CAAC,CAAC,KAAK,GAAG,IAAImE,MAAM,CAACE,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QACvDiE,QAAQ,GAAG,IAAI;QACftI,SAAS,GAAGA,SAAS,CAAClkC,KAAK,CAAC,CAAC,CAAC;MAClC;MACA,IAAIqW,SAAS,GAAIgyB,MAAM,CAACvpC,IAAI,KAAKoQ,SAAS,GAAIm5B,MAAM,CAACvpC,IAAI,GAAGsF,EAAE,CAAC2E,SAAS,CAAC,CAAC;MAC1E,IAAI4/B,OAAO,GAAGN,MAAM,CAACM,OAAO,IAAIN,MAAM,CAACvpC,IAAI,IAAIsF,EAAE,CAAC4E,QAAQ,CAAC,CAAC;MAC5D,IAAIw7B,MAAM,GAAGP,YAAY,CAACC,SAAS,CAAC;MACpC,IAAIsB,SAAS,GAAGtB,SAAS;QAAE1+B,GAAG;MAC9B,IAAIg/B,MAAM,CAACxlC,MAAM,EAAE;QACfwmC,SAAS,GAAGhB,MAAM,CAAC,CAAC,CAAC;QACrBh/B,GAAG,GAAGg/B,MAAM,CAACxkC,KAAK,CAAC,CAAC,EAAEwkC,MAAM,CAACxlC,MAAM,CAAC,CAACsnB,IAAI,CAAC,GAAG,CAAC;MAClD;MACA,IAAIkf,SAAS,EAAE;QACX,IAAI;UACAlW,iBAAiB,CAAClrB,EAAE,EAAEohC,SAAS,EAAE,IAAI,CAAC,mBAAmB,IAAI,CAAC,gBAAgB,CAAC;QACnF,CAAC,CACD,OAAOllC,CAAC,EAAE;UACNivB,WAAW,CAACnrB,EAAE,EAAE,iBAAiB,GAAGohC,SAAS,CAAC;UAC9C;QACJ;MACJ;MACA,IAAI/2B,KAAK,GAAGqgB,cAAc,CAAC1qB,EAAE,CAAC,CAAC8qB,QAAQ,CAAC,CAAC;MACzC,IAAIud,YAAY,GAAG,EAAE;MACrB,KAAK,IAAIjqC,CAAC,GAAG6T,SAAS,EAAE7T,CAAC,IAAImmC,OAAO,EAAEnmC,CAAC,EAAE,EAAE;QACvC,IAAI1D,IAAI,GAAGsF,EAAE,CAACrF,OAAO,CAACyD,CAAC,CAAC;QACxB,IAAI0zB,OAAO,GAAGznB,KAAK,CAACjP,IAAI,CAACV,IAAI,CAAC;QAC9B,IAAIo3B,OAAO,KAAKsW,QAAQ,EAAE;UACtBC,YAAY,CAACxlC,IAAI,CAACzB,GAAG,GAAGpB,EAAE,CAACuR,aAAa,CAACnT,CAAC,CAAC,GAAG1D,IAAI,CAAC;QACvD;MACJ;MACA,IAAI,CAAC0G,GAAG,EAAE;QACN+pB,WAAW,CAACnrB,EAAE,EAAEqoC,YAAY,CAACnmB,IAAI,CAAC,IAAI,CAAC,CAAC;QACxC;MACJ;MACA,IAAIlmB,KAAK,GAAG,CAAC;MACb,IAAIssC,WAAW,GAAG,SAAAA,CAAA,EAAY;QAC1B,IAAItsC,KAAK,GAAGqsC,YAAY,CAACztC,MAAM,EAAE;UAC7B,IAAI2tC,UAAU,GAAGF,YAAY,CAACrsC,KAAK,EAAE,CAAC;UACtC,IAAIg2B,OAAO,GAAGhyB,EAAE,CAACqR,aAAa,CAACk3B,UAAU,CAAC;UAC1C,IAAIvW,OAAO,IAAI,IAAI,EAAE;YACjBsW,WAAW,CAAC,CAAC;YACb;UACJ;UACA,IAAInsC,OAAO,GAAI61B,OAAO,GAAG,CAAC,GAAI5wB,GAAG;UACjCgf,mBAAmB,CAACmD,cAAc,CAACvjB,EAAE,EAAE7D,OAAO,EAAE;YAC5CkY,QAAQ,EAAEi0B;UACd,CAAC,CAAC;QACN,CAAC,MACI,IAAItoC,EAAE,CAACwR,kBAAkB,EAAE;UAC5BxR,EAAE,CAACwR,kBAAkB,CAAC,CAAC;QAC3B;MACJ,CAAC;MACD82B,WAAW,CAAC,CAAC;IACjB,CAAC;IACDE,UAAU,EAAE,SAAAA,CAAUxoC,EAAE,EAAEikC,MAAM,EAAE;MAC9B,IAAI,CAACjkC,EAAE,CAACoK,eAAe,EAAE;QACrB,MAAM,IAAI2Q,KAAK,CAAC,4DAA4D,GACxE,2CAA2C,CAAC;MACpD;MACA,IAAI+kB,SAAS,GAAGmE,MAAM,CAACnE,SAAS;MAChC,IAAIM,MAAM,GAAGN,SAAS,GAAGC,gBAAgB,CAACD,SAAS,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;MACvE,IAAIsB,SAAS;QAAEqH,WAAW,GAAG,EAAE;QAAEC,QAAQ;QAAEpH,SAAS;QAAEqH,KAAK;MAC3D,IAAIC,OAAO,GAAG,KAAK,CAAC,CAAC;MACrB,IAAIl+B,MAAM,GAAG,KAAK,CAAC,CAAC;MACpB,IAAI01B,MAAM,CAACxlC,MAAM,EAAE;QACfwmC,SAAS,GAAGhB,MAAM,CAAC,CAAC,CAAC;QACrB,IAAIlmC,SAAS,CAAC,MAAM,CAAC,IAAIknC,SAAS,KAAK,EAAE,EAAE;UACvCA,SAAS,GAAG,IAAI32B,MAAM,CAAC22B,SAAS,CAAC,CAACx2B,MAAM,CAAC,CAAC;QAC9C;QACA69B,WAAW,GAAGrI,MAAM,CAAC,CAAC,CAAC;QACvB,IAAIqI,WAAW,KAAK39B,SAAS,EAAE;UAC3B,IAAI5Q,SAAS,CAAC,MAAM,CAAC,EAAE;YACnBuuC,WAAW,GAAG3H,oBAAoB,CAAC2H,WAAW,CAACxtC,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;UACjF,CAAC,MACI;YACDwtC,WAAW,GAAG7H,qBAAqB,CAAC6H,WAAW,CAAC;UACpD;UACAprB,cAAc,CAAC0B,yBAAyB,GAAG0pB,WAAW;QAC1D;QACAC,QAAQ,GAAGtI,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,CAAChc,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;MACpD,CAAC,MACI;QACD,IAAI0b,SAAS,IAAIA,SAAS,CAACllC,MAAM,EAAE;UAC/BuwB,WAAW,CAACnrB,EAAE,EAAE,sCAAsC,GAClD,qBAAqB,CAAC;UAC1B;QACJ;MACJ;MACA,IAAI0oC,QAAQ,EAAE;QACVpH,SAAS,GAAGoH,QAAQ,CAAC,CAAC,CAAC;QACvBC,KAAK,GAAGhhB,QAAQ,CAAC+gB,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC7B,IAAIpH,SAAS,EAAE;UACX,IAAIA,SAAS,CAACzuB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;YAC9B+1B,OAAO,GAAG,IAAI;UAClB;UACA,IAAItH,SAAS,CAACzuB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;YAC9BnI,MAAM,GAAG,IAAI;UACjB;UACA,IAAIxQ,SAAS,CAAC,MAAM,CAAC,EAAE;YACnBknC,SAAS,GAAGA,SAAS,GAAG,GAAG,GAAGE,SAAS;UAC3C,CAAC,MACI;YACDF,SAAS,GAAGA,SAAS,CAACnmC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,GAAG,GAAGqmC,SAAS;UACjE;QACJ;MACJ;MACA,IAAIF,SAAS,EAAE;QACX,IAAI;UACAlW,iBAAiB,CAAClrB,EAAE,EAAEohC,SAAS,EAAE,IAAI,CAAC,mBAAmB,IAAI,CAAC,gBAAgB,CAAC;QACnF,CAAC,CACD,OAAOllC,CAAC,EAAE;UACNivB,WAAW,CAACnrB,EAAE,EAAE,iBAAiB,GAAGohC,SAAS,CAAC;UAC9C;QACJ;MACJ;MACAqH,WAAW,GAAGA,WAAW,IAAIprB,cAAc,CAAC0B,yBAAyB;MACrE,IAAI0pB,WAAW,KAAK39B,SAAS,EAAE;QAC3BqgB,WAAW,CAACnrB,EAAE,EAAE,2CAA2C,CAAC;QAC5D;MACJ;MACA,IAAIX,KAAK,GAAGqrB,cAAc,CAAC1qB,EAAE,CAAC;MAC9B,IAAIqK,KAAK,GAAGhL,KAAK,CAACyrB,QAAQ,CAAC,CAAC;MAC5B,IAAI7Y,SAAS,GAAIgyB,MAAM,CAACvpC,IAAI,KAAKoQ,SAAS,GAAIm5B,MAAM,CAACvpC,IAAI,GAAGsF,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI;MAC/E,IAAI6pC,OAAO,GAAGN,MAAM,CAACM,OAAO,IAAItyB,SAAS;MACzC,IAAIA,SAAS,IAAIjS,EAAE,CAAC2E,SAAS,CAAC,CAAC,IAAI4/B,OAAO,IAAIvkC,EAAE,CAAC4E,QAAQ,CAAC,CAAC,EAAE;QACzD2/B,OAAO,GAAGzX,QAAQ;MACtB;MACA,IAAI6b,KAAK,EAAE;QACP12B,SAAS,GAAGsyB,OAAO;QACnBA,OAAO,GAAGtyB,SAAS,GAAG02B,KAAK,GAAG,CAAC;MACnC;MACA,IAAIE,QAAQ,GAAGzc,mBAAmB,CAACpsB,EAAE,EAAE,IAAIJ,GAAG,CAACqS,SAAS,EAAE,CAAC,CAAC,CAAC;MAC7D,IAAI3V,MAAM,GAAG0D,EAAE,CAACoK,eAAe,CAACC,KAAK,EAAEw+B,QAAQ,CAAC;MAChDC,SAAS,CAAC9oC,EAAE,EAAE4oC,OAAO,EAAEl+B,MAAM,EAAEuH,SAAS,EAAEsyB,OAAO,EAAEjoC,MAAM,EAAE+N,KAAK,EAAEo+B,WAAW,EAAExE,MAAM,CAAC5vB,QAAQ,CAAC;IACnG,CAAC;IACD00B,WAAW,EAAE,SAAAA,CAAU/oC,EAAE,EAAEikC,MAAM,EAAE;MAC/B3gB,UAAU,CAACtjB,EAAE,EAAEikC,MAAM,CAACnE,SAAS,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC;IAC3D,CAAC;IACD//B,IAAI,EAAEX,UAAU,CAACjC,QAAQ,CAAC4C,IAAI;IAC9BE,IAAI,EAAEb,UAAU,CAACjC,QAAQ,CAAC8C,IAAI;IAC9B+oC,KAAK,EAAE,SAAAA,CAAUhpC,EAAE,EAAE;MACjB,IAAIZ,UAAU,CAACjC,QAAQ,CAAC8rC,IAAI,EAAE;QAC1B7pC,UAAU,CAACjC,QAAQ,CAAC8rC,IAAI,CAACjpC,EAAE,CAAC;MAChC,CAAC,MACI,IAAIA,EAAE,CAACipC,IAAI,EAAE;QACdjpC,EAAE,CAACipC,IAAI,CAAC,CAAC;MACb;IACJ,CAAC;IACDC,UAAU,EAAE,SAAAA,CAAUlpC,EAAE,EAAE;MACtBwrB,oBAAoB,CAACxrB,EAAE,CAAC;IAC5B,CAAC;IACDk0B,IAAI,EAAE,SAAAA,CAAUl0B,EAAE,EAAE;MAChB,IAAIyuB,GAAG,GAAGtC,UAAU,CAACnsB,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC;MACpC,IAAI3K,IAAI,GAAG+zB,GAAG,CAAC/zB,IAAI;MACnB,IAAIi3B,QAAQ,GAAG3xB,EAAE,CAACrF,OAAO,CAACD,IAAI,CAAC;MAC/B2iB,cAAc,CAACI,kBAAkB,CAACwK,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE0J,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC;IACjF,CAAC;IACD4B,MAAM,EAAE,SAAAA,CAAUvzB,EAAE,EAAEikC,MAAM,EAAE;MAC1B,IAAIvpC,IAAI,GAAGupC,MAAM,CAACQ,aAAa;MAC/B,IAAIF,OAAO,GAAG4D,KAAK,CAAClE,MAAM,CAACS,gBAAgB,CAAC,GAAGhqC,IAAI,GAAGupC,MAAM,CAACS,gBAAgB;MAC7E3W,SAAS,CAACwF,MAAM,CAACvzB,EAAE,EAAE;QAAEwW,QAAQ,EAAE;MAAK,CAAC,EAAE,CACrC;QAAE5Y,MAAM,EAAE,IAAIgC,GAAG,CAAClF,IAAI,EAAE,CAAC,CAAC;QACtBmD,IAAI,EAAE,IAAI+B,GAAG,CAAC2kC,OAAO,GAAG,CAAC,EAAE,CAAC;MAAE,CAAC,CACtC,CAAC;IACN,CAAC;IACDriB,IAAI,EAAE,SAAAA,CAAUliB,EAAE,EAAEikC,MAAM,EAAE;MACxB,IAAIvpC,IAAI,GAAGupC,MAAM,CAACQ,aAAa;MAC/B,IAAIF,OAAO,GAAG4D,KAAK,CAAClE,MAAM,CAACS,gBAAgB,CAAC,GAAGhqC,IAAI,GAAGupC,MAAM,CAACS,gBAAgB;MAC7E1kC,EAAE,CAAC+E,SAAS,CAAC,IAAInF,GAAG,CAAClF,IAAI,EAAE,CAAC,CAAC,CAAC;MAC9Bgf,OAAO,CAACgc,SAAS,CAAC11B,EAAE,EAAE;QAAE0nB,MAAM,EAAE6c,OAAO,GAAG7pC;MAAK,CAAC,EAAEsF,EAAE,CAACX,KAAK,CAACsV,GAAG,CAAC;IACnE,CAAC;IACDw0B,QAAQ,EAAE,SAAAA,CAAUnpC,EAAE,EAAEikC,MAAM,EAAE;MAC5B,IAAI,CAACA,MAAM,CAACnE,SAAS,IAAI,CAAC5F,IAAI,CAAC+J,MAAM,CAACnE,SAAS,CAAC,EAAE;QAC9C3U,WAAW,CAACnrB,EAAE,EAAE,mBAAmB,CAAC;QACpC;MACJ;MACA,IAAIX,KAAK,GAAGW,EAAE,CAACX,KAAK,CAACsV,GAAG;MACxB,IAAIosB,MAAM,GAAG,IAAI3hC,UAAU,CAACyS,YAAY,CAACqoB,IAAI,CAAC+J,MAAM,CAACnE,SAAS,CAAC,CAAC;MAChE,OAAO,CAACiB,MAAM,CAAC7uB,GAAG,CAAC,CAAC,EAAE;QAClB6uB,MAAM,CAACruB,QAAQ,CAAC,CAAC;QACjB,IAAIi2B,KAAK,GAAG5H,MAAM,CAACx7B,GAAG;QACtB,IAAI,CAACw7B,MAAM,CAACxuB,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE;UAClC4Y,WAAW,CAACnrB,EAAE,EAAE,oBAAoB,GAAGikC,MAAM,CAACnE,SAAS,CAAC1W,SAAS,CAACuf,KAAK,CAAC,CAAC;UACzE;QACJ;QACA,IAAIS,GAAG,GAAGrI,MAAM,CAACz9B,IAAI,CAAC,CAAC;QACvB,IAAIy9B,MAAM,CAACxuB,KAAK,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE;UACzB,IAAI,CAACwuB,MAAM,CAACxuB,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE;YAClC4Y,WAAW,CAACnrB,EAAE,EAAE,oBAAoB,GAAGikC,MAAM,CAACnE,SAAS,CAAC1W,SAAS,CAACuf,KAAK,CAAC,CAAC;YACzE;UACJ;UACA,IAAIU,SAAS,GAAGD,GAAG;UACnB,IAAIE,UAAU,GAAGvI,MAAM,CAACz9B,IAAI,CAAC,CAAC;UAC9B,IAAI8W,WAAW,CAACivB,SAAS,CAAC,IAAIjvB,WAAW,CAACkvB,UAAU,CAAC,IACjD9uB,WAAW,CAAC6uB,SAAS,CAAC,IAAI7uB,WAAW,CAAC8uB,UAAU,CAAC,EAAE;YACnD,IAAIpuC,KAAK,GAAGmuC,SAAS,CAACpzB,UAAU,CAAC,CAAC,CAAC;YACnC,IAAIszB,MAAM,GAAGD,UAAU,CAACrzB,UAAU,CAAC,CAAC,CAAC;YACrC,IAAI/a,KAAK,IAAIquC,MAAM,EAAE;cACjBpe,WAAW,CAACnrB,EAAE,EAAE,oBAAoB,GAAGikC,MAAM,CAACnE,SAAS,CAAC1W,SAAS,CAACuf,KAAK,CAAC,CAAC;cACzE;YACJ;YACA,KAAK,IAAI7nB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIyoB,MAAM,GAAGruC,KAAK,EAAE4lB,CAAC,EAAE,EAAE;cACtC,IAAI1E,IAAI,GAAGotB,MAAM,CAACC,YAAY,CAACvuC,KAAK,GAAG4lB,CAAC,CAAC;cACzC,OAAOzhB,KAAK,CAACC,KAAK,CAAC8c,IAAI,CAAC;YAC5B;UACJ,CAAC,MACI;YACD+O,WAAW,CAACnrB,EAAE,EAAE,oBAAoB,GAAGqpC,SAAS,GAAG,GAAG,CAAC;YACvD;UACJ;QACJ,CAAC,MACI;UACD,OAAOhqC,KAAK,CAACC,KAAK,CAAC8pC,GAAG,CAAC;QAC3B;MACJ;IACJ;EACJ,CAAC;EACD,IAAIhpB,mBAAmB,GAAG,IAAIqjB,mBAAmB,CAAC,CAAC;EACnD,SAASqF,SAASA,CAAC9oC,EAAE,EAAE4oC,OAAO,EAAEl+B,MAAM,EAAEuH,SAAS,EAAEsyB,OAAO,EAAEmF,YAAY,EAAEr/B,KAAK,EAAE2tB,WAAW,EAAE3jB,QAAQ,EAAE;IACpGrU,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACg1B,MAAM,GAAG,IAAI;IAC1B,IAAIpG,IAAI,GAAG,KAAK;IAChB,IAAIqG,OAAO,EAAEC,kBAAkB,EAAEC,MAAM;IACvC,SAASC,UAAUA,CAAA,EAAG;MAClB/pC,EAAE,CAAC8D,SAAS,CAAC,YAAY;QACrB,OAAO,CAACy/B,IAAI,EAAE;UACVtoC,OAAO,CAAC,CAAC;UACTqI,IAAI,CAAC,CAAC;QACV;QACA25B,IAAI,CAAC,CAAC;MACV,CAAC,CAAC;IACN;IACA,SAAShiC,OAAOA,CAAA,EAAG;MACf,IAAI8H,IAAI,GAAG/C,EAAE,CAAC0F,QAAQ,CAACgkC,YAAY,CAAC/9B,IAAI,CAAC,CAAC,EAAE+9B,YAAY,CAAC99B,EAAE,CAAC,CAAC,CAAC;MAC9D,IAAIo+B,OAAO,GAAGjnC,IAAI,CAAC9H,OAAO,CAACoP,KAAK,EAAE2tB,WAAW,CAAC;MAC9C,IAAIiS,oBAAoB,GAAGP,YAAY,CAAC99B,EAAE,CAAC,CAAC,CAAClR,IAAI;MACjDgvC,YAAY,CAACzuC,OAAO,CAAC+uC,OAAO,CAAC;MAC7BH,kBAAkB,GAAGH,YAAY,CAAC99B,EAAE,CAAC,CAAC,CAAClR,IAAI;MAC3C6pC,OAAO,IAAIsF,kBAAkB,GAAGI,oBAAoB;MACpDH,MAAM,GAAGD,kBAAkB,GAAGI,oBAAoB;IACtD;IACA,SAASC,kBAAkBA,CAAA,EAAG;MAC1B,IAAIC,WAAW,GAAGP,OAAO,IAAIzd,UAAU,CAACud,YAAY,CAAC99B,EAAE,CAAC,CAAC,CAAC;MAC1D,IAAI2G,KAAK,GAAGm3B,YAAY,CAACv+B,QAAQ,CAAC,CAAC;MACnC,IAAIoH,KAAK,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,IAAI43B,WAAW,IAAIluB,WAAW,CAACytB,YAAY,CAAC/9B,IAAI,CAAC,CAAC,EAAEw+B,WAAW,CAAC,EAAE;QACpF53B,KAAK,GAAGm3B,YAAY,CAACv+B,QAAQ,CAAC,CAAC;MACnC;MACA,OAAOoH,KAAK;IAChB;IACA,SAASjP,IAAIA,CAAA,EAAG;MACZ,OAAO4mC,kBAAkB,CAAC,CAAC,IACvB9G,SAAS,CAACsG,YAAY,CAAC/9B,IAAI,CAAC,CAAC,EAAEsG,SAAS,EAAEsyB,OAAO,CAAC,EAAE;QACpD,IAAI,CAAC75B,MAAM,IAAIg/B,YAAY,CAAC/9B,IAAI,CAAC,CAAC,CAACjR,IAAI,IAAImvC,kBAAkB,IAAI,CAACC,MAAM,EAAE;UACtE;QACJ;QACA9pC,EAAE,CAACmE,cAAc,CAACulC,YAAY,CAAC/9B,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC;QAC1C3L,EAAE,CAAC+G,YAAY,CAAC2iC,YAAY,CAAC/9B,IAAI,CAAC,CAAC,EAAE+9B,YAAY,CAAC99B,EAAE,CAAC,CAAC,CAAC;QACvDg+B,OAAO,GAAGF,YAAY,CAAC/9B,IAAI,CAAC,CAAC;QAC7B43B,IAAI,GAAG,KAAK;QACZ;MACJ;MACAA,IAAI,GAAG,IAAI;IACf;IACA,SAAStG,IAAIA,CAACntB,KAAK,EAAE;MACjB,IAAIA,KAAK,EAAE;QACPA,KAAK,CAAC,CAAC;MACX;MACA9P,EAAE,CAACwQ,KAAK,CAAC,CAAC;MACV,IAAIo5B,OAAO,EAAE;QACT5pC,EAAE,CAAC+E,SAAS,CAAC6kC,OAAO,CAAC;QACrB,IAAIj1B,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;QACtBA,GAAG,CAACg1B,MAAM,GAAG,KAAK;QAClBh1B,GAAG,CAACuJ,QAAQ,GAAGvJ,GAAG,CAACwJ,SAAS,GAAGyrB,OAAO,CAACjsC,EAAE;MAC7C;MACA,IAAI0W,QAAQ,EAAE;QACVA,QAAQ,CAAC,CAAC;MACd;IACJ;IACA,SAASoX,eAAeA,CAACvvB,CAAC,EAAEkuC,MAAM,EAAEt6B,KAAK,EAAE;MACvC1Q,UAAU,CAACuB,MAAM,CAACzE,CAAC,CAAC;MACpB,IAAI4E,OAAO,GAAGmgB,eAAe,CAAC/kB,CAAC,CAAC;MAChC,QAAQ4E,OAAO;QACX,KAAK,GAAG;UACJ7F,OAAO,CAAC,CAAC;UACTqI,IAAI,CAAC,CAAC;UACN;QACJ,KAAK,GAAG;UACJA,IAAI,CAAC,CAAC;UACN;QACJ,KAAK,GAAG;UACJ,IAAI+mC,aAAa,GAAGh2B,QAAQ;UAC5BA,QAAQ,GAAGvJ,SAAS;UACpB9K,EAAE,CAAC8D,SAAS,CAACimC,UAAU,CAAC;UACxB11B,QAAQ,GAAGg2B,aAAa;UACxB;QACJ,KAAK,GAAG;UACJpvC,OAAO,CAAC,CAAC;QACb,KAAK,GAAG;QACR,KAAK,OAAO;QACZ,KAAK,OAAO;QACZ,KAAK,OAAO;UACRgiC,IAAI,CAACntB,KAAK,CAAC;UACX;MACR;MACA,IAAIyzB,IAAI,EAAE;QACNtG,IAAI,CAACntB,KAAK,CAAC;MACf;MACA,OAAO,IAAI;IACf;IACAxM,IAAI,CAAC,CAAC;IACN,IAAIigC,IAAI,EAAE;MACNpY,WAAW,CAACnrB,EAAE,EAAE,iBAAiB,GAAGqK,KAAK,CAACO,MAAM,CAAC;MACjD;IACJ;IACA,IAAI,CAACg+B,OAAO,EAAE;MACVmB,UAAU,CAAC,CAAC;MACZ,IAAI11B,QAAQ,EAAE;QACVA,QAAQ,CAAC,CAAC;MACd;MACA;IACJ;IACA2Q,UAAU,CAAChlB,EAAE,EAAE;MACXmhB,MAAM,EAAEvD,GAAG,CAAC,MAAM,EAAE,eAAe,EAAEA,GAAG,CAAC,QAAQ,EAAEoa,WAAW,CAAC,EAAE,cAAc,CAAC;MAChF1iB,SAAS,EAAEmW;IACf,CAAC,CAAC;EACN;EACA,SAAS1J,cAAcA,CAAC/hB,EAAE,EAAEyX,UAAU,EAAE;IACpC,IAAI9C,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,IAAIyI,cAAc,GAAGC,cAAc,CAACD,cAAc;IAClD,IAAIktB,wBAAwB,GAAGjtB,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAAC,GAAG,CAAC;IACjF,IAAIZ,SAAS,GAAGM,cAAc,CAACN,SAAS;IACxC,IAAIzZ,UAAU,GAAG+Z,cAAc,CAACF,qBAAqB;IACrD,IAAI,CAACJ,SAAS,EAAE;MACZ9c,EAAE,CAAC3C,GAAG,CAAC,QAAQ,EAAEmC,QAAQ,CAAC;MAC1B,IAAImV,GAAG,CAACsgB,SAAS,EACbtgB,GAAG,CAACsgB,SAAS,CAACxtB,KAAK,CAAC,CAAC;MACzBkN,GAAG,CAACsgB,SAAS,GAAG,IAAI;MACpB71B,UAAU,CAAC/B,GAAG,CAAC2C,EAAE,CAACkN,aAAa,CAAC,CAAC,EAAE,SAAS,EAAEgoB,uBAAuB,CAAC;IAC1E;IACA,IAAI,CAACpY,SAAS,IAAInI,GAAG,CAAC2J,gBAAgB,GAAG,CAAC,EAAE;MACxCqa,cAAc,CAAC34B,EAAE,EAAE2U,GAAG,EAAEA,GAAG,CAAC2J,gBAAgB,GAAG,CAAC,EAAE,IAAI,CAAC,sBAAsB,CAAC;MAC9E3J,GAAG,CAACqJ,kBAAkB,CAAC8L,cAAc,GAAGnV,GAAG,CAAC2J,gBAAgB;IAChE;IACA,OAAO3J,GAAG,CAAC2J,gBAAgB;IAC3B3J,GAAG,CAAC6E,UAAU,GAAG,KAAK;IACtB,IAAI,CAAC/B,UAAU,EAAE;MACbzX,EAAE,CAAC+E,SAAS,CAAC/E,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC3K,IAAI,EAAEsF,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC1H,EAAE,GAAG,CAAC,CAAC;IAC5D;IACAqC,EAAE,CAAC6N,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC;IAC7B7N,EAAE,CAAC6N,SAAS,CAAC,cAAc,EAAE,IAAI,CAAC;IAClC7N,EAAE,CAACgO,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;IAC3Bs8B,wBAAwB,CAACtiB,OAAO,CAAC3kB,UAAU,CAACqZ,OAAO,CAACwF,IAAI,CAAC,EAAE,CAAC,CAAC;IAC7D9iB,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;MAAE0J,IAAI,EAAE;IAAS,CAAC,CAAC;IAC5D,IAAI0T,cAAc,CAACL,WAAW,EAAE;MAC5BwtB,mBAAmB,CAACntB,cAAc,CAAC;IACvC;EACJ;EACA,SAASwD,WAAWA,CAACzkB,OAAO,EAAE;IAC1B+Z,aAAa,CAAC+uB,OAAO,CAAC9oC,OAAO,CAAC;EAClC;EACA,SAAS0nB,UAAUA,CAAC1N,IAAI,EAAE1G,IAAI,EAAErT,IAAI,EAAEC,IAAI,EAAEmuC,KAAK,EAAE;IAC/C,IAAIruC,OAAO,GAAG;MAAEga,IAAI,EAAEA,IAAI;MAAE1G,IAAI,EAAEA;IAAK,CAAC;IACxCtT,OAAO,CAACsT,IAAI,CAAC,GAAGrT,IAAI;IACpBD,OAAO,CAACsT,IAAI,GAAG,MAAM,CAAC,GAAGpT,IAAI;IAC7B,KAAK,IAAI0E,GAAG,IAAIypC,KAAK,EACjBruC,OAAO,CAAC4E,GAAG,CAAC,GAAGypC,KAAK,CAACzpC,GAAG,CAAC;IAC7B6f,WAAW,CAACzkB,OAAO,CAAC;EACxB;EACA0D,YAAY,CAAC,0BAA0B,EAAE,GAAG,EAAE,QAAQ,CAAC;EACvD,SAASi1B,oBAAoBA,CAAC90B,EAAE,EAAE2U,GAAG,EAAEyI,cAAc,EAAEG,YAAY,EAAE;IACjE,IAAIC,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACH,YAAY,CAAC;IAC1E,IAAIA,YAAY,IAAI,GAAG,EAAE;MACrB,IAAIC,QAAQ,CAACyE,SAAS,CAAC,CAAC,CAAC,EAAE;QACvB7B,mBAAmB,CAACmD,cAAc,CAACvjB,EAAE,EAAEwd,QAAQ,CAACyE,SAAS,CAAC,CAAC,CAAC,CAAC;MACjE;MACA7E,cAAc,CAACN,SAAS,GAAG,KAAK;MAChC;IACJ;IACA,IAAImF,SAAS,GAAGzE,QAAQ,CAACyE,SAAS;IAClC,IAAIwoB,GAAG,GAAG,CAAC;IACXrtB,cAAc,CAACN,SAAS,GAAG,IAAI;IAC/BM,cAAc,CAACJ,mBAAmB,GAAGQ,QAAQ,CAACuK,aAAa,CAACnsB,KAAK,CAAC,CAAC,CAAC;IACpE,KAAK,IAAIwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6jB,SAAS,CAACrnB,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACvC,IAAI2E,IAAI,GAAGkf,SAAS,CAAC7jB,CAAC,CAAC;MACvB,IAAImU,KAAK,EAAExR,GAAG;MACd,OAAOgC,IAAI,EAAE;QACTwP,KAAK,GAAI,mBAAmB,CAAEvX,IAAI,CAAC+H,IAAI,CAAC;QACxChC,GAAG,GAAGwR,KAAK,CAAC,CAAC,CAAC;QACdxP,IAAI,GAAGA,IAAI,CAACqmB,SAAS,CAAC7W,KAAK,CAACvW,KAAK,GAAG+E,GAAG,CAACnG,MAAM,CAAC;QAC/C6kB,MAAM,CAAC8B,SAAS,CAACvhB,EAAE,EAAEe,GAAG,EAAE,OAAO,CAAC;QAClC,IAAI4T,GAAG,CAAC6E,UAAU,EAAE;UAChB,IAAIkD,OAAO,GAAGc,QAAQ,CAACsK,iBAAiB,CAAC2iB,GAAG,EAAE,CAAC,CAAC/tB,OAAO;UACvDW,cAAc,CAACD,cAAc,CAACF,qBAAqB,CAACR,OAAO,GACvDA,OAAO;UACXguB,uBAAuB,CAAC1qC,EAAE,EAAE0c,OAAO,EAAE,CAAC,CAAC;UACvCqF,cAAc,CAAC/hB,EAAE,CAAC;QACtB;MACJ;IACJ;IACAod,cAAc,CAACN,SAAS,GAAG,KAAK;EACpC;EACA,SAAS8E,MAAMA,CAACxE,cAAc,EAAErc,GAAG,EAAE;IACjC,IAAIqc,cAAc,CAACN,SAAS,EAAE;MAC1B;IACJ;IACA,IAAIS,YAAY,GAAGH,cAAc,CAACP,cAAc;IAChD,IAAIW,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACH,YAAY,CAAC;IAC1E,IAAIC,QAAQ,EAAE;MACVA,QAAQ,CAACyK,QAAQ,CAAClnB,GAAG,CAAC;IAC1B;EACJ;EACA,SAASwpC,mBAAmBA,CAACntB,cAAc,EAAE;IACzC,IAAIA,cAAc,CAACN,SAAS,EAAE;MAC1B;IACJ;IACA,IAAIS,YAAY,GAAGH,cAAc,CAACP,cAAc;IAChD,IAAIW,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACH,YAAY,CAAC;IAC1E,IAAIC,QAAQ,IAAIA,QAAQ,CAAC0K,qBAAqB,EAAE;MAC5C1K,QAAQ,CAAC0K,qBAAqB,CAAC9K,cAAc,CAACF,qBAAqB,CAAC;IACxE;EACJ;EACA,SAASmO,cAAcA,CAACjO,cAAc,EAAE/S,KAAK,EAAE;IAC3C,IAAI+S,cAAc,CAACN,SAAS,EAAE;MAC1B;IACJ;IACA,IAAIS,YAAY,GAAGH,cAAc,CAACP,cAAc;IAChD,IAAIW,QAAQ,GAAGH,cAAc,CAACI,kBAAkB,CAACC,WAAW,CAACH,YAAY,CAAC;IAC1E,IAAIC,QAAQ,IAAIA,QAAQ,CAAC2K,eAAe,EAAE;MACtC3K,QAAQ,CAAC2K,eAAe,CAAC9d,KAAK,CAAC;IACnC;EACJ;EACA,SAAS7K,QAAQA,CAACQ,EAAE,EAAE2qC,SAAS,EAAE;IAC7B,IAAIvtB,cAAc,GAAGC,cAAc,CAACD,cAAc;IAClD,IAAI/Z,UAAU,GAAG+Z,cAAc,CAACF,qBAAqB;IACrD,IAAI,CAACE,cAAc,CAACN,SAAS,EAAE;MAC3B,IAAInI,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;MACtB,OAAOg2B,SAAS,EAAE;QACdtnC,UAAU,CAACsZ,6BAA6B,GAAG,IAAI;QAC/C,IAAItZ,UAAU,CAACunC,WAAW,GAAG,CAAC,EAAE;UAC5BvnC,UAAU,CAACunC,WAAW,EAAE;QAC5B,CAAC,MACI,IAAID,SAAS,CAACxjC,MAAM,IAAI,QAAQ,IAAIwjC,SAAS,CAACxjC,MAAM,IAAI,OAAO,IAC7DwjC,SAAS,CAACxjC,MAAM,KAAK2D,SAAS,CAAC,uBAAuB;UACzD,IAAI+/B,cAAc,GAAG7qC,EAAE,CAAC4F,cAAc,CAAC,CAAC,CAAChL,MAAM;UAC/C,IAAIiwC,cAAc,GAAG,CAAC,EAClBxnC,UAAU,CAACunC,WAAW,GAAGC,cAAc;UAC3C,IAAI9nC,IAAI,GAAG4nC,SAAS,CAAC5nC,IAAI,CAACmf,IAAI,CAAC,IAAI,CAAC;UACpC,IAAI7e,UAAU,CAACynC,UAAU,EAAE;YACvBznC,UAAU,CAACqZ,OAAO,GAAG,EAAE;YACvBrZ,UAAU,CAACynC,UAAU,GAAG,KAAK;UACjC;UACA,IAAI/nC,IAAI,EAAE;YACN,IAAI/C,EAAE,CAACX,KAAK,CAAC4O,SAAS,IAAI,CAAC,IAAI,CAAC7S,IAAI,CAAC2H,IAAI,CAAC,EAAE;cACxCM,UAAU,CAACqZ,OAAO,CAAC7Z,IAAI,CAAC,CAACE,IAAI,CAAC,CAAC;YACnC,CAAC,MACI;cACD,IAAIA,IAAI,CAACnI,MAAM,GAAG,CAAC,EAAE;gBACjB,IAAIq6B,SAAS,GAAGtgB,GAAG,IAAIA,GAAG,CAACsgB,SAAS,IAAItgB,GAAG,CAACsgB,SAAS,CAACvtB,IAAI,CAAC,CAAC;gBAC5D,IAAIpL,MAAM,GAAG0D,EAAE,CAACqF,SAAS,CAAC,CAAC;gBAC3B,IAAI4vB,SAAS,IAAIA,SAAS,CAACv6B,IAAI,IAAI4B,MAAM,CAAC5B,IAAI,EAAE;kBAC5C,IAAIyhB,MAAM,GAAG8Y,SAAS,CAACt3B,EAAE,GAAGrB,MAAM,CAACqB,EAAE;kBACrC,IAAIwe,MAAM,GAAG,CAAC,IAAIA,MAAM,GAAGpZ,IAAI,CAACnI,MAAM,EAAE;oBACpCyI,UAAU,CAACqZ,OAAO,CAAC7Z,IAAI,CAAC,CAACE,IAAI,EAAEoZ,MAAM,CAAC,CAAC;oBACvCpZ,IAAI,GAAG,EAAE;kBACb;gBACJ;cACJ;cACA,IAAIA,IAAI,EACJM,UAAU,CAACqZ,OAAO,CAAC7Z,IAAI,CAACE,IAAI,CAAC;YACrC;UACJ;QACJ;QACA4nC,SAAS,GAAGA,SAAS,CAACrnC,IAAI;MAC9B;IACJ;EACJ;EACA,SAAS4V,gBAAgBA,CAAClZ,EAAE,EAAE;IAC1B,IAAI2U,GAAG,GAAG3U,EAAE,CAACX,KAAK,CAACsV,GAAG;IACtB,IAAIA,GAAG,CAAC6E,UAAU,EAAE;MAChB,IAAI4D,cAAc,GAAGC,cAAc,CAACD,cAAc;MAClD,IAAIA,cAAc,CAACN,SAAS,EAAE;QAC1B;MACJ;MACA,IAAIzZ,UAAU,GAAG+Z,cAAc,CAACF,qBAAqB;MACrD,IAAI7Z,UAAU,CAACsZ,6BAA6B,EAAE;QAC1CtZ,UAAU,CAACsZ,6BAA6B,GAAG,KAAK;MACpD,CAAC,MACI;QACDtZ,UAAU,CAACynC,UAAU,GAAG,IAAI;QAC5B,IAAIn2B,GAAG,CAACsgB,SAAS,EACbtgB,GAAG,CAACsgB,SAAS,CAACxtB,KAAK,CAAC,CAAC;QACzBkN,GAAG,CAACsgB,SAAS,GAAGj1B,EAAE,CAACqI,WAAW,CAACrI,EAAE,CAACqF,SAAS,CAAC,CAAC,EAAE;UAAEkD,UAAU,EAAE;QAAK,CAAC,CAAC;MACxE;IACJ,CAAC,MACI,IAAI,CAACvI,EAAE,CAACkD,KAAK,CAACmgB,OAAO,EAAE;MACxB0nB,uBAAuB,CAAC/qC,EAAE,EAAE2U,GAAG,CAAC;IACpC;EACJ;EACA,SAASo2B,uBAAuBA,CAAC/qC,EAAE,EAAE2U,GAAG,EAAE6oB,QAAQ,EAAE;IAChD,IAAI5/B,MAAM,GAAGoC,EAAE,CAACqF,SAAS,CAAC,QAAQ,CAAC;IACnC,IAAIxH,IAAI,GAAGmC,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;IAC/B,IAAIsP,GAAG,CAAC4J,UAAU,IAAI,CAACve,EAAE,CAACoH,iBAAiB,CAAC,CAAC,EAAE;MAC3C0a,cAAc,CAAC9hB,EAAE,EAAE,KAAK,CAAC;IAC7B,CAAC,MACI,IAAI,CAAC2U,GAAG,CAAC4J,UAAU,IAAI,CAAC5J,GAAG,CAAC6E,UAAU,IAAIxZ,EAAE,CAACoH,iBAAiB,CAAC,CAAC,EAAE;MACnEuN,GAAG,CAAC4J,UAAU,GAAG,IAAI;MACrB5J,GAAG,CAACgD,UAAU,GAAG,KAAK;MACtBvY,UAAU,CAAC2C,MAAM,CAAC/B,EAAE,EAAE,iBAAiB,EAAE;QAAE0J,IAAI,EAAE;MAAS,CAAC,CAAC;IAChE;IACA,IAAIiL,GAAG,CAAC4J,UAAU,EAAE;MAChB,IAAIyc,UAAU,GAAG,CAAChO,cAAc,CAACnvB,IAAI,EAAED,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACvD,IAAIq9B,YAAY,GAAGjO,cAAc,CAACnvB,IAAI,EAAED,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACxDC,IAAI,GAAG4b,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAEm9B,UAAU,CAAC;MACxCp9B,MAAM,GAAG6b,YAAY,CAAC7b,MAAM,EAAE,CAAC,EAAEq9B,YAAY,CAAC;MAC9CtmB,GAAG,CAACrP,GAAG,GAAG;QACN1H,MAAM,EAAEA,MAAM;QACdC,IAAI,EAAEA;MACV,CAAC;MACDkvB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEiO,SAAS,CAAC/kB,IAAI,EAAED,MAAM,CAAC,CAAC;MACjDmvB,UAAU,CAAC/sB,EAAE,EAAE2U,GAAG,EAAE,GAAG,EAAEkO,SAAS,CAAChlB,IAAI,EAAED,MAAM,CAAC,CAAC;IACrD,CAAC,MACI,IAAI,CAAC+W,GAAG,CAAC6E,UAAU,IAAI,CAACgkB,QAAQ,EAAE;MACnC7oB,GAAG,CAACuJ,QAAQ,GAAGle,EAAE,CAACqF,SAAS,CAAC,CAAC,CAAC1H,EAAE;IACpC;EACJ;EACA,SAASqiB,aAAaA,CAAClf,OAAO,EAAE5E,CAAC,EAAE;IAC/B,IAAI,CAAC4E,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,GAAG,GAAG7E,CAAC,CAAC6E,GAAG;IAChB,IAAI,CAACwlB,OAAO,GAAGrqB,CAAC,CAACqqB,OAAO;IACxB,IAAI,CAACC,MAAM,GAAGtqB,CAAC,CAACsqB,MAAM;IACtB,IAAI,CAACC,OAAO,GAAGvqB,CAAC,CAACuqB,OAAO;IACxB,IAAI,CAACE,QAAQ,GAAGzqB,CAAC,CAACyqB,QAAQ;EAC9B;EACA,SAASuO,uBAAuBA,CAACh5B,CAAC,EAAE;IAChC,IAAIkhB,cAAc,GAAGC,cAAc,CAACD,cAAc;IAClD,IAAI/Z,UAAU,GAAG+Z,cAAc,CAACF,qBAAqB;IACrD,IAAIpc,OAAO,GAAG1B,UAAU,CAAC0B,OAAO,GAAG1B,UAAU,CAAC0B,OAAO,CAAC5E,CAAC,CAAC,GAAGA,CAAC,CAAC6E,GAAG;IAChE,IAAI,CAACD,OAAO,EAAE;MACV;IACJ;IACA,IAAIA,OAAO,CAAC+R,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI/R,OAAO,CAAC+R,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;MACvE,IAAIxP,UAAU,CAACynC,UAAU,EAAE;QACvBznC,UAAU,CAACqZ,OAAO,GAAG,EAAE;QACvBrZ,UAAU,CAACynC,UAAU,GAAG,KAAK;MACjC;MACAznC,UAAU,CAACqZ,OAAO,CAAC7Z,IAAI,CAAC,IAAImd,aAAa,CAAClf,OAAO,EAAE5E,CAAC,CAAC,CAAC;IAC1D;EACJ;EACA,SAASy8B,cAAcA,CAAC34B,EAAE,EAAE2U,GAAG,EAAE+S,MAAM,EAAEsjB,eAAe,EAAE;IACtD,IAAI5tB,cAAc,GAAGC,cAAc,CAACD,cAAc;IAClDA,cAAc,CAACN,SAAS,GAAG,IAAI;IAC/B,IAAImuB,QAAQ,GAAG,CAAC,CAACt2B,GAAG,CAACsJ,qBAAqB;IAC1C,IAAIitB,gBAAgB,GAAGv2B,GAAG,CAACmJ,UAAU;IACrC,SAASqtB,aAAaA,CAAA,EAAG;MACrB,IAAIF,QAAQ,EAAE;QACV7oB,iBAAiB,CAAC8H,aAAa,CAAClqB,EAAE,EAAE2U,GAAG,EAAEA,GAAG,CAACsJ,qBAAqB,CAAC;MACvE,CAAC,MACI;QACDmE,iBAAiB,CAACkI,SAAS,CAACtqB,EAAE,EAAE2U,GAAG,CAAC;MACxC;IACJ;IACA,SAASy2B,YAAYA,CAAC1jB,MAAM,EAAE;MAC1B,IAAItK,cAAc,CAACF,qBAAqB,CAACR,OAAO,CAAC9hB,MAAM,GAAG,CAAC,EAAE;QACzD8sB,MAAM,GAAG,CAAC/S,GAAG,CAACsJ,qBAAqB,GAAG,CAAC,GAAGyJ,MAAM;QAChD,IAAI2jB,YAAY,GAAGjuB,cAAc,CAACF,qBAAqB;QACvDwtB,uBAAuB,CAAC1qC,EAAE,EAAEqrC,YAAY,CAAC3uB,OAAO,EAAEgL,MAAM,CAAC;MAC7D;IACJ;IACA/S,GAAG,CAACmJ,UAAU,GAAGnJ,GAAG,CAACqJ,kBAAkB;IACvC,IAAIitB,QAAQ,IAAIt2B,GAAG,CAACsJ,qBAAqB,CAACnG,qBAAqB,EAAE;MAC7D,KAAK,IAAI1Z,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;QAC7B+sC,aAAa,CAAC,CAAC;QACfC,YAAY,CAAC,CAAC,CAAC;MACnB;IACJ,CAAC,MACI;MACD,IAAI,CAACJ,eAAe,EAAE;QAClBG,aAAa,CAAC,CAAC;MACnB;MACAC,YAAY,CAAC1jB,MAAM,CAAC;IACxB;IACA/S,GAAG,CAACmJ,UAAU,GAAGotB,gBAAgB;IACjC,IAAIv2B,GAAG,CAAC6E,UAAU,IAAI,CAACwxB,eAAe,EAAE;MACpCjpB,cAAc,CAAC/hB,EAAE,CAAC;IACtB;IACAod,cAAc,CAACN,SAAS,GAAG,KAAK;EACpC;EACA,SAASgI,SAASA,CAAC9kB,EAAE,EAAEe,GAAG,EAAE;IACxB3B,UAAU,CAACoC,SAAS,CAACT,GAAG,EAAE,YAAY,EAAE,SAASuqC,UAAUA,CAACC,OAAO,EAAE;MACjE,IAAI,OAAOA,OAAO,IAAI,QAAQ,EAAE;QAC5BnsC,UAAU,CAACjC,QAAQ,CAACouC,OAAO,CAAC,CAACvrC,EAAE,CAAC;MACpC,CAAC,MACI;QACDurC,OAAO,CAACvrC,EAAE,CAAC;MACf;MACA,OAAO,IAAI;IACf,CAAC,CAAC;EACN;EACA,SAAS0qC,uBAAuBA,CAAC1qC,EAAE,EAAE0c,OAAO,EAAEgL,MAAM,EAAE;IAClD,IAAI7pB,IAAI,GAAGmC,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;IAC/B,IAAImZ,WAAW,GAAGnB,cAAc,CAACD,cAAc,CAACF,qBAAqB,CAACsB,WAAW;IACjF,IAAIA,WAAW,EAAE;MACb2W,eAAe,CAACn1B,EAAE,EAAEnC,IAAI,EAAE2gB,WAAW,GAAG,CAAC,CAAC;MAC1CkJ,MAAM,GAAG1nB,EAAE,CAAC4F,cAAc,CAAC,CAAC,CAAChL,MAAM;MACnCoF,EAAE,CAAC+E,SAAS,CAAClH,IAAI,CAAC;IACtB;IACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGspB,MAAM,EAAEtpB,CAAC,EAAE,EAAE;MAC7B,IAAIogB,WAAW,EAAE;QACbxe,EAAE,CAAC+E,SAAS,CAAC0U,YAAY,CAAC5b,IAAI,EAAEO,CAAC,EAAE,CAAC,CAAC,CAAC;MAC1C;MACA,KAAK,IAAI0iB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpE,OAAO,CAAC9hB,MAAM,EAAEkmB,CAAC,EAAE,EAAE;QACrC,IAAIhe,MAAM,GAAG4Z,OAAO,CAACoE,CAAC,CAAC;QACvB,IAAIhe,MAAM,YAAYkd,aAAa,EAAE;UACjC8E,SAAS,CAAC9kB,EAAE,EAAE8C,MAAM,CAAChC,OAAO,EAAEgC,MAAM,CAAC;QACzC,CAAC,MACI,IAAI,OAAOA,MAAM,IAAI,QAAQ,EAAE;UAChC9C,EAAE,CAAC4M,gBAAgB,CAAC9J,MAAM,CAAC;QAC/B,CAAC,MACI;UACD,IAAI5H,KAAK,GAAG8E,EAAE,CAACqF,SAAS,CAAC,CAAC;UAC1B,IAAIlK,GAAG,GAAGse,YAAY,CAACve,KAAK,EAAE,CAAC,EAAE4H,MAAM,CAAC,CAAC,CAAC,CAAClI,MAAM,IAAIkI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;UACrE9C,EAAE,CAACvE,YAAY,CAACqH,MAAM,CAAC,CAAC,CAAC,EAAE5H,KAAK,EAAE4H,MAAM,CAAC,CAAC,CAAC,GAAG5H,KAAK,GAAGC,GAAG,CAAC;UAC1D6E,EAAE,CAAC+E,SAAS,CAAC5J,GAAG,CAAC;QACrB;MACJ;IACJ;IACA,IAAIqjB,WAAW,EAAE;MACbxe,EAAE,CAAC+E,SAAS,CAAC0U,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1C;EACJ;EACAuB,UAAU,CAACosC,GAAG,GAAG/rB,MAAM;EACvB,IAAIgsB,aAAa,GAAG;IAAE,QAAQ,EAAE,IAAI;IAAEC,SAAS,EAAE,IAAI;IAAE,QAAQ,EAAE,KAAK;IAAEC,GAAG,EAAE,KAAK;IAC9E/hC,IAAI,EAAE,MAAM;IAAEgiC,KAAK,EAAE,OAAO;IAAE1iB,EAAE,EAAE,IAAI;IAAE2iB,IAAI,EAAE,MAAM;IAAEhxC,KAAK,EAAE,OAAO;IAAEsF,MAAM,EAAE,KAAK;IACnF2rC,IAAI,EAAE,MAAM;IAAE3wC,GAAG,EAAE,KAAK;IAAE4wC,MAAM,EAAE,QAAQ;IAAEC,QAAQ,EAAE,UAAU;IAAEC,KAAK,EAAE;EAC7E,CAAC;EACD,SAASzqC,SAASA,CAAC0qC,MAAM,EAAEnrC,GAAG,EAAE7E,CAAC,EAAEyY,GAAG,EAAE;IACpC,IAAI5T,GAAG,CAACnG,MAAM,GAAG,CAAC,IAAImG,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;MACjCA,GAAG,GAAGA,GAAG,CAAC9F,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IACnC;IACA8F,GAAG,GAAG0qC,aAAa,CAAC1qC,GAAG,CAAC,IAAIA,GAAG;IAC/B,IAAI3E,IAAI,GAAG,EAAE;IACb,IAAIF,CAAC,CAACqqB,OAAO,EAAE;MACXnqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAIF,CAAC,CAACsqB,MAAM,EAAE;MACVpqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAI,CAACA,IAAI,IAAI2E,GAAG,CAACnG,MAAM,GAAG,CAAC,KAAKsB,CAAC,CAACyqB,QAAQ,EAAE;MACxCvqB,IAAI,IAAI,IAAI;IAChB;IACA,IAAIuY,GAAG,IAAI,CAACA,GAAG,CAACgK,iBAAiB,IAAI5d,GAAG,CAACnG,MAAM,IAAI,CAAC,EAAE;MAClD,IAAIme,OAAO,CAAC6N,MAAM,IAAI7lB,GAAG,IAAIgY,OAAO,CAAC6N,MAAM,EAAE;QACzC,IAAI7N,OAAO,CAAC8N,SAAS,KAAK,KAAK,IAAI,CAACzqB,IAAI,EACpC2E,GAAG,GAAGgY,OAAO,CAAC6N,MAAM,CAAC7lB,GAAG,CAAC;MACjC,CAAC,MACI,IAAIA,GAAG,CAACkV,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG,EAAE;QAC9B,IAAI6Q,IAAI,GAAG5qB,CAAC,CAAC4qB,IAAI,IAAI5qB,CAAC,CAAC4qB,IAAI,CAAClrB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;QAC3C,IAAI,CAACM,CAAC,CAACyqB,QAAQ,EACXG,IAAI,GAAGA,IAAI,CAACxlB,WAAW,CAAC,CAAC;QAC7B,IAAIwlB,IAAI,EACJ/lB,GAAG,GAAG+lB,IAAI;MAClB;IACJ;IACA1qB,IAAI,IAAI2E,GAAG;IACX,IAAI3E,IAAI,CAACxB,MAAM,GAAG,CAAC,EAAE;MACjBwB,IAAI,GAAG,GAAG,GAAGA,IAAI,GAAG,GAAG;IAC3B;IACA,OAAOA,IAAI;EACf;EACA,IAAImlB,SAAS,GAAG9B,MAAM,CAAC8B,SAAS,CAAC9hB,IAAI,CAACggB,MAAM,CAAC;EAC7CA,MAAM,CAAC8B,SAAS,GAAG,UAAUvhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,EAAE;IAC1C,OAAOnH,EAAE,CAAC8D,SAAS,CAAC,YAAY;MAC5B,OAAOyd,SAAS,CAACvhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,CAAC;IACrC,CAAC,EAAE,IAAI,CAAC;EACZ,CAAC;EACD,SAASglC,aAAaA,CAAC9sC,KAAK,EAAE;IAC1B,IAAI0T,CAAC,GAAG,IAAI1T,KAAK,CAAC+sC,WAAW,CAAC,CAAC;IAC/B/lB,MAAM,CAAClQ,IAAI,CAAC9W,KAAK,CAAC,CAACinB,OAAO,CAAC,UAAUvlB,GAAG,EAAE;MACtC,IAAIA,GAAG,IAAI,WAAW,EAClB;MACJ,IAAIiB,CAAC,GAAG3C,KAAK,CAAC0B,GAAG,CAAC;MAClB,IAAIjD,KAAK,CAACC,OAAO,CAACiE,CAAC,CAAC,EAChBA,CAAC,GAAGA,CAAC,CAACpG,KAAK,CAAC,CAAC,CAAC,KACb,IAAIoG,CAAC,IAAI,OAAOA,CAAC,IAAI,QAAQ,IAAIA,CAAC,CAACoqC,WAAW,IAAI/lB,MAAM,EACzDrkB,CAAC,GAAGmqC,aAAa,CAACnqC,CAAC,CAAC;MACxB+Q,CAAC,CAAChS,GAAG,CAAC,GAAGiB,CAAC;IACd,CAAC,CAAC;IACF,IAAI3C,KAAK,CAACiG,GAAG,EAAE;MACXyN,CAAC,CAACzN,GAAG,GAAG;QACJzH,IAAI,EAAEwB,KAAK,CAACiG,GAAG,CAACzH,IAAI,IAAIsuB,UAAU,CAAC9sB,KAAK,CAACiG,GAAG,CAACzH,IAAI,CAAC;QAClDD,MAAM,EAAEyB,KAAK,CAACiG,GAAG,CAAC1H,MAAM,IAAIuuB,UAAU,CAAC9sB,KAAK,CAACiG,GAAG,CAAC1H,MAAM;MAC3D,CAAC;IACL;IACA,OAAOmV,CAAC;EACZ;EACA,SAAS0O,oBAAoBA,CAACzhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,EAAE;IAC3C,IAAIklC,SAAS,GAAG,KAAK;IACrB,IAAI13B,GAAG,GAAG8K,MAAM,CAACK,kBAAkB,CAAC9f,EAAE,CAAC;IACvC,IAAIwe,WAAW,GAAG7J,GAAG,CAAC6J,WAAW,IAAI7J,GAAG,CAAC23B,gBAAgB;IACzD,IAAIC,cAAc,GAAGvsC,EAAE,CAACzG,GAAG,CAACmK,iBAAiB;IAC7C,IAAIiR,GAAG,CAAC23B,gBAAgB,IAAI,CAACC,cAAc,EAAE;MACzC53B,GAAG,CAAC23B,gBAAgB,GAAG,KAAK;IAChC,CAAC,MACI,IAAIC,cAAc,IAAI53B,GAAG,CAAC6J,WAAW,EAAE;MACxC7J,GAAG,CAAC23B,gBAAgB,GAAG,IAAI;IAC/B;IACA,IAAIvrC,GAAG,IAAI,OAAO,IAAI,CAAC4T,GAAG,CAAC6E,UAAU,IAAI,CAAC7E,GAAG,CAAC4J,UAAU,IAAIguB,cAAc,EAAE;MACxEvsC,EAAE,CAACzG,GAAG,CAAC0L,mBAAmB,CAAC,CAAC;IAChC,CAAC,MACI,IAAIuZ,WAAW,IAAI,CAAC+tB,cAAc,IAAIvsC,EAAE,CAACzG,GAAG,CAACmJ,sBAAsB,EAAE;MACtE2pC,SAAS,GAAG5sB,MAAM,CAAC8B,SAAS,CAACvhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,CAAC;IACjD,CAAC,MACI;MACD,IAAIqlC,GAAG,GAAGL,aAAa,CAACx3B,GAAG,CAAC;MAC5B,IAAI83B,eAAe,GAAG93B,GAAG,CAACmJ,UAAU,CAAC2uB,eAAe,IAAI,EAAE;MAC1DzsC,EAAE,CAAC8D,SAAS,CAAC,YAAY;QACrB9D,EAAE,CAACkD,KAAK,CAACmgB,OAAO,GAAG,IAAI;QACvB,IAAIrnB,KAAK,GAAG,CAAC;QACbgE,EAAE,CAACzG,GAAG,CAACmzC,gBAAgB,CAAC,YAAY;UAChC,IAAIpnC,GAAG,GAAGtF,EAAE,CAACzG,GAAG,CAACgD,SAAS;UAC1ByD,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACuJ,QAAQ,GAAG5Y,GAAG,CAACqnC,cAAc,IAAI,IAAI,GAAGrnC,GAAG,CAACG,IAAI,CAACxL,MAAM,GAAGqL,GAAG,CAACqnC,cAAc;UACzF3sC,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACmJ,UAAU,CAACwE,WAAW,GAAGmqB,eAAe,CAACzwC,KAAK,CAAC;UAC5D,IAAI6B,IAAI,GAAGmC,EAAE,CAACqF,SAAS,CAAC,MAAM,CAAC;UAC/B,IAAIzH,MAAM,GAAGoC,EAAE,CAACqF,SAAS,CAAC,QAAQ,CAAC;UACnC,IAAI21B,UAAU,GAAG,CAAChO,cAAc,CAACnvB,IAAI,EAAED,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UACvD,IAAIq9B,YAAY,GAAGjO,cAAc,CAACnvB,IAAI,EAAED,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UACxDC,IAAI,GAAG4b,YAAY,CAAC5b,IAAI,EAAE,CAAC,EAAEm9B,UAAU,CAAC;UACxCp9B,MAAM,GAAG6b,YAAY,CAAC7b,MAAM,EAAE,CAAC,EAAEq9B,YAAY,CAAC;UAC9Cj7B,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACrP,GAAG,CAACzH,IAAI,GAAGA,IAAI;UAC5BmC,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACrP,GAAG,CAAC1H,MAAM,GAAGA,MAAM;UAChCyuC,SAAS,GAAG9qB,SAAS,CAACvhB,EAAE,EAAEe,GAAG,EAAEoG,MAAM,CAAC;UACtC7B,GAAG,CAACqnC,cAAc,GAAG3sC,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACuJ,QAAQ,IAAI,CAAC,CAAC,GAAG,IAAI,GAAGle,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACuJ,QAAQ;UAC/E,IAAIle,EAAE,CAACzG,GAAG,CAACmJ,sBAAsB,EAAE;YAC/B+pC,eAAe,CAACzwC,KAAK,CAAC,GAAGgE,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACmJ,UAAU,CAACwE,WAAW;UAChE;UACA,IAAItiB,EAAE,CAACyC,oBAAoB,CAAC,CAAC,EAAE;YAC3BzC,EAAE,CAACX,KAAK,CAACsV,GAAG,GAAGw3B,aAAa,CAACK,GAAG,CAAC;UACrC;UACAxwC,KAAK,EAAE;QACX,CAAC,CAAC;QACF,IAAIgE,EAAE,CAACkD,KAAK,CAACO,cAAc,IAAI,CAAC4oC,SAAS,EACrCrsC,EAAE,CAACkD,KAAK,CAACO,cAAc,GAAG,KAAK;QACnCkR,GAAG,CAACC,MAAM,GAAG5U,EAAE,CAACX,KAAK,CAACsV,GAAG,CAACC,MAAM;QAChC5U,EAAE,CAACX,KAAK,CAACsV,GAAG,GAAGA,GAAG;QAClBA,GAAG,CAACmJ,UAAU,CAAC2uB,eAAe,GAAGA,eAAe;QAChD93B,GAAG,CAACmJ,UAAU,CAACwE,WAAW,GAAG,IAAI;MACrC,CAAC,EAAE,IAAI,CAAC;IACZ;IACA,IAAI+pB,SAAS,IAAI,CAAC13B,GAAG,CAAC4J,UAAU,IAAI,CAAC5J,GAAG,CAACxU,MAAM,IAAIwU,GAAG,CAAC4J,UAAU,IAAIve,EAAE,CAACoH,iBAAiB,CAAC,CAAC,EAAE;MACzF2jC,uBAAuB,CAAC/qC,EAAE,EAAE2U,GAAG,EAAE,IAAI,CAAC;IAC1C;IACA,OAAO03B,SAAS;EACpB;EACAztB,mBAAmB,CAAC,CAAC;EACrBllB,OAAO,CAAC0F,UAAU,GAAGA,UAAU;EAC/B,IAAIwtC,MAAM,GAAGntB,MAAM,CAACK,kBAAkB;EACtCpmB,OAAO,CAACm+B,OAAO,GAAG;IACdgV,GAAG,EAAE,kBAAkB;IACvBC,UAAU,EAAE,SAAAA,CAAU3jB,OAAO,EAAE4jB,QAAQ,EAAE/jC,MAAM,EAAE1D,GAAG,EAAE7K,OAAO,EAAE;MAC3D,IAAIka,GAAG,GAAG,IAAI,CAACtV,KAAK,CAACsV,GAAG,IAAI,CAAC,CAAC;MAC9B,IAAIq4B,CAAC,GAAGhkC,MAAM,CAACgB,cAAc;MAC7B,IAAI/C,CAAC,GAAG+B,MAAM,CAACI,UAAU;MACzB,IAAIS,GAAG,GAAGkjC,QAAQ,CAACljC,GAAG;MACtB,IAAID,IAAI,GAAGmjC,QAAQ,CAACnjC,IAAI;MACxB,IAAI,CAAC+K,GAAG,CAAC6E,UAAU,EAAE;QACjB,IAAIyzB,WAAW,GAAG,CAAC3nC,GAAG,CAAChJ,MAAM,GACvB7B,OAAO,CAAC8B,SAAS,CAAC2wC,WAAW,CAAC,CAAC,IAAIzyC,OAAO,CAAC8B,SAAS,CAACiJ,OAAO,CAAC,CAAC,GAC9D5L,KAAK,CAACyM,aAAa,CAACf,GAAG,CAAChJ,MAAM,EAAEgJ,GAAG,CAACpK,KAAK,CAAC,IAAI,CAAC;QACrD,IAAI,CAAC+xC,WAAW,IAAIrjC,IAAI,GAAGojC,CAAC,EACxBpjC,IAAI,IAAIojC,CAAC;MACjB;MACA,IAAI,CAACr4B,GAAG,CAAC6E,UAAU,IAAI7E,GAAG,CAACC,MAAM,EAAE;QAC/B3N,CAAC,GAAGA,CAAC,GAAG,CAAC;QACT4C,GAAG,IAAI5C,CAAC;MACZ;MACAxI,MAAM,CAAC0uC,SAAS,CAAChkB,OAAO,EAAEvf,IAAI,EAAEC,GAAG,CAAC;MACpCpL,MAAM,CAAC2uC,QAAQ,CAACjkB,OAAO,CAAC0I,KAAK,EAAE,OAAO,EAAEmb,CAAC,GAAG,IAAI,CAAC;MACjDvuC,MAAM,CAAC2uC,QAAQ,CAACjkB,OAAO,CAAC0I,KAAK,EAAE,QAAQ,EAAE5qB,CAAC,GAAG,IAAI,CAAC;IACtD,CAAC;IACDomC,yBAAyB,EAAE,SAAAA,CAAUvzC,MAAM,EAAE;MACzC,IAAIkG,EAAE,GAAGlG,MAAM,CAACuF,KAAK,CAACW,EAAE;MACxB,IAAI2U,GAAG,GAAGi4B,MAAM,CAAC5sC,EAAE,CAAC;MACpB,IAAI,CAAC2U,GAAG,CAAC6E,UAAU,EAAE;QACjB,OAAO1f,MAAM,CAACW,OAAO,CAAC8B,SAAS,CAAC2wC,WAAW,CAAC,CAAC,IAAIpzC,MAAM,CAACW,OAAO,CAAC8B,SAAS,CAACiJ,OAAO,CAAC,CAAC;MACvF;IACJ,CAAC;IACD8nC,cAAc,EAAE,SAAAA,CAAUC,IAAI,EAAErB,MAAM,EAAEnrC,GAAG,EAAEC,OAAO,EAAE9E,CAAC,EAAE;MACrD,IAAIpC,MAAM,GAAGyzC,IAAI,CAACzzC,MAAM;MACxB,IAAIkG,EAAE,GAAGlG,MAAM,CAACuF,KAAK,CAACW,EAAE;MACxB,IAAI2U,GAAG,GAAGi4B,MAAM,CAAC5sC,EAAE,CAAC;MACpB,IAAIgB,OAAO,IAAI,CAAC,CAAC,EACb;MACJ,IAAI,CAAC2T,GAAG,CAAC6E,UAAU,EAAE;QACjB,IAAI0yB,MAAM,IAAI,CAAC,CAAC,EAAE;UACd,IAAInrC,GAAG,CAACkV,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;YAC1B,IAAIs3B,IAAI,CAACC,QAAQ,EAAE;cACfzsC,GAAG,GAAGwsC,IAAI,CAACC,QAAQ;cACnB,IAAIzsC,GAAG,IAAIwsC,IAAI,CAACE,SAAS,IAAI,CAAC,EAC1B1sC,GAAG,GAAGA,GAAG,CAACE,WAAW,CAAC,CAAC;YAC/B;UACJ;UACAssC,IAAI,CAACG,SAAS,GAAG3sC,GAAG;QACxB,CAAC,MACI,IAAImrC,MAAM,IAAI,CAAC,IAAIA,MAAM,IAAI,CAAC,EAAE;UACjC,IAAIqB,IAAI,CAACC,QAAQ,IAAIzsC,GAAG,IAAIwsC,IAAI,CAACE,SAAS,IAAIvB,MAAM,IAAIqB,IAAI,CAACG,SAAS,EAAE;YACpE3sC,GAAG,GAAGwsC,IAAI,CAACG,SAAS;YACpBxB,MAAM,GAAG,CAAC,CAAC;UACf,CAAC,MACI;YACDqB,IAAI,CAACG,SAAS,GAAG,IAAI;YACrBH,IAAI,CAACC,QAAQ,GAAGzsC,GAAG;YACnBwsC,IAAI,CAACE,SAAS,GAAGvB,MAAM;UAC3B;QACJ,CAAC,MACI;UACDqB,IAAI,CAACG,SAAS,GAAGH,IAAI,CAACC,QAAQ,GAAG,IAAI;QACzC;MACJ;MACA,IAAIxtC,EAAE,CAACX,KAAK,CAAC4O,SAAS,IAAI0G,GAAG,CAAC6E,UAAU,IAAIzY,GAAG,IAAI,WAAW,IAAImrC,MAAM,IAAI,CAAC,EAAE;QAC3E,OAAO;UAAE/vC,OAAO,EAAE;QAAW,CAAC;MAClC;MACA,IAAI4E,GAAG,IAAI,GAAG,IAAImrC,MAAM,IAAI,CAAC,EAAE;QAAE;QAC7B,IAAI,CAACptC,SAAS,CAAC4nB,KAAK,IAAI5sB,MAAM,CAAC6zC,WAAW,CAAC,CAAC,EAAE;UAC1C7zC,MAAM,CAAC8zC,IAAI,CAAC,MAAM,EAAE,YAAY;YAC5B,IAAIj5B,GAAG,CAAC6E,UAAU,EACd1f,MAAM,CAACyC,SAAS,CAACoM,cAAc,CAAC,CAAC,CAAC,KAElC3I,EAAE,CAAC8D,SAAS,CAAC,YAAY;cAAEge,cAAc,CAAC9hB,EAAE,CAAC;YAAE,CAAC,CAAC;UACzD,CAAC,CAAC;UACF,OAAO;YAAE7D,OAAO,EAAE,MAAM;YAAE0xC,SAAS,EAAE;UAAK,CAAC;QAC/C;MACJ;MACA,IAAI9sC,GAAG,IAAI,KAAK,IAAI,CAAC4T,GAAG,CAAC6E,UAAU,IAAI,CAAC7E,GAAG,CAAC4J,UAAU,IAAI,CAACve,EAAE,CAACzG,GAAG,CAACmK,iBAAiB,EAAE;QACjF,IAAIu/B,WAAW,GAAGvY,cAAc,CAAC1qB,EAAE,CAAC;QACpC,IAAIu/B,OAAO,GAAG0D,WAAW,CAAC7D,UAAU,CAAC,CAAC;QACtC,IAAIG,OAAO,EACPv/B,EAAE,CAACwC,aAAa,CAAC+8B,OAAO,CAAC;MACjC;MACA,IAAI2M,MAAM,IAAI,CAAC,CAAC,IAAIA,MAAM,GAAG,CAAC,IAAIA,MAAM,KAAK,CAAC,IAAInrC,GAAG,CAACnG,MAAM,GAAG,CAAC,EAAE;QAC9D,IAAI4e,UAAU,GAAG7E,GAAG,CAAC6E,UAAU;QAC/B,IAAIpd,IAAI,GAAGoF,SAAS,CAAC0qC,MAAM,EAAEnrC,GAAG,EAAE7E,CAAC,IAAI,CAAC,CAAC,EAAEyY,GAAG,CAAC;QAC/C,IAAIA,GAAG,CAACC,MAAM,IAAI,IAAI,EAClBD,GAAG,CAACC,MAAM,GAAG,EAAE;QACnB,IAAIy3B,SAAS,GAAG5qB,oBAAoB,CAACzhB,EAAE,EAAE5D,IAAI,EAAE,MAAM,CAAC;QACtDuY,GAAG,GAAGi4B,MAAM,CAAC5sC,EAAE,CAAC,CAAC,CAAC;QAClB,IAAIqsC,SAAS,IAAI13B,GAAG,CAACC,MAAM,IAAI,IAAI,EAC/BD,GAAG,CAACC,MAAM,IAAIxY,IAAI,CAAC,KAClB,IAAIuY,GAAG,CAACC,MAAM,IAAI,IAAI,EACvBD,GAAG,CAACC,MAAM,GAAG,EAAE;QACnB5U,EAAE,CAACiC,OAAO,CAAC,cAAc,CAAC;QAC1B,IAAI,CAACoqC,SAAS,KAAKH,MAAM,IAAI,CAAC,CAAC,IAAI1yB,UAAU,CAAC,EAC1C;QACJ,OAAO;UAAErd,OAAO,EAAE,MAAM;UAAE0xC,SAAS,EAAE,CAACxB;QAAU,CAAC;MACrD;IACJ,CAAC;IACDyB,MAAM,EAAE,SAAAA,CAAUh0C,MAAM,EAAE;MACtB,IAAI,CAACA,MAAM,CAACuF,KAAK,EACbvF,MAAM,CAACuF,KAAK,GAAG,CAAC,CAAC;MACrB,IAAIW,EAAE,GAAG,IAAIZ,UAAU,CAACtF,MAAM,CAAC;MAC/BA,MAAM,CAACuF,KAAK,CAACW,EAAE,GAAGA,EAAE;MACpBlG,MAAM,CAACi0C,eAAe,GAAG,IAAI;MAC7B90B,YAAY,CAACjZ,EAAE,CAAC;MAChB4sC,MAAM,CAAC5sC,EAAE,CAAC,CAAC4U,MAAM,GAAG,IAAI;MACxB5U,EAAE,CAAC5C,EAAE,CAAC,kBAAkB,EAAE,YAAY;QAClC,IAAI4C,EAAE,CAACyC,oBAAoB,CAAC,CAAC,EACzB;QACJmqC,MAAM,CAAC5sC,EAAE,CAAC,CAAC4U,MAAM,GAAG,IAAI;QACxB5U,EAAE,CAACzG,GAAG,CAAC0I,OAAO,CAAC,cAAc,CAAC;QAC9BjC,EAAE,CAACzG,GAAG,CAACkB,OAAO,CAACoC,aAAa,CAAC,CAAC;MAClC,CAAC,CAAC;MACFmD,EAAE,CAAC5C,EAAE,CAAC,cAAc,EAAE,YAAY;QAC9B4C,EAAE,CAACzG,GAAG,CAACiD,QAAQ,CAACwxC,YAAY,CAAC,CAAC;QAC9BhuC,EAAE,CAACzG,GAAG,CAAC0I,OAAO,CAAC,cAAc,CAAC;MAClC,CAAC,CAAC;MACFjC,EAAE,CAAC5C,EAAE,CAAC,iBAAiB,EAAE,YAAY;QACjC,IAAI4C,EAAE,CAACyC,oBAAoB,CAAC,CAAC,EACzB;QACJwrC,eAAe,CAAC,CAAC;QACjBjuC,EAAE,CAACiC,OAAO,CAAC,cAAc,CAAC;MAC9B,CAAC,CAAC;MACF,SAASgsC,eAAeA,CAAA,EAAG;QACvB,IAAIC,SAAS,GAAGtB,MAAM,CAAC5sC,EAAE,CAAC,CAACwZ,UAAU;QACrCxZ,EAAE,CAACzG,GAAG,CAACiD,QAAQ,CAAC4wC,QAAQ,CAAC,aAAa,EAAE,CAACc,SAAS,CAAC;QACnDp0C,MAAM,CAACqT,SAAS,CAACghC,cAAc,CAAC,CAACD,SAAS,CAAC;QAC3Cp0C,MAAM,CAAC0C,QAAQ,CAAC4xC,qBAAqB,GAAGF,SAAS;QACjDp0C,MAAM,CAAC0C,QAAQ,CAAC6xC,YAAY,GAAG,CAACH,SAAS;MAC7C;MACAD,eAAe,CAAC,CAAC;MACjBn0C,MAAM,CAAC0C,QAAQ,CAAC8xC,YAAY,CAACxB,UAAU,GAAG,IAAI,CAACA,UAAU,CAACrtC,IAAI,CAACO,EAAE,CAAC;IACtE,CAAC;IACDuuC,MAAM,EAAE,SAAAA,CAAUz0C,MAAM,EAAE;MACtB,IAAIkG,EAAE,GAAGlG,MAAM,CAACuF,KAAK,CAACW,EAAE;MACxBqZ,YAAY,CAACrZ,EAAE,CAAC;MAChBA,EAAE,CAACuC,OAAO,CAAC,CAAC;MACZzI,MAAM,CAACuF,KAAK,CAACW,EAAE,GAAG,IAAI;MACtBlG,MAAM,CAACi0C,eAAe,GAAG,IAAI;MAC7Bj0C,MAAM,CAAC0C,QAAQ,CAAC8xC,YAAY,CAACxB,UAAU,GAAG,IAAI;MAC9ChzC,MAAM,CAAC0C,QAAQ,CAAC4wC,QAAQ,CAAC,aAAa,EAAE,KAAK,CAAC;MAC9CtzC,MAAM,CAACqT,SAAS,CAACghC,cAAc,CAAC,KAAK,CAAC;MACtCr0C,MAAM,CAAC0C,QAAQ,CAAC4xC,qBAAqB,GAAG,IAAI;IAChD,CAAC;IACDI,aAAa,EAAE,SAAAA,CAAU10C,MAAM,EAAE;MAC7B,IAAIkG,EAAE,GAAGlG,MAAM,CAACuF,KAAK,CAACW,EAAE;MACxB,IAAI2U,GAAG,GAAGi4B,MAAM,CAAC5sC,EAAE,CAAC;MACpB,IAAI2U,GAAG,CAAC6E,UAAU,EACd,OAAO,QAAQ;MACnB,IAAI5E,MAAM,GAAG,EAAE;MACf,IAAID,GAAG,CAAC4J,UAAU,EAAE;QAChB3J,MAAM,IAAI,QAAQ;QAClB,IAAID,GAAG,CAACgD,UAAU,EACd/C,MAAM,IAAI,OAAO;QACrB,IAAID,GAAG,CAAC6J,WAAW,EACf5J,MAAM,IAAI,QAAQ;MAC1B;MACA,IAAID,GAAG,CAACC,MAAM,EACVA,MAAM,IAAI,CAACA,MAAM,GAAG,GAAG,GAAG,EAAE,IAAID,GAAG,CAACC,MAAM;MAC9C,OAAOA,MAAM;IACjB;EACJ,CAAC;EACD6K,MAAM,CAAC5f,YAAY,CAAC;IAChBzD,IAAI,EAAE,MAAM;IACZa,GAAG,EAAE,SAAAA,CAAUK,KAAK,EAAE0C,EAAE,EAAE;MACtB,IAAIA,EAAE,EAAE;QACJA,EAAE,CAACzG,GAAG,CAACsU,SAAS,CAAC,MAAM,EAAEvQ,KAAK,CAAC;MACnC;IACJ,CAAC;IACDmS,IAAI,EAAE;EACV,CAAC,EAAE,KAAK,CAAC;EACTgQ,MAAM,CAACyB,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,YAAY;IACtC3iB,OAAO,CAAChB,GAAG,CAAC,2BAA2B,CAAC;EAC5C,CAAC,CAAC;EACF2Y,aAAa,CAACrT,IAAI,CAAC;IAAEsT,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEtH,IAAI,EAAE;IAAM;EAAE,CAAC,EAAE;IAAEuG,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEtH,IAAI,EAAE,KAAK;MAAE6+B,GAAG,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEt4B,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEtH,IAAI,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEuG,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEtH,IAAI,EAAE,IAAI;MAAE6+B,GAAG,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEt4B,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEw3B,MAAM,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEv4B,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEw3B,MAAM,EAAE,IAAI;MAAED,GAAG,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEt4B,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEtH,IAAI,EAAE,IAAI;MAAE6+B,GAAG,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEt4B,IAAI,EAAE,IAAI;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,MAAM;IAAEkU,UAAU,EAAE;MAAEtH,IAAI,EAAE,IAAI;MAAE6+B,GAAG,EAAE;IAAK;EAAE,CAAC,EAAE;IAAEt4B,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAAiB;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAAiB;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,WAAW;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAA4B;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,WAAW;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAA4B;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAAmB;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,SAAS;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAAkB;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,WAAW;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAAmB;EAAE,CAAC,EAAE;IAAE+Z,IAAI,EAAE,WAAW;IAAE1G,IAAI,EAAE,QAAQ;IAAEzM,MAAM,EAAE,YAAY;IAAEkU,UAAU,EAAE;MAAE9a,IAAI,EAAE;IAAkB;EAAE,CAAC,CAAC;EAC3+C8Z,aAAa,CAACrT,IAAI,CAAC;IACfsT,IAAI,EAAE,IAAI;IACV1G,IAAI,EAAE,UAAU;IAChB4H,QAAQ,EAAE;EACd,CAAC,CAAC;EACFoI,MAAM,CAACmE,cAAc,CAAC,UAAU,EAAE,UAAU5jB,EAAE,EAAEsX,YAAY,EAAEzR,MAAM,EAAE0mB,SAAS,EAAEC,OAAO,EAAE;IACtF,IAAI5uB,MAAM,GAAGiI,MAAM,CAAC,CAAC,CAAC,CAACjI,MAAM,CAAClD,IAAI;IAClC,IAAImD,IAAI,GAAGgI,MAAM,CAAC,CAAC,CAAC,CAAChI,IAAI,CAACnD,IAAI;IAC9B,IAAI4c,YAAY,CAACd,QAAQ,EACrB3Y,IAAI,EAAE;IACVhE,QAAQ,CAACmG,EAAE,CAACzG,GAAG,EAAE;MAAEgB,QAAQ,EAAEqD,MAAM;MAAEpD,MAAM,EAAEqD;IAAK,CAAC,CAAC;IACpD,OAAO+B,GAAG,CAAC/B,IAAI,EAAE,CAAC,CAAC;EACvB,CAAC,CAAC;EACFgC,YAAY,CAAC,WAAW,EAAEiL,SAAS,EAAE,QAAQ,EAAE,CAAC,IAAI,CAAC,EAAE,UAAUwB,KAAK,EAAEtM,EAAE,EAAE;IACxE,IAAIA,EAAE,KAAK8K,SAAS,EAAE;MAClB;IACJ;IACA,IAAIwB,KAAK,KAAKxB,SAAS,EAAE;MACrB,IAAIxN,KAAK,GAAG0C,EAAE,CAACzG,GAAG,CAACW,SAAS,CAAC,mBAAmB,CAAC;MACjD,OAAOoD,KAAK;IAChB,CAAC,MACI;MACD,IAAIrD,MAAM,GAAGI,IAAI,CAAC+gB,KAAK,CAAC9O,KAAK,CAAC;MAC9B,IAAIrS,MAAM,GAAG,CAAC,EAAE;QACZ+F,EAAE,CAACzG,GAAG,CAACsU,SAAS,CAAC,mBAAmB,EAAE5T,MAAM,CAAC;MACjD;IACJ;EACJ,CAAC,CAAC;EACFyf,OAAO,CAACi1B,UAAU,GAAG,UAAU3uC,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;IAChD3U,EAAE,CAAC4uC,MAAM,GAAG13B,UAAU;IACtB,IAAIlX,EAAE,CAACzG,GAAG,CAACmJ,sBAAsB,EAC7B1C,EAAE,CAACzG,GAAG,CAAC6D,EAAE,CAAC,oBAAoB,EAAEyxC,qBAAqB,CAAC,CAAC,KAEvDA,qBAAqB,CAAC,IAAI,EAAE7uC,EAAE,CAACzG,GAAG,CAAC;EAC3C,CAAC;EACD,SAASs1C,qBAAqBA,CAACtqC,EAAE,EAAEhL,GAAG,EAAE;IACpCA,GAAG,CAAC8D,GAAG,CAAC,oBAAoB,EAAEwxC,qBAAqB,CAAC;IACpD,IAAIztC,GAAG,GAAG7H,GAAG,CAAC8F,KAAK,CAACW,EAAE,CAAC4uC,MAAM;IAC7B,IAAIxtC,GAAG,EAAE;MACL7H,GAAG,CAACgI,WAAW,CAACH,GAAG,CAACpG,IAAI,GAAGoG,GAAG,GAAGA,GAAG,CAAChF,IAAI,EAAEgF,GAAG,CAAC/E,IAAI,CAAC;IACxD;IACA9C,GAAG,CAAC2J,KAAK,GAAG3J,GAAG,CAAC0K,MAAM;EAC1B;EACAyV,OAAO,CAACyW,IAAI,GAAG,UAAUnwB,EAAE,EAAEkX,UAAU,EAAEvC,GAAG,EAAE;IAC1C3U,EAAE,CAACzG,GAAG,CAACgI,WAAW,CAAC,CAAC,kBAAkB,EAAE,kBAAkB,EAAE,WAAW,EAAE,WAAW,CACnF,CAAC,CAAC2V,UAAU,CAACu3B,GAAG,GAAG,CAAC,GAAG,CAAC,KAAKv3B,UAAU,CAACtH,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5D,CAAC;EACD8I,mBAAmB,GAAGxC,aAAa,CAACtb,MAAM,CAAC,CAAC;EAC5ClB,OAAO,CAACm+B,OAAO,CAAC3hB,aAAa,GAAGA,aAAa;EAC7Cxc,OAAO,CAACm+B,OAAO,CAACne,OAAO,GAAGA,OAAO;EACjChgB,OAAO,CAAC8xC,GAAG,GAAG/rB,MAAM;AAEpB,CAAC,CAAC;AAAiB,CAAC,YAAW;EACXlmB,GAAG,CAACE,OAAO,CAAC,CAAC,kBAAkB,CAAC,EAAE,UAAS0H,CAAC,EAAE;IAC1C,IAAI,OAAOxH,MAAM,IAAI,QAAQ,IAAI,OAAOD,OAAO,IAAI,QAAQ,IAAIC,MAAM,EAAE;MACnEA,MAAM,CAACD,OAAO,GAAGyH,CAAC;IACtB;EACJ,CAAC,CAAC;AACN,CAAC,EAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}