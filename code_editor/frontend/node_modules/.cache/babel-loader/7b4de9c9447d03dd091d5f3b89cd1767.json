{"ast":null,"code":"/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function (low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.Long.create = function (low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function () {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function (other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function (opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\nflatbuffers.Builder.prototype.clear = function () {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function (forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function () {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function () {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function (size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function (byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function (value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function (value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function (value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function (value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function (value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function (value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function (value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function (value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function (value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function (value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function (value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function (value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function (voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function (voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function (obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function () {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function (voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function () {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function (bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function (offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function (numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function () {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\n  outer_loop: for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finish = function (root_table, opt_file_identifier) {\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' + flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT);\n  this.addOffset(root_table);\n  this.bb.setPosition(this.space);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function (table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function (elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function () {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function (s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(codePoint >> 6 & 0x1F | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(codePoint >> 12 & 0x0F | 0xE0);\n          } else {\n            utf8.push(codePoint >> 18 & 0x07 | 0xF0, codePoint >> 12 & 0x3F | 0x80);\n          }\n          utf8.push(codePoint >> 6 & 0x3F | 0x80);\n        }\n        utf8.push(codePoint & 0x3F | 0x80);\n      }\n    }\n  }\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function (low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function (bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function (byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\nflatbuffers.ByteBuffer.prototype.clear = function () {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function () {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function () {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function (position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function () {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function (offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function (offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function (offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function (offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function (offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function (offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function (offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function (offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function (offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function (offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function (offset, value) {\n  this.bytes_[offset] = /** @type {number} */value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function (offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function (offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function (offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function (offset, value) {\n  this.writeUint32(offset, value.low);\n  this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function (offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function (offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function () {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function (bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function (t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function (offset, opt_encoding) {\n  offset += this.readInt32(offset);\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n  offset += flatbuffers.SIZEOF_INT;\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint = (a & 0x1F) << 6 | b & 0x3F;\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint = (a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F;\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint = (a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F;\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & (1 << 10) - 1) + 0xDC00);\n    }\n  }\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function (offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function (offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function (offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function (ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' + flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function (low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}","map":{"version":3,"names":["flatbuffers","Offset","Table","SIZEOF_SHORT","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","Encoding","UTF8_BYTES","UTF16_STRING","int32","Int32Array","float32","Float32Array","buffer","float64","Float64Array","isLittleEndian","Uint16Array","Uint8Array","Long","low","high","create","ZERO","prototype","toFloat64","equals","other","Builder","opt_initial_size","initial_size","bb","ByteBuffer","allocate","space","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","clear","capacity","forceDefaults","dataBuffer","asUint8Array","bytes","subarray","position","offset","prep","size","additional_bytes","align_size","old_buf_size","growByteBuffer","pad","byte_size","i","writeInt8","value","writeInt16","writeInt32","writeInt64","writeFloat32","writeFloat64","addInt8","addInt16","addInt32","addInt64","addFloat32","addFloat64","addFieldInt8","voffset","defaultValue","slot","addFieldInt16","addFieldInt32","addFieldInt64","addFieldFloat32","addFieldFloat64","addFieldOffset","addOffset","addFieldStruct","nested","obj","Error","notNested","new_buf_size","nbb","setPosition","set","startObject","numfields","endObject","vtableloc","trimmed_size","standard_fields","len","existing_vtable","vt1","outer_loop","length","vt2","readInt16","j","push","finish","root_table","opt_file_identifier","file_identifier","charCodeAt","requiredField","table","field","table_start","vtable_start","readInt32","ok","startVector","elem_size","num_elems","alignment","endVector","createString","s","utf8","codePoint","a","b","createLong","bytes_","position_","readInt8","readUint8","readUint16","readUint32","readInt64","readUint64","readFloat32","readFloat64","writeUint8","writeUint16","writeUint32","writeUint64","getBufferIdentifier","result","String","fromCharCode","__offset","bb_pos","vtable_offset","__union","t","__string","opt_encoding","c","d","__indirect","__vector","__vector_len","__has_identifier","ident"],"sources":["/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/node_modules/flatbuffers/js/flatbuffers.mjs"],"sourcesContent":["/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier) {\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT);\n  this.addOffset(root_table);\n  this.bb.setPosition(this.space);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}