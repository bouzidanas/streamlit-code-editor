{"ast":null,"code":"ace.define(\"ace/mode/clojure_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var ClojureHighlightRules = function () {\n    var builtinFunctions = '* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* ' + '*command-line-args* *compile-files* *compile-path* *e *err* *file* ' + '*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* ' + '*print-dup* *print-length* *print-level* *print-meta* *print-readably* ' + '*read-eval* *source-path* *use-context-classloader* ' + '*warn-on-reflection* + - -> ->> .. / < <= = ' + '== > &gt; >= &gt;= accessor aclone ' + 'add-classpath add-watch agent agent-errors aget alength alias all-ns ' + 'alter alter-meta! alter-var-root amap ancestors and apply areduce ' + 'array-map aset aset-boolean aset-byte aset-char aset-double aset-float ' + 'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? ' + 'atom await await-for await1 bases bean bigdec bigint binding bit-and ' + 'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left ' + 'bit-shift-right bit-test bit-xor boolean boolean-array booleans ' + 'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array ' + 'char-escape-string char-name-string char? chars chunk chunk-append ' + 'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? ' + 'class class? clear-agent-errors clojure-version coll? comment commute ' + 'comp comparator compare compare-and-set! compile complement concat cond ' + 'condp conj conj! cons constantly construct-proxy contains? count ' + 'counted? create-ns create-struct cycle dec decimal? declare definline ' + 'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? ' + 'deliver deref derive descendants destructure disj disj! dissoc dissoc! ' + 'distinct distinct? doall doc dorun doseq dosync dotimes doto double ' + 'double-array doubles drop drop-last drop-while empty empty? ensure ' + 'enumeration-seq eval even? every? false? ffirst file-seq filter find ' + 'find-doc find-ns find-var first float float-array float? floats flush ' + 'fn fn? fnext for force format future future-call future-cancel ' + 'future-cancelled? future-done? future? gen-class gen-interface gensym ' + 'get get-in get-method get-proxy-class get-thread-bindings get-validator ' + 'hash hash-map hash-set identical? identity if-let if-not ifn? import ' + 'in-ns inc init-proxy instance? int int-array integer? interleave intern ' + 'interpose into into-array ints io! isa? iterate iterator-seq juxt key ' + 'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list ' + 'list* list? load load-file load-reader load-string loaded-libs locking ' + 'long long-array longs loop macroexpand macroexpand-1 make-array ' + 'make-hierarchy map map? mapcat max max-key memfn memoize merge ' + 'merge-with meta method-sig methods min min-key mod name namespace neg? ' + 'newline next nfirst nil? nnext not not-any? not-empty not-every? not= ' + 'ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ' + 'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? ' + 'or parents partial partition pcalls peek persistent! pmap pop pop! ' + 'pop-thread-bindings pos? pr pr-str prefer-method prefers ' + 'primitives-classnames print print-ctor print-doc print-dup print-method ' + 'print-namespace-doc print-simple print-special-doc print-str printf ' + 'println println-str prn prn-str promise proxy proxy-call-with-super ' + 'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot ' + 'rand rand-int range ratio? rational? rationalize re-find re-groups ' + 're-matcher re-matches re-pattern re-seq read read-line read-string ' + 'reduce ref ref-history-count ref-max-history ref-min-history ref-set ' + 'refer refer-clojure release-pending-sends rem remove remove-method ' + 'remove-ns remove-watch repeat repeatedly replace replicate require ' + 'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq ' + 'rsubseq second select-keys send send-off seq seq? seque sequence ' + 'sequential? set set-validator! set? short short-array shorts ' + 'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by ' + 'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? ' + 'split-at split-with str stream? string? struct struct-map subs subseq ' + 'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take ' + 'take-last take-nth take-while test the-ns time to-array to-array-2d ' + 'trampoline transient tree-seq true? type unchecked-add unchecked-dec ' + 'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate ' + 'unchecked-remainder unchecked-subtract underive unquote ' + 'unquote-splicing update-in update-proxy use val vals var-get var-set ' + 'var? vary-meta vec vector vector? when when-first when-let when-not ' + 'while with-bindings with-bindings* with-in-str with-loading-context ' + 'with-local-vars with-meta with-open with-out-str with-precision xml-seq ' + 'zero? zipmap';\n    var keywords = 'throw try var ' + 'def do fn if let loop monitor-enter monitor-exit new quote recur set!';\n    var buildinConstants = \"true false nil\";\n    var keywordMapper = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"constant.language\": buildinConstants,\n      \"support.function\": builtinFunctions\n    }, \"identifier\", false, \" \");\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \";.*$\"\n      }, {\n        token: \"keyword\",\n        //parens\n        regex: \"[\\\\(|\\\\)]\"\n      }, {\n        token: \"keyword\",\n        //lists\n        regex: \"[\\\\'\\\\(]\"\n      }, {\n        token: \"keyword\",\n        //vectors\n        regex: \"[\\\\[|\\\\]]\"\n      }, {\n        token: \"string.regexp\",\n        //Regular Expressions\n        regex: '#\"',\n        next: \"regex\"\n      }, {\n        token: \"keyword\",\n        //sets and maps\n        regex: \"[\\\\{|\\\\}|\\\\#\\\\{|\\\\#\\\\}]\"\n      }, {\n        token: \"keyword\",\n        // ampersands\n        regex: '[\\\\&]'\n      }, {\n        token: \"keyword\",\n        // metadata\n        regex: '[\\\\#\\\\^\\\\{]'\n      }, {\n        token: \"keyword\",\n        // anonymous fn syntactic sugar\n        regex: '[\\\\%]'\n      }, {\n        token: \"keyword\",\n        // deref reader macro\n        regex: '[@]'\n      }, {\n        token: \"constant.numeric\",\n        // hex\n        regex: \"0[xX][0-9a-fA-F]+\\\\b\"\n      }, {\n        token: \"constant.numeric\",\n        // float\n        regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n      }, {\n        token: \"constant.language\",\n        regex: '[!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+||=|!=|<=|>=|<>|<|>|!|&&]'\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$\\\\-]*\\\\b\"\n      }, {\n        token: \"string\",\n        // single line\n        regex: '\"',\n        next: \"string\"\n      }, {\n        token: \"constant\",\n        // symbol\n        regex: /:[^()\\[\\]{}'\"\\^%`,;\\s]+/\n      }],\n      \"string\": [{\n        token: \"constant.language.escape\",\n        regex: \"\\\\\\\\.|\\\\\\\\$\"\n      }, {\n        token: \"string\",\n        regex: '\"',\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"regex\": [{\n        token: \"regexp.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"string.regexp\",\n        regex: '\"',\n        next: \"start\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\(\\?[:=!]|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n      }, {\n        token: \"constant.language.delimiter\",\n        regex: /\\|/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\[\\^?/,\n        next: \"regex_character_class\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex_character_class\": [{\n        token: \"regexp.charclass.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"]\",\n        next: \"regex\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"-\"\n      }, {\n        defaultToken: \"string.regexp.charachterclass\"\n      }]\n    };\n  };\n  oop.inherits(ClojureHighlightRules, TextHighlightRules);\n  exports.ClojureHighlightRules = ClojureHighlightRules;\n});\nace.define(\"ace/mode/matching_parens_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  var MatchingParensOutdent = function () {};\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\)/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\))/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n      var match = line.match(/^(\\s+)/);\n      if (match) {\n        return match[1];\n      }\n      return \"\";\n    };\n  }).call(MatchingParensOutdent.prototype);\n  exports.MatchingParensOutdent = MatchingParensOutdent;\n});\nace.define(\"ace/mode/clojure\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/clojure_highlight_rules\", \"ace/mode/matching_parens_outdent\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var ClojureHighlightRules = require(\"./clojure_highlight_rules\").ClojureHighlightRules;\n  var MatchingParensOutdent = require(\"./matching_parens_outdent\").MatchingParensOutdent;\n  var Mode = function () {\n    this.HighlightRules = ClojureHighlightRules;\n    this.$outdent = new MatchingParensOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \";\";\n    this.minorIndentFunctions = [\"defn\", \"defn-\", \"defmacro\", \"def\", \"deftest\", \"testing\"];\n    this.$toIndent = function (str) {\n      return str.split('').map(function (ch) {\n        if (/\\s/.exec(ch)) {\n          return ch;\n        } else {\n          return ' ';\n        }\n      }).join('');\n    };\n    this.$calculateIndent = function (line, tab) {\n      var baseIndent = this.$getIndent(line);\n      var delta = 0;\n      var isParen, ch;\n      for (var i = line.length - 1; i >= 0; i--) {\n        ch = line[i];\n        if (ch === '(') {\n          delta--;\n          isParen = true;\n        } else if (ch === '(' || ch === '[' || ch === '{') {\n          delta--;\n          isParen = false;\n        } else if (ch === ')' || ch === ']' || ch === '}') {\n          delta++;\n        }\n        if (delta < 0) {\n          break;\n        }\n      }\n      if (delta < 0 && isParen) {\n        i += 1;\n        var iBefore = i;\n        var fn = '';\n        while (true) {\n          ch = line[i];\n          if (ch === ' ' || ch === '\\t') {\n            if (this.minorIndentFunctions.indexOf(fn) !== -1) {\n              return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n            } else {\n              return this.$toIndent(line.substring(0, i + 1));\n            }\n          } else if (ch === undefined) {\n            return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n          }\n          fn += line[i];\n          i++;\n        }\n      } else if (delta < 0 && !isParen) {\n        return this.$toIndent(line.substring(0, i + 1));\n      } else if (delta > 0) {\n        baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\n        return baseIndent;\n      } else {\n        return baseIndent;\n      }\n    };\n    this.getNextLineIndent = function (state, line, tab) {\n      return this.$calculateIndent(line, tab);\n    };\n    this.checkOutdent = function (state, line, input) {\n      return this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, doc, row) {\n      this.$outdent.autoOutdent(doc, row);\n    };\n    this.$id = \"ace/mode/clojure\";\n    this.snippetFileId = \"ace/snippets/clojure\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/clojure\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"names":["ace","define","require","exports","module","oop","TextHighlightRules","ClojureHighlightRules","builtinFunctions","keywords","buildinConstants","keywordMapper","createKeywordMapper","$rules","token","regex","next","defaultToken","inherits","Range","MatchingParensOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","getLine","match","column","length","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","TextMode","Mode","HighlightRules","$outdent","$behaviour","$defaultBehaviour","lineCommentStart","minorIndentFunctions","$toIndent","str","split","map","ch","exec","join","$calculateIndent","tab","baseIndent","delta","isParen","i","iBefore","fn","indexOf","substring","undefined","getNextLineIndent","state","$id","snippetFileId","m"],"sources":["/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/node_modules/ace-builds/src-noconflict/mode-clojure.js"],"sourcesContent":["ace.define(\"ace/mode/clojure_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar ClojureHighlightRules = function () {\n    var builtinFunctions = ('* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* ' +\n        '*command-line-args* *compile-files* *compile-path* *e *err* *file* ' +\n        '*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* ' +\n        '*print-dup* *print-length* *print-level* *print-meta* *print-readably* ' +\n        '*read-eval* *source-path* *use-context-classloader* ' +\n        '*warn-on-reflection* + - -> ->> .. / < <= = ' +\n        '== > &gt; >= &gt;= accessor aclone ' +\n        'add-classpath add-watch agent agent-errors aget alength alias all-ns ' +\n        'alter alter-meta! alter-var-root amap ancestors and apply areduce ' +\n        'array-map aset aset-boolean aset-byte aset-char aset-double aset-float ' +\n        'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? ' +\n        'atom await await-for await1 bases bean bigdec bigint binding bit-and ' +\n        'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left ' +\n        'bit-shift-right bit-test bit-xor boolean boolean-array booleans ' +\n        'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array ' +\n        'char-escape-string char-name-string char? chars chunk chunk-append ' +\n        'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? ' +\n        'class class? clear-agent-errors clojure-version coll? comment commute ' +\n        'comp comparator compare compare-and-set! compile complement concat cond ' +\n        'condp conj conj! cons constantly construct-proxy contains? count ' +\n        'counted? create-ns create-struct cycle dec decimal? declare definline ' +\n        'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? ' +\n        'deliver deref derive descendants destructure disj disj! dissoc dissoc! ' +\n        'distinct distinct? doall doc dorun doseq dosync dotimes doto double ' +\n        'double-array doubles drop drop-last drop-while empty empty? ensure ' +\n        'enumeration-seq eval even? every? false? ffirst file-seq filter find ' +\n        'find-doc find-ns find-var first float float-array float? floats flush ' +\n        'fn fn? fnext for force format future future-call future-cancel ' +\n        'future-cancelled? future-done? future? gen-class gen-interface gensym ' +\n        'get get-in get-method get-proxy-class get-thread-bindings get-validator ' +\n        'hash hash-map hash-set identical? identity if-let if-not ifn? import ' +\n        'in-ns inc init-proxy instance? int int-array integer? interleave intern ' +\n        'interpose into into-array ints io! isa? iterate iterator-seq juxt key ' +\n        'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list ' +\n        'list* list? load load-file load-reader load-string loaded-libs locking ' +\n        'long long-array longs loop macroexpand macroexpand-1 make-array ' +\n        'make-hierarchy map map? mapcat max max-key memfn memoize merge ' +\n        'merge-with meta method-sig methods min min-key mod name namespace neg? ' +\n        'newline next nfirst nil? nnext not not-any? not-empty not-every? not= ' +\n        'ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ' +\n        'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? ' +\n        'or parents partial partition pcalls peek persistent! pmap pop pop! ' +\n        'pop-thread-bindings pos? pr pr-str prefer-method prefers ' +\n        'primitives-classnames print print-ctor print-doc print-dup print-method ' +\n        'print-namespace-doc print-simple print-special-doc print-str printf ' +\n        'println println-str prn prn-str promise proxy proxy-call-with-super ' +\n        'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot ' +\n        'rand rand-int range ratio? rational? rationalize re-find re-groups ' +\n        're-matcher re-matches re-pattern re-seq read read-line read-string ' +\n        'reduce ref ref-history-count ref-max-history ref-min-history ref-set ' +\n        'refer refer-clojure release-pending-sends rem remove remove-method ' +\n        'remove-ns remove-watch repeat repeatedly replace replicate require ' +\n        'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq ' +\n        'rsubseq second select-keys send send-off seq seq? seque sequence ' +\n        'sequential? set set-validator! set? short short-array shorts ' +\n        'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by ' +\n        'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? ' +\n        'split-at split-with str stream? string? struct struct-map subs subseq ' +\n        'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take ' +\n        'take-last take-nth take-while test the-ns time to-array to-array-2d ' +\n        'trampoline transient tree-seq true? type unchecked-add unchecked-dec ' +\n        'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate ' +\n        'unchecked-remainder unchecked-subtract underive unquote ' +\n        'unquote-splicing update-in update-proxy use val vals var-get var-set ' +\n        'var? vary-meta vec vector vector? when when-first when-let when-not ' +\n        'while with-bindings with-bindings* with-in-str with-loading-context ' +\n        'with-local-vars with-meta with-open with-out-str with-precision xml-seq ' +\n        'zero? zipmap');\n    var keywords = ('throw try var ' +\n        'def do fn if let loop monitor-enter monitor-exit new quote recur set!');\n    var buildinConstants = (\"true false nil\");\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"support.function\": builtinFunctions\n    }, \"identifier\", false, \" \");\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \";.*$\"\n            }, {\n                token: \"keyword\", //parens\n                regex: \"[\\\\(|\\\\)]\"\n            }, {\n                token: \"keyword\", //lists\n                regex: \"[\\\\'\\\\(]\"\n            }, {\n                token: \"keyword\", //vectors\n                regex: \"[\\\\[|\\\\]]\"\n            }, {\n                token: \"string.regexp\", //Regular Expressions\n                regex: '#\"',\n                next: \"regex\"\n            }, {\n                token: \"keyword\", //sets and maps\n                regex: \"[\\\\{|\\\\}|\\\\#\\\\{|\\\\#\\\\}]\"\n            }, {\n                token: \"keyword\", // ampersands\n                regex: '[\\\\&]'\n            }, {\n                token: \"keyword\", // metadata\n                regex: '[\\\\#\\\\^\\\\{]'\n            }, {\n                token: \"keyword\", // anonymous fn syntactic sugar\n                regex: '[\\\\%]'\n            }, {\n                token: \"keyword\", // deref reader macro\n                regex: '[@]'\n            }, {\n                token: \"constant.numeric\", // hex\n                regex: \"0[xX][0-9a-fA-F]+\\\\b\"\n            }, {\n                token: \"constant.numeric\", // float\n                regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n            }, {\n                token: \"constant.language\",\n                regex: '[!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+||=|!=|<=|>=|<>|<|>|!|&&]'\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$\\\\-]*\\\\b\"\n            }, {\n                token: \"string\", // single line\n                regex: '\"',\n                next: \"string\"\n            }, {\n                token: \"constant\", // symbol\n                regex: /:[^()\\[\\]{}'\"\\^%`,;\\s]+/\n            }\n        ],\n        \"string\": [\n            {\n                token: \"constant.language.escape\",\n                regex: \"\\\\\\\\.|\\\\\\\\$\"\n            }, {\n                token: \"string\",\n                regex: '\"',\n                next: \"start\"\n            }, {\n                defaultToken: \"string\"\n            }\n        ],\n        \"regex\": [\n            {\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"string.regexp\",\n                regex: '\"',\n                next: \"start\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\(\\?[:=!]|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token: \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                next: \"regex_character_class\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"regex\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                defaultToken: \"string.regexp.charachterclass\"\n            }\n        ]\n    };\n};\noop.inherits(ClojureHighlightRules, TextHighlightRules);\nexports.ClojureHighlightRules = ClojureHighlightRules;\n\n});\n\nace.define(\"ace/mode/matching_parens_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar MatchingParensOutdent = function () { };\n(function () {\n    this.checkOutdent = function (line, input) {\n        if (!/^\\s+$/.test(line))\n            return false;\n        return /^\\s*\\)/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\))/);\n        if (!match)\n            return 0;\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({ row: row, column: column });\n        if (!openBracePos || openBracePos.row == row)\n            return 0;\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n        var match = line.match(/^(\\s+)/);\n        if (match) {\n            return match[1];\n        }\n        return \"\";\n    };\n}).call(MatchingParensOutdent.prototype);\nexports.MatchingParensOutdent = MatchingParensOutdent;\n\n});\n\nace.define(\"ace/mode/clojure\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/clojure_highlight_rules\",\"ace/mode/matching_parens_outdent\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar ClojureHighlightRules = require(\"./clojure_highlight_rules\").ClojureHighlightRules;\nvar MatchingParensOutdent = require(\"./matching_parens_outdent\").MatchingParensOutdent;\nvar Mode = function () {\n    this.HighlightRules = ClojureHighlightRules;\n    this.$outdent = new MatchingParensOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n(function () {\n    this.lineCommentStart = \";\";\n    this.minorIndentFunctions = [\"defn\", \"defn-\", \"defmacro\", \"def\", \"deftest\", \"testing\"];\n    this.$toIndent = function (str) {\n        return str.split('').map(function (ch) {\n            if (/\\s/.exec(ch)) {\n                return ch;\n            }\n            else {\n                return ' ';\n            }\n        }).join('');\n    };\n    this.$calculateIndent = function (line, tab) {\n        var baseIndent = this.$getIndent(line);\n        var delta = 0;\n        var isParen, ch;\n        for (var i = line.length - 1; i >= 0; i--) {\n            ch = line[i];\n            if (ch === '(') {\n                delta--;\n                isParen = true;\n            }\n            else if (ch === '(' || ch === '[' || ch === '{') {\n                delta--;\n                isParen = false;\n            }\n            else if (ch === ')' || ch === ']' || ch === '}') {\n                delta++;\n            }\n            if (delta < 0) {\n                break;\n            }\n        }\n        if (delta < 0 && isParen) {\n            i += 1;\n            var iBefore = i;\n            var fn = '';\n            while (true) {\n                ch = line[i];\n                if (ch === ' ' || ch === '\\t') {\n                    if (this.minorIndentFunctions.indexOf(fn) !== -1) {\n                        return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                    }\n                    else {\n                        return this.$toIndent(line.substring(0, i + 1));\n                    }\n                }\n                else if (ch === undefined) {\n                    return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n                }\n                fn += line[i];\n                i++;\n            }\n        }\n        else if (delta < 0 && !isParen) {\n            return this.$toIndent(line.substring(0, i + 1));\n        }\n        else if (delta > 0) {\n            baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\n            return baseIndent;\n        }\n        else {\n            return baseIndent;\n        }\n    };\n    this.getNextLineIndent = function (state, line, tab) {\n        return this.$calculateIndent(line, tab);\n    };\n    this.checkOutdent = function (state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n    this.$id = \"ace/mode/clojure\";\n    this.snippetFileId = \"ace/snippets/clojure\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/clojure\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}