{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector';\nimport { MessageHeader } from '../enum';\nimport { Footer } from './metadata/file';\nimport streamAdapters from '../io/adapters';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch';\nimport { ITERATOR_DONE, ReadableInterop } from '../io/interfaces';\nimport { MessageReader, AsyncMessageReader, JSONMessageReader, checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding } from './message';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isArrowJSON, isFileHandle, isFetchResponse, isReadableDOMStream, isReadableNodeStream } from '../util/compat';\nexport class RecordBatchReader extends ReadableInterop {\n  constructor(impl) {\n    super();\n    this._impl = impl;\n  }\n  get closed() {\n    return this._impl.closed;\n  }\n  get schema() {\n    return this._impl.schema;\n  }\n  get autoDestroy() {\n    return this._impl.autoDestroy;\n  }\n  get dictionaries() {\n    return this._impl.dictionaries;\n  }\n  get numDictionaries() {\n    return this._impl.numDictionaries;\n  }\n  get numRecordBatches() {\n    return this._impl.numRecordBatches;\n  }\n  get footer() {\n    return this._impl.isFile() ? this._impl.footer : null;\n  }\n  isSync() {\n    return this._impl.isSync();\n  }\n  isAsync() {\n    return this._impl.isAsync();\n  }\n  isFile() {\n    return this._impl.isFile();\n  }\n  isStream() {\n    return this._impl.isStream();\n  }\n  next() {\n    return this._impl.next();\n  }\n  throw(value) {\n    return this._impl.throw(value);\n  }\n  return(value) {\n    return this._impl.return(value);\n  }\n  cancel() {\n    return this._impl.cancel();\n  }\n  reset(schema) {\n    this._impl.reset(schema);\n    this._DOMStream = undefined;\n    this._nodeStream = undefined;\n    return this;\n  }\n  open(options) {\n    const opening = this._impl.open(options);\n    return isPromise(opening) ? opening.then(() => this) : this;\n  }\n  readRecordBatch(index) {\n    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n  toDOMStream() {\n    return streamAdapters.toDOMStream(this.isSync() ? {\n      [Symbol.iterator]: () => this\n    } : {\n      [Symbol.asyncIterator]: () => this\n    });\n  }\n  toNodeStream() {\n    return streamAdapters.toNodeStream(this.isSync() ? {\n      [Symbol.iterator]: () => this\n    } : {\n      [Symbol.asyncIterator]: () => this\n    }, {\n      objectMode: true\n    });\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(\n  // @ts-ignore\n  writableStrategy,\n  // @ts-ignore\n  readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static from(source) {\n    if (source instanceof RecordBatchReader) {\n      return source;\n    } else if (isArrowJSON(source)) {\n      return fromArrowJSON(source);\n    } else if (isFileHandle(source)) {\n      return fromFileHandle(source);\n    } else if (isPromise(source)) {\n      return (async () => await RecordBatchReader.from(await source))();\n    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n      return fromAsyncByteStream(new AsyncByteStream(source));\n    }\n    return fromByteStream(new ByteStream(source));\n  }\n  /** @nocollapse */\n  static readAll(source) {\n    if (source instanceof RecordBatchReader) {\n      return source.isSync() ? readAllSync(source) : readAllAsync(source);\n    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {\n      return readAllSync(source);\n    }\n    return readAllAsync(source);\n  }\n}\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n/** @ignore */\nexport class RecordBatchStreamReader extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  async *[Symbol.asyncIterator]() {\n    yield* this[Symbol.iterator]();\n  }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  [Symbol.iterator]() {\n    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n}\n/** @ignore */\nexport class RecordBatchFileReader extends RecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n}\n/** @ignore */\nclass RecordBatchReaderImpl {\n  constructor() {\n    let dictionaries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n  get numDictionaries() {\n    return this._dictionaryIndex;\n  }\n  get numRecordBatches() {\n    return this._recordBatchIndex;\n  }\n  isSync() {\n    return false;\n  }\n  isAsync() {\n    return false;\n  }\n  isFile() {\n    return false;\n  }\n  isStream() {\n    return false;\n  }\n  reset(schema) {\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.schema = schema;\n    this.dictionaries = new Map();\n    return this;\n  }\n  _loadRecordBatch(header, body) {\n    return new RecordBatch(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));\n  }\n  _loadDictionaryBatch(header, body) {\n    const {\n      id,\n      isDelta,\n      data\n    } = header;\n    const {\n      dictionaries,\n      schema\n    } = this;\n    const dictionary = dictionaries.get(id);\n    if (isDelta || !dictionary) {\n      const type = schema.dictionaries.get(id);\n      return dictionary && isDelta ? dictionary.concat(Vector.new(this._loadVectors(data, body, [type])[0])) : Vector.new(this._loadVectors(data, body, [type])[0]);\n    }\n    return dictionary;\n  }\n  _loadVectors(header, body, types) {\n    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n}\n/** @ignore */\nclass RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);\n  }\n  isSync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  cancel() {\n    if (!this.closed && (this.closed = true)) {\n      this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n  open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n      if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n        this.cancel();\n      }\n    }\n    return this;\n  }\n  throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.throw(value);\n    }\n    return ITERATOR_DONE;\n  }\n  return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.return(value);\n    }\n    return ITERATOR_DONE;\n  }\n  next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n    let message,\n      {\n        _reader: reader\n      } = this;\n    while (message = this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return {\n          done: false,\n          value: recordBatch\n        };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const vector = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return {\n        done: false,\n        value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n      };\n    }\n    return this.return();\n  }\n  _readNextMessageAndValidate(type) {\n    return this._reader.readMessage(type);\n  }\n}\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = new AsyncMessageReader(this._handle = source);\n  }\n  isAsync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  async cancel() {\n    if (!this.closed && (this.closed = true)) {\n      await this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n  async open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n      if (!(this.schema || (this.schema = await this._reader.readSchema()))) {\n        await this.cancel();\n      }\n    }\n    return this;\n  }\n  async throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return await this.reset()._reader.throw(value);\n    }\n    return ITERATOR_DONE;\n  }\n  async return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return await this.reset()._reader.return(value);\n    }\n    return ITERATOR_DONE;\n  }\n  async next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n    let message,\n      {\n        _reader: reader\n      } = this;\n    while (message = await this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        await this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = await reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return {\n          done: false,\n          value: recordBatch\n        };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = await reader.readMessageBody(message.bodyLength);\n        const vector = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return {\n        done: false,\n        value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n      };\n    }\n    return await this.return();\n  }\n  async _readNextMessageAndValidate(type) {\n    return await this._reader.readMessage(type);\n  }\n}\n/** @ignore */\nclass RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isSync() {\n    return true;\n  }\n  isFile() {\n    return true;\n  }\n  open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = this._readFooter()).schema;\n      for (const block of this._footer.dictionaryBatches()) {\n        block && this._readDictionaryBatch(this._dictionaryIndex++);\n      }\n    }\n    return super.open(options);\n  }\n  readRecordBatch(index) {\n    if (this.closed) {\n      return null;\n    }\n    if (!this._footer) {\n      this.open();\n    }\n    const block = this._footer && this._footer.getRecordBatch(index);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.RecordBatch);\n      if (message && message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return recordBatch;\n      }\n    }\n    return null;\n  }\n  _readDictionaryBatch(index) {\n    const block = this._footer && this._footer.getDictionaryBatch(index);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n      if (message && message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const vector = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n  }\n  _readFooter() {\n    const {\n      _handle\n    } = this;\n    const offset = _handle.size - magicAndPadding;\n    const length = _handle.readInt32(offset);\n    const buffer = _handle.readAt(offset - length, length);\n    return Footer.decode(buffer);\n  }\n  _readNextMessageAndValidate(type) {\n    if (!this._footer) {\n      this.open();\n    }\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);\n      if (block && this._handle.seek(block.offset)) {\n        return this._reader.readMessage(type);\n      }\n    }\n    return null;\n  }\n}\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {\n  constructor(source) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n    const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;\n    const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;\n    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isFile() {\n    return true;\n  }\n  isAsync() {\n    return true;\n  }\n  async open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = await this._readFooter()).schema;\n      for (const block of this._footer.dictionaryBatches()) {\n        block && (await this._readDictionaryBatch(this._dictionaryIndex++));\n      }\n    }\n    return await super.open(options);\n  }\n  async readRecordBatch(index) {\n    if (this.closed) {\n      return null;\n    }\n    if (!this._footer) {\n      await this.open();\n    }\n    const block = this._footer && this._footer.getRecordBatch(index);\n    if (block && (await this._handle.seek(block.offset))) {\n      const message = await this._reader.readMessage(MessageHeader.RecordBatch);\n      if (message && message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = await this._reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return recordBatch;\n      }\n    }\n    return null;\n  }\n  async _readDictionaryBatch(index) {\n    const block = this._footer && this._footer.getDictionaryBatch(index);\n    if (block && (await this._handle.seek(block.offset))) {\n      const message = await this._reader.readMessage(MessageHeader.DictionaryBatch);\n      if (message && message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = await this._reader.readMessageBody(message.bodyLength);\n        const vector = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n  }\n  async _readFooter() {\n    const {\n      _handle\n    } = this;\n    _handle._pending && (await _handle._pending);\n    const offset = _handle.size - magicAndPadding;\n    const length = await _handle.readInt32(offset);\n    const buffer = await _handle.readAt(offset - length, length);\n    return Footer.decode(buffer);\n  }\n  async _readNextMessageAndValidate(type) {\n    if (!this._footer) {\n      await this.open();\n    }\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = this._footer.getRecordBatch(this._recordBatchIndex);\n      if (block && (await this._handle.seek(block.offset))) {\n        return await this._reader.readMessage(type);\n      }\n    }\n    return null;\n  }\n}\n/** @ignore */\nclass RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source, dictionaries);\n  }\n  _loadVectors(header, body, types) {\n    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n}\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n/** @ignore */\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];\n}\n/** @ignore */\nfunction* readAllSync(source) {\n  const reader = RecordBatchReader.from(source);\n  try {\n    if (!reader.open({\n      autoDestroy: false\n    }).closed) {\n      do {\n        yield reader;\n      } while (!reader.reset().open().closed);\n    }\n  } finally {\n    reader.cancel();\n  }\n}\n/** @ignore */\nasync function* readAllAsync(source) {\n  const reader = await RecordBatchReader.from(source);\n  try {\n    if (!(await reader.open({\n      autoDestroy: false\n    })).closed) {\n      do {\n        yield reader;\n      } while (!(await reader.reset().open()).closed);\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n/** @ignore */\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\n/** @ignore */\nfunction fromByteStream(source) {\n  const bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));\n}\n/** @ignore */\nasync function fromAsyncByteStream(source) {\n  const bytes = await source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(await source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(async function* () {}()));\n}\n/** @ignore */\nasync function fromFileHandle(source) {\n  const {\n    size\n  } = await source.stat();\n  const file = new AsyncRandomAccessFile(source, size);\n  if (size >= magicX2AndPadding) {\n    if (checkForMagicArrowString(await file.readAt(0, magicLength + 7 & ~7))) {\n      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n    }\n  }\n  return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n}","map":{"version":3,"mappings":"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","names":["Vector","MessageHeader","Footer","streamAdapters","ByteStream","AsyncByteStream","RandomAccessFile","AsyncRandomAccessFile","VectorLoader","JSONVectorLoader","RecordBatch","_InternalEmptyPlaceholderRecordBatch","ITERATOR_DONE","ReadableInterop","MessageReader","AsyncMessageReader","JSONMessageReader","checkForMagicArrowString","magicLength","magicAndPadding","magicX2AndPadding","isPromise","isIterable","isAsyncIterable","isIteratorResult","isArrowJSON","isFileHandle","isFetchResponse","isReadableDOMStream","isReadableNodeStream","RecordBatchReader","constructor","impl","_impl","closed","schema","autoDestroy","dictionaries","numDictionaries","numRecordBatches","footer","isFile","isSync","isAsync","isStream","next","throw","value","return","cancel","reset","_DOMStream","undefined","_nodeStream","open","options","opening","then","readRecordBatch","index","Symbol","iterator","asyncIterator","toDOMStream","toNodeStream","objectMode","throughNode","Error","throughDOM","writableStrategy","readableStrategy","from","source","fromArrowJSON","fromFileHandle","fromAsyncByteStream","fromByteStream","readAll","readAllSync","readAllAsync","ArrayBuffer","isView","RecordBatchStreamReader","AsyncRecordBatchStreamReader","RecordBatchFileReader","AsyncRecordBatchFileReader","RecordBatchReaderImpl","Map","_dictionaryIndex","_recordBatchIndex","_loadRecordBatch","header","body","length","_loadVectors","fields","_loadDictionaryBatch","id","isDelta","data","dictionary","get","type","concat","new","types","nodes","buffers","visitMany","RecordBatchStreamReaderImpl","_reader","_handle","shouldAutoDestroy","readSchema","message","reader","_readNextMessageAndValidate","isSchema","isRecordBatch","buffer","readMessageBody","bodyLength","recordBatch","done","isDictionaryBatch","vector","set","readMessage","AsyncRecordBatchStreamReaderImpl","RecordBatchFileReaderImpl","_footer","_readFooter","block","dictionaryBatches","_readDictionaryBatch","getRecordBatch","seek","offset","getDictionaryBatch","DictionaryBatch","size","readInt32","readAt","decode","AsyncRecordBatchFileReaderImpl","rest","byteLength","shift","_pending","RecordBatchJSONReaderImpl","self","bytes","peek","read","stat","file"],"sources":["ipc/reader.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { MessageHeader } from '../enum';\nimport { Footer } from './metadata/file';\nimport { Schema, Field } from '../schema';\nimport streamAdapters from '../io/adapters';\nimport { Message } from './metadata/message';\nimport * as metadata from './metadata/message';\nimport { ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch';\nimport {\n    FileHandle,\n    ArrowJSONLike,\n    ITERATOR_DONE,\n    ReadableInterop,\n} from '../io/interfaces';\nimport {\n    MessageReader, AsyncMessageReader, JSONMessageReader,\n    checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding\n} from './message';\nimport {\n    isPromise,\n    isIterable, isAsyncIterable,\n    isIteratorResult, isArrowJSON,\n    isFileHandle, isFetchResponse,\n    isReadableDOMStream, isReadableNodeStream\n} from '../util/compat';\n\n/** @ignore */ export type FromArg0 = ArrowJSONLike;\n/** @ignore */ export type FromArg1 = PromiseLike<ArrowJSONLike>;\n/** @ignore */ export type FromArg2 = Iterable<ArrayBufferViewInput> | ArrayBufferViewInput;\n/** @ignore */ export type FromArg3 = PromiseLike<Iterable<ArrayBufferViewInput> | ArrayBufferViewInput>;\n/** @ignore */ export type FromArg4 = Response | NodeJS.ReadableStream | ReadableStream<ArrayBufferViewInput> | AsyncIterable<ArrayBufferViewInput>;\n/** @ignore */ export type FromArg5 = FileHandle | PromiseLike<FileHandle> | PromiseLike<FromArg4>;\n/** @ignore */ export type FromArgs = FromArg0 | FromArg1 | FromArg2 | FromArg3 | FromArg4 | FromArg5;\n\n/** @ignore */ type OpenOptions = { autoDestroy?: boolean; };\n/** @ignore */ type RecordBatchReaders<T extends { [key: string]: DataType } = any> = RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n/** @ignore */ type AsyncRecordBatchReaders<T extends { [key: string]: DataType } = any> = AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>;\n/** @ignore */ type RecordBatchFileReaders<T extends { [key: string]: DataType } = any> = RecordBatchFileReader<T> | AsyncRecordBatchFileReader<T>;\n/** @ignore */ type RecordBatchStreamReaders<T extends { [key: string]: DataType } = any> = RecordBatchStreamReader<T> | AsyncRecordBatchStreamReader<T>;\n\nexport class RecordBatchReader<T extends { [key: string]: DataType } = any> extends ReadableInterop<RecordBatch<T>> {\n\n    protected _impl: RecordBatchReaderImpls<T>;\n    protected constructor(impl: RecordBatchReaderImpls<T>) {\n        super();\n        this._impl = impl;\n    }\n\n    public get closed() { return this._impl.closed; }\n    public get schema() { return this._impl.schema; }\n    public get autoDestroy() { return this._impl.autoDestroy; }\n    public get dictionaries() { return this._impl.dictionaries; }\n    public get numDictionaries() { return this._impl.numDictionaries; }\n    public get numRecordBatches() { return this._impl.numRecordBatches; }\n    public get footer() { return this._impl.isFile() ? this._impl.footer : null; }\n\n    public isSync(): this is RecordBatchReaders<T> { return this._impl.isSync(); }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return this._impl.isAsync(); }\n    public isFile(): this is RecordBatchFileReaders<T> { return this._impl.isFile(); }\n    public isStream(): this is RecordBatchStreamReaders<T> { return this._impl.isStream(); }\n\n    public next() {\n        return this._impl.next();\n    }\n    public throw(value?: any) {\n        return this._impl.throw(value);\n    }\n    public return(value?: any) {\n        return this._impl.return(value);\n    }\n    public cancel() {\n        return this._impl.cancel();\n    }\n    public reset(schema?: Schema<T> | null): this {\n        this._impl.reset(schema);\n        this._DOMStream = undefined;\n        this._nodeStream = undefined;\n        return this;\n    }\n    public open(options?: OpenOptions) {\n        const opening = this._impl.open(options);\n        return isPromise(opening) ? opening.then(() => this) : this;\n    }\n    public readRecordBatch(index: number): RecordBatch<T> | null | Promise<RecordBatch<T> | null> {\n        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n    }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return (<IterableIterator<RecordBatch<T>>> this._impl)[Symbol.iterator]();\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return (<AsyncIterableIterator<RecordBatch<T>>> this._impl)[Symbol.asyncIterator]();\n    }\n    public toDOMStream() {\n        return streamAdapters.toDOMStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>));\n    }\n    public toNodeStream() {\n        return streamAdapters.toNodeStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>),\n            { objectMode: true });\n    }\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode(options?: import('stream').DuplexOptions & { autoDestroy: boolean }): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    public static throughDOM<T extends { [key: string]: DataType }>(\n        // @ts-ignore\n        writableStrategy?: ByteLengthQueuingStrategy,\n        // @ts-ignore\n        readableStrategy?: { autoDestroy: boolean }\n    ): { writable: WritableStream<Uint8Array>, readable: ReadableStream<RecordBatch<T>> } {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    public static from<T extends RecordBatchReader>(source: T): T;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg0): RecordBatchStreamReader<T>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg1): Promise<RecordBatchStreamReader<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg2): RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg3): Promise<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg4): Promise<RecordBatchFileReader<T> | AsyncRecordBatchReaders<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg5): Promise<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source;\n        } else if (isArrowJSON(source)) {\n            return fromArrowJSON<T>(source);\n        } else if (isFileHandle(source)) {\n            return fromFileHandle<T>(source);\n        } else if (isPromise<any>(source)) {\n            return (async () => await RecordBatchReader.from<any>(await source))();\n        } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n            return fromAsyncByteStream<T>(new AsyncByteStream(source));\n        }\n        return fromByteStream<T>(new ByteStream(source));\n    }\n\n    public static readAll<T extends RecordBatchReader>(source: T): T extends RecordBatchReaders ? IterableIterator<T> : AsyncIterableIterator<T>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg0): IterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg1): AsyncIterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg2): IterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg3): AsyncIterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg4): AsyncIterableIterator<RecordBatchFileReader<T> | AsyncRecordBatchReaders<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg5): AsyncIterableIterator<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static readAll<T extends { [key: string]: DataType } = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source.isSync() ? readAllSync(source) : readAllAsync(source as AsyncRecordBatchReaders<T>);\n        } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable<ArrayBufferViewInput>(source) || isIteratorResult(source)) {\n            return readAllSync<T>(source) as IterableIterator<RecordBatchReaders<T>>;\n        }\n        return readAllAsync<T>(source) as AsyncIterableIterator<RecordBatchReaders<T> | AsyncRecordBatchReaders<T>>;\n    }\n}\n\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n\n/** @ignore */\nexport class RecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: RecordBatchStreamReaderImpl<T>) { super (_impl); }\n    public [Symbol.iterator]() { return (this._impl as IterableIterator<RecordBatch<T>>)[Symbol.iterator](); }\n    public async *[Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> { yield* this[Symbol.iterator](); }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: AsyncRecordBatchStreamReaderImpl<T>) { super (_impl); }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> { throw new Error(`AsyncRecordBatchStreamReader is not Iterable`); }\n    public [Symbol.asyncIterator]() { return (this._impl as AsyncIterableIterator<RecordBatch<T>>)[Symbol.asyncIterator](); }\n}\n/** @ignore */\nexport class RecordBatchFileReader<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReader<T> {\n    constructor(protected _impl: RecordBatchFileReaderImpl<T>) { super (_impl); }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReader<T> {\n    constructor(protected _impl: AsyncRecordBatchFileReaderImpl<T>) { super (_impl); }\n}\n\n//\n// Now override the return types for each sync/async RecordBatchReader variant\n//\n\n/** @ignore */\nexport interface RecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): this;\n    cancel(): void;\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): Promise<this>;\n    cancel(): Promise<void>;\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n}\n\n/** @ignore */\nexport interface RecordBatchFileReader<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReader<T> {\n    footer: Footer;\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchFileReader<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReader<T> {\n    footer: Footer;\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\ntype RecordBatchReaderImpls<T extends { [key: string]: DataType } = any> =\n     RecordBatchJSONReaderImpl<T> |\n     RecordBatchFileReaderImpl<T> |\n     RecordBatchStreamReaderImpl<T> |\n     AsyncRecordBatchFileReaderImpl<T> |\n     AsyncRecordBatchStreamReaderImpl<T>;\n\n/** @ignore */\ninterface RecordBatchReaderImpl<T extends { [key: string]: DataType } = any> {\n\n    closed: boolean;\n    schema: Schema<T>;\n    autoDestroy: boolean;\n    dictionaries: Map<number, Vector>;\n\n    isFile(): this is RecordBatchFileReaders<T>;\n    isStream(): this is RecordBatchStreamReaders<T>;\n    isSync(): this is RecordBatchReaders<T>;\n    isAsync(): this is AsyncRecordBatchReaders<T>;\n\n    reset(schema?: Schema<T> | null): this;\n}\n\n/** @ignore */\ninterface RecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): this;\n    cancel(): void;\n\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n\n    [Symbol.iterator](): IterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): Promise<this>;\n    cancel(): Promise<void>;\n\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface RecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\nabstract class RecordBatchReaderImpl<T extends { [key: string]: DataType } = any> implements RecordBatchReaderImpl<T> {\n\n    // @ts-ignore\n    public schema: Schema;\n    public closed = false;\n    public autoDestroy = true;\n    public dictionaries: Map<number, Vector>;\n\n    protected _dictionaryIndex = 0;\n    protected _recordBatchIndex = 0;\n    public get numDictionaries() { return this._dictionaryIndex; }\n    public get numRecordBatches() { return this._recordBatchIndex; }\n\n    constructor(dictionaries = new Map<number, Vector>()) {\n        this.dictionaries = dictionaries;\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return false; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return false; }\n    public isFile(): this is RecordBatchFileReaders<T> { return false; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return false; }\n\n    public reset(schema?: Schema<T> | null) {\n        this._dictionaryIndex = 0;\n        this._recordBatchIndex = 0;\n        this.schema = <any> schema;\n        this.dictionaries = new Map();\n        return this;\n    }\n\n    protected _loadRecordBatch(header: metadata.RecordBatch, body: any) {\n        return new RecordBatch<T>(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));\n    }\n    protected _loadDictionaryBatch(header: metadata.DictionaryBatch, body: any) {\n        const { id, isDelta, data } = header;\n        const { dictionaries, schema } = this;\n        const dictionary = dictionaries.get(id);\n        if (isDelta || !dictionary) {\n            const type = schema.dictionaries.get(id)!;\n            return (dictionary && isDelta ? dictionary.concat(\n                Vector.new(this._loadVectors(data, body, [type])[0])) :\n                Vector.new(this._loadVectors(data, body, [type])[0])) as Vector;\n        }\n        return dictionary;\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n/** @ignore */\nclass RecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> implements IterableIterator<RecordBatch<T>> {\n\n    protected _reader: MessageReader;\n    protected _handle: ByteStream | ArrowJSONLike;\n\n    constructor(source: ByteStream | ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = !isArrowJSON(source)\n            ? new MessageReader(this._handle = source)\n            : new JSONMessageReader(this._handle = source);\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return this as IterableIterator<RecordBatch<T>>;\n    }\n    public cancel() {\n        if (!this.closed && (this.closed = true)) {\n            this.reset()._reader.return();\n            this._reader = <any> null;\n            this.dictionaries = <any> null;\n        }\n    }\n    public open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = this._reader.readSchema()!))) {\n                this.cancel();\n            }\n        }\n        return this;\n    }\n    public throw(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public return(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public next(): IteratorResult<RecordBatch<T>> {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null, { _reader: reader } = this;\n        while (message = this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return this.return();\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> implements AsyncIterableIterator<RecordBatch<T>> {\n\n    protected _handle: AsyncByteStream;\n    protected _reader: AsyncMessageReader;\n\n    constructor(source: AsyncByteStream, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = new AsyncMessageReader(this._handle = source);\n    }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return this as AsyncIterableIterator<RecordBatch<T>>;\n    }\n    public async cancel() {\n        if (!this.closed && (this.closed = true)) {\n            await this.reset()._reader.return();\n            this._reader = <any> null;\n            this.dictionaries = <any> null;\n        }\n    }\n    public async open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = (await this._reader.readSchema())!))) {\n                await this.cancel();\n            }\n        }\n        return this;\n    }\n    public async throw(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async return(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async next() {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null, { _reader: reader } = this;\n        while (message = await this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                await this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return await this.return();\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return await this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass RecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n\n    // @ts-ignore\n    protected _footer?: Footer;\n    // @ts-ignore\n    protected _handle: RandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: RandomAccessFile | ArrayBufferViewInput, dictionaries?: Map<number, Vector>) {\n        super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n    }\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return super.open(options);\n    }\n    public readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { this.open(); }\n        const block = this._footer && this._footer.getRecordBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message && message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected _readDictionaryBatch(index: number) {\n        const block = this._footer && this._footer.getDictionaryBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message && message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected _readFooter() {\n        const { _handle } = this;\n        const offset = _handle.size - magicAndPadding;\n        const length = _handle.readInt32(offset);\n        const buffer = _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Message<T> | null {\n        if (!this._footer) { this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && this._handle.seek(block.offset)) {\n                return this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReaderImpl<T>\n    implements AsyncRecordBatchFileReaderImpl<T> {\n\n    protected _footer?: Footer;\n    // @ts-ignore\n    protected _handle: AsyncRandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: FileHandle, byteLength?: number, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, ...rest: any[]) {\n        const byteLength = typeof rest[0] !== 'number' ? <number> rest.shift() : undefined;\n        const dictionaries = rest[0] instanceof Map ? <Map<number, Vector>> rest.shift() : undefined;\n        super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n    }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public async open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = await this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && await this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return await super.open(options);\n    }\n    public async readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { await this.open(); }\n        const block = this._footer && this._footer.getRecordBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message && message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected async _readDictionaryBatch(index: number) {\n        const block = this._footer && this._footer.getDictionaryBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message && message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected async _readFooter() {\n        const { _handle } = this;\n        _handle._pending && await _handle._pending;\n        const offset = _handle.size - magicAndPadding;\n        const length = await _handle.readInt32(offset);\n        const buffer = await _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Promise<Message<T> | null> {\n        if (!this._footer) { await this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && await this._handle.seek(block.offset)) {\n                return await this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass RecordBatchJSONReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n    constructor(source: ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(source, dictionaries);\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n\n/** @ignore */\nfunction shouldAutoDestroy(self: { autoDestroy: boolean }, options?: OpenOptions) {\n    return options && (typeof options['autoDestroy'] === 'boolean') ? options['autoDestroy'] : self['autoDestroy'];\n}\n\n/** @ignore */\nfunction* readAllSync<T extends { [key: string]: DataType } = any>(source: RecordBatchReaders<T> | FromArg0 | FromArg2) {\n    const reader = RecordBatchReader.from<T>(<any> source) as RecordBatchReaders<T>;\n    try {\n        if (!reader.open({ autoDestroy: false }).closed) {\n            do { yield reader; } while (!(reader.reset().open()).closed);\n        }\n    } finally { reader.cancel(); }\n}\n\n/** @ignore */\nasync function* readAllAsync<T extends { [key: string]: DataType } = any>(source: AsyncRecordBatchReaders<T> | FromArg1 | FromArg3 | FromArg4 | FromArg5) {\n    const reader = await RecordBatchReader.from<T>(<any> source) as RecordBatchReader<T>;\n    try {\n        if (!(await reader.open({ autoDestroy: false })).closed) {\n            do { yield reader; } while (!(await reader.reset().open()).closed);\n        }\n    } finally { await reader.cancel(); }\n}\n\n/** @ignore */\nfunction fromArrowJSON<T extends { [key: string]: DataType }>(source: ArrowJSONLike) {\n    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl<T>(source));\n}\n\n/** @ignore */\nfunction fromByteStream<T extends { [key: string]: DataType }>(source: ByteStream) {\n    const bytes = source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(source.read()))\n        : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(function*(): any {}()));\n}\n\n/** @ignore */\nasync function fromAsyncByteStream<T extends { [key: string]: DataType }>(source: AsyncByteStream) {\n    const bytes = await source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(await source.read()))\n        : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(async function*(): any {}()));\n}\n\n/** @ignore */\nasync function fromFileHandle<T extends { [key: string]: DataType }>(source: FileHandle) {\n    const { size } = await source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding) {\n        if (checkForMagicArrowString(await file.readAt(0, (magicLength + 7) & ~7))) {\n            return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl<T>(file));\n        }\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(file));\n}\n"]},"metadata":{},"sourceType":"module"}