{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DictionaryVector } from '../vector/dictionary';\n/** @ignore */\nexport class Value {\n  eq(other) {\n    if (!(other instanceof Value)) {\n      other = new Literal(other);\n    }\n    return new Equals(this, other);\n  }\n  le(other) {\n    if (!(other instanceof Value)) {\n      other = new Literal(other);\n    }\n    return new LTeq(this, other);\n  }\n  ge(other) {\n    if (!(other instanceof Value)) {\n      other = new Literal(other);\n    }\n    return new GTeq(this, other);\n  }\n  lt(other) {\n    return new Not(this.ge(other));\n  }\n  gt(other) {\n    return new Not(this.le(other));\n  }\n  ne(other) {\n    return new Not(this.eq(other));\n  }\n}\n/** @ignore */\nexport class Literal extends Value {\n  constructor(v) {\n    super();\n    this.v = v;\n  }\n}\n/** @ignore */\nexport class Col extends Value {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  bind(batch) {\n    if (!this.colidx) {\n      // Assume column index doesn't change between calls to bind\n      //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n      this.colidx = -1;\n      const fields = batch.schema.fields;\n      for (let idx = -1; ++idx < fields.length;) {\n        if (fields[idx].name === this.name) {\n          this.colidx = idx;\n          break;\n        }\n      }\n      if (this.colidx < 0) {\n        throw new Error(\"Failed to bind Col \\\"\".concat(this.name, \"\\\"\"));\n      }\n    }\n    const vec = this.vector = batch.getChildAt(this.colidx);\n    return idx => vec.get(idx);\n  }\n}\n/** @ignore */\nexport class Predicate {\n  and() {\n    for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n      expr[_key] = arguments[_key];\n    }\n    return new And(this, ...expr);\n  }\n  or() {\n    for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      expr[_key2] = arguments[_key2];\n    }\n    return new Or(this, ...expr);\n  }\n  not() {\n    return new Not(this);\n  }\n}\n/** @ignore */\nexport class ComparisonPredicate extends Predicate {\n  constructor(left, right) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n  bind(batch) {\n    if (this.left instanceof Literal) {\n      if (this.right instanceof Literal) {\n        return this._bindLitLit(batch, this.left, this.right);\n      } else {\n        // right is a Col\n        return this._bindLitCol(batch, this.left, this.right);\n      }\n    } else {\n      // left is a Col\n      if (this.right instanceof Literal) {\n        return this._bindColLit(batch, this.left, this.right);\n      } else {\n        // right is a Col\n        return this._bindColCol(batch, this.left, this.right);\n      }\n    }\n  }\n}\n/** @ignore */\nexport class CombinationPredicate extends Predicate {\n  constructor() {\n    super();\n    for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      children[_key3] = arguments[_key3];\n    }\n    this.children = children;\n  }\n}\n// add children to prototype so it doesn't get mangled in es2015/umd\nCombinationPredicate.prototype.children = Object.freeze([]); // freeze for safety\n/** @ignore */\nexport class And extends CombinationPredicate {\n  constructor() {\n    for (var _len4 = arguments.length, children = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      children[_key4] = arguments[_key4];\n    }\n    // Flatten any Ands\n    children = children.reduce((accum, p) => {\n      return accum.concat(p instanceof And ? p.children : p);\n    }, []);\n    super(...children);\n  }\n  bind(batch) {\n    const bound = this.children.map(p => p.bind(batch));\n    return (idx, batch) => bound.every(p => p(idx, batch));\n  }\n}\n/** @ignore */\nexport class Or extends CombinationPredicate {\n  constructor() {\n    for (var _len5 = arguments.length, children = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      children[_key5] = arguments[_key5];\n    }\n    // Flatten any Ors\n    children = children.reduce((accum, p) => {\n      return accum.concat(p instanceof Or ? p.children : p);\n    }, []);\n    super(...children);\n  }\n  bind(batch) {\n    const bound = this.children.map(p => p.bind(batch));\n    return (idx, batch) => bound.some(p => p(idx, batch));\n  }\n}\n/** @ignore */\nexport class Equals extends ComparisonPredicate {\n  _bindLitLit(_batch, left, right) {\n    const rtrn = left.v == right.v;\n    return () => rtrn;\n  }\n  _bindColCol(batch, left, right) {\n    const left_func = left.bind(batch);\n    const right_func = right.bind(batch);\n    return (idx, batch) => left_func(idx, batch) == right_func(idx, batch);\n  }\n  _bindColLit(batch, col, lit) {\n    const col_func = col.bind(batch);\n    if (col.vector instanceof DictionaryVector) {\n      let key;\n      const vector = col.vector;\n      if (vector.dictionary !== this.lastDictionary) {\n        key = vector.reverseLookup(lit.v);\n        this.lastDictionary = vector.dictionary;\n        this.lastKey = key;\n      } else {\n        key = this.lastKey;\n      }\n      if (key === -1) {\n        // the value doesn't exist in the dictionary - always return\n        // false\n        // TODO: special-case of PredicateFunc that encapsulates this\n        // \"always false\" behavior. That way filtering operations don't\n        // have to bother checking\n        return () => false;\n      } else {\n        return idx => {\n          return vector.getKey(idx) === key;\n        };\n      }\n    } else {\n      return (idx, cols) => col_func(idx, cols) == lit.v;\n    }\n  }\n  _bindLitCol(batch, lit, col) {\n    // Equals is commutative\n    return this._bindColLit(batch, col, lit);\n  }\n}\n/** @ignore */\nexport class LTeq extends ComparisonPredicate {\n  _bindLitLit(_batch, left, right) {\n    const rtrn = left.v <= right.v;\n    return () => rtrn;\n  }\n  _bindColCol(batch, left, right) {\n    const left_func = left.bind(batch);\n    const right_func = right.bind(batch);\n    return (idx, cols) => left_func(idx, cols) <= right_func(idx, cols);\n  }\n  _bindColLit(batch, col, lit) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => col_func(idx, cols) <= lit.v;\n  }\n  _bindLitCol(batch, lit, col) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => lit.v <= col_func(idx, cols);\n  }\n}\n/** @ignore */\nexport class GTeq extends ComparisonPredicate {\n  _bindLitLit(_batch, left, right) {\n    const rtrn = left.v >= right.v;\n    return () => rtrn;\n  }\n  _bindColCol(batch, left, right) {\n    const left_func = left.bind(batch);\n    const right_func = right.bind(batch);\n    return (idx, cols) => left_func(idx, cols) >= right_func(idx, cols);\n  }\n  _bindColLit(batch, col, lit) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => col_func(idx, cols) >= lit.v;\n  }\n  _bindLitCol(batch, lit, col) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => lit.v >= col_func(idx, cols);\n  }\n}\n/** @ignore */\nexport class Not extends Predicate {\n  constructor(child) {\n    super();\n    this.child = child;\n  }\n  bind(batch) {\n    const func = this.child.bind(batch);\n    return (idx, batch) => !func(idx, batch);\n  }\n}\n/** @ignore */\nexport class CustomPredicate extends Predicate {\n  constructor(next, bind_) {\n    super();\n    this.next = next;\n    this.bind_ = bind_;\n  }\n  bind(batch) {\n    this.bind_(batch);\n    return this.next;\n  }\n}\nexport function lit(v) {\n  return new Literal(v);\n}\nexport function col(n) {\n  return new Col(n);\n}\nexport function and() {\n  for (var _len6 = arguments.length, p = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    p[_key6] = arguments[_key6];\n  }\n  return new And(...p);\n}\nexport function or() {\n  for (var _len7 = arguments.length, p = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    p[_key7] = arguments[_key7];\n  }\n  return new Or(...p);\n}\nexport function custom(next, bind) {\n  return new CustomPredicate(next, bind);\n}","map":{"version":3,"names":["DictionaryVector","Value","eq","other","Literal","Equals","le","LTeq","ge","GTeq","lt","Not","gt","ne","constructor","v","Col","name","bind","batch","colidx","fields","schema","idx","length","Error","concat","vec","vector","getChildAt","get","Predicate","and","_len","arguments","expr","Array","_key","And","or","_len2","_key2","Or","not","ComparisonPredicate","left","right","_bindLitLit","_bindLitCol","_bindColLit","_bindColCol","CombinationPredicate","_len3","children","_key3","prototype","Object","freeze","_len4","_key4","reduce","accum","p","bound","map","every","_len5","_key5","some","_batch","rtrn","left_func","right_func","col","lit","col_func","key","dictionary","lastDictionary","reverseLookup","lastKey","getKey","cols","child","func","CustomPredicate","next","bind_","n","_len6","_key6","_len7","_key7","custom"],"sources":["compute/predicate.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { RecordBatch } from '../recordbatch';\nimport { DictionaryVector } from '../vector/dictionary';\n\n/** @ignore */\nexport type ValueFunc<T> = (idx: number, cols: RecordBatch) => T | null;\n/** @ignore */\nexport type PredicateFunc = (idx: number, cols: RecordBatch) => boolean;\n\n/** @ignore */\nexport abstract class Value<T> {\n    eq(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new Equals(this, other);\n    }\n    le(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new LTeq(this, other);\n    }\n    ge(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new GTeq(this, other);\n    }\n    lt(other: Value<T> | T): Predicate {\n        return new Not(this.ge(other));\n    }\n    gt(other: Value<T> | T): Predicate {\n        return new Not(this.le(other));\n    }\n    ne(other: Value<T> | T): Predicate {\n        return new Not(this.eq(other));\n    }\n}\n\n/** @ignore */\nexport class Literal<T= any> extends Value<T> {\n    constructor(public v: T) { super(); }\n}\n\n/** @ignore */\nexport class Col<T= any> extends Value<T> {\n    // @ts-ignore\n    public vector: Vector;\n    // @ts-ignore\n    public colidx: number;\n\n    constructor(public name: string) { super(); }\n    bind(batch: RecordBatch): (idx: number, batch?: RecordBatch) => any {\n        if (!this.colidx) {\n            // Assume column index doesn't change between calls to bind\n            //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n            this.colidx = -1;\n            const fields = batch.schema.fields;\n            for (let idx = -1; ++idx < fields.length;) {\n                if (fields[idx].name === this.name) {\n                    this.colidx = idx;\n                    break;\n                }\n            }\n            if (this.colidx < 0) { throw new Error(`Failed to bind Col \"${this.name}\"`); }\n        }\n\n        const vec = this.vector = batch.getChildAt(this.colidx)!;\n        return (idx: number) => vec.get(idx);\n    }\n}\n\n/** @ignore */\nexport abstract class Predicate {\n    abstract bind(batch: RecordBatch): PredicateFunc;\n    and(...expr: Predicate[]): And { return new And(this, ...expr); }\n    or(...expr: Predicate[]): Or { return new Or(this, ...expr); }\n    not(): Predicate { return new Not(this); }\n}\n\n/** @ignore */\nexport abstract class ComparisonPredicate<T= any> extends Predicate {\n    constructor(public readonly left: Value<T>, public readonly right: Value<T>) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        if (this.left instanceof Literal) {\n            if (this.right instanceof Literal) {\n                return this._bindLitLit(batch, this.left, this.right);\n            } else { // right is a Col\n\n                return this._bindLitCol(batch, this.left, this.right as Col);\n            }\n        } else { // left is a Col\n            if (this.right instanceof Literal) {\n                return this._bindColLit(batch, this.left as Col, this.right);\n            } else { // right is a Col\n                return this._bindColCol(batch, this.left as Col, this.right as Col);\n            }\n        }\n    }\n\n    protected abstract _bindLitLit(batch: RecordBatch, left: Literal, right: Literal): PredicateFunc;\n    protected abstract _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc;\n    protected abstract _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc;\n    protected abstract _bindLitCol(batch: RecordBatch, lit: Literal, col: Col): PredicateFunc;\n}\n\n/** @ignore */\nexport abstract class CombinationPredicate extends Predicate {\n    readonly children: Predicate[];\n    constructor(...children: Predicate[]) {\n        super();\n        this.children = children;\n    }\n}\n// add children to prototype so it doesn't get mangled in es2015/umd\n(<any> CombinationPredicate.prototype).children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\nexport class And extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ands\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof And ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.every((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Or extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ors\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof Or ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.some((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Equals extends ComparisonPredicate {\n    // Helpers used to cache dictionary reverse lookups between calls to bind\n    private lastDictionary: Vector|undefined;\n    private lastKey: number|undefined;\n\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v == right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, batch: RecordBatch) => left_func(idx, batch) == right_func(idx, batch);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        if (col.vector instanceof DictionaryVector) {\n            let key: any;\n            const vector = col.vector as DictionaryVector;\n            if (vector.dictionary !== this.lastDictionary) {\n                key = vector.reverseLookup(lit.v);\n                this.lastDictionary = vector.dictionary;\n                this.lastKey = key;\n            } else {\n                key = this.lastKey;\n            }\n\n            if (key === -1) {\n                // the value doesn't exist in the dictionary - always return\n                // false\n                // TODO: special-case of PredicateFunc that encapsulates this\n                // \"always false\" behavior. That way filtering operations don't\n                // have to bother checking\n                return () => false;\n            } else {\n                return (idx: number) => {\n                    return vector.getKey(idx) === key;\n                };\n            }\n        } else {\n            return (idx: number, cols: RecordBatch) => col_func(idx, cols) == lit.v;\n        }\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        // Equals is commutative\n        return this._bindColLit(batch, col, lit);\n    }\n}\n\n/** @ignore */\nexport class LTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v <= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) <= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) <= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v <= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class GTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v >= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) >= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) >= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v >= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class Not extends Predicate {\n    constructor(public readonly child: Predicate) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        const func = this.child.bind(batch);\n        return (idx: number, batch: RecordBatch) => !func(idx, batch);\n    }\n}\n\n/** @ignore */\nexport class CustomPredicate extends Predicate {\n    constructor(private next: PredicateFunc, private bind_: (batch: RecordBatch) => void) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        this.bind_(batch);\n        return this.next;\n    }\n}\n\nexport function lit(v: any): Value<any> { return new Literal(v); }\nexport function col(n: string): Col<any> { return new Col(n); }\nexport function and(...p: Predicate[]): And { return new And(...p); }\nexport function or(...p: Predicate[]): Or { return new Or(...p); }\nexport function custom(next: PredicateFunc, bind: (batch: RecordBatch) => void) {\n    return new CustomPredicate(next, bind);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}