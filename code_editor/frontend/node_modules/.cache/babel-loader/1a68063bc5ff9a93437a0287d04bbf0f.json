{"ast":null,"code":"var _jsxFileName = \"/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/editor.tsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef } from \"react\";\nimport AceEditor from \"react-ace\";\nimport ace from \"ace-builds\";\nimport \"ace-builds/webpack-resolver\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/mode-javascript\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport \"ace-builds/src-noconflict/ext-searchbox\";\nimport \"ace-builds/src-noconflict/ext-prompt\";\nimport \"ace-builds/src-noconflict/ext-modelist\";\nimport \"ace-builds/src-noconflict/ext-keybinding_menu\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const Editor = ({\n  lang,\n  theme,\n  shortcuts,\n  props,\n  snippetString,\n  commands,\n  completions,\n  ghostText,\n  keybindingString,\n  editorRef,\n  code,\n  replaceCompleter,\n  onChange,\n  onSelectionChange,\n  onBlur\n}) => {\n  _s();\n  const preventGhostText = useRef(false);\n  if (editorRef.current) {\n    console.log(\"cursor @ useEffect\", editorRef.current.editor.getCursorPosition());\n    if (ghostText === \"\") {\n      // editorRef.current.editor.removeGhostText();\n    } else {\n      editorRef.current.editor.setGhostText(ghostText, editorRef.current.editor.getCursorPosition());\n    }\n  }\n  let commandsList = useRef(commands);\n  useEffect(() => {\n    if (editorRef.current) {\n      // Add/remove keybindings\n      ace.require('ace/autocomplete').Autocomplete.for(editorRef.current.editor);\n      const keybindings = JSON.parse(keybindingString);\n      if (keybindings.commands && keybindings.commands.length > 0) {\n        // const bindkeySelector = editorRef.current.editor.commands.platform as string;\n        keybindings.commands.forEach(binding => {\n          if (binding.name && typeof binding.name === \"string\") {\n            var _editorRef$current$ed;\n            if (JSON.stringify((_editorRef$current$ed = editorRef.current.editor.commands.commands[binding.name].bindKey) !== null && _editorRef$current$ed !== void 0 ? _editorRef$current$ed : \"\") !== JSON.stringify(binding.bindkey)) {\n              const newCommand = {\n                ...editorRef.current.editor.commands.commands[binding.name]\n              };\n              newCommand.bindKey = binding.bindkey;\n              editorRef.current.editor.commands.addCommand(newCommand);\n              commandsList.current = [...commandsList.current, newCommand];\n            }\n          }\n        });\n      }\n      if (keybindings.completer && keybindings.completer.length > 0) {\n        // const bindkeySelector = editorRef.current.editor.completer.keyboardHandler.platform as string;\n        keybindings.completer.forEach(binding => {\n          if (binding.name && typeof binding.name === \"string\") {\n            var _editorRef$current$ed2;\n            if (JSON.stringify((_editorRef$current$ed2 = editorRef.current.editor.completer.keyboardHandler.commands[binding.name].bindKey) !== null && _editorRef$current$ed2 !== void 0 ? _editorRef$current$ed2 : \"\") !== JSON.stringify(binding.bindkey)) {\n              const newCommand = {\n                ...editorRef.current.editor.completer.keyboardHandler.commands[binding.name]\n              };\n              newCommand.bindKey = binding.bindkey;\n              editorRef.current.editor.completer.keyboardHandler.addCommand(newCommand);\n            }\n          }\n        });\n      }\n\n      // Add/remove snippets\n      ace.require(\"ace/ext/keybinding_menu\").init(editorRef.current.editor);\n      const snippetManager = ace.require('ace/snippets').snippetManager;\n      const snippets = JSON.parse(snippetString);\n      for (const [snippetsLang, snippetsAddRemove] of Object.entries(snippets)) {\n        if (snippetsAddRemove[0]) snippetManager.register(snippetManager.parseSnippetFile(snippetsAddRemove[0], snippetsLang), snippetsLang);\n        if (snippetsAddRemove[1]) snippetManager.unregister(snippetManager.parseSnippetFile(snippetsAddRemove[1], snippetsLang), snippetsLang);\n      }\n\n      // Add completions\n      if (completions.length > 0) {\n        const customCompleter = {\n          getCompletions: (editor, session, pos, prefix, callback) => {\n            callback(null, completions);\n          }\n        };\n        if (replaceCompleter) {\n          editorRef.current.editor.completers.pop();\n        }\n        ace.require(\"ace/ext/language_tools\").addCompleter(customCompleter);\n      }\n    }\n  }, [snippetString, keybindingString]);\n\n  // useEffect(() => {\n  //   if(editorRef.current){\n  //     console.log(\"cursor @ useEffect\", editorRef.current.editor.getCursorPosition());\n  //     if (ghostText === \"\") {\n  //       // editorRef.current.editor.removeGhostText();\n  //     }\n  //     else if (!preventGhostText.current) {\n  //       editorRef.current.editor.setGhostText(ghostText, undefined);\n  //       // // Can also use editorRef.current.editor.addGhostText();\n  //       // // However, adding ghost text directly using the editor skips important \n  //       // // checks for config flags that could disable ghost text.\n  //       // const aceInline = ace.require(\"ace/autocomplete/inline\").AceInline;\n  //       // const inline = new aceInline();\n  //       // const testCompletion: ace.Ace.Completion = {\n  //       //   snippet: ghostText,\n  //       // }\n  //       // const result = inline.show(editorRef.current.editor, testCompletion, \"\");\n  //       // !result && inline.hide() && console.log(\"failed to show ghost text\");\n  //     }\n  //   }\n  // }, [ghostText, editorRef]);\n\n  return /*#__PURE__*/_jsxDEV(AceEditor, {\n    ref: editorRef,\n    name: \"REACT_ACE_EDITOR\",\n    mode: lang,\n    theme: theme,\n    value: code,\n    keyboardHandler: shortcuts,\n    commands: commandsList.current,\n    onChange: onChange,\n    onSelectionChange: onSelectionChange,\n    onBlur: onBlur,\n    onCursorChange: (value, event) => {},\n    onInput: event => {\n      // if (editorRef.current) {\n      //   editorRef.current.editor.removeGhostText();\n      // }\n      // preventGhostText.current = true;\n    },\n    ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 149,\n    columnNumber: 11\n  }, this);\n};\n_s(Editor, \"RBhB/4uXHFJDZs3t8gioyAOcjcw=\");\n_c = Editor;\nvar _c;\n$RefreshReg$(_c, \"Editor\");","map":{"version":3,"names":["useEffect","useRef","AceEditor","ace","jsxDEV","_jsxDEV","Editor","lang","theme","shortcuts","props","snippetString","commands","completions","ghostText","keybindingString","editorRef","code","replaceCompleter","onChange","onSelectionChange","onBlur","_s","preventGhostText","current","console","log","editor","getCursorPosition","setGhostText","commandsList","require","Autocomplete","for","keybindings","JSON","parse","length","forEach","binding","name","_editorRef$current$ed","stringify","bindKey","bindkey","newCommand","addCommand","completer","_editorRef$current$ed2","keyboardHandler","init","snippetManager","snippets","snippetsLang","snippetsAddRemove","Object","entries","register","parseSnippetFile","unregister","customCompleter","getCompletions","session","pos","prefix","callback","completers","pop","addCompleter","ref","mode","value","onCursorChange","event","onInput","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/editor.tsx"],"sourcesContent":["import { useEffect, useRef} from \"react\"\nimport AceEditor from \"react-ace\";\nimport ace from \"ace-builds\";\n\nimport \"ace-builds/webpack-resolver\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/mode-javascript\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport \"ace-builds/src-noconflict/ext-searchbox\";\nimport \"ace-builds/src-noconflict/ext-prompt\";\nimport \"ace-builds/src-noconflict/ext-modelist\";\nimport \"ace-builds/src-noconflict/ext-keybinding_menu\";\n\nexport interface KeyBinding {\n    bindkey: string | object,\n    name: string\n}\n\nexport interface EditorKeyBindings {\n  commands?: KeyBinding[],\n  completer?: KeyBinding[]\n}\n\nexport type EditorProps = {\n    code: string,\n    lang: string,\n    theme: string,\n    shortcuts: string,\n    props: any,\n    editorRef: any,\n    snippetString: string,\n    ghostText: string,\n    commands: object[],\n    completions: object[],\n    keybindingString: string,\n    replaceCompleter: boolean,\n    onChange: (value: string, event?: any) => void,\n    onSelectionChange: (value: any, event?: any) => void,\n    onBlur: (event: any, editor?: any) => void\n  }\n  \nexport const Editor = ({ lang, theme, shortcuts, props, snippetString, commands, completions, ghostText, keybindingString, editorRef, code, replaceCompleter, onChange, onSelectionChange, onBlur }: EditorProps ) => {\n  \n  const preventGhostText = useRef<boolean>(false);\n\n  if(editorRef.current){\n    console.log(\"cursor @ useEffect\", editorRef.current.editor.getCursorPosition());\n    if (ghostText === \"\") {\n      // editorRef.current.editor.removeGhostText();\n    }\n    else {\n      editorRef.current.editor.setGhostText(ghostText, editorRef.current.editor.getCursorPosition());\n    }\n  }\n\n  let commandsList = useRef<object[]>(commands);\n  useEffect(() => {\n    if(editorRef.current){\n\n      // Add/remove keybindings\n      ace.require('ace/autocomplete').Autocomplete.for(editorRef.current.editor);\n      const keybindings = JSON.parse(keybindingString) as EditorKeyBindings;\n      if(keybindings.commands && keybindings.commands.length > 0){\n        // const bindkeySelector = editorRef.current.editor.commands.platform as string;\n        keybindings.commands.forEach((binding) => {\n            if(binding.name && typeof binding.name === \"string\"){\n              if (JSON.stringify(editorRef.current.editor.commands.commands[binding.name].bindKey ?? \"\") !== JSON.stringify(binding.bindkey)) {\n                const newCommand = {...editorRef.current.editor.commands.commands[binding.name]};\n                newCommand.bindKey = binding.bindkey;\n                editorRef.current.editor.commands.addCommand(newCommand);\n                commandsList.current= [...commandsList.current, newCommand];\n              }\n            }\n   \n        });\n      }\n      if(keybindings.completer && keybindings.completer.length > 0){\n        // const bindkeySelector = editorRef.current.editor.completer.keyboardHandler.platform as string;\n        keybindings.completer.forEach((binding) => {\n            if(binding.name && typeof binding.name === \"string\"){\n              if (JSON.stringify(editorRef.current.editor.completer.keyboardHandler.commands[binding.name].bindKey ?? \"\") !== JSON.stringify(binding.bindkey)) {\n                const newCommand = {...editorRef.current.editor.completer.keyboardHandler.commands[binding.name]};\n                newCommand.bindKey = binding.bindkey;\n                editorRef.current.editor.completer.keyboardHandler.addCommand(newCommand);\n              }\n            }\n        });\n      }\n\n      // Add/remove snippets\n      ace.require(\"ace/ext/keybinding_menu\").init(editorRef.current.editor);\n      const snippetManager = ace.require('ace/snippets').snippetManager;\n      const snippets = JSON.parse(snippetString) as object;\n      for (const [snippetsLang, snippetsAddRemove] of Object.entries(snippets)){\n        if(snippetsAddRemove[0])\n          snippetManager.register(snippetManager.parseSnippetFile(snippetsAddRemove[0], snippetsLang), snippetsLang)\n        \n        if(snippetsAddRemove[1])\n          snippetManager.unregister(snippetManager.parseSnippetFile(snippetsAddRemove[1], snippetsLang), snippetsLang)\n      }\n\n      // Add completions\n      if (completions.length > 0) {\n        const customCompleter = {\n          getCompletions: (\n              editor: ace.Ace.Editor,\n              session: ace.Ace.EditSession,\n              pos: ace.Ace.Point,\n              prefix: string,\n              callback: ace.Ace.CompleterCallback\n          ): void => {\n              callback(\n                  null,\n                  (completions as ace.Ace.Completion[])\n              );\n            },\n          };\n        if(replaceCompleter) {\n          editorRef.current.editor.completers.pop();\n        }\n        ace.require(\"ace/ext/language_tools\").addCompleter(customCompleter);\n      }\n    }\n  }, [snippetString, keybindingString]);\n\n  // useEffect(() => {\n  //   if(editorRef.current){\n  //     console.log(\"cursor @ useEffect\", editorRef.current.editor.getCursorPosition());\n  //     if (ghostText === \"\") {\n  //       // editorRef.current.editor.removeGhostText();\n  //     }\n  //     else if (!preventGhostText.current) {\n  //       editorRef.current.editor.setGhostText(ghostText, undefined);\n  //       // // Can also use editorRef.current.editor.addGhostText();\n  //       // // However, adding ghost text directly using the editor skips important \n  //       // // checks for config flags that could disable ghost text.\n  //       // const aceInline = ace.require(\"ace/autocomplete/inline\").AceInline;\n  //       // const inline = new aceInline();\n  //       // const testCompletion: ace.Ace.Completion = {\n  //       //   snippet: ghostText,\n  //       // }\n  //       // const result = inline.show(editorRef.current.editor, testCompletion, \"\");\n  //       // !result && inline.hide() && console.log(\"failed to show ghost text\");\n  //     }\n  //   }\n  // }, [ghostText, editorRef]);\n\n  return (\n          <AceEditor\n           ref={editorRef}\n           name=\"REACT_ACE_EDITOR\"\n           mode={lang}\n           theme={theme}\n           value={code}\n           keyboardHandler={shortcuts}\n           commands={commandsList.current}\n           onChange={onChange}\n           onSelectionChange={onSelectionChange}\n           onBlur={onBlur}\n           onCursorChange={(value, event) => {\n              \n           }}\n           onInput={(event) => {\n              // if (editorRef.current) {\n              //   editorRef.current.editor.removeGhostText();\n              // }\n              // preventGhostText.current = true;\n           }}\n           {...props}/>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}