{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DataType } from './type';\nimport { selectArgs } from './util/args';\nimport { selectFieldArgs } from './util/args';\nimport { instance as comparer } from './visitor/typecomparator';\nexport class Schema {\n  constructor() {\n    let fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let metadata = arguments.length > 1 ? arguments[1] : undefined;\n    let dictionaries = arguments.length > 2 ? arguments[2] : undefined;\n    this.fields = fields || [];\n    this.metadata = metadata || new Map();\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n    this.dictionaries = dictionaries;\n  }\n  /** @nocollapse */\n  static from() {\n    return Schema.new(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]);\n  }\n  /** @nocollapse */\n  static new() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new Schema(selectFieldArgs(args)[0]);\n  }\n  get [Symbol.toStringTag]() {\n    return 'Schema';\n  }\n  toString() {\n    return \"Schema<{ \".concat(this.fields.map((f, i) => \"\".concat(i, \": \").concat(f)).join(', '), \" }>\");\n  }\n  compareTo(other) {\n    return comparer.compareSchemas(this, other);\n  }\n  select() {\n    for (var _len2 = arguments.length, columnNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      columnNames[_key2] = arguments[_key2];\n    }\n    const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\n    return new Schema(this.fields.filter(f => names[f.name]), this.metadata);\n  }\n  selectAt() {\n    for (var _len3 = arguments.length, columnIndices = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      columnIndices[_key3] = arguments[_key3];\n    }\n    return new Schema(columnIndices.map(i => this.fields[i]).filter(Boolean), this.metadata);\n  }\n  assign() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    const other = args[0] instanceof Schema ? args[0] : new Schema(selectArgs(Field, args));\n    const curFields = [...this.fields];\n    const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n    const newFields = other.fields.filter(f2 => {\n      const i = curFields.findIndex(f => f.name === f2.name);\n      return ~i ? (curFields[i] = f2.clone({\n        metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n      })) && false : true;\n    });\n    const newDictionaries = generateDictionaryMap(newFields, new Map());\n    return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n  }\n}\nexport class Field {\n  constructor(name, type) {\n    let nullable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let metadata = arguments.length > 3 ? arguments[3] : undefined;\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata || new Map();\n  }\n  /** @nocollapse */\n  static new() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    let [name, type, nullable, metadata] = args;\n    if (args[0] && typeof args[0] === 'object') {\n      ({\n        name\n      } = args[0]);\n      type === undefined && (type = args[0].type);\n      nullable === undefined && (nullable = args[0].nullable);\n      metadata === undefined && (metadata = args[0].metadata);\n    }\n    return new Field(\"\".concat(name), type, nullable, metadata);\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Field';\n  }\n  toString() {\n    return \"\".concat(this.name, \": \").concat(this.type);\n  }\n  compareTo(other) {\n    return comparer.compareField(this, other);\n  }\n  clone() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    let [name, type, nullable, metadata] = args;\n    !args[0] || typeof args[0] !== 'object' ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : ({\n      name = this.name,\n      type = this.type,\n      nullable = this.nullable,\n      metadata = this.metadata\n    } = args[0]);\n    return Field.new(name, type, nullable, metadata);\n  }\n}\n/** @ignore */\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n/** @ignore */\nfunction generateDictionaryMap(fields) {\n  let dictionaries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n  for (let i = -1, n = fields.length; ++i < n;) {\n    const field = fields[i];\n    const type = field.type;\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        dictionaries.set(type.id, type.dictionary);\n      } else if (dictionaries.get(type.id) !== type.dictionary) {\n        throw new Error(\"Cannot create Schema containing two different dictionaries with the same Id\");\n      }\n    }\n    if (type.children && type.children.length > 0) {\n      generateDictionaryMap(type.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nSchema.prototype.fields = null;\nSchema.prototype.metadata = null;\nSchema.prototype.dictionaries = null;\nField.prototype.type = null;\nField.prototype.name = null;\nField.prototype.nullable = null;\nField.prototype.metadata = null;","map":{"version":3,"names":["DataType","selectArgs","selectFieldArgs","instance","comparer","Schema","constructor","fields","arguments","length","undefined","metadata","dictionaries","Map","generateDictionaryMap","from","new","_len","args","Array","_key","Symbol","toStringTag","toString","concat","map","f","i","join","compareTo","other","compareSchemas","select","_len2","columnNames","_key2","names","reduce","xs","x","Object","create","filter","name","selectAt","_len3","columnIndices","_key3","Boolean","assign","_len4","_key4","Field","curFields","mergeMaps","newFields","f2","findIndex","clone","newDictionaries","type","nullable","_len5","_key5","typeId","compareField","_len6","_key6","m1","m2","n","field","isDictionary","has","id","set","dictionary","get","Error","children","prototype"],"sources":["schema.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Vector } from './vector';\nimport { DataType } from './type';\nimport { selectArgs } from './util/args';\nimport { selectFieldArgs } from './util/args';\nimport { instance as comparer } from './visitor/typecomparator';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = T[keyof T][] | Data<T[keyof T]>[] | Vector<T[keyof T]>[];\n\nexport class Schema<T extends { [key: string]: DataType } = any> {\n\n    public static from<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\n    public static from<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\n    public static from<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\n    /** @nocollapse */\n    public static from(...args: any[]) {\n        return Schema.new(args[0], args[1]);\n    }\n\n    public static new<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\n    public static new<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\n    /** @nocollapse */\n    public static new(...args: any[]) {\n        return new Schema(selectFieldArgs(args)[0]);\n    }\n\n    public readonly fields: Field<T[keyof T]>[];\n    public readonly metadata: Map<string, string>;\n    public readonly dictionaries: Map<number, DataType>;\n\n    constructor(fields: Field[] = [],\n                metadata?: Map<string, string> | null,\n                dictionaries?: Map<number, DataType> | null) {\n        this.fields = (fields || []) as Field<T[keyof T]>[];\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(fields);\n        }\n        this.dictionaries = dictionaries;\n    }\n    public get [Symbol.toStringTag]() { return 'Schema'; }\n    public toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n\n    public compareTo(other?: Schema | null): other is Schema<T> {\n        return comparer.compareSchemas(this, other);\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\n        return new Schema<{ [P in K]: T[P] }>(this.fields.filter((f) => names[f.name]), this.metadata);\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        return new Schema<{ [key: string]: K }>(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);\n    }\n\n    public assign<R extends { [key: string]: DataType } = any>(schema: Schema<R>): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...fields: (Field<R[keyof R]> | Field<R[keyof R]>[])[]): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...args: (Schema<R> | Field<R[keyof R]> | Field<R[keyof R]>[])[]) {\n\n        const other = args[0] instanceof Schema ? args[0] as Schema<R>\n            : new Schema<R>(selectArgs<Field<R[keyof R]>>(Field, args));\n\n        const curFields = [...this.fields] as Field[];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        }) as Field[];\n\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n\n        return new Schema<T & R>(\n            [...curFields, ...newFields], metadata,\n            new Map([...this.dictionaries, ...newDictionaries])\n        );\n    }\n}\n\nexport class Field<T extends DataType = any> {\n\n    public static new<T extends DataType = any>(props: { name: string | number, type: T, nullable?: boolean, metadata?: Map<string, string> | null }): Field<T>;\n    public static new<T extends DataType = any>(name: string | number | Field<T>, type: T, nullable?: boolean, metadata?: Map<string, string> | null): Field<T>;\n    /** @nocollapse */\n    public static new<T extends DataType = any>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field<T>(`${name}`, type, nullable, metadata);\n    }\n\n    public readonly type: T;\n    public readonly name: string;\n    public readonly nullable: boolean;\n    public readonly metadata: Map<string, string>;\n\n    constructor(name: string, type: T, nullable = false, metadata?: Map<string, string> | null) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n\n    public get typeId() { return this.type.typeId; }\n    public get [Symbol.toStringTag]() { return 'Field'; }\n    public toString() { return `${this.name}: ${this.type}`; }\n    public compareTo(other?: Field | null): other is Field<T> {\n        return comparer.compareField(this, other);\n    }\n    public clone<R extends DataType = T>(props: { name?: string | number, type?: R, nullable?: boolean, metadata?: Map<string, string> | null }): Field<R>;\n    public clone<R extends DataType = T>(name?: string | number | Field<T>, type?: R, nullable?: boolean, metadata?: Map<string, string> | null): Field<R>;\n    public clone<R extends DataType = T>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata} = args[0]);\n        return Field.new<R>(name, type, nullable, metadata);\n    }\n}\n\n/** @ignore */\nfunction mergeMaps<TKey, TVal>(m1?: Map<TKey, TVal> | null, m2?: Map<TKey, TVal> | null): Map<TKey, TVal> {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n\n/** @ignore */\nfunction generateDictionaryMap(fields: Field[], dictionaries = new Map<number, DataType>()): Map<number, DataType> {\n\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            } else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n\n    return dictionaries;\n}\n\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n(Schema.prototype as any).fields = null;\n(Schema.prototype as any).metadata = null;\n(Schema.prototype as any).dictionaries = null;\n\n(Field.prototype as any).type = null;\n(Field.prototype as any).name = null;\n(Field.prototype as any).nullable = null;\n(Field.prototype as any).metadata = null;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SAASA,QAAQ,QAAQ,QAAQ;AACjC,SAASC,UAAU,QAAQ,aAAa;AACxC,SAASC,eAAe,QAAQ,aAAa;AAC7C,SAASC,QAAQ,IAAIC,QAAQ,QAAQ,0BAA0B;AAM/D,OAAM,MAAOC,MAAM;EAsBfC,YAAA,EAEuD;IAAA,IAF3CC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAkB,EAAE;IAAA,IACpBG,QAAqC,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IACrCE,YAA2C,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACnD,IAAI,CAACH,MAAM,GAAIA,MAAM,IAAI,EAA0B;IACnD,IAAI,CAACI,QAAQ,GAAGA,QAAQ,IAAI,IAAIE,GAAG,EAAE;IACrC,IAAI,CAACD,YAAY,EAAE;MACfA,YAAY,GAAGE,qBAAqB,CAACP,MAAM,CAAC;;IAEhD,IAAI,CAACK,YAAY,GAAGA,YAAY;EACpC;EA1BA;EACO,OAAOG,IAAIA,CAAA,EAAe;IAC7B,OAAOV,MAAM,CAACW,GAAG,CAAAR,SAAA,CAAAC,MAAA,QAAAC,SAAA,GAAAF,SAAA,KAAAA,SAAA,CAAAC,MAAA,QAAAC,SAAA,GAAAF,SAAA,GAAiB,CAAC;EACvC;EAKA;EACO,OAAOQ,GAAGA,CAAA,EAAe;IAAA,SAAAC,IAAA,GAAAT,SAAA,CAAAC,MAAA,EAAXS,IAAW,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAAXF,IAAW,CAAAE,IAAA,IAAAZ,SAAA,CAAAY,IAAA;IAAA;IAC5B,OAAO,IAAIf,MAAM,CAACH,eAAe,CAACgB,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAC/C;EAgBA,KAAYG,MAAM,CAACC,WAAW,IAAC;IAAK,OAAO,QAAQ;EAAE;EAC9CC,QAAQA,CAAA;IACX,mBAAAC,MAAA,CAAmB,IAAI,CAACjB,MAAM,CAACkB,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,QAAAH,MAAA,CAAQG,CAAC,QAAAH,MAAA,CAAKE,CAAC,CAAE,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC;EACzE;EAEOC,SAASA,CAACC,KAAqB;IAClC,OAAO1B,QAAQ,CAAC2B,cAAc,CAAC,IAAI,EAAED,KAAK,CAAC;EAC/C;EAEOE,MAAMA,CAAA,EAA6C;IAAA,SAAAC,KAAA,GAAAzB,SAAA,CAAAC,MAAA,EAAhByB,WAAgB,OAAAf,KAAA,CAAAc,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;MAAhBD,WAAgB,CAAAC,KAAA,IAAA3B,SAAA,CAAA2B,KAAA;IAAA;IACtD,MAAMC,KAAK,GAAGF,WAAW,CAACG,MAAM,CAAC,CAACC,EAAE,EAAEC,CAAC,KAAK,CAACD,EAAE,CAACC,CAAC,CAAC,GAAG,IAAI,KAAKD,EAAE,EAAEE,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,CAAC;IACtF,OAAO,IAAIpC,MAAM,CAAqB,IAAI,CAACE,MAAM,CAACmC,MAAM,CAAEhB,CAAC,IAAKU,KAAK,CAACV,CAAC,CAACiB,IAAI,CAAC,CAAC,EAAE,IAAI,CAAChC,QAAQ,CAAC;EAClG;EACOiC,QAAQA,CAAA,EAAuD;IAAA,SAAAC,KAAA,GAAArC,SAAA,CAAAC,MAAA,EAAvBqC,aAAuB,OAAA3B,KAAA,CAAA0B,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;MAAvBD,aAAuB,CAAAC,KAAA,IAAAvC,SAAA,CAAAuC,KAAA;IAAA;IAClE,OAAO,IAAI1C,MAAM,CAAuByC,aAAa,CAACrB,GAAG,CAAEE,CAAC,IAAK,IAAI,CAACpB,MAAM,CAACoB,CAAC,CAAC,CAAC,CAACe,MAAM,CAACM,OAAO,CAAC,EAAE,IAAI,CAACrC,QAAQ,CAAC;EACpH;EAIOsC,MAAMA,CAAA,EAA8G;IAAA,SAAAC,KAAA,GAAA1C,SAAA,CAAAC,MAAA,EAA7DS,IAA6D,OAAAC,KAAA,CAAA+B,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAA7DjC,IAA6D,CAAAiC,KAAA,IAAA3C,SAAA,CAAA2C,KAAA;IAAA;IAEvH,MAAMrB,KAAK,GAAGZ,IAAI,CAAC,CAAC,CAAC,YAAYb,MAAM,GAAGa,IAAI,CAAC,CAAC,CAAc,GACxD,IAAIb,MAAM,CAAIJ,UAAU,CAAoBmD,KAAK,EAAElC,IAAI,CAAC,CAAC;IAE/D,MAAMmC,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC9C,MAAM,CAAY;IAC7C,MAAMI,QAAQ,GAAG2C,SAAS,CAACA,SAAS,CAAC,IAAIzC,GAAG,EAAE,EAAE,IAAI,CAACF,QAAQ,CAAC,EAAEmB,KAAK,CAACnB,QAAQ,CAAC;IAC/E,MAAM4C,SAAS,GAAGzB,KAAK,CAACvB,MAAM,CAACmC,MAAM,CAAEc,EAAE,IAAI;MACzC,MAAM7B,CAAC,GAAG0B,SAAS,CAACI,SAAS,CAAE/B,CAAC,IAAKA,CAAC,CAACiB,IAAI,KAAKa,EAAE,CAACb,IAAI,CAAC;MACxD,OAAO,CAAChB,CAAC,GAAG,CAAC0B,SAAS,CAAC1B,CAAC,CAAC,GAAG6B,EAAE,CAACE,KAAK,CAAC;QACjC/C,QAAQ,EAAE2C,SAAS,CAACA,SAAS,CAAC,IAAIzC,GAAG,EAAE,EAAEwC,SAAS,CAAC1B,CAAC,CAAC,CAAChB,QAAQ,CAAC,EAAE6C,EAAE,CAAC7C,QAAQ;OAC/E,CAAC,KAAK,KAAK,GAAG,IAAI;IACvB,CAAC,CAAY;IAEb,MAAMgD,eAAe,GAAG7C,qBAAqB,CAACyC,SAAS,EAAE,IAAI1C,GAAG,EAAE,CAAC;IAEnE,OAAO,IAAIR,MAAM,CACb,CAAC,GAAGgD,SAAS,EAAE,GAAGE,SAAS,CAAC,EAAE5C,QAAQ,EACtC,IAAIE,GAAG,CAAC,CAAC,GAAG,IAAI,CAACD,YAAY,EAAE,GAAG+C,eAAe,CAAC,CAAC,CACtD;EACL;;AAGJ,OAAM,MAAOP,KAAK;EAqBd9C,YAAYqC,IAAY,EAAEiB,IAAO,EAAyD;IAAA,IAAvDC,QAAQ,GAAArD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IAAA,IAAEG,QAAqC,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACtF,IAAI,CAACiC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAClD,QAAQ,GAAGA,QAAQ,IAAI,IAAIE,GAAG,EAAE;EACzC;EAtBA;EACO,OAAOG,GAAGA,CAAA,EAAyC;IAAA,SAAA8C,KAAA,GAAAtD,SAAA,CAAAC,MAAA,EAAXS,IAAW,OAAAC,KAAA,CAAA2C,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAX7C,IAAW,CAAA6C,KAAA,IAAAvD,SAAA,CAAAuD,KAAA;IAAA;IACtD,IAAI,CAACpB,IAAI,EAAEiB,IAAI,EAAEC,QAAQ,EAAElD,QAAQ,CAAC,GAAGO,IAAI;IAC3C,IAAIA,IAAI,CAAC,CAAC,CAAC,IAAI,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACxC,CAAC;QAAEyB;MAAI,CAAE,GAAGzB,IAAI,CAAC,CAAC,CAAC;MAClB0C,IAAI,KAAKlD,SAAS,KAAMkD,IAAI,GAAG1C,IAAI,CAAC,CAAC,CAAC,CAAC0C,IAAI,CAAC;MAC5CC,QAAQ,KAAKnD,SAAS,KAAMmD,QAAQ,GAAG3C,IAAI,CAAC,CAAC,CAAC,CAAC2C,QAAQ,CAAC;MACxDlD,QAAQ,KAAKD,SAAS,KAAMC,QAAQ,GAAGO,IAAI,CAAC,CAAC,CAAC,CAACP,QAAQ,CAAC;;IAE7D,OAAO,IAAIyC,KAAK,IAAA5B,MAAA,CAAOmB,IAAI,GAAIiB,IAAI,EAAEC,QAAQ,EAAElD,QAAQ,CAAC;EAC5D;EAcA,IAAWqD,MAAMA,CAAA;IAAK,OAAO,IAAI,CAACJ,IAAI,CAACI,MAAM;EAAE;EAC/C,KAAY3C,MAAM,CAACC,WAAW,IAAC;IAAK,OAAO,OAAO;EAAE;EAC7CC,QAAQA,CAAA;IAAK,UAAAC,MAAA,CAAU,IAAI,CAACmB,IAAI,QAAAnB,MAAA,CAAK,IAAI,CAACoC,IAAI;EAAI;EAClD/B,SAASA,CAACC,KAAoB;IACjC,OAAO1B,QAAQ,CAAC6D,YAAY,CAAC,IAAI,EAAEnC,KAAK,CAAC;EAC7C;EAGO4B,KAAKA,CAAA,EAAuC;IAAA,SAAAQ,KAAA,GAAA1D,SAAA,CAAAC,MAAA,EAAXS,IAAW,OAAAC,KAAA,CAAA+C,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAXjD,IAAW,CAAAiD,KAAA,IAAA3D,SAAA,CAAA2D,KAAA;IAAA;IAC/C,IAAI,CAACxB,IAAI,EAAEiB,IAAI,EAAEC,QAAQ,EAAElD,QAAQ,CAAC,GAAGO,IAAI;IAC1C,CAACA,IAAI,CAAC,CAAC,CAAC,IAAI,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,GACjC,CAACyB,IAAI,GAAG,IAAI,CAACA,IAAI,EAAEiB,IAAI,GAAG,IAAI,CAACA,IAAI,EAAEC,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAElD,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,GAAGO,IAAI,IAC/F;MAACyB,IAAI,GAAG,IAAI,CAACA,IAAI;MAAEiB,IAAI,GAAG,IAAI,CAACA,IAAI;MAAEC,QAAQ,GAAG,IAAI,CAACA,QAAQ;MAAElD,QAAQ,GAAG,IAAI,CAACA;IAAQ,CAAC,GAAGO,IAAI,CAAC,CAAC,CAAC,CAAC;IAC1G,OAAOkC,KAAK,CAACpC,GAAG,CAAI2B,IAAI,EAAEiB,IAAI,EAAEC,QAAQ,EAAElD,QAAQ,CAAC;EACvD;;AAGJ;AACA,SAAS2C,SAASA,CAAac,EAA2B,EAAEC,EAA2B;EACnF,OAAO,IAAIxD,GAAG,CAAC,CAAC,IAAIuD,EAAE,IAAI,IAAIvD,GAAG,EAAE,CAAC,EAAE,IAAIwD,EAAE,IAAI,IAAIxD,GAAG,EAAE,CAAC,CAAC,CAAC;AAChE;AAEA;AACA,SAASC,qBAAqBA,CAACP,MAAe,EAA4C;EAAA,IAA1CK,YAAA,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAe,IAAIK,GAAG,EAAoB;EAEtF,KAAK,IAAIc,CAAC,GAAG,CAAC,CAAC,EAAE2C,CAAC,GAAG/D,MAAM,CAACE,MAAM,EAAE,EAAEkB,CAAC,GAAG2C,CAAC,GAAG;IAC1C,MAAMC,KAAK,GAAGhE,MAAM,CAACoB,CAAC,CAAC;IACvB,MAAMiC,IAAI,GAAGW,KAAK,CAACX,IAAI;IACvB,IAAI5D,QAAQ,CAACwE,YAAY,CAACZ,IAAI,CAAC,EAAE;MAC7B,IAAI,CAAChD,YAAY,CAAC6D,GAAG,CAACb,IAAI,CAACc,EAAE,CAAC,EAAE;QAC5B9D,YAAY,CAAC+D,GAAG,CAACf,IAAI,CAACc,EAAE,EAAEd,IAAI,CAACgB,UAAU,CAAC;OAC7C,MAAM,IAAIhE,YAAY,CAACiE,GAAG,CAACjB,IAAI,CAACc,EAAE,CAAC,KAAKd,IAAI,CAACgB,UAAU,EAAE;QACtD,MAAM,IAAIE,KAAK,8EAA8E,CAAC;;;IAGtG,IAAIlB,IAAI,CAACmB,QAAQ,IAAInB,IAAI,CAACmB,QAAQ,CAACtE,MAAM,GAAG,CAAC,EAAE;MAC3CK,qBAAqB,CAAC8C,IAAI,CAACmB,QAAQ,EAAEnE,YAAY,CAAC;;;EAI1D,OAAOA,YAAY;AACvB;AAEA;AACA;AACCP,MAAM,CAAC2E,SAAiB,CAACzE,MAAM,GAAG,IAAI;AACtCF,MAAM,CAAC2E,SAAiB,CAACrE,QAAQ,GAAG,IAAI;AACxCN,MAAM,CAAC2E,SAAiB,CAACpE,YAAY,GAAG,IAAI;AAE5CwC,KAAK,CAAC4B,SAAiB,CAACpB,IAAI,GAAG,IAAI;AACnCR,KAAK,CAAC4B,SAAiB,CAACrC,IAAI,GAAG,IAAI;AACnCS,KAAK,CAAC4B,SAAiB,CAACnB,QAAQ,GAAG,IAAI;AACvCT,KAAK,CAAC4B,SAAiB,CAACrE,QAAQ,GAAG,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module"}