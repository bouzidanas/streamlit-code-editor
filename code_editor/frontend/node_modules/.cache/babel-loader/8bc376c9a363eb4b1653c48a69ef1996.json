{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport * as Schema_ from './fb/Schema';\nimport * as Message_ from './fb/Message';\nexport var ArrowType = Schema_.org.apache.arrow.flatbuf.Type;\nexport var DateUnit = Schema_.org.apache.arrow.flatbuf.DateUnit;\nexport var TimeUnit = Schema_.org.apache.arrow.flatbuf.TimeUnit;\nexport var Precision = Schema_.org.apache.arrow.flatbuf.Precision;\nexport var UnionMode = Schema_.org.apache.arrow.flatbuf.UnionMode;\nexport var IntervalUnit = Schema_.org.apache.arrow.flatbuf.IntervalUnit;\nexport var MessageHeader = Message_.org.apache.arrow.flatbuf.MessageHeader;\nexport var MetadataVersion = Schema_.org.apache.arrow.flatbuf.MetadataVersion;\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport var Type;\n(function (Type) {\n  /** The default placeholder type */\n  Type[Type[\"NONE\"] = 0] = \"NONE\";\n  /** A NULL type having no physical storage */\n  Type[Type[\"Null\"] = 1] = \"Null\";\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Type[Type[\"Int\"] = 2] = \"Int\";\n  /** 2, 4, or 8-byte floating point value */\n  Type[Type[\"Float\"] = 3] = \"Float\";\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Type[Type[\"Binary\"] = 4] = \"Binary\";\n  /** UTF8 variable-length string as List<Char> */\n  Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Type[Type[\"Bool\"] = 6] = \"Bool\";\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Type[Type[\"Date\"] = 8] = \"Date\";\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Type[Type[\"Time\"] = 9] = \"Time\";\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Type[Type[\"Interval\"] = 11] = \"Interval\";\n  /** A list of some logical data type */\n  Type[Type[\"List\"] = 12] = \"List\";\n  /** Struct of logical types */\n  Type[Type[\"Struct\"] = 13] = \"Struct\";\n  /** Union of logical types */\n  Type[Type[\"Union\"] = 14] = \"Union\";\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  /** Map of named logical types */\n  Type[Type[\"Map\"] = 17] = \"Map\";\n  /** Dictionary aka Category type */\n  Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n  Type[Type[\"Int8\"] = -2] = \"Int8\";\n  Type[Type[\"Int16\"] = -3] = \"Int16\";\n  Type[Type[\"Int32\"] = -4] = \"Int32\";\n  Type[Type[\"Int64\"] = -5] = \"Int64\";\n  Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n  Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n  Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n  Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n  Type[Type[\"Float16\"] = -10] = \"Float16\";\n  Type[Type[\"Float32\"] = -11] = \"Float32\";\n  Type[Type[\"Float64\"] = -12] = \"Float64\";\n  Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n  Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n  Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n  Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n  Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n  Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n  Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n  Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n  Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n  Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n  Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n  Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n  Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n  Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\nexport var BufferType;\n(function (BufferType) {\n  /**\n   * used in List type, Dense Union and variable length primitive types (String, Binary)\n   */\n  BufferType[BufferType[\"OFFSET\"] = 0] = \"OFFSET\";\n  /**\n   * actual data, either wixed width primitive types in slots or variable width delimited by an OFFSET vector\n   */\n  BufferType[BufferType[\"DATA\"] = 1] = \"DATA\";\n  /**\n   * Bit vector indicating if each value is null\n   */\n  BufferType[BufferType[\"VALIDITY\"] = 2] = \"VALIDITY\";\n  /**\n   * Type vector used in Union type\n   */\n  BufferType[BufferType[\"TYPE\"] = 3] = \"TYPE\";\n})(BufferType || (BufferType = {}));","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,OAAO,MAAM,aAAa;AACtC,OAAO,KAAKC,QAAQ,MAAM,cAAc;AAExC,OAAM,IAAQC,SAAS,GAAGF,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACC,IAAI;AAC/D,OAAM,IAAQC,QAAQ,GAAGR,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACE,QAAQ;AAClE,OAAM,IAAQC,QAAQ,GAAGT,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACG,QAAQ;AAClE,OAAM,IAAQC,SAAS,GAAGV,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACI,SAAS;AACpE,OAAM,IAAQC,SAAS,GAAGX,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACK,SAAS;AACpE,OAAM,IAAQC,YAAY,GAAGZ,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACM,YAAY;AAC1E,OAAM,IAAQC,aAAa,GAAGZ,QAAQ,CAACE,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACO,aAAa;AAC7E,OAAM,IAAQC,eAAe,GAAGd,OAAO,CAACG,GAAG,CAACC,MAAM,CAACC,KAAK,CAACC,OAAO,CAACQ,eAAe;AAEhF;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,WAAYP,IAiEX;AAjED,WAAYA,IAAI;EACZ;EACAA,+BAAoB;EACpB;EACAA,+BAAoB;EACpB;EACAA,6BAAoB;EACpB;EACAA,iCAAoB;EACpB;EACAA,mCAAoB;EACpB;EACAA,+BAAoB;EACpB;EACAA,+BAAoB;EACpB;EACAA,qCAAoB;EACpB;EACAA,+BAAoB;EACpB;EACAA,+BAAoB;EACpB;EACAA,0CAAoB;EACpB;EACAA,wCAAoB;EACpB;EACAA,gCAAoB;EACpB;EACAA,oCAAoB;EACpB;EACAA,kCAAoB;EACpB;EACAA,sDAAoB;EACpB;EACAA,kDAAoB;EACpB;EACAA,8BAAoB;EAEpB;EACAA,4CAA0B;EAC1BA,gCAA0B;EAC1BA,kCAA0B;EAC1BA,kCAA0B;EAC1BA,kCAA0B;EAC1BA,kCAA0B;EAC1BA,oCAA0B;EAC1BA,oCAA0B;EAC1BA,oCAA0B;EAC1BA,uCAA2B;EAC3BA,uCAA2B;EAC3BA,uCAA2B;EAC3BA,uCAA2B;EAC3BA,uDAA2B;EAC3BA,uDAA2B;EAC3BA,iEAA2B;EAC3BA,iEAA2B;EAC3BA,+DAA2B;EAC3BA,6CAA2B;EAC3BA,uDAA2B;EAC3BA,uDAA2B;EAC3BA,qDAA2B;EAC3BA,6CAA2B;EAC3BA,+CAA2B;EAC3BA,uDAA2B;EAC3BA,2DAA2B;AAC/B,CAAC,EAjEWA,IAAI,KAAJA,IAAI;AAmEhB,WAAYQ,UAoBT;AApBH,WAAYA,UAAU;EAClB;;;EAGAA,+CAAU;EAEV;;;EAGAA,2CAAQ;EAER;;;EAGAA,mDAAY;EAEZ;;;EAGAA,2CAAQ;AACV,CAAC,EApBSA,UAAU,KAAVA,UAAU","names":["Schema_","Message_","ArrowType","org","apache","arrow","flatbuf","Type","DateUnit","TimeUnit","Precision","UnionMode","IntervalUnit","MessageHeader","MetadataVersion","BufferType"],"sources":["enum.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport * as Schema_ from './fb/Schema';\nimport * as Message_ from './fb/Message';\n\nexport import ArrowType = Schema_.org.apache.arrow.flatbuf.Type;\nexport import DateUnit = Schema_.org.apache.arrow.flatbuf.DateUnit;\nexport import TimeUnit = Schema_.org.apache.arrow.flatbuf.TimeUnit;\nexport import Precision = Schema_.org.apache.arrow.flatbuf.Precision;\nexport import UnionMode = Schema_.org.apache.arrow.flatbuf.UnionMode;\nexport import IntervalUnit = Schema_.org.apache.arrow.flatbuf.IntervalUnit;\nexport import MessageHeader = Message_.org.apache.arrow.flatbuf.MessageHeader;\nexport import MetadataVersion = Schema_.org.apache.arrow.flatbuf.MetadataVersion;\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n    /** The default placeholder type */\n    NONE            =  0,\n    /** A NULL type having no physical storage */\n    Null            =  1,\n    /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n    Int             =  2,\n    /** 2, 4, or 8-byte floating point value */\n    Float           =  3,\n    /** Variable-length bytes (no guarantee of UTF8-ness) */\n    Binary          =  4,\n    /** UTF8 variable-length string as List<Char> */\n    Utf8            =  5,\n    /** Boolean as 1 bit, LSB bit-packed ordering */\n    Bool            =  6,\n    /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n    Decimal         =  7,\n    /** int32_t days or int64_t milliseconds since the UNIX epoch */\n    Date            =  8,\n    /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n    Time            =  9,\n    /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n    Timestamp       = 10,\n    /** YEAR_MONTH or DAY_TIME interval in SQL style */\n    Interval        = 11,\n    /** A list of some logical data type */\n    List            = 12,\n    /** Struct of logical types */\n    Struct          = 13,\n    /** Union of logical types */\n    Union           = 14,\n    /** Fixed-size binary. Each value occupies the same number of bytes */\n    FixedSizeBinary = 15,\n    /** Fixed-size list. Each value occupies the same number of bytes */\n    FixedSizeList   = 16,\n    /** Map of named logical types */\n    Map             = 17,\n\n    /** Dictionary aka Category type */\n    Dictionary            = -1,\n    Int8                  = -2,\n    Int16                 = -3,\n    Int32                 = -4,\n    Int64                 = -5,\n    Uint8                 = -6,\n    Uint16                = -7,\n    Uint32                = -8,\n    Uint64                = -9,\n    Float16               = -10,\n    Float32               = -11,\n    Float64               = -12,\n    DateDay               = -13,\n    DateMillisecond       = -14,\n    TimestampSecond       = -15,\n    TimestampMillisecond  = -16,\n    TimestampMicrosecond  = -17,\n    TimestampNanosecond   = -18,\n    TimeSecond            = -19,\n    TimeMillisecond       = -20,\n    TimeMicrosecond       = -21,\n    TimeNanosecond        = -22,\n    DenseUnion            = -23,\n    SparseUnion           = -24,\n    IntervalDayTime       = -25,\n    IntervalYearMonth     = -26,\n}\n\nexport enum BufferType {\n    /**\n     * used in List type, Dense Union and variable length primitive types (String, Binary)\n     */\n    OFFSET = 0,\n\n    /**\n     * actual data, either wixed width primitive types in slots or variable width delimited by an OFFSET vector\n     */\n    DATA = 1,\n\n    /**\n     * Bit vector indicating if each value is null\n     */\n    VALIDITY = 2,\n\n    /**\n     * Type vector used in Union type\n     */\n    TYPE = 3\n  }\n"]},"metadata":{},"sourceType":"module"}