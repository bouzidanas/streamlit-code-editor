[{"/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/index.tsx":"1","/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/CodeEditor.tsx":"2","/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/editor.tsx":"3","/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/button-menu.tsx":"4"},{"size":267,"mtime":1717163090216,"results":"5","hashOfConfig":"6"},{"size":29734,"mtime":1717164920475,"results":"7","hashOfConfig":"6"},{"size":6146,"mtime":1717164619975,"results":"8","hashOfConfig":"6"},{"size":7036,"mtime":1711206596223,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1mzrtdn",{"filePath":"12","messages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},{"filePath":"15","messages":"16","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17"},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/index.tsx",[],"/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/CodeEditor.tsx",["21","22","23","24","25","26","27"],"import {\n  Streamlit,\n  withStreamlitConnection,\n  ComponentProps,\n  Theme,\n} from \"streamlit-component-lib\"\nimport {v1} from 'uuid';\nimport styled, { createGlobalStyle } from \"styled-components/macro\"\nimport { useState, useRef, useEffect, useMemo } from \"react\"\nimport AceEditor from \"react-ace\";\nimport ace from \"ace-builds\";\nimport { Editor } from './editor';\nimport { Menu as ButtonMenu, Set as ButtonSet, customButton, buttonGroup, Info as InfoBar } from \"./button-menu\"\n\nimport \"ace-builds/webpack-resolver\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/mode-javascript\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport \"ace-builds/src-noconflict/ext-searchbox\";\nimport \"ace-builds/src-noconflict/ext-prompt\";\nimport \"ace-builds/src-noconflict/ext-modelist\";\n\ninterface CodeEditorProps extends ComponentProps {\n  args: any\n  width: number\n  disabled: boolean\n  theme?: Theme\n}\n\nconst defaultOptions = {\n  fontFamily: '\"Source Code Pro\", monospace',\n  cursorStyle: \"smooth\",\n  displayIndentGuides: false,\n  wrap: false,\n  highlightActiveLine: true,\n  showPrintMargin: false,\n  showLineNumbers: false,\n  foldStyle: \"markbegin\",\n  autoScrollEditorIntoView: false,\n  animatedScroll: true,\n  fadeFoldWidgets: true,\n}\n\nconst defaultEditorProps = {\n  editorProps: {\n    $blockScrolling: true\n  }\n}\n\nconst defaultProps = {\n  cursorStart: 1,\n  enableBasicAutocompletion: false,\n  enableLiveAutocompletion: true,\n  enableSnippets: true,\n  focus: false,\n  fontSize: 14,\n  highlightActiveLine: true,\n  navigateToFileEnd: true,\n  placeholder: null,\n  readOnly: false,\n  scrollMargin: [15, 15, 0, 0],\n  setOptions: defaultOptions,\n  showGutter: true,\n  showPrintMargin: false,\n  style: {},\n  tabSize: 4,\n  width: \"auto\",\n  debounceChangePeriod: 250,\n}\n\nconst GlobalCSS = createGlobalStyle<{isDisabled?: boolean, inject: string}>`\n  html {\n    opacity: ${props => props.isDisabled? \"0.5\": \"1\"};\n    cursor: ${props => props.isDisabled? \"not-allowed\": \"auto\"};\n    pointer-events: ${props => props.isDisabled? \"none\": \"auto\"};\n  }\n  ${props => props.inject}\n`\nconst StyledCodeEditor = styled.div`\n  width: 100%;\n  border-radius: 8px;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n  :hover button {\n    opacity: 1;\n    transform: scale(1);\n  }\n  button.always-on {\n    opacity: 1;\n    transform: scale(1);\n    transition: none;\n  }\n  :hover button svg {\n        opacity: 1;\n        transform: scale(1);\n  }\n  :hover button.with-icon span {\n    opacity: 1;\n    transform: scale(1);\n  }\n  button.always-on > span {\n    opacity: 1;\n    transform: scale(1);\n    transition: none;\n  }\n  button.always-on > svg {\n    opacity: 1;\n    transform: scale(1);\n    transition: none;\n  }\n  `;\n\nconst CodeEditor = ({ args, width, disabled, theme }: CodeEditorProps) => {\n\n  //sets code to the initial value every time the component is rendered\n  //to set the initial value once, use a function instead of a value.\n  const [code, setCode] = useState(args['code']);\n  // const [keybindingAddRemove, setKeybindingAddRemove] = useState([\"\",\"\"]);\n\n  const aceEditor = useRef<AceEditor>(null);\n  const infoTextRef = useRef<HTMLSpanElement>(null);\n  const baseSession = useRef<ace.Ace.EditSession | null>(null);\n  const keepFocus = useRef<boolean>(false);\n  const reset = useRef<boolean>(false);\n\n  var timeoutId: NodeJS.Timeout;\n\n  /**\n    * This function takes as input either a snippetText string that is expected\n    * to be already formatted like the text in a SnippetFile or a dictionary or \n    * and array of dictionaries. For the first case, it just returns the input.\n    * For the second and third case, a (SnippetFile format) string is constructed\n    * from the dict(s) and returned. Learn more about snippets {@link  here}\n    * @param snippetRaw snippets to be converted to a single snippetText string\n    * @returns {string} snippetText\n    */\n  const createSnippets = (snippetRaw: string | object | [object]): string => {\n    return (typeof snippetRaw === \"string\" ? snippetRaw : (Array.isArray(snippetRaw) ? snippetRaw : [snippetRaw]).map(({ name, code }) =>\n    ([\n      'snippet ' + name,\n      code.split('\\n')\n        .map((c: string) => '\\t' + c)\n        .join('\\n'),\n    ].join('\\n'))\n    ).join('\\n'))\n  }\n  const [snippetAddRemove, setSnippetAddRemove] = useState({[args['lang']] : [createSnippets(args[\"snippets\"][0]), createSnippets(args[\"snippets\"][1])]});\n  const [keybindingAddRemove, setKeybindingAddRemove] = useState(args['keybindings']);\n\n\n  useEffect(() => {\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    if(aceEditor.current && keepFocus.current){\n      aceEditor.current.editor.focus();\n      keepFocus.current = false;\n    }\n  }, [keepFocus.current]);\n\n  // To reasons for the useEffect here: \n  //   1. to set the focus on the editor only when the focus argument has changed to true.\n  //   2. to set the focus on the editor after rendering the component at which point, the \n  //      editor should be ready.\n  useEffect(() => {\n    if(aceEditor.current && args.focus){\n      aceEditor.current.editor.focus();\n    }\n  }, [args.focus]);\n\n  const onInputHandler = (event: any) => {\n    // const newText = aceEditor.current?.editor.getValue();\n    // newText && setCode(newText);\n  }\n\n  const onChangeHandler = (newCode: string) => {\n    const newText = aceEditor.current?.editor.getValue() ?? newCode\n    setCode(newText);\n\n    const responseMode = typeof args[\"response_mode\"] === \"string\" ? [args[\"response_mode\"]] : args[\"response_mode\"];\n    if (responseMode.includes(\"debounce\") && aceEditor.current && aceEditor.current.editor) {\n      const editor = aceEditor.current.editor as any;\n      const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n      Streamlit.setComponentValue({id: v1().slice(0,8), type: \"change\", lang: outgoingMode, text: newText, selected: editor.getSelectedText(), cursor: editor.getCursorPosition()});\n    }\n  }\n  \n  const onSelectionChangeHandler = (selectedText: any) => {\n    const responseMode = typeof args[\"response_mode\"] === \"string\" ? [args[\"response_mode\"]] : args[\"response_mode\"];\n    if (responseMode.includes(\"select\") && aceEditor.current && aceEditor.current.editor) {\n      const editor = aceEditor.current.editor as any;\n      const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n      Streamlit.setComponentValue({id: v1().slice(0,8), type: \"selection\", lang: outgoingMode, text: code, selected: editor.getSelectedText(), cursor: editor.getCursorPosition()});\n    }\n  }\n\n  const onEditorBlur = (event: any, editor: any) => {\n    const responseMode = typeof args[\"response_mode\"] === \"string\" ? [args[\"response_mode\"]] : args[\"response_mode\"];\n    if (responseMode.includes(\"blur\") && editor) {\n      const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n      setCode(editor.getValue());\n      Streamlit.setComponentValue({id: v1().slice(0,8), type: \"blur\", lang: outgoingMode, text: editor.getValue(), selected: editor.getSelectedText(), cursor: editor.getCursorPosition()});\n    }\n  }\n\n  // commands is an array of objects containing functions\n  // that the editor can be triggered to call.\n  const commands = { commands: [\n    {\n      name: 'submit', //name for the key binding.\n      description: \"Send 'submit' response\", //description of the command\n      bindKey: { win: 'Ctrl-Enter', mac: 'Command-Enter' }, //key combination used for the command.\n      exec: (editor: any) => {\n        const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n        Streamlit.setComponentValue({id: v1().slice(0,8), type: \"submit\", lang: outgoingMode, text: editor.getValue(), selected: editor.getSelectedText(), cursor: editor.getCursorPosition()});\n      }\n    },\n    {\n      name: 'saveState',\n      description: \"Save state\",\n      bindKey: { win: 'Ctrl-Alt-S', mac: 'Command-Alt-S' },\n      exec: (editor: ace.Ace.Editor) => {\n        setCode(editor.getValue());\n      }\n    },\n    {\n      name: 'copyAll',\n      description: \"Copy all text to clipboard\",\n      exec: (editor: ace.Ace.Editor) => {\n        unsecureCopyTextToClipboard(editor.getValue());\n      }\n    },\n    {\n      name: 'reset',\n      exec: () => {\n        resetEditor();\n      }\n    },\n    {\n      name: 'keepFocus',\n      description: \"Return cursor to editor\",\n      exec: () => {\n        keepFocus.current = true;\n      }\n    },\n    {\n      name: \"setMode\",\n      description: \"Set language mode\",\n      exec: (editor: ace.Ace.Editor, lang: string) => {\n          if(lang && typeof lang === \"string\")\n            editor.getSession().setMode(\"ace/mode/\" + lang);\n      },\n      readOnly: true\n    },\n    {\n      name: \"changeShortcuts\",\n      description: \"Switch shortcuts\",\n      exec: (editor: any, shortcuts?: string) => {\n        if(shortcuts && typeof shortcuts === \"string\")\n          editor.setKeyboardHandler(\"ace/keyboard/\" + shortcuts);\n        else {\n          //rotate through the available keyboard handlers\n          const handlers = [\"ace/keyboard/vim\", \"ace/keyboard/emacs\", \"ace/keyboard/sublime\", \"ace/keyboard/vscode\"];\n          const currentHandler = handlers[(handlers.indexOf(editor.$keybindingId) + 1) % 4];\n          editor.setKeyboardHandler(currentHandler);\n        }\n      },\n      readOnly: true\n    },\n    {\n      name: 'toggleKeyboardShortcuts',\n      exec: (editor: ace.Ace.Editor) => {\n        if(!document.getElementById('kbshortcutmenu'))\n          editor.execCommand('showKeyboardShortcuts');\n        else \n          editor.execCommand('simulateKeyPress', {type:\"keydown\", keyCode: 27});\n      }\n    },\n    {\n      name: 'simulateKeyPress',\n      exec: (editor: ace.Ace.Editor, args: {type: string, key?: string, keyCode?: number}) => {\n        if(args.key)\n          document.dispatchEvent(new KeyboardEvent(args.type,{'key': args.key})); \n        else if(args.keyCode)\n          document.dispatchEvent(new KeyboardEvent(args.type,{'keyCode': args.keyCode})); \n      }\n    },\n    {\n      name: 'infoMessage',\n      description: \"Display message in info bar\",\n      exec: (editor: ace.Ace.Editor, args: {text: string, timeout?: number, classToggle?: string, targetQueryString?: string} ) => {\n        if(args.targetQueryString){\n          const target = document.querySelector(args.targetQueryString) as HTMLElement;\n          if(target){\n            target.innerText = args.text;\n            target.classList.add(args.classToggle || \"\")\n            if(args.timeout){\n              timeoutId = setTimeout(() => {\n                target.classList.remove(args.classToggle || \"\");\n              }, args.timeout);\n            }\n          }\n        }\n        else if(infoTextRef.current){\n          infoTextRef.current.innerText = args.text;\n          infoTextRef.current.classList.add(args.classToggle || \"\");\n          if(args.timeout){\n            timeoutId = setTimeout(() => {\n              infoTextRef.current?.classList.remove(args.classToggle || \"\");\n            }, args.timeout);\n          }\n        }\n      }\n    },\n    {\n      name: 'response', //name for the key binding.\n      description: \"Send custom response\", //description of the command\n      exec: (editor: any, responseType = \"\") => {\n        const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n        Streamlit.setComponentValue({id: v1().slice(0,8), type: responseType, lang: outgoingMode, text: editor.getValue(), selected: editor.getSelectedText(), cursor: editor.getCursorPosition()});\n      }\n    },\n    {\n      name: 'returnSelection', //name for the key binding.\n      description: \"Send selected text to Streamlit\", //description of the command\n      exec: (editor: any) => {\n        const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n        Streamlit.setComponentValue({id: v1().slice(0,8), type: \"selection\", lang: outgoingMode, text: editor.getSelectedText(), cursor: editor.getCursorPosition()});\n      }\n    },\n    {\n      name: 'appendGhostText',\n      description: \"Add ghost test to end of line\",\n      bindKey: { win: 'Ctrl-/', mac: 'Command-/' },\n      exec: (editor: any) => {\n        console.log(\"appendGhostText\");\n        // get cursor position\n        const cursorPos = editor.getCursorPosition();\n        const line = editor.session.getLine(cursorPos.row);\n        const ghostText = editor.renderer.$ghostText;\n        console.log(ghostText);\n        if(ghostText){\n          editor.session.replace({start: {\"row\": cursorPos.row, \"column\": line.length}, end: {\"row\": cursorPos.row, \"column\": line.length}}, ghostText.text);\n          // editor.renderer.$ghostText = \"\";\n          editor.removeGhostText();\n          // editor.renderer.removeGhostText();\n        }\n      }\n    },\n    {\n      name: 'editSnippets',\n      description: \"Edit snippets\",\n      bindKey: { win: 'Ctrl-Alt-N', mac: 'Command-Alt-N' },\n      exec: (editor: any) => {\n        const snippetManager = ace.require('ace/snippets').snippetManager;\n        if(baseSession.current){\n          const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n          if(outgoingMode === \"snippets\"){\n            const snippetText = editor.getSession().getValue();\n            editor.setSession(baseSession.current);\n            baseSession.current = null;\n            setCode(editor.getSession().getValue());\n            if(outgoingMode === \"snippets\"){}\n            try{\n              const snippetsPlusMinus = snippetText.split(\"###~~~\")[1];\n              const [snippetsPlus, snippetsMinus] = snippetsPlusMinus.split(\"###---\");\n              const snippetsToAdd = snippetsPlus.split(\"###+++\")[1];\n              const snippetsToRemove = snippetsMinus;\n              const langMode = editor.getSession().$modeId.split(\"/\").pop();\n              setSnippetAddRemove({[langMode] : [snippetAddRemove[langMode][0] + snippetsToAdd, snippetAddRemove[langMode][1] + snippetsToRemove]});\n            } catch (error) {\n              editor.execCommand(\"infoMessage\",{text: \"error parsing file, restoring original file\", timeout: 2000, classToggle: \"show\"});\n            }\n          }\n        } else {\n          const langMode = editor.getSession().$modeId.split(\"/\").pop()\n          const snippetConcatText = `\\n###~~~#(DO NOT EDIT THIS LINE)\n# Commented out above are all the snippets that are currently\n# registered for ${args['lang']} mode.\n\\n\\n###+++#(DO NOT EDIT THIS LINE) \\n# Put the snippets you want to add below this line.\\n\\n\\n\\n\n\\n\\n\\n###---#(DO NOT EDIT THIS LINE) \\n# Put the snippets you want to remove below this line.\\n\\n\\n\\n\\n\\n\\n`;\n          const snippetText = \"#\" + createSnippets(snippetManager.snippetMap[langMode].map((snip: any) => ({name: snip.name, code: snip.content}))).replace(/\\n/g, \"\\n#\") + snippetConcatText;\n          // snippetManager.files[editor.getSession().$modeId].snippetText\n          const lineCount = (snippetText.match(/\\n/g) || []).length;\n          baseSession.current = editor.getSession();\n          const snippetsSession = ace.createEditSession(snippetText, \"ace/mode/snippets\");\n          editor.setSession(snippetsSession);\n          const cursorPos = {row: (lineCount - 15)>0? lineCount - 15 : 0, column: 0};\n          editor.moveCursorTo(cursorPos.row, cursorPos.column);\n          editor.renderer.scrollCursorIntoView(cursorPos, 0.5);\n        }\n      }\n    },\n    {\n      name: 'editKeyBindings',\n      description: \"Edit keybindings\",\n      bindKey: { win: 'Ctrl-Alt-B', mac: 'Command-Alt-B' },\n      exec: (editor: any) => {\n        ace.require('ace/autocomplete').Autocomplete.for(editor);\n        if(baseSession.current){\n          const outgoingMode = editor.getSession().$modeId.split(\"/\").pop();\n          if(outgoingMode === \"json\"){\n            const keybindingsJSON = editor.getSession().getValue();\n            editor.setSession(baseSession.current);\n            baseSession.current = null;\n            setCode(editor.getSession().getValue());\n            try{\n              setKeybindingAddRemove(JSON.parse(keybindingsJSON));\n            } catch (error) {\n              editor.execCommand(\"infoMessage\",{text: \"error parsing file, restoring original file\", timeout: 2000, classToggle: \"show\"});\n            }\n          }\n        } else {\n          const keybindings = {commands: {}, completer: {}};\n          if(editor.completer && editor.completer.keyboardHandler.commands){\n            keybindings.completer = Object.keys(editor.completer.keyboardHandler.commands).map((key: any) => ({bindkey: editor.completer.keyboardHandler.commands[key].bindKey ?? \"\", name: editor.completer.keyboardHandler.commands[key].name}));\n          }\n          if(editor.commands.commands){\n            keybindings.commands = Object.keys(editor.commands.commands).map((key: any) => ({bindkey: editor.commands.commands[key].bindKey ?? \"\", name: editor.commands.commands[key].name}));\n          }\n          const keybindingsJSON = JSON.stringify(keybindings, undefined, 2);\n          baseSession.current = editor.getSession();\n          const keybindingsSession = ace.createEditSession(keybindingsJSON, \"ace/mode/json\");\n          editor.setSession(keybindingsSession);\n        }\n      }\n    },\n    {\n      name: 'exitSession', //name for the key binding.\n      bindKey: { win: 'Esc', mac: 'Esc' },\n      description: \"Return to main session (keep changes)\", //description of the command\n      exec: (editor: any) => {\n        if(baseSession.current){\n          const mode = editor.getSession().$modeId.split(\"/\").pop();\n          if (mode === \"snippets\")\n            editor.execCommand(\"editSnippets\");\n          else if (mode === \"json\")\n            editor.execCommand(\"editKeyBindings\");\n        }\n      }\n    },\n    {\n      name: 'abandonSession', //name for the key binding.\n      bindKey: { win: 'Ctrl-Alt-Esc', mac: 'Command-Alt-Esc' },\n      description: \"Return to main session (discard changes)\", //description of the command\n      exec: (editor: any) => {\n        if(baseSession.current){\n          editor.setSession(baseSession.current);\n          baseSession.current = null;\n          setCode(editor.getSession().getValue());\n        }\n      }\n    },\n    {\n      name: 'classART', //name for the key binding.\n      description: \"Add/Remove/Toggle class for element\", //description of the command\n      exec: (editor: any, args: {targetQueryString: string, type: string, class: string}) => {\n        if(args.targetQueryString && args.type && args.class){\n          switch(args.type){\n            case \"add\":\n              document.querySelectorAll(args.targetQueryString)?.forEach((el: any) => el.classList.add(args.class));\n              break;\n            case \"remove\":\n              document.querySelectorAll(args.targetQueryString)?.forEach((el: any) => el.classList.remove(args.class));\n              break;\n            case \"toggle\":\n              document.querySelectorAll(args.targetQueryString)?.forEach((el: any) => el.classList.toggle(args.class));\n              break;\n            default:\n              break;\n          }\n        }\n      }\n    },\n    {\n      name: 'conditionalExecute', //name for the key binding.\n      description: \"Execute command if element exists\", //description of the command\n      exec: (editor: any, args: {targetQueryString: string, command: any[], condition?: boolean}) => {\n        if(args.targetQueryString && args.command && Array.isArray(args.command)){\n          if(!(args.condition ?? true) === !document.querySelector(args.targetQueryString)){\n            typeof args.command[0] === \"string\" ? execute(args.command[0], args.command[1]) : console.warn(\"Editor command - conditionalExecute: improper command format! Command array must contain name of command as first element and arguments as second element.\");\n          }\n        }\n      }\n    },\n    {\n      name: 'delayedExecute', //name for the key binding.\n      description: \"Execute command after a period of time\", //description of the command\n      exec: (editor: any, args: { command: string | any[], timeout?: number}) => {\n        if(args.command){\n          if(Array.isArray(args.command) && args.command.length === 2){\n            typeof args.command[0] === \"string\" ? setTimeout(() => {execute(args.command[0], args.command[1])}, args.timeout ?? defaultProps.debounceChangePeriod) : console.warn(\"Editor command - conditionalExecute: improper command format! Command array must contain name of command as first element and arguments as second element.\");\n          }\n          else if(typeof args.command === \"string\"){\n            setTimeout(() => {\n              execute(args.command as string);\n            }, args.timeout ?? defaultProps.debounceChangePeriod);\n          }\n        }\n      }\n    }\n  ]};\n\n  const execute = (command: string, args: any = \"\") => {\n    const editor = aceEditor.current?.editor;\n    if (editor) {\n      if (!args) {\n        editor.execCommand(command)\n      }\n      else if (typeof args === \"number\" || typeof args === \"string\") {\n        editor.execCommand(command, args);\n      }\n      else if (typeof args === \"object\" && !Array.isArray(args)) {\n        var containsNumsStr = true;\n        Object.keys(args).forEach((key: any) => {\n          containsNumsStr = typeof args[key] === \"string\" || typeof args[key] === \"number\" || Array.isArray(args[key]);\n        });\n        if (Object.keys(args).length < 4 && containsNumsStr) {\n          editor.execCommand(command, args);\n        }\n      }\n      else {\n        console.warn(`Function - execute: failed to parse/execute \"${command}\" command!`);\n      }\n    }\n  }\n\n  const executeAll = (commands: any[]) => {\n    commands.forEach(singleCommand => {\n      if (Array.isArray(singleCommand)) {\n        typeof singleCommand[0] === \"string\" ? execute(singleCommand[0], singleCommand[1]) : console.warn(\"Function - executeAll: improper command format! Singular commands must contain name of command as first element and arguments as second element.\");\n      } else if (typeof singleCommand === \"string\") {\n        execute(singleCommand);\n      } else {\n        console.warn(\"Function - executeAll: failed to parse/execute command(s)!\");\n      }\n    });\n  }\n\n  const resetEditor = () => {\n    setCode(args['code']);\n  }\n\n  const unsecureCopyTextToClipboard = (text: string) => {\n    const textField = document.createElement('textarea');\n    textField.value = text;\n    document.body.appendChild(textField);\n    textField.select();\n    document.execCommand('copy');\n    textField.remove();\n  }\n\n  /**\n   * resizeObserver observes changes in elements its given to observe and is used here\n   * to communicate to streamlit the height of the component that has changed\n   * so that streamlit can adjust the iframe containing the component accordingly.\n   */\n  const resizeObserver = new ResizeObserver((entries: any) => {\n    // If we know that the body will always fully contain our component (without cutting it off)\n    // then we can use docuemnt.body height instead\n    Streamlit.setFrameHeight((entries[0].contentBoxSize.blockSize ?? entries[0].contentRect.height)); \n  })\n\n  const observe = (divElem: any) => {\n    divElem ? resizeObserver.observe(divElem as HTMLDivElement) : resizeObserver.disconnect();\n  }\n\n  // This useEffect is used to reset the editor when the code argument changes and\n  // the allow_reset argument is true. The allow_reset argument only impacts the\n  // behavior of the component when the component has a fixed key argument because\n  // changing the key argument results in the creation of a new component instance.\n  // Everything would be reset anyways.\n  useEffect(() => {\n    if (args['allow_reset'] === true && args['code'] !== code) {\n      reset.current = !reset.current;\n      resetEditor();\n    }\n  }, [args['code']]);\n\n  /**\n   * This could also be memoized but I don't think it would be necessary because its not expensive.\n   */\n  const themeChoice = () => {\n    const isDarkTheme = theme? theme.base === \"dark\" : true;\n    switch (args['theme']) {\n      case \"contrast\":\n        return isDarkTheme? \"streamlit_light\" : \"streamlit_dark\";\n      case \"light\":\n        return \"streamlit_light\";\n      case \"dark\":\n        return \"streamlit_dark\";\n      case \"default\":\n        return isDarkTheme? \"streamlit_dark\" : \"streamlit_light\";\n      default:\n        return isDarkTheme? \"streamlit_dark\" : \"streamlit_light\";\n    }\n  }\n\n  const themeProp = themeChoice();\n  const componentContainerProps = args[\"component_props\"];\n\n  const {info: infoArg, menu: menuArg, focus: focusArg, code: codeArg, ...rest} = args;\n  const editorArgsString = JSON.stringify(rest);\n  const menuArgsString = JSON.stringify(menuArg);\n  const infoArgsString = JSON.stringify(infoArg);\n  const buttonArgsString = JSON.stringify(args['buttons']);\n  const themeString = JSON.stringify(theme);\n  const snippets = JSON.stringify(snippetAddRemove);\n\n  /**\n   * This section contains the main sub-components (child components). These components are wrapped in useMemos\n   * in order to prevent unnecessary re-rendering of the components. This is listed as one of its use cases in the\n   * React docs ({@link https://beta.reactjs.org/reference/react/useMemo#skipping-re-rendering-of-components Skipping re-rendering of components})\n   *\n   * This component is the editor component that is rendered. It is only re-rendered when\n   * certain properties change. This is important because we should account for the possibility that the editor \n   * is being used at any given moment. Unnecessary and frequent re-rendering of the editor (for outside reasons\n   * especially) can impact user experience and responsiveness.\n   */\n  const editor = useMemo(() => {\n    const keybindings = JSON.stringify(keybindingAddRemove);\n    const revertedArgs = JSON.parse(editorArgsString);\n\n    // Create commands for each button\n    if(revertedArgs['buttons'].length > 0) {\n      revertedArgs['buttons'].forEach((button: any) => {\n          commands.commands = [...commands.commands, {\n            name: (button.name as string).trim().replace(/\\s+/g, '_') + '_button',\n            bindKey: button.bindKey,\n            description: \"Execute '\" + button.name + \"' button command(s)\",\n            exec: () => {\n            executeAll(button.commands);\n          }}];\n      });\n    }\n\n    let heightProps = {};\n    if(typeof revertedArgs['height'] === \"number\") \n      heightProps = {minLines: 1, maxLines: revertedArgs['height']};\n    else if(typeof revertedArgs['height'] === \"string\") \n      heightProps = {height: revertedArgs['height']};\n    else if(Array.isArray(revertedArgs['height']) && revertedArgs['height'].length === 2) \n      heightProps = {minLines: revertedArgs['height'][0], maxLines: revertedArgs['height'][1]};\n\n    const aceEditorProps = { ...defaultEditorProps, ...revertedArgs['editor_props'] };\n    const aceOptions = { ...defaultOptions, ...revertedArgs['options'] };\n    const partProps = { setOptions: aceOptions, editorProps: aceEditorProps };\n    const aceProps = { ...defaultProps, ...partProps,...heightProps, ...revertedArgs['props'] };\n\n    /**\n     * TODO: Remove props from aceProps that we don't want to allow user access to.\n     */\n    return (\n        <Editor\n         editorRef={aceEditor}\n         code={code} \n         lang={revertedArgs['lang']} \n         theme={themeProp} \n         shortcuts={revertedArgs['shortcuts']} \n         snippetString={snippets} \n         ghostText={revertedArgs['ghost_text']}\n         commands={commands.commands} \n         completions={revertedArgs['completions']}\n         replaceCompleter={revertedArgs['replace_completer']}\n         keybindingString={keybindings} \n         props={aceProps} \n         onChange={onChangeHandler}\n         onSelectionChange={onSelectionChangeHandler}\n         onBlur={onEditorBlur} \n          onInput={onInputHandler} \n        />\n      );\n  }, [editorArgsString, themeProp, snippets, keybindingAddRemove, reset.current]);\n\n  const buttons = useMemo(() => {\n    const revertedButtons = JSON.parse(buttonArgsString);\n    const revertedTheme = JSON.parse(themeString);\n    const customButtonTheme = revertedTheme ?? {};\n    const customButtons = {buttons: (revertedButtons ?? []) as customButton[], name: \"customButtons\"} as buttonGroup;\n    return (\n      < ButtonSet\n       buttonGroup={customButtons} \n       theme={customButtonTheme} \n       themeProp={themeProp} \n       executeAll={(commands) => executeAll(commands)} />\n    );\n  }, [buttonArgsString, themeString, themeProp]);\n\n  const menu = useMemo(() => {\n    const revertedMenu = JSON.parse(menuArgsString);\n    const revertedTheme = JSON.parse(themeString);\n    const menuTheme = revertedTheme ?? {};\n    return (\n      <ButtonMenu\n       menu={revertedMenu} \n       theme={menuTheme} \n       themeProp={themeProp} \n       executeAll={(commands) => executeAll(commands)} />\n    );\n  }, [menuArgsString, themeString, themeProp]);\n\n  const info = useMemo(() => {\n    const revertedInfo = JSON.parse(infoArgsString);\n    const revertedTheme = JSON.parse(themeString);\n    const infoTheme = revertedTheme ?? {};\n    return (\n      <InfoBar\n       infoRef={infoTextRef} \n       info={revertedInfo} \n       theme={infoTheme} />\n    );\n  }, [infoArgsString, themeString]);\n\n  const globalCSS = useMemo(() => {\n    return (\n      <GlobalCSS isDisabled={disabled} inject={componentContainerProps.globalCSS} />\n    );\n  }, [componentContainerProps.globalCSS, disabled]);\n\n  return (\n    <StyledCodeEditor ref={observe} style={componentContainerProps.style} css={componentContainerProps.css} className={\"streamlit_code-editor \" + theme?.base ?? \"\" } >\n      {globalCSS}\n      {editor}\n      {buttons}\n      {menu}\n      {info}\n    </StyledCodeEditor>\n  )\n}\n\nexport default withStreamlitConnection(CodeEditor)\n","/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/editor.tsx",["28"],"import { useEffect, useRef} from \"react\"\nimport AceEditor from \"react-ace\";\nimport ace from \"ace-builds\";\n\nimport \"ace-builds/webpack-resolver\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/src-noconflict/mode-javascript\";\nimport \"ace-builds/src-noconflict/ext-language_tools\";\nimport \"ace-builds/src-noconflict/ext-searchbox\";\nimport \"ace-builds/src-noconflict/ext-prompt\";\nimport \"ace-builds/src-noconflict/ext-modelist\";\nimport \"ace-builds/src-noconflict/ext-keybinding_menu\";\n\nexport interface KeyBinding {\n    bindkey: string | object,\n    name: string\n}\n\nexport interface EditorKeyBindings {\n  commands?: KeyBinding[],\n  completer?: KeyBinding[]\n}\n\nexport type EditorProps = {\n    code: string,\n    lang: string,\n    theme: string,\n    shortcuts: string,\n    props: any,\n    editorRef: any,\n    snippetString: string,\n    ghostText: string,\n    commands: object[],\n    completions: object[],\n    keybindingString: string,\n    replaceCompleter: boolean,\n    onChange: (value: string, event?: any) => void,\n    onSelectionChange: (value: any, event?: any) => void,\n    onBlur: (event: any, editor?: any) => void,\n    onInput: ((event?: any) => void)\n  }\n  \nexport const Editor = ({ lang, theme, shortcuts, props, snippetString, commands, completions, ghostText, keybindingString, editorRef, code, replaceCompleter, onChange, onSelectionChange, onBlur, onInput }: EditorProps ) => {\n  \n  const preventGhostText = useRef<boolean>(false);\n\n  preventGhostText.current = false;\n\n  let commandsList = useRef<object[]>(commands);\n  useEffect(() => {\n    if(editorRef.current){\n\n      // Add/remove keybindings\n      ace.require('ace/autocomplete').Autocomplete.for(editorRef.current.editor);\n      const keybindings = JSON.parse(keybindingString) as EditorKeyBindings;\n      if(keybindings.commands && keybindings.commands.length > 0){\n        // const bindkeySelector = editorRef.current.editor.commands.platform as string;\n        keybindings.commands.forEach((binding) => {\n            if(binding.name && typeof binding.name === \"string\"){\n              if (JSON.stringify(editorRef.current.editor.commands.commands[binding.name].bindKey ?? \"\") !== JSON.stringify(binding.bindkey)) {\n                const newCommand = {...editorRef.current.editor.commands.commands[binding.name]};\n                newCommand.bindKey = binding.bindkey;\n                editorRef.current.editor.commands.addCommand(newCommand);\n                commandsList.current= [...commandsList.current, newCommand];\n              }\n            }\n   \n        });\n      }\n      if(keybindings.completer && keybindings.completer.length > 0){\n        // const bindkeySelector = editorRef.current.editor.completer.keyboardHandler.platform as string;\n        keybindings.completer.forEach((binding) => {\n            if(binding.name && typeof binding.name === \"string\"){\n              if (JSON.stringify(editorRef.current.editor.completer.keyboardHandler.commands[binding.name].bindKey ?? \"\") !== JSON.stringify(binding.bindkey)) {\n                const newCommand = {...editorRef.current.editor.completer.keyboardHandler.commands[binding.name]};\n                newCommand.bindKey = binding.bindkey;\n                editorRef.current.editor.completer.keyboardHandler.addCommand(newCommand);\n              }\n            }\n        });\n      }\n\n      // Add/remove snippets\n      ace.require(\"ace/ext/keybinding_menu\").init(editorRef.current.editor);\n      const snippetManager = ace.require('ace/snippets').snippetManager;\n      const snippets = JSON.parse(snippetString) as object;\n      for (const [snippetsLang, snippetsAddRemove] of Object.entries(snippets)){\n        if(snippetsAddRemove[0])\n          snippetManager.register(snippetManager.parseSnippetFile(snippetsAddRemove[0], snippetsLang), snippetsLang)\n        \n        if(snippetsAddRemove[1])\n          snippetManager.unregister(snippetManager.parseSnippetFile(snippetsAddRemove[1], snippetsLang), snippetsLang)\n      }\n\n      // Add completions\n      if (completions.length > 0) {\n        const customCompleter = {\n          getCompletions: (\n              editor: ace.Ace.Editor,\n              session: ace.Ace.EditSession,\n              pos: ace.Ace.Point,\n              prefix: string,\n              callback: ace.Ace.CompleterCallback\n          ): void => {\n              callback(\n                  null,\n                  (completions as ace.Ace.Completion[])\n              );\n            },\n          };\n        if(replaceCompleter) {\n          editorRef.current.editor.completers.pop();\n        }\n        ace.require(\"ace/ext/language_tools\").addCompleter(customCompleter);\n      }\n    }\n  }, [snippetString, keybindingString]);\n\n  useEffect(() => {\n    if(editorRef.current){\n      console.log(\"cursor @ useEffect\", editorRef.current.editor.getCursorPosition())\n      if (ghostText === \"\") {\n        // editorRef.current.editor.removeGhostText();\n      }\n      else if (!preventGhostText.current) {\n        // editorRef.current.editor.setGhostText(ghostText, undefined);\n        // Can also use editorRef.current.editor.addGhostText();\n        // However, adding ghost text directly using the editor skips important \n        // checks for config flags that could disable ghost text.\n        const aceInline = ace.require(\"ace/autocomplete/inline\").AceInline;\n        const inline = new aceInline();\n        const testCompletion: ace.Ace.Completion = {\n          snippet: ghostText,\n        }\n        const result = inline.show(editorRef.current.editor, testCompletion, \"\");\n        !result && inline.hide() && console.log(\"failed to show ghost text\");\n      }\n    }\n  }, [ghostText, editorRef]);\n\n  return (\n          <AceEditor\n           ref={editorRef}\n           name=\"REACT_ACE_EDITOR\"\n           mode={lang}\n           theme={theme}\n           value={code}\n           keyboardHandler={shortcuts}\n           commands={commandsList.current}\n           onChange={onChange}\n           onSelectionChange={onSelectionChange}\n           onBlur={onBlur}\n           onCursorChange={(value, event) => {\n              \n           }}\n           onInput={onInput}\n           {...props}/>\n  );\n};","/home/anasb/code-projects/streamlit/streamlit-code-editor/code_editor/frontend/src/button-menu.tsx",[],["29","30"],{"ruleId":"31","severity":1,"message":"32","line":158,"column":6,"nodeType":"33","endLine":158,"endColumn":8,"suggestions":"34"},{"ruleId":"31","severity":1,"message":"35","line":165,"column":6,"nodeType":"33","endLine":165,"endColumn":25,"suggestions":"36"},{"ruleId":"31","severity":1,"message":"37","line":584,"column":6,"nodeType":"33","endLine":584,"endColumn":20,"suggestions":"38"},{"ruleId":"31","severity":1,"message":"39","line":584,"column":7,"nodeType":"40","endLine":584,"endColumn":19},{"ruleId":"31","severity":1,"message":"41","line":679,"column":6,"nodeType":"33","endLine":679,"endColumn":81,"suggestions":"42"},{"ruleId":"31","severity":1,"message":"43","line":693,"column":6,"nodeType":"33","endLine":693,"endColumn":48,"suggestions":"44"},{"ruleId":"31","severity":1,"message":"43","line":706,"column":6,"nodeType":"33","endLine":706,"endColumn":46,"suggestions":"45"},{"ruleId":"31","severity":1,"message":"46","line":117,"column":6,"nodeType":"33","endLine":117,"endColumn":39,"suggestions":"47"},{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","replacedBy":"51"},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'timeoutId'. Either include it or remove the dependency array.","ArrayExpression",["52"],"React Hook useEffect has an unnecessary dependency: 'keepFocus.current'. Either exclude it or remove the dependency array. Mutable values like 'keepFocus.current' aren't valid dependencies because mutating them doesn't re-render the component.",["53"],"React Hook useEffect has missing dependencies: 'args', 'code', and 'resetEditor'. Either include them or remove the dependency array.",["54"],"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","MemberExpression","React Hook useMemo has missing dependencies: 'code', 'commands', 'executeAll', 'onChangeHandler', 'onEditorBlur', and 'onSelectionChangeHandler'. Either include them or remove the dependency array. Mutable values like 'reset.current' aren't valid dependencies because mutating them doesn't re-render the component.",["55"],"React Hook useMemo has a missing dependency: 'executeAll'. Either include it or remove the dependency array.",["56"],["57"],"React Hook useEffect has missing dependencies: 'completions', 'editorRef', and 'replaceCompleter'. Either include them or remove the dependency array.",["58"],"no-native-reassign",["59"],"no-negated-in-lhs",["60"],{"desc":"61","fix":"62"},{"desc":"63","fix":"64"},{"desc":"65","fix":"66"},{"desc":"67","fix":"68"},{"desc":"69","fix":"70"},{"desc":"71","fix":"72"},{"desc":"73","fix":"74"},"no-global-assign","no-unsafe-negation","Update the dependencies array to be: [timeoutId]",{"range":"75","text":"76"},"Update the dependencies array to be: []",{"range":"77","text":"78"},"Update the dependencies array to be: [args, code, resetEditor]",{"range":"79","text":"80"},"Update the dependencies array to be: [keybindingAddRemove, editorArgsString, code, themeProp, snippets, commands, onChangeHandler, onSelectionChangeHandler, onEditorBlur, executeAll]",{"range":"81","text":"82"},"Update the dependencies array to be: [buttonArgsString, themeString, themeProp, executeAll]",{"range":"83","text":"84"},"Update the dependencies array to be: [menuArgsString, themeString, themeProp, executeAll]",{"range":"85","text":"86"},"Update the dependencies array to be: [snippetString, keybindingString, editorRef, completions, replaceCompleter]",{"range":"87","text":"88"},[4624,4626],"[timeoutId]",[4782,4801],"[]",[23727,23741],"[args, code, resetEditor]",[27821,27896],"[keybindingAddRemove, editorArgsString, code, themeProp, snippets, commands, onChangeHandler, onSelectionChangeHandler, onEditorBlur, executeAll]",[28413,28455],"[buttonArgsString, themeString, themeProp, executeAll]",[28822,28862],"[menuArgsString, themeString, themeProp, executeAll]",[4650,4683],"[snippetString, keybindingString, editorRef, completions, replaceCompleter]"]