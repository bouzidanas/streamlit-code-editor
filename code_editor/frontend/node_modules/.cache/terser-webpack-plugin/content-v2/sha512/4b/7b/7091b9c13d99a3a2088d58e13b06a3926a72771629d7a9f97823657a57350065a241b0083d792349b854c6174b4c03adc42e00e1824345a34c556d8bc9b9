{"code":"ace.define(\"ace/mode/asciidoc_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,t,n){\"use strict\";var o=e(\"../lib/oop\"),i=e(\"./text_highlight_rules\").TextHighlightRules,r=function(){var e=\"[a-zA-Z\\xa1-\\uffff]+\\\\b\";function t(e){return(/\\w/.test(e)?\"\\\\b\":\"(?:\\\\B|^)\")+e+\"[^\"+e+\"].*?\"+e+\"(?![\\\\w*])\"}this.$rules={start:[{token:\"empty\",regex:/$/},{token:\"literal\",regex:/^\\.{4,}\\s*$/,next:\"listingBlock\"},{token:\"literal\",regex:/^-{4,}\\s*$/,next:\"literalBlock\"},{token:\"string\",regex:/^\\+{4,}\\s*$/,next:\"passthroughBlock\"},{token:\"keyword\",regex:/^={4,}\\s*$/},{token:\"text\",regex:/^\\s*$/},{token:\"empty\",regex:\"\",next:\"dissallowDelimitedBlock\"}],dissallowDelimitedBlock:[{include:\"paragraphEnd\"},{token:\"comment\",regex:\"^//.+$\"},{token:\"keyword\",regex:\"^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\"},{include:\"listStart\"},{token:\"literal\",regex:/^\\s+.+$/,next:\"indentedBlock\"},{token:\"empty\",regex:\"\",next:\"text\"}],paragraphEnd:[{token:\"doc.comment\",regex:/^\\/{4,}\\s*$/,next:\"commentBlock\"},{token:\"tableBlock\",regex:/^\\s*[|!]=+\\s*$/,next:\"tableBlock\"},{token:\"keyword\",regex:/^(?:--|''')\\s*$/,next:\"start\"},{token:\"option\",regex:/^\\[.*\\]\\s*$/,next:\"start\"},{token:\"pageBreak\",regex:/^>{3,}$/,next:\"start\"},{token:\"literal\",regex:/^\\.{4,}\\s*$/,next:\"listingBlock\"},{token:\"titleUnderline\",regex:/^(?:={2,}|-{2,}|~{2,}|\\^{2,}|\\+{2,})\\s*$/,next:\"start\"},{token:\"singleLineTitle\",regex:/^={1,5}\\s+\\S.*$/,next:\"start\"},{token:\"otherBlock\",regex:/^(?:\\*{2,}|_{2,})\\s*$/,next:\"start\"},{token:\"optionalTitle\",regex:/^\\.[^.\\s].+$/,next:\"start\"}],listStart:[{token:\"keyword\",regex:/^\\s*(?:\\d+\\.|[a-zA-Z]\\.|[ixvmIXVM]+\\)|\\*{1,5}|-|\\.{1,5})\\s/,next:\"listText\"},{token:\"meta.tag\",regex:/^.+(?::{2,4}|;;)(?: |$)/,next:\"listText\"},{token:\"support.function.list.callout\",regex:/^(?:<\\d+>|\\d+>|>) /,next:\"text\"},{token:\"keyword\",regex:/^\\+\\s*$/,next:\"start\"}],text:[{token:[\"link\",\"variable.language\"],regex:/((?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+)(\\[.*?\\])/},{token:\"link\",regex:/(?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+/},{token:\"link\",regex:/\\b[\\w\\.\\/\\-]+@[\\w\\.\\/\\-]+\\b/},{include:\"macros\"},{include:\"paragraphEnd\"},{token:\"literal\",regex:/\\+{3,}/,next:\"smallPassthrough\"},{token:\"escape\",regex:/\\((?:C|TM|R)\\)|\\.{3}|->|<-|=>|<=|&#(?:\\d+|x[a-fA-F\\d]+);|(?: |^)--(?=\\s+\\S)/},{token:\"escape\",regex:/\\\\[_*'`+#]|\\\\{2}[_*'`+#]{2}/},{token:\"keyword\",regex:/\\s\\+$/},{token:\"text\",regex:e},{token:[\"keyword\",\"string\",\"keyword\"],regex:/(<<[\\w\\d\\-$]+,)(.*?)(>>|$)/},{token:\"keyword\",regex:/<<[\\w\\d\\-$]+,?|>>/},{token:\"constant.character\",regex:/\\({2,3}.*?\\){2,3}/},{token:\"keyword\",regex:/\\[\\[.+?\\]\\]/},{token:\"support\",regex:/^\\[{3}[\\w\\d =\\-]+\\]{3}/},{include:\"quotes\"},{token:\"empty\",regex:/^\\s*$/,next:\"start\"}],listText:[{include:\"listStart\"},{include:\"text\"}],indentedBlock:[{token:\"literal\",regex:/^[\\s\\w].+$/,next:\"indentedBlock\"},{token:\"literal\",regex:\"\",next:\"start\"}],listingBlock:[{token:\"literal\",regex:/^\\.{4,}\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"constant.numeric\",regex:\"<\\\\d+>\"},{token:\"literal\",regex:\"[^<]+\"},{token:\"literal\",regex:\"<\"}],literalBlock:[{token:\"literal\",regex:/^-{4,}\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"constant.numeric\",regex:\"<\\\\d+>\"},{token:\"literal\",regex:\"[^<]+\"},{token:\"literal\",regex:\"<\"}],passthroughBlock:[{token:\"literal\",regex:/^\\+{4,}\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"literal\",regex:e+\"|\\\\d+\"},{include:\"macros\"},{token:\"literal\",regex:\".\"}],smallPassthrough:[{token:\"literal\",regex:/[+]{3,}/,next:\"dissallowDelimitedBlock\"},{token:\"literal\",regex:/^\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"literal\",regex:e+\"|\\\\d+\"},{include:\"macros\"}],commentBlock:[{token:\"doc.comment\",regex:/^\\/{4,}\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"doc.comment\",regex:\"^.*$\"}],tableBlock:[{token:\"tableBlock\",regex:/^\\s*\\|={3,}\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"tableBlock\",regex:/^\\s*!={3,}\\s*$/,next:\"innerTableBlock\"},{token:\"tableBlock\",regex:/\\|/},{include:\"text\",noEscape:!0}],innerTableBlock:[{token:\"tableBlock\",regex:/^\\s*!={3,}\\s*$/,next:\"tableBlock\"},{token:\"tableBlock\",regex:/^\\s*|={3,}\\s*$/,next:\"dissallowDelimitedBlock\"},{token:\"tableBlock\",regex:/!/}],macros:[{token:\"macro\",regex:/{[\\w\\-$]+}/},{token:[\"text\",\"string\",\"text\",\"constant.character\",\"text\"],regex:/({)([\\w\\-$]+)(:)?(.+)?(})/},{token:[\"text\",\"markup.list.macro\",\"keyword\",\"string\"],regex:/(\\w+)(footnote(?:ref)?::?)([^\\s\\[]+)?(\\[.*?\\])?/},{token:[\"markup.list.macro\",\"keyword\",\"string\"],regex:/([a-zA-Z\\-][\\w\\.\\/\\-]*::?)([^\\s\\[]+)(\\[.*?\\])?/},{token:[\"markup.list.macro\",\"keyword\"],regex:/([a-zA-Z\\-][\\w\\.\\/\\-]+::?)(\\[.*?\\])/},{token:\"keyword\",regex:/^:.+?:(?= |$)/}],quotes:[{token:\"string.italic\",regex:/__[^_\\s].*?__/},{token:\"string.italic\",regex:t(\"_\")},{token:\"keyword.bold\",regex:/\\*\\*[^*\\s].*?\\*\\*/},{token:\"keyword.bold\",regex:t(\"\\\\*\")},{token:\"literal\",regex:t(\"\\\\+\")},{token:\"literal\",regex:/\\+\\+[^+\\s].*?\\+\\+/},{token:\"literal\",regex:/\\$\\$.+?\\$\\$/},{token:\"literal\",regex:t(\"`\")},{token:\"keyword\",regex:t(\"^\")},{token:\"keyword\",regex:t(\"~\")},{token:\"keyword\",regex:/##?/},{token:\"keyword\",regex:/(?:\\B|^)``|\\b''/}]};var n={macro:\"constant.character\",tableBlock:\"doc.comment\",titleUnderline:\"markup.heading\",singleLineTitle:\"markup.heading\",pageBreak:\"string\",option:\"string.regexp\",otherBlock:\"markup.list\",literal:\"support.function\",optionalTitle:\"constant.numeric\",escape:\"constant.language.escape\",link:\"markup.underline.list\"};for(var o in this.$rules)for(var i=this.$rules[o],r=i.length;r--;){var l=i[r];if(l.include||\"string\"==typeof l){var a=[r,1].concat(this.$rules[l.include||l]);l.noEscape&&(a=a.filter((function(e){return!e.next}))),i.splice.apply(i,a)}else l.token in n&&(l.token=n[l.token])}};o.inherits(r,i),t.AsciidocHighlightRules=r})),ace.define(\"ace/mode/folding/asciidoc\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"],(function(e,t,n){\"use strict\";var o=e(\"../../lib/oop\"),i=e(\"./fold_mode\").FoldMode,r=e(\"../../range\").Range,l=t.FoldMode=function(){};o.inherits(l,i),function(){this.foldingStartMarker=/^(?:\\|={10,}|[\\.\\/=\\-~^+]{4,}\\s*$|={1,5} )/,this.singleLineHeadingRe=/^={1,5}(?=\\s+\\S)/,this.getFoldWidget=function(e,t,n){var o=e.getLine(n);return this.foldingStartMarker.test(o)?\"=\"==o[0]?this.singleLineHeadingRe.test(o)?\"start\":e.getLine(n-1).length!=e.getLine(n).length?\"\":\"start\":\"dissallowDelimitedBlock\"==e.bgTokenizer.getState(n)?\"end\":\"start\":\"\"},this.getFoldWidgetRange=function(e,t,n){var o=e.getLine(n),i=o.length,l=e.getLength(),a=n,s=n;if(o.match(this.foldingStartMarker)){var g,c=[\"=\",\"-\",\"~\",\"^\",\"+\"],k=\"markup.heading\",d=this.singleLineHeadingRe;if(h(n)==k){for(var x=m();++n<l;){if(h(n)==k)if(m()<=x)break}if((s=g&&g.value.match(this.singleLineHeadingRe)?n-1:n-2)>a)for(;s>a&&(!h(s)||\"[\"==g.value[0]);)s--;if(s>a){var u=e.getLine(s).length;return new r(a,i,s,u)}}else{if(\"dissallowDelimitedBlock\"==e.bgTokenizer.getState(n)){for(;n-- >0&&-1!=e.bgTokenizer.getState(n).lastIndexOf(\"Block\"););if((s=n+1)<a){u=e.getLine(n).length;return new r(s,5,a,i-5)}}else{for(;++n<l&&\"dissallowDelimitedBlock\"!=e.bgTokenizer.getState(n););if((s=n)>a){u=e.getLine(n).length;return new r(a,5,s,u-5)}}}}function h(t){return(g=e.getTokens(t)[0])&&g.type}function m(){var t=g.value.match(d);if(t)return t[0].length;var o=c.indexOf(g.value[0])+1;return 1==o&&e.getLine(n-1).length!=e.getLine(n).length?1/0:o}}}.call(l.prototype)})),ace.define(\"ace/mode/asciidoc\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/asciidoc_highlight_rules\",\"ace/mode/folding/asciidoc\"],(function(e,t,n){\"use strict\";var o=e(\"../lib/oop\"),i=e(\"./text\").Mode,r=e(\"./asciidoc_highlight_rules\").AsciidocHighlightRules,l=e(\"./folding/asciidoc\").FoldMode,a=function(){this.HighlightRules=r,this.foldingRules=new l};o.inherits(a,i),function(){this.type=\"text\",this.getNextLineIndent=function(e,t,n){if(\"listblock\"==e){var o=/^((?:.+)?)([-+*][ ]+)/.exec(t);return o?new Array(o[1].length+1).join(\" \")+o[2]:\"\"}return this.$getIndent(t)},this.$id=\"ace/mode/asciidoc\"}.call(a.prototype),t.Mode=a})),ace.require([\"ace/mode/asciidoc\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"4ce871607664f755ce1edb794510b0b0.js","input":"ace.define(\"ace/mode/asciidoc_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var AsciidocHighlightRules = function () {\n    var identifierRe = \"[a-zA-Z\\u00a1-\\uffff]+\\\\b\";\n    this.$rules = {\n      \"start\": [{\n        token: \"empty\",\n        regex: /$/\n      }, {\n        token: \"literal\",\n        regex: /^\\.{4,}\\s*$/,\n        next: \"listingBlock\"\n      }, {\n        token: \"literal\",\n        regex: /^-{4,}\\s*$/,\n        next: \"literalBlock\"\n      }, {\n        token: \"string\",\n        regex: /^\\+{4,}\\s*$/,\n        next: \"passthroughBlock\"\n      }, {\n        token: \"keyword\",\n        regex: /^={4,}\\s*$/\n      }, {\n        token: \"text\",\n        regex: /^\\s*$/\n      }, {\n        token: \"empty\",\n        regex: \"\",\n        next: \"dissallowDelimitedBlock\"\n      }],\n      \"dissallowDelimitedBlock\": [{\n        include: \"paragraphEnd\"\n      }, {\n        token: \"comment\",\n        regex: '^//.+$'\n      }, {\n        token: \"keyword\",\n        regex: \"^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\"\n      }, {\n        include: \"listStart\"\n      }, {\n        token: \"literal\",\n        regex: /^\\s+.+$/,\n        next: \"indentedBlock\"\n      }, {\n        token: \"empty\",\n        regex: \"\",\n        next: \"text\"\n      }],\n      \"paragraphEnd\": [{\n        token: \"doc.comment\",\n        regex: /^\\/{4,}\\s*$/,\n        next: \"commentBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /^\\s*[|!]=+\\s*$/,\n        next: \"tableBlock\"\n      }, {\n        token: \"keyword\",\n        regex: /^(?:--|''')\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"option\",\n        regex: /^\\[.*\\]\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"pageBreak\",\n        regex: /^>{3,}$/,\n        next: \"start\"\n      }, {\n        token: \"literal\",\n        regex: /^\\.{4,}\\s*$/,\n        next: \"listingBlock\"\n      }, {\n        token: \"titleUnderline\",\n        regex: /^(?:={2,}|-{2,}|~{2,}|\\^{2,}|\\+{2,})\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"singleLineTitle\",\n        regex: /^={1,5}\\s+\\S.*$/,\n        next: \"start\"\n      }, {\n        token: \"otherBlock\",\n        regex: /^(?:\\*{2,}|_{2,})\\s*$/,\n        next: \"start\"\n      }, {\n        token: \"optionalTitle\",\n        regex: /^\\.[^.\\s].+$/,\n        next: \"start\"\n      }],\n      \"listStart\": [{\n        token: \"keyword\",\n        regex: /^\\s*(?:\\d+\\.|[a-zA-Z]\\.|[ixvmIXVM]+\\)|\\*{1,5}|-|\\.{1,5})\\s/,\n        next: \"listText\"\n      }, {\n        token: \"meta.tag\",\n        regex: /^.+(?::{2,4}|;;)(?: |$)/,\n        next: \"listText\"\n      }, {\n        token: \"support.function.list.callout\",\n        regex: /^(?:<\\d+>|\\d+>|>) /,\n        next: \"text\"\n      }, {\n        token: \"keyword\",\n        regex: /^\\+\\s*$/,\n        next: \"start\"\n      }],\n      \"text\": [{\n        token: [\"link\", \"variable.language\"],\n        regex: /((?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+)(\\[.*?\\])/\n      }, {\n        token: \"link\",\n        regex: /(?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+/\n      }, {\n        token: \"link\",\n        regex: /\\b[\\w\\.\\/\\-]+@[\\w\\.\\/\\-]+\\b/\n      }, {\n        include: \"macros\"\n      }, {\n        include: \"paragraphEnd\"\n      }, {\n        token: \"literal\",\n        regex: /\\+{3,}/,\n        next: \"smallPassthrough\"\n      }, {\n        token: \"escape\",\n        regex: /\\((?:C|TM|R)\\)|\\.{3}|->|<-|=>|<=|&#(?:\\d+|x[a-fA-F\\d]+);|(?: |^)--(?=\\s+\\S)/\n      }, {\n        token: \"escape\",\n        regex: /\\\\[_*'`+#]|\\\\{2}[_*'`+#]{2}/\n      }, {\n        token: \"keyword\",\n        regex: /\\s\\+$/\n      }, {\n        token: \"text\",\n        regex: identifierRe\n      }, {\n        token: [\"keyword\", \"string\", \"keyword\"],\n        regex: /(<<[\\w\\d\\-$]+,)(.*?)(>>|$)/\n      }, {\n        token: \"keyword\",\n        regex: /<<[\\w\\d\\-$]+,?|>>/\n      }, {\n        token: \"constant.character\",\n        regex: /\\({2,3}.*?\\){2,3}/\n      }, {\n        token: \"keyword\",\n        regex: /\\[\\[.+?\\]\\]/\n      }, {\n        token: \"support\",\n        regex: /^\\[{3}[\\w\\d =\\-]+\\]{3}/\n      }, {\n        include: \"quotes\"\n      }, {\n        token: \"empty\",\n        regex: /^\\s*$/,\n        next: \"start\"\n      }],\n      \"listText\": [{\n        include: \"listStart\"\n      }, {\n        include: \"text\"\n      }],\n      \"indentedBlock\": [{\n        token: \"literal\",\n        regex: /^[\\s\\w].+$/,\n        next: \"indentedBlock\"\n      }, {\n        token: \"literal\",\n        regex: \"\",\n        next: \"start\"\n      }],\n      \"listingBlock\": [{\n        token: \"literal\",\n        regex: /^\\.{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"constant.numeric\",\n        regex: '<\\\\d+>'\n      }, {\n        token: \"literal\",\n        regex: '[^<]+'\n      }, {\n        token: \"literal\",\n        regex: '<'\n      }],\n      \"literalBlock\": [{\n        token: \"literal\",\n        regex: /^-{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"constant.numeric\",\n        regex: '<\\\\d+>'\n      }, {\n        token: \"literal\",\n        regex: '[^<]+'\n      }, {\n        token: \"literal\",\n        regex: '<'\n      }],\n      \"passthroughBlock\": [{\n        token: \"literal\",\n        regex: /^\\+{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"literal\",\n        regex: identifierRe + \"|\\\\d+\"\n      }, {\n        include: \"macros\"\n      }, {\n        token: \"literal\",\n        regex: \".\"\n      }],\n      \"smallPassthrough\": [{\n        token: \"literal\",\n        regex: /[+]{3,}/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"literal\",\n        regex: /^\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"literal\",\n        regex: identifierRe + \"|\\\\d+\"\n      }, {\n        include: \"macros\"\n      }],\n      \"commentBlock\": [{\n        token: \"doc.comment\",\n        regex: /^\\/{4,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"doc.comment\",\n        regex: '^.*$'\n      }],\n      \"tableBlock\": [{\n        token: \"tableBlock\",\n        regex: /^\\s*\\|={3,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /^\\s*!={3,}\\s*$/,\n        next: \"innerTableBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /\\|/\n      }, {\n        include: \"text\",\n        noEscape: true\n      }],\n      \"innerTableBlock\": [{\n        token: \"tableBlock\",\n        regex: /^\\s*!={3,}\\s*$/,\n        next: \"tableBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /^\\s*|={3,}\\s*$/,\n        next: \"dissallowDelimitedBlock\"\n      }, {\n        token: \"tableBlock\",\n        regex: /!/\n      }],\n      \"macros\": [{\n        token: \"macro\",\n        regex: /{[\\w\\-$]+}/\n      }, {\n        token: [\"text\", \"string\", \"text\", \"constant.character\", \"text\"],\n        regex: /({)([\\w\\-$]+)(:)?(.+)?(})/\n      }, {\n        token: [\"text\", \"markup.list.macro\", \"keyword\", \"string\"],\n        regex: /(\\w+)(footnote(?:ref)?::?)([^\\s\\[]+)?(\\[.*?\\])?/\n      }, {\n        token: [\"markup.list.macro\", \"keyword\", \"string\"],\n        regex: /([a-zA-Z\\-][\\w\\.\\/\\-]*::?)([^\\s\\[]+)(\\[.*?\\])?/\n      }, {\n        token: [\"markup.list.macro\", \"keyword\"],\n        regex: /([a-zA-Z\\-][\\w\\.\\/\\-]+::?)(\\[.*?\\])/\n      }, {\n        token: \"keyword\",\n        regex: /^:.+?:(?= |$)/\n      }],\n      \"quotes\": [{\n        token: \"string.italic\",\n        regex: /__[^_\\s].*?__/\n      }, {\n        token: \"string.italic\",\n        regex: quoteRule(\"_\")\n      }, {\n        token: \"keyword.bold\",\n        regex: /\\*\\*[^*\\s].*?\\*\\*/\n      }, {\n        token: \"keyword.bold\",\n        regex: quoteRule(\"\\\\*\")\n      }, {\n        token: \"literal\",\n        regex: quoteRule(\"\\\\+\")\n      }, {\n        token: \"literal\",\n        regex: /\\+\\+[^+\\s].*?\\+\\+/\n      }, {\n        token: \"literal\",\n        regex: /\\$\\$.+?\\$\\$/\n      }, {\n        token: \"literal\",\n        regex: quoteRule(\"`\")\n      }, {\n        token: \"keyword\",\n        regex: quoteRule(\"^\")\n      }, {\n        token: \"keyword\",\n        regex: quoteRule(\"~\")\n      }, {\n        token: \"keyword\",\n        regex: /##?/\n      }, {\n        token: \"keyword\",\n        regex: /(?:\\B|^)``|\\b''/\n      }]\n    };\n    function quoteRule(ch) {\n      var prefix = /\\w/.test(ch) ? \"\\\\b\" : \"(?:\\\\B|^)\";\n      return prefix + ch + \"[^\" + ch + \"].*?\" + ch + \"(?![\\\\w*])\";\n    }\n    var tokenMap = {\n      macro: \"constant.character\",\n      tableBlock: \"doc.comment\",\n      titleUnderline: \"markup.heading\",\n      singleLineTitle: \"markup.heading\",\n      pageBreak: \"string\",\n      option: \"string.regexp\",\n      otherBlock: \"markup.list\",\n      literal: \"support.function\",\n      optionalTitle: \"constant.numeric\",\n      escape: \"constant.language.escape\",\n      link: \"markup.underline.list\"\n    };\n    for (var state in this.$rules) {\n      var stateRules = this.$rules[state];\n      for (var i = stateRules.length; i--;) {\n        var rule = stateRules[i];\n        if (rule.include || typeof rule == \"string\") {\n          var args = [i, 1].concat(this.$rules[rule.include || rule]);\n          if (rule.noEscape) {\n            args = args.filter(function (x) {\n              return !x.next;\n            });\n          }\n          stateRules.splice.apply(stateRules, args);\n        } else if (rule.token in tokenMap) {\n          rule.token = tokenMap[rule.token];\n        }\n      }\n    }\n  };\n  oop.inherits(AsciidocHighlightRules, TextHighlightRules);\n  exports.AsciidocHighlightRules = AsciidocHighlightRules;\n});\nace.define(\"ace/mode/folding/asciidoc\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^(?:\\|={10,}|[\\.\\/=\\-~^+]{4,}\\s*$|={1,5} )/;\n    this.singleLineHeadingRe = /^={1,5}(?=\\s+\\S)/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      if (!this.foldingStartMarker.test(line)) return \"\";\n      if (line[0] == \"=\") {\n        if (this.singleLineHeadingRe.test(line)) return \"start\";\n        if (session.getLine(row - 1).length != session.getLine(row).length) return \"\";\n        return \"start\";\n      }\n      if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\") return \"end\";\n      return \"start\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n      if (!line.match(this.foldingStartMarker)) return;\n      var token;\n      function getTokenType(row) {\n        token = session.getTokens(row)[0];\n        return token && token.type;\n      }\n      var levels = [\"=\", \"-\", \"~\", \"^\", \"+\"];\n      var heading = \"markup.heading\";\n      var singleLineHeadingRe = this.singleLineHeadingRe;\n      function getLevel() {\n        var match = token.value.match(singleLineHeadingRe);\n        if (match) return match[0].length;\n        var level = levels.indexOf(token.value[0]) + 1;\n        if (level == 1) {\n          if (session.getLine(row - 1).length != session.getLine(row).length) return Infinity;\n        }\n        return level;\n      }\n      if (getTokenType(row) == heading) {\n        var startHeadingLevel = getLevel();\n        while (++row < maxRow) {\n          if (getTokenType(row) != heading) continue;\n          var level = getLevel();\n          if (level <= startHeadingLevel) break;\n        }\n        var isSingleLineHeading = token && token.value.match(this.singleLineHeadingRe);\n        endRow = isSingleLineHeading ? row - 1 : row - 2;\n        if (endRow > startRow) {\n          while (endRow > startRow && (!getTokenType(endRow) || token.value[0] == \"[\")) endRow--;\n        }\n        if (endRow > startRow) {\n          var endColumn = session.getLine(endRow).length;\n          return new Range(startRow, startColumn, endRow, endColumn);\n        }\n      } else {\n        var state = session.bgTokenizer.getState(row);\n        if (state == \"dissallowDelimitedBlock\") {\n          while (row-- > 0) {\n            if (session.bgTokenizer.getState(row).lastIndexOf(\"Block\") == -1) break;\n          }\n          endRow = row + 1;\n          if (endRow < startRow) {\n            var endColumn = session.getLine(row).length;\n            return new Range(endRow, 5, startRow, startColumn - 5);\n          }\n        } else {\n          while (++row < maxRow) {\n            if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\") break;\n          }\n          endRow = row;\n          if (endRow > startRow) {\n            var endColumn = session.getLine(row).length;\n            return new Range(startRow, 5, endRow, endColumn - 5);\n          }\n        }\n      }\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/asciidoc\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/asciidoc_highlight_rules\", \"ace/mode/folding/asciidoc\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var AsciidocHighlightRules = require(\"./asciidoc_highlight_rules\").AsciidocHighlightRules;\n  var AsciidocFoldMode = require(\"./folding/asciidoc\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = AsciidocHighlightRules;\n    this.foldingRules = new AsciidocFoldMode();\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.type = \"text\";\n    this.getNextLineIndent = function (state, line, tab) {\n      if (state == \"listblock\") {\n        var match = /^((?:.+)?)([-+*][ ]+)/.exec(line);\n        if (match) {\n          return new Array(match[1].length + 1).join(\" \") + match[2];\n        } else {\n          return \"\";\n        }\n      } else {\n        return this.$getIndent(line);\n      }\n    };\n    this.$id = \"ace/mode/asciidoc\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/asciidoc\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}