{"code":"ace.define(\"ace/mode/haskell_cabal_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,t,i){\"use strict\";var o=e(\"../lib/oop\"),l=e(\"./text_highlight_rules\").TextHighlightRules,n=function(){this.$rules={start:[{token:\"comment\",regex:\"^\\\\s*--.*$\"},{token:[\"keyword\"],regex:/^(\\s*\\w.*?)(:(?:\\s+|$))/},{token:\"constant.numeric\",regex:/[\\d_]+(?:(?:[\\.\\d_]*)?)/},{token:\"constant.language.boolean\",regex:\"(?:true|false|TRUE|FALSE|True|False|yes|no)\\\\b\"},{token:\"markup.heading\",regex:/^(\\w.*)$/}]}};o.inherits(n,l),t.CabalHighlightRules=n})),ace.define(\"ace/mode/folding/haskell_cabal\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"],(function(e,t,i){\"use strict\";var o=e(\"../../lib/oop\"),l=e(\"./fold_mode\").FoldMode,n=e(\"../../range\").Range,a=t.FoldMode=function(){};o.inherits(a,l),function(){this.isHeading=function(e,t){var i=e.getTokens(t)[0];return 0==t||i&&0===i.type.lastIndexOf(\"markup.heading\",0)},this.getFoldWidget=function(e,t,i){if(this.isHeading(e,i))return\"start\";if(\"markbeginend\"===t&&!/^\\s*$/.test(e.getLine(i))){for(var o=e.getLength();++i<o&&/^\\s*$/.test(e.getLine(i)););if(i==o||this.isHeading(e,i))return\"end\"}return\"\"},this.getFoldWidgetRange=function(e,t,i){var o=e.getLine(i).length,l=e.getLength(),a=i,s=i;if(this.isHeading(e,i)){for(;++i<l;)if(this.isHeading(e,i)){i--;break}if((s=i)>a)for(;s>a&&/^\\s*$/.test(e.getLine(s));)s--;if(s>a){var r=e.getLine(s).length;return new n(a,o,s,r)}}else if(\"end\"===this.getFoldWidget(e,t,i)){for(s=i,r=e.getLine(s).length;--i>=0&&!this.isHeading(e,i););o=e.getLine(i).length;return new n(i,o,s,r)}}}.call(a.prototype)})),ace.define(\"ace/mode/haskell_cabal\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/haskell_cabal_highlight_rules\",\"ace/mode/folding/haskell_cabal\"],(function(e,t,i){\"use strict\";var o=e(\"../lib/oop\"),l=e(\"./text\").Mode,n=e(\"./haskell_cabal_highlight_rules\").CabalHighlightRules,a=e(\"./folding/haskell_cabal\").FoldMode,s=function(){this.HighlightRules=n,this.foldingRules=new a,this.$behaviour=this.$defaultBehaviour};o.inherits(s,l),function(){this.lineCommentStart=\"--\",this.blockComment=null,this.$id=\"ace/mode/haskell_cabal\"}.call(s.prototype),t.Mode=s})),ace.require([\"ace/mode/haskell_cabal\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"4f6529e536928dbeb390203c11e4db2a.js","input":"ace.define(\"ace/mode/haskell_cabal_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  /**\n  * Haskell Cabal files highlighter (https://www.haskell.org/cabal/users-guide/developing-packages.html)\n  **/\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var CabalHighlightRules = function () {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"^\\\\s*--.*$\"\n      }, {\n        token: [\"keyword\"],\n        regex: /^(\\s*\\w.*?)(:(?:\\s+|$))/\n      }, {\n        token: \"constant.numeric\",\n        // float\n        regex: /[\\d_]+(?:(?:[\\.\\d_]*)?)/\n      }, {\n        token: \"constant.language.boolean\",\n        regex: \"(?:true|false|TRUE|FALSE|True|False|yes|no)\\\\b\"\n      }, {\n        token: \"markup.heading\",\n        regex: /^(\\w.*)$/\n      }]\n    };\n  };\n  oop.inherits(CabalHighlightRules, TextHighlightRules);\n  exports.CabalHighlightRules = CabalHighlightRules;\n});\nace.define(\"ace/mode/folding/haskell_cabal\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  /*\n  * Folding mode for Cabal files (Haskell): allow folding each seaction, including\n  * the initial general section.\n  */\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.isHeading = function (session, row) {\n      var heading = \"markup.heading\";\n      var token = session.getTokens(row)[0];\n      return row == 0 || token && token.type.lastIndexOf(heading, 0) === 0;\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n      if (this.isHeading(session, row)) {\n        return \"start\";\n      } else if (foldStyle === \"markbeginend\" && !/^\\s*$/.test(session.getLine(row))) {\n        var maxRow = session.getLength();\n        while (++row < maxRow) {\n          if (!/^\\s*$/.test(session.getLine(row))) {\n            break;\n          }\n        }\n        if (row == maxRow || this.isHeading(session, row)) {\n          return \"end\";\n        }\n      }\n      return \"\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n      if (this.isHeading(session, row)) {\n        while (++row < maxRow) {\n          if (this.isHeading(session, row)) {\n            row--;\n            break;\n          }\n        }\n        endRow = row;\n        if (endRow > startRow) {\n          while (endRow > startRow && /^\\s*$/.test(session.getLine(endRow))) endRow--;\n        }\n        if (endRow > startRow) {\n          var endColumn = session.getLine(endRow).length;\n          return new Range(startRow, startColumn, endRow, endColumn);\n        }\n      } else if (this.getFoldWidget(session, foldStyle, row) === \"end\") {\n        var endRow = row;\n        var endColumn = session.getLine(endRow).length;\n        while (--row >= 0) {\n          if (this.isHeading(session, row)) {\n            break;\n          }\n        }\n        var line = session.getLine(row);\n        var startColumn = line.length;\n        return new Range(row, startColumn, endRow, endColumn);\n      }\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/haskell_cabal\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/haskell_cabal_highlight_rules\", \"ace/mode/folding/haskell_cabal\"], function (require, exports, module) {\n  /**\n  * Haskell Cabal files mode (https://www.haskell.org/cabal/users-guide/developing-packages.html)\n  **/\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var CabalHighlightRules = require(\"./haskell_cabal_highlight_rules\").CabalHighlightRules;\n  var FoldMode = require(\"./folding/haskell_cabal\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = CabalHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"--\";\n    this.blockComment = null;\n    this.$id = \"ace/mode/haskell_cabal\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/haskell_cabal\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}