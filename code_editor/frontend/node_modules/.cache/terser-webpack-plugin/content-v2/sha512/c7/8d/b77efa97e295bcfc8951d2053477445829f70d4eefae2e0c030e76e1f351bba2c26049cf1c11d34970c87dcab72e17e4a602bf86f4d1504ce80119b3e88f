{"code":"!function(e){if((\"undefined\"==typeof e.window||!e.document)&&(!e.require||!e.define)){e.console||(e.console=function(){var e=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:e})},e.console.error=e.console.warn=e.console.log=e.console.trace=e.console),e.window=e,e.ace=e,e.onerror=function(e,t,n,r,i){postMessage({type:\"error\",data:{message:e,data:i&&i.data,file:t,line:n,col:r,stack:i&&i.stack}})},e.normalizeModule=function(t,n){if(-1!==n.indexOf(\"!\")){var r=n.split(\"!\");return e.normalizeModule(t,r[0])+\"!\"+e.normalizeModule(t,r[1])}if(\".\"==n.charAt(0)){var i=t.split(\"/\").slice(0,-1).join(\"/\");for(n=(i?i+\"/\":\"\")+n;-1!==n.indexOf(\".\")&&o!=n;){var o=n;n=n.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return n},e.require=function(t,n){if(n||(n=t,t=null),!n.charAt)throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");n=e.normalizeModule(t,n);var r=e.require.modules[n];if(r)return r.initialized||(r.initialized=!0,r.exports=r.factory().exports),r.exports;if(!e.require.tlns)return console.log(\"unable to load \"+n);var i=function(e,t){var n=e,r=\"\";for(;n;){var i=t[n];if(\"string\"==typeof i)return i+r;if(i)return i.location.replace(/\\/*$/,\"/\")+(r||i.main||i.name);if(!1===i)return\"\";var o=n.lastIndexOf(\"/\");if(-1===o)break;r=n.substr(o)+r,n=n.slice(0,o)}return e}(n,e.require.tlns);return\".js\"!=i.slice(-3)&&(i+=\".js\"),e.require.id=n,e.require.modules[n]={},importScripts(i),e.require(t,n)},e.require.modules={},e.require.tlns={},e.define=function(t,n,r){if(2==arguments.length?(r=n,\"string\"!=typeof t&&(n=t,t=e.require.id)):1==arguments.length&&(r=t,n=[],t=e.require.id),\"function\"==typeof r){n.length||(n=[\"require\",\"exports\",\"module\"]);var i=function(n){return e.require(t,n)};e.require.modules[t]={exports:{},factory:function(){var e=this,t=r.apply(this,n.slice(0,r.length).map((function(t){switch(t){case\"require\":return i;case\"exports\":return e.exports;case\"module\":return e;default:return i(t)}})));return t&&(e.exports=t),e}}}else e.require.modules[t]={exports:r,initialized:!0}},e.define.amd={},e.require.tlns={},e.initBaseUrls=function(e){for(var t in e)this.require.tlns[t]=e[t]},e.initSender=function(){var t=e.require(\"ace/lib/event_emitter\").EventEmitter,n=e.require(\"ace/lib/oop\"),r=function(){};return function(){n.implement(this,t),this.callback=function(e,t){postMessage({type:\"call\",id:t,data:e})},this.emit=function(e,t){postMessage({type:\"event\",name:e,data:t})}}.call(r.prototype),new r};var t=e.main=null,n=e.sender=null;e.onmessage=function(r){var i=r.data;if(i.event&&n)n._signal(i.event,i.data);else if(i.command)if(t[i.command])t[i.command].apply(t,i.args);else{if(!e[i.command])throw new Error(\"Unknown command:\"+i.command);e[i.command].apply(e,i.args)}else if(i.init){e.initBaseUrls(i.tlns),n=e.sender=e.initSender();var o=this.require(i.module)[i.classname];t=e.main=new o(n)}}}}(this),ace.define(\"ace/lib/oop\",[],(function(e,t,n){\"use strict\";t.inherits=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})},t.mixin=function(e,t){for(var n in t)e[n]=t[n];return e},t.implement=function(e,n){t.mixin(e,n)}})),ace.define(\"ace/apply_delta\",[],(function(e,t,n){\"use strict\";t.applyDelta=function(e,t,n){var r=t.start.row,i=t.start.column,o=e[r]||\"\";switch(t.action){case\"insert\":if(1===t.lines.length)e[r]=o.substring(0,i)+t.lines[0]+o.substring(i);else{var s=[r,1].concat(t.lines);e.splice.apply(e,s),e[r]=o.substring(0,i)+e[r],e[r+t.lines.length-1]+=o.substring(i)}break;case\"remove\":var a=t.end.column,c=t.end.row;r===c?e[r]=o.substring(0,i)+o.substring(a):e.splice(r,c-r+1,o.substring(0,i)+e[c].substring(a))}}})),ace.define(\"ace/lib/event_emitter\",[],(function(e,t,n){\"use strict\";var r={},i=function(){this.propagationStopped=!0},o=function(){this.defaultPrevented=!0};r._emit=r._dispatchEvent=function(e,t){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var n=this._eventRegistry[e]||[],r=this._defaultHandlers[e];if(n.length||r){\"object\"==typeof t&&t||(t={}),t.type||(t.type=e),t.stopPropagation||(t.stopPropagation=i),t.preventDefault||(t.preventDefault=o),n=n.slice();for(var s=0;s<n.length&&(n[s](t,this),!t.propagationStopped);s++);return r&&!t.defaultPrevented?r(t,this):void 0}},r._signal=function(e,t){var n=(this._eventRegistry||{})[e];if(n){n=n.slice();for(var r=0;r<n.length;r++)n[r](t,this)}},r.once=function(e,t){var n=this;if(this.on(e,(function r(){n.off(e,r),t.apply(null,arguments)})),!t)return new Promise((function(e){t=e}))},r.setDefaultHandler=function(e,t){var n=this._defaultHandlers;if(n||(n=this._defaultHandlers={_disabled_:{}}),n[e]){var r=n[e],i=n._disabled_[e];i||(n._disabled_[e]=i=[]),i.push(r);var o=i.indexOf(t);-1!=o&&i.splice(o,1)}n[e]=t},r.removeDefaultHandler=function(e,t){var n=this._defaultHandlers;if(n){var r=n._disabled_[e];if(n[e]==t)r&&this.setDefaultHandler(e,r.pop());else if(r){var i=r.indexOf(t);-1!=i&&r.splice(i,1)}}},r.on=r.addEventListener=function(e,t,n){this._eventRegistry=this._eventRegistry||{};var r=this._eventRegistry[e];return r||(r=this._eventRegistry[e]=[]),-1==r.indexOf(t)&&r[n?\"unshift\":\"push\"](t),t},r.off=r.removeListener=r.removeEventListener=function(e,t){this._eventRegistry=this._eventRegistry||{};var n=this._eventRegistry[e];if(n){var r=n.indexOf(t);-1!==r&&n.splice(r,1)}},r.removeAllListeners=function(e){e||(this._eventRegistry=this._defaultHandlers=void 0),this._eventRegistry&&(this._eventRegistry[e]=void 0),this._defaultHandlers&&(this._defaultHandlers[e]=void 0)},t.EventEmitter=r})),ace.define(\"ace/range\",[],(function(e,t,n){\"use strict\";var r=function(e,t,n,r){this.start={row:e,column:t},this.end={row:n,column:r}};(function(){this.isEqual=function(e){return this.start.row===e.start.row&&this.end.row===e.end.row&&this.start.column===e.start.column&&this.end.column===e.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(e,t){return 0==this.compare(e,t)},this.compareRange=function(e){var t,n=e.end,r=e.start;return 1==(t=this.compare(n.row,n.column))?1==(t=this.compare(r.row,r.column))?2:0==t?1:0:-1==t?-2:-1==(t=this.compare(r.row,r.column))?-1:1==t?42:0},this.comparePoint=function(e){return this.compare(e.row,e.column)},this.containsRange=function(e){return 0==this.comparePoint(e.start)&&0==this.comparePoint(e.end)},this.intersects=function(e){var t=this.compareRange(e);return-1==t||0==t||1==t},this.isEnd=function(e,t){return this.end.row==e&&this.end.column==t},this.isStart=function(e,t){return this.start.row==e&&this.start.column==t},this.setStart=function(e,t){\"object\"==typeof e?(this.start.column=e.column,this.start.row=e.row):(this.start.row=e,this.start.column=t)},this.setEnd=function(e,t){\"object\"==typeof e?(this.end.column=e.column,this.end.row=e.row):(this.end.row=e,this.end.column=t)},this.inside=function(e,t){return 0==this.compare(e,t)&&(!this.isEnd(e,t)&&!this.isStart(e,t))},this.insideStart=function(e,t){return 0==this.compare(e,t)&&!this.isEnd(e,t)},this.insideEnd=function(e,t){return 0==this.compare(e,t)&&!this.isStart(e,t)},this.compare=function(e,t){return this.isMultiLine()||e!==this.start.row?e<this.start.row?-1:e>this.end.row?1:this.start.row===e?t>=this.start.column?0:-1:this.end.row===e?t<=this.end.column?0:1:0:t<this.start.column?-1:t>this.end.column?1:0},this.compareStart=function(e,t){return this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},this.compareEnd=function(e,t){return this.end.row==e&&this.end.column==t?1:this.compare(e,t)},this.compareInside=function(e,t){return this.end.row==e&&this.end.column==t?1:this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},this.clipRows=function(e,t){if(this.end.row>t)var n={row:t+1,column:0};else if(this.end.row<e)n={row:e,column:0};if(this.start.row>t)var i={row:t+1,column:0};else if(this.start.row<e)i={row:e,column:0};return r.fromPoints(i||this.start,n||this.end)},this.extend=function(e,t){var n=this.compare(e,t);if(0==n)return this;if(-1==n)var i={row:e,column:t};else var o={row:e,column:t};return r.fromPoints(i||this.start,o||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return r.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new r(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new r(this.start.row,0,this.end.row,0)},this.toScreenRange=function(e){var t=e.documentToScreenPosition(this.start),n=e.documentToScreenPosition(this.end);return new r(t.row,t.column,n.row,n.column)},this.moveBy=function(e,t){this.start.row+=e,this.start.column+=t,this.end.row+=e,this.end.column+=t}}).call(r.prototype),r.fromPoints=function(e,t){return new r(e.row,e.column,t.row,t.column)},r.comparePoints=function(e,t){return e.row-t.row||e.column-t.column},r.comparePoints=function(e,t){return e.row-t.row||e.column-t.column},t.Range=r})),ace.define(\"ace/anchor\",[],(function(e,t,n){\"use strict\";var r=e(\"./lib/oop\"),i=e(\"./lib/event_emitter\").EventEmitter,o=t.Anchor=function(e,t,n){this.$onChange=this.onChange.bind(this),this.attach(e),\"undefined\"==typeof n?this.setPosition(t.row,t.column):this.setPosition(t,n)};(function(){function e(e,t,n){var r=n?e.column<=t.column:e.column<t.column;return e.row<t.row||e.row==t.row&&r}r.implement(this,i),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(t){if((t.start.row!=t.end.row||t.start.row==this.row)&&!(t.start.row>this.row)){var n=function(t,n,r){var i=\"insert\"==t.action,o=(i?1:-1)*(t.end.row-t.start.row),s=(i?1:-1)*(t.end.column-t.start.column),a=t.start,c=i?a:t.end;if(e(n,a,r))return{row:n.row,column:n.column};if(e(c,n,!r))return{row:n.row+o,column:n.column+(n.row==c.row?s:0)};return{row:a.row,column:a.column}}(t,{row:this.row,column:this.column},this.$insertRight);this.setPosition(n.row,n.column,!0)}},this.setPosition=function(e,t,n){var r;if(r=n?{row:e,column:t}:this.$clipPositionToDocument(e,t),this.row!=r.row||this.column!=r.column){var i={row:this.row,column:this.column};this.row=r.row,this.column=r.column,this._signal(\"change\",{old:i,value:r})}},this.detach=function(){this.document.off(\"change\",this.$onChange)},this.attach=function(e){this.document=e||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(e,t){var n={};return e>=this.document.getLength()?(n.row=Math.max(0,this.document.getLength()-1),n.column=this.document.getLine(n.row).length):e<0?(n.row=0,n.column=0):(n.row=e,n.column=Math.min(this.document.getLine(n.row).length,Math.max(0,t))),t<0&&(n.column=0),n}}).call(o.prototype)})),ace.define(\"ace/document\",[],(function(e,t,n){\"use strict\";var r=e(\"./lib/oop\"),i=e(\"./apply_delta\").applyDelta,o=e(\"./lib/event_emitter\").EventEmitter,s=e(\"./range\").Range,a=e(\"./anchor\").Anchor,c=function(e){this.$lines=[\"\"],0===e.length?this.$lines=[\"\"]:Array.isArray(e)?this.insertMergedLines({row:0,column:0},e):this.insert({row:0,column:0},e)};(function(){r.implement(this,o),this.setValue=function(e){var t=this.getLength()-1;this.remove(new s(0,0,t,this.getLine(t).length)),this.insert({row:0,column:0},e||\"\")},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(e,t){return new a(this,e,t)},0===\"aaa\".split(/a/).length?this.$split=function(e){return e.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:this.$split=function(e){return e.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(e){var t=e.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=t?t[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(e){this.$newLineMode!==e&&(this.$newLineMode=e,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(e){return\"\\r\\n\"==e||\"\\r\"==e||\"\\n\"==e},this.getLine=function(e){return this.$lines[e]||\"\"},this.getLines=function(e,t){return this.$lines.slice(e,t+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(e){return this.getLinesForRange(e).join(this.getNewLineCharacter())},this.getLinesForRange=function(e){var t;if(e.start.row===e.end.row)t=[this.getLine(e.start.row).substring(e.start.column,e.end.column)];else{(t=this.getLines(e.start.row,e.end.row))[0]=(t[0]||\"\").substring(e.start.column);var n=t.length-1;e.end.row-e.start.row==n&&(t[n]=t[n].substring(0,e.end.column))}return t},this.insertLines=function(e,t){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(e,t)},this.removeLines=function(e,t){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(e,t)},this.insertNewLine=function(e){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(e,[\"\",\"\"])},this.insert=function(e,t){return this.getLength()<=1&&this.$detectNewLine(t),this.insertMergedLines(e,this.$split(t))},this.insertInLine=function(e,t){var n=this.clippedPos(e.row,e.column),r=this.pos(e.row,e.column+t.length);return this.applyDelta({start:n,end:r,action:\"insert\",lines:[t]},!0),this.clonePos(r)},this.clippedPos=function(e,t){var n=this.getLength();void 0===e?e=n:e<0?e=0:e>=n&&(e=n-1,t=void 0);var r=this.getLine(e);return void 0==t&&(t=r.length),{row:e,column:t=Math.min(Math.max(t,0),r.length)}},this.clonePos=function(e){return{row:e.row,column:e.column}},this.pos=function(e,t){return{row:e,column:t}},this.$clipPosition=function(e){var t=this.getLength();return e.row>=t?(e.row=Math.max(0,t-1),e.column=this.getLine(t-1).length):(e.row=Math.max(0,e.row),e.column=Math.min(Math.max(e.column,0),this.getLine(e.row).length)),e},this.insertFullLines=function(e,t){var n=0;(e=Math.min(Math.max(e,0),this.getLength()))<this.getLength()?(t=t.concat([\"\"]),n=0):(t=[\"\"].concat(t),e--,n=this.$lines[e].length),this.insertMergedLines({row:e,column:n},t)},this.insertMergedLines=function(e,t){var n=this.clippedPos(e.row,e.column),r={row:n.row+t.length-1,column:(1==t.length?n.column:0)+t[t.length-1].length};return this.applyDelta({start:n,end:r,action:\"insert\",lines:t}),this.clonePos(r)},this.remove=function(e){var t=this.clippedPos(e.start.row,e.start.column),n=this.clippedPos(e.end.row,e.end.column);return this.applyDelta({start:t,end:n,action:\"remove\",lines:this.getLinesForRange({start:t,end:n})}),this.clonePos(t)},this.removeInLine=function(e,t,n){var r=this.clippedPos(e,t),i=this.clippedPos(e,n);return this.applyDelta({start:r,end:i,action:\"remove\",lines:this.getLinesForRange({start:r,end:i})},!0),this.clonePos(r)},this.removeFullLines=function(e,t){e=Math.min(Math.max(0,e),this.getLength()-1);var n=(t=Math.min(Math.max(0,t),this.getLength()-1))==this.getLength()-1&&e>0,r=t<this.getLength()-1,i=n?e-1:e,o=n?this.getLine(i).length:0,a=r?t+1:t,c=r?0:this.getLine(a).length,u=new s(i,o,a,c),l=this.$lines.slice(e,t+1);return this.applyDelta({start:u.start,end:u.end,action:\"remove\",lines:this.getLinesForRange(u)}),l},this.removeNewLine=function(e){e<this.getLength()-1&&e>=0&&this.applyDelta({start:this.pos(e,this.getLine(e).length),end:this.pos(e+1,0),action:\"remove\",lines:[\"\",\"\"]})},this.replace=function(e,t){return e instanceof s||(e=s.fromPoints(e.start,e.end)),0===t.length&&e.isEmpty()?e.start:t==this.getTextRange(e)?e.end:(this.remove(e),t?this.insert(e.start,t):e.start)},this.applyDeltas=function(e){for(var t=0;t<e.length;t++)this.applyDelta(e[t])},this.revertDeltas=function(e){for(var t=e.length-1;t>=0;t--)this.revertDelta(e[t])},this.applyDelta=function(e,t){var n=\"insert\"==e.action;(n?e.lines.length<=1&&!e.lines[0]:!s.comparePoints(e.start,e.end))||(n&&e.lines.length>2e4?this.$splitAndapplyLargeDelta(e,2e4):(i(this.$lines,e,t),this._signal(\"change\",e)))},this.$safeApplyDelta=function(e){var t=this.$lines.length;(\"remove\"==e.action&&e.start.row<t&&e.end.row<t||\"insert\"==e.action&&e.start.row<=t)&&this.applyDelta(e)},this.$splitAndapplyLargeDelta=function(e,t){for(var n=e.lines,r=n.length-t+1,i=e.start.row,o=e.start.column,s=0,a=0;s<r;s=a){a+=t-1;var c=n.slice(s,a);c.push(\"\"),this.applyDelta({start:this.pos(i+s,o),end:this.pos(i+a,o=0),action:e.action,lines:c},!0)}e.lines=n.slice(s),e.start.row=i+s,e.start.column=o,this.applyDelta(e,!0)},this.revertDelta=function(e){this.$safeApplyDelta({start:this.clonePos(e.start),end:this.clonePos(e.end),action:\"insert\"==e.action?\"remove\":\"insert\",lines:e.lines.slice()})},this.indexToPosition=function(e,t){for(var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=t||0,o=n.length;i<o;i++)if((e-=n[i].length+r)<0)return{row:i,column:e+n[i].length+r};return{row:o-1,column:e+n[o-1].length+r}},this.positionToIndex=function(e,t){for(var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=0,o=Math.min(e.row,n.length),s=t||0;s<o;++s)i+=n[s].length+r;return i+e.column}}).call(c.prototype),t.Document=c})),ace.define(\"ace/lib/lang\",[],(function(e,t,n){\"use strict\";t.last=function(e){return e[e.length-1]},t.stringReverse=function(e){return e.split(\"\").reverse().join(\"\")},t.stringRepeat=function(e,t){for(var n=\"\";t>0;)1&t&&(n+=e),(t>>=1)&&(e+=e);return n};var r=/^\\s\\s*/,i=/\\s\\s*$/;t.stringTrimLeft=function(e){return e.replace(r,\"\")},t.stringTrimRight=function(e){return e.replace(i,\"\")},t.copyObject=function(e){var t={};for(var n in e)t[n]=e[n];return t},t.copyArray=function(e){for(var t=[],n=0,r=e.length;n<r;n++)e[n]&&\"object\"==typeof e[n]?t[n]=this.copyObject(e[n]):t[n]=e[n];return t},t.deepCopy=function e(t){if(\"object\"!==typeof t||!t)return t;var n;if(Array.isArray(t)){n=[];for(var r=0;r<t.length;r++)n[r]=e(t[r]);return n}if(\"[object Object]\"!==Object.prototype.toString.call(t))return t;for(var r in n={},t)n[r]=e(t[r]);return n},t.arrayToMap=function(e){for(var t={},n=0;n<e.length;n++)t[e[n]]=1;return t},t.createMap=function(e){var t=Object.create(null);for(var n in e)t[n]=e[n];return t},t.arrayRemove=function(e,t){for(var n=0;n<=e.length;n++)t===e[n]&&e.splice(n,1)},t.escapeRegExp=function(e){return e.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},t.escapeHTML=function(e){return(\"\"+e).replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},t.getMatchOffsets=function(e,t){var n=[];return e.replace(t,(function(e){n.push({offset:arguments[arguments.length-2],length:e.length})})),n},t.deferredCall=function(e){var t=null,n=function(){t=null,e()},r=function e(r){return e.cancel(),t=setTimeout(n,r||0),e};return r.schedule=r,r.call=function(){return this.cancel(),e(),r},r.cancel=function(){return clearTimeout(t),t=null,r},r.isPending=function(){return t},r},t.delayedCall=function(e,t){var n=null,r=function(){n=null,e()},i=function(e){null==n&&(n=setTimeout(r,e||t))};return i.delay=function(e){n&&clearTimeout(n),n=setTimeout(r,e||t)},i.schedule=i,i.call=function(){this.cancel(),e()},i.cancel=function(){n&&clearTimeout(n),n=null},i.isPending=function(){return n},i}})),ace.define(\"ace/worker/mirror\",[],(function(e,t,n){\"use strict\";var r=e(\"../document\").Document,i=e(\"../lib/lang\"),o=t.Mirror=function(e){this.sender=e;var t=this.doc=new r(\"\"),n=this.deferredUpdate=i.delayedCall(this.onUpdate.bind(this)),o=this;e.on(\"change\",(function(e){var r=e.data;if(r[0].start)t.applyDeltas(r);else for(var i=0;i<r.length;i+=2){var s,a;if((\"insert\"==(s=Array.isArray(r[i+1])?{action:\"insert\",start:r[i],lines:r[i+1]}:{action:\"remove\",start:r[i],end:r[i+1]}).action?s.start:s.end).row>=t.$lines.length)throw(a=new Error(\"Invalid delta\")).data={path:o.$path,linesLength:t.$lines.length,start:s.start,end:s.end},a;t.applyDelta(s,!0)}if(o.$timeout)return n.schedule(o.$timeout);o.onUpdate()}))};(function(){this.$timeout=500,this.setTimeout=function(e){this.$timeout=e},this.setValue=function(e){this.doc.setValue(e),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(e){this.sender.callback(this.doc.getValue(),e)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(o.prototype)})),ace.define(\"ace/mode/lua/luaparse\",[],(function(e,t,n){!function(e){\"use strict\";var t,n,r,i,o;e.version=\"0.3.1\";var s=e.defaultOptions={wait:!1,comments:!0,scope:!1,locations:!1,ranges:!1,onCreateNode:null,onCreateScope:null,onDestroyScope:null,onLocalDeclaration:null,luaVersion:\"5.3\",encodingMode:\"none\"};function a(e,t){return t=t||0,e<128?String.fromCharCode(e):e<2048?String.fromCharCode(192|t|e>>6,128|t|63&e):e<65536?String.fromCharCode(224|t|e>>12,128|t|e>>6&63,128|t|63&e):e<1114112?String.fromCharCode(240|t|e>>18,128|t|e>>12&63,128|t|e>>6&63,128|t|63&e):null}function c(e,t){for(var n=e.toString(16);n.length<t;)n=\"0\"+n;return n}function u(e){return function(t){var n=e.exec(t);if(!n)return t;F(null,b.invalidCodeUnit,c(n[0].charCodeAt(0),4).toUpperCase())}}var l={\"pseudo-latin1\":{fixup:u(/[^\\x00-\\xff]/),encodeByte:function(e){return null===e?\"\":String.fromCharCode(e)},encodeUTF8:function(e){return a(e)}},\"x-user-defined\":{fixup:u(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),encodeByte:function(e){return null===e?\"\":e>=128?String.fromCharCode(63232|e):String.fromCharCode(e)},encodeUTF8:function(e){return a(e,63232)}},none:{discardStrings:!0,fixup:function(e){return e},encodeByte:function(e){return\"\"},encodeUTF8:function(e){return\"\"}}},h=1,p=2,f=4,d=8,m=16,g=32,v=64,w=128,y=256;e.tokenTypes={EOF:h,StringLiteral:p,Keyword:f,Identifier:d,NumericLiteral:m,Punctuator:g,BooleanLiteral:v,NilLiteral:w,VarargLiteral:y};var b=e.errors={unexpected:\"unexpected %1 '%2' near '%3'\",unexpectedEOF:\"unexpected symbol near '<eof>'\",expected:\"'%1' expected near '%2'\",expectedToken:\"%1 expected near '%2'\",unfinishedString:\"unfinished string near '%1'\",malformedNumber:\"malformed number near '%1'\",decimalEscapeTooLarge:\"decimal escape too large near '%1'\",invalidEscape:\"invalid escape sequence near '%1'\",hexadecimalDigitExpected:\"hexadecimal digit expected near '%1'\",braceExpected:\"missing '%1' near '%2'\",tooLargeCodepoint:\"UTF-8 value too large near '%1'\",unfinishedLongString:\"unfinished long string (starting at line %1) near '%2'\",unfinishedLongComment:\"unfinished long comment (starting at line %1) near '%2'\",ambiguousSyntax:\"ambiguous syntax (function call x new statement) near '%1'\",noLoopToBreak:\"no loop to break near '%1'\",labelAlreadyDefined:\"label '%1' already defined on line %2\",labelNotVisible:\"no visible label '%1' for <goto>\",gotoJumpInLocalScope:\"<goto %1> jumps into the scope of local '%2'\",cannotUseVararg:\"cannot use '...' outside a vararg function near '%1'\",invalidCodeUnit:\"code unit U+%1 is not allowed in the current encoding mode\"},x=e.ast={labelStatement:function(e){return{type:\"LabelStatement\",label:e}},breakStatement:function(){return{type:\"BreakStatement\"}},gotoStatement:function(e){return{type:\"GotoStatement\",label:e}},returnStatement:function(e){return{type:\"ReturnStatement\",arguments:e}},ifStatement:function(e){return{type:\"IfStatement\",clauses:e}},ifClause:function(e,t){return{type:\"IfClause\",condition:e,body:t}},elseifClause:function(e,t){return{type:\"ElseifClause\",condition:e,body:t}},elseClause:function(e){return{type:\"ElseClause\",body:e}},whileStatement:function(e,t){return{type:\"WhileStatement\",condition:e,body:t}},doStatement:function(e){return{type:\"DoStatement\",body:e}},repeatStatement:function(e,t){return{type:\"RepeatStatement\",condition:e,body:t}},localStatement:function(e,t){return{type:\"LocalStatement\",variables:e,init:t}},assignmentStatement:function(e,t){return{type:\"AssignmentStatement\",variables:e,init:t}},callStatement:function(e){return{type:\"CallStatement\",expression:e}},functionStatement:function(e,t,n,r){return{type:\"FunctionDeclaration\",identifier:e,isLocal:n,parameters:t,body:r}},forNumericStatement:function(e,t,n,r,i){return{type:\"ForNumericStatement\",variable:e,start:t,end:n,step:r,body:i}},forGenericStatement:function(e,t,n){return{type:\"ForGenericStatement\",variables:e,iterators:t,body:n}},chunk:function(e){return{type:\"Chunk\",body:e}},identifier:function(e){return{type:\"Identifier\",name:e}},literal:function(e,t,n){return{type:e=e===p?\"StringLiteral\":e===m?\"NumericLiteral\":e===v?\"BooleanLiteral\":e===w?\"NilLiteral\":\"VarargLiteral\",value:t,raw:n}},tableKey:function(e,t){return{type:\"TableKey\",key:e,value:t}},tableKeyString:function(e,t){return{type:\"TableKeyString\",key:e,value:t}},tableValue:function(e){return{type:\"TableValue\",value:e}},tableConstructorExpression:function(e){return{type:\"TableConstructorExpression\",fields:e}},binaryExpression:function(e,t,n){return{type:\"and\"===e||\"or\"===e?\"LogicalExpression\":\"BinaryExpression\",operator:e,left:t,right:n}},unaryExpression:function(e,t){return{type:\"UnaryExpression\",operator:e,argument:t}},memberExpression:function(e,t,n){return{type:\"MemberExpression\",indexer:t,identifier:n,base:e}},indexExpression:function(e,t){return{type:\"IndexExpression\",base:e,index:t}},callExpression:function(e,t){return{type:\"CallExpression\",base:e,arguments:t}},tableCallExpression:function(e,t){return{type:\"TableCallExpression\",base:e,arguments:t}},stringCallExpression:function(e,t){return{type:\"StringCallExpression\",base:e,argument:t}},comment:function(e,t){return{type:\"Comment\",value:e,raw:t}}};function L(e){if(Ee){var t=Ae.pop();t.complete(),t.bless(e)}return n.onCreateNode&&n.onCreateNode(e),e}var S=Array.prototype.slice,C=(Object.prototype.toString,function(e,t){for(var n=0,r=e.length;n<r;++n)if(e[n]===t)return n;return-1});function E(e,t,n){for(var r=0,i=e.length;r<i;++r)if(e[r][t]===n)return r;return-1}function A(e){var t=S.call(arguments,1);return e=e.replace(/%(\\d)/g,(function(e,n){return\"\"+t[n-1]||\"\"})),e}Array.prototype.indexOf&&(C=function(e,t){return e.indexOf(t)});var k,D,P,M,O,$,_,N,T,R,j,U=function(e){for(var t,n,r=S.call(arguments,1),i=0,o=r.length;i<o;++i)for(n in t=r[i])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e};function I(e){return Object.create?Object.create(e,{line:{writable:!0,value:e.line},index:{writable:!0,value:e.index},column:{writable:!0,value:e.column}}):e}function F(e){var t,n,r=A.apply(null,S.call(arguments,1));throw null===e||\"undefined\"===typeof e.line?(n=k-N+1,(t=I(new SyntaxError(A(\"[%1:%2] %3\",_,n,r)))).index=k,t.line=_,t.column=n):(n=e.range[0]-e.lineStart,(t=I(new SyntaxError(A(\"[%1:%2] %3\",e.line,n,r)))).line=e.line,t.index=e.range[0],t.column=n),t}function q(e){var n=t.slice(e.range[0],e.range[1]);return n||e.value}function V(e,t){F(t,b.expectedToken,e,q(t))}function G(e){var t=q(M);if(\"undefined\"!==typeof e.type){var n;switch(e.type){case p:n=\"string\";break;case f:n=\"keyword\";break;case d:n=\"identifier\";break;case m:n=\"number\";break;case g:n=\"symbol\";break;case v:n=\"boolean\";break;case w:return F(e,b.unexpected,\"symbol\",\"nil\",t);case h:return F(e,b.unexpectedEOF)}return F(e,b.unexpected,n,q(e),t)}return F(e,b.unexpected,\"symbol\",e,t)}function B(){for(z();45===t.charCodeAt(k)&&45===t.charCodeAt(k+1);)oe(),z();if(k>=r)return{type:h,value:\"<eof>\",line:_,lineStart:N,range:[k,k]};var e=t.charCodeAt(k),n=t.charCodeAt(k+1);if($=k,de(e))return K();switch(e){case 39:case 34:return X();case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return Y();case 46:return pe(n)?Y():46===n?46===t.charCodeAt(k+2)?J():W(\"..\"):W(\".\");case 61:return W(61===n?\"==\":\"=\");case 62:return i.bitwiseOperators&&62===n?W(\">>\"):W(61===n?\">=\":\">\");case 60:return i.bitwiseOperators&&60===n?W(\"<<\"):W(61===n?\"<=\":\"<\");case 126:if(61===n)return W(\"~=\");if(!i.bitwiseOperators)break;return W(\"~\");case 58:return i.labels&&58===n?W(\"::\"):W(\":\");case 91:return 91===n||61===n?Q():W(\"[\");case 47:return i.integerDivision&&47===n?W(\"//\"):W(\"/\");case 38:case 124:if(!i.bitwiseOperators)break;case 42:case 94:case 37:case 44:case 123:case 125:case 93:case 40:case 41:case 59:case 35:case 45:case 43:return W(t.charAt(k))}return G(t.charAt(k))}function H(){var e=t.charCodeAt(k),n=t.charCodeAt(k+1);return!!he(e)&&(10===e&&13===n&&++k,13===e&&10===n&&++k,++_,N=++k,!0)}function z(){for(;k<r;)if(le(t.charCodeAt(k)))++k;else if(!H())break}function K(){for(var e,n;me(t.charCodeAt(++k)););return ge(e=o.fixup(t.slice($,k)))?n=f:\"true\"===e||\"false\"===e?(n=v,e=\"true\"===e):\"nil\"===e?(n=w,e=null):n=d,{type:n,value:e,line:_,lineStart:N,range:[$,k]}}function W(e){return k+=e.length,{type:g,value:e,line:_,lineStart:N,range:[$,k]}}function J(){return{type:y,value:\"...\",line:_,lineStart:N,range:[$,k+=3]}}function X(){for(var e,n=t.charCodeAt(k++),i=_,s=N,a=k,c=o.discardStrings?null:\"\";n!==(e=t.charCodeAt(k++));)if((k>r||he(e))&&(c+=t.slice(a,k-1),F(null,b.unfinishedString,t.slice($,k-1))),92===e){if(!o.discardStrings){var u=t.slice(a,k-1);c+=o.fixup(u)}var l=ie();o.discardStrings||(c+=l),a=k}return o.discardStrings||(c+=o.encodeByte(null),c+=o.fixup(t.slice(a,k-1))),{type:p,value:c,line:i,lineStart:s,lastLine:_,lastLineStart:N,range:[$,k]}}function Q(){var e=_,t=N,n=se(!1);return!1===n&&F(D,b.expected,\"[\",q(D)),{type:p,value:o.discardStrings?null:o.fixup(n),line:e,lineStart:t,lastLine:_,lastLineStart:N,range:[$,k]}}function Y(){var e=t.charAt(k),n=t.charAt(k+1),r=\"0\"===e&&\"xX\".indexOf(n||null)>=0?te():ne(),i=Z();return ee()&&(i||r.hasFractionPart)&&F(null,b.malformedNumber,t.slice($,k)),{type:m,value:r.value,line:_,lineStart:N,range:[$,k]}}function Z(){if(i.imaginaryNumbers)return\"iI\".indexOf(t.charAt(k)||null)>=0&&(++k,!0)}function ee(){if(i.integerSuffixes)if(\"uU\".indexOf(t.charAt(k)||null)>=0)if(++k,\"lL\".indexOf(t.charAt(k)||null)>=0){if(++k,\"lL\".indexOf(t.charAt(k)||null)>=0)return++k,\"ULL\";F(null,b.malformedNumber,t.slice($,k))}else F(null,b.malformedNumber,t.slice($,k));else if(\"lL\".indexOf(t.charAt(k)||null)>=0){if(++k,\"lL\".indexOf(t.charAt(k)||null)>=0)return++k,\"LL\";F(null,b.malformedNumber,t.slice($,k))}}function te(){var e,n,r,i,o=0,s=1,a=1;for(i=k+=2,fe(t.charCodeAt(k))||F(null,b.malformedNumber,t.slice($,k));fe(t.charCodeAt(k));)++k;e=parseInt(t.slice(i,k),16);var c=!1;if(\".\"===t.charAt(k)){for(c=!0,n=++k;fe(t.charCodeAt(k));)++k;o=t.slice(n,k),o=n===k?0:parseInt(o,16)/Math.pow(16,k-n)}var u=!1;if(\"pP\".indexOf(t.charAt(k)||null)>=0){for(u=!0,++k,\"+-\".indexOf(t.charAt(k)||null)>=0&&(a=\"+\"===t.charAt(k++)?1:-1),r=k,pe(t.charCodeAt(k))||F(null,b.malformedNumber,t.slice($,k));pe(t.charCodeAt(k));)++k;s=t.slice(r,k),s=Math.pow(2,s*a)}return{value:(e+o)*s,hasFractionPart:c||u}}function ne(){for(;pe(t.charCodeAt(k));)++k;var e=!1;if(\".\"===t.charAt(k))for(e=!0,++k;pe(t.charCodeAt(k));)++k;var n=!1;if(\"eE\".indexOf(t.charAt(k)||null)>=0)for(n=!0,++k,\"+-\".indexOf(t.charAt(k)||null)>=0&&++k,pe(t.charCodeAt(k))||F(null,b.malformedNumber,t.slice($,k));pe(t.charCodeAt(k));)++k;return{value:parseFloat(t.slice($,k)),hasFractionPart:e||n}}function re(){var e=k++;for(\"{\"!==t.charAt(k++)&&F(null,b.braceExpected,\"{\",\"\\\\\"+t.slice(e,k)),fe(t.charCodeAt(k))||F(null,b.hexadecimalDigitExpected,\"\\\\\"+t.slice(e,k));48===t.charCodeAt(k);)++k;for(var n=k;fe(t.charCodeAt(k));)++k-n>6&&F(null,b.tooLargeCodepoint,\"\\\\\"+t.slice(e,k));var r=t.charAt(k++);\"}\"!==r&&('\"'===r||\"'\"===r?F(null,b.braceExpected,\"}\",\"\\\\\"+t.slice(e,k--)):F(null,b.hexadecimalDigitExpected,\"\\\\\"+t.slice(e,k)));var i=parseInt(t.slice(n,k-1)||\"0\",16),s=\"\\\\\"+t.slice(e,k);return i>1114111&&F(null,b.tooLargeCodepoint,s),o.encodeUTF8(i,s)}function ie(){var e=k;switch(t.charAt(k)){case\"a\":return++k,\"\\x07\";case\"n\":return++k,\"\\n\";case\"r\":return++k,\"\\r\";case\"t\":return++k,\"\\t\";case\"v\":return++k,\"\\v\";case\"b\":return++k,\"\\b\";case\"f\":return++k,\"\\f\";case\"\\r\":case\"\\n\":return H(),\"\\n\";case\"0\":case\"1\":case\"2\":case\"3\":case\"4\":case\"5\":case\"6\":case\"7\":case\"8\":case\"9\":for(;pe(t.charCodeAt(k))&&k-e<3;)++k;var n=t.slice(e,k),r=parseInt(n,10);return r>255&&F(null,b.decimalEscapeTooLarge,\"\\\\\"+r),o.encodeByte(r,\"\\\\\"+n);case\"z\":if(i.skipWhitespaceEscape)return++k,z(),\"\";break;case\"x\":if(i.hexEscapes){if(fe(t.charCodeAt(k+1))&&fe(t.charCodeAt(k+2)))return k+=3,o.encodeByte(parseInt(t.slice(e+1,k),16),\"\\\\\"+t.slice(e,k));F(null,b.hexadecimalDigitExpected,\"\\\\\"+t.slice(e,k+2))}break;case\"u\":if(i.unicodeEscapes)return re();break;case\"\\\\\":case'\"':case\"'\":return t.charAt(k++)}return i.strictEscapes&&F(null,b.invalidEscape,\"\\\\\"+t.slice(e,k+1)),t.charAt(k++)}function oe(){$=k,k+=2;var e=t.charAt(k),i=\"\",o=!1,s=k,a=N,c=_;if(\"[\"===e&&(!1===(i=se(!0))?i=e:o=!0),!o){for(;k<r&&!he(t.charCodeAt(k));)++k;n.comments&&(i=t.slice(s,k))}if(n.comments){var u=x.comment(i,t.slice($,k));n.locations&&(u.loc={start:{line:c,column:$-a},end:{line:_,column:k-N}}),n.ranges&&(u.range=[$,k]),n.onCreateNode&&n.onCreateNode(u),O.push(u)}}function se(e){var n,i=0,o=\"\",s=!1,a=_;for(++k;\"=\"===t.charAt(k+i);)++i;if(\"[\"!==t.charAt(k+i))return!1;for(k+=i+1,he(t.charCodeAt(k))&&H(),n=k;k<r;){for(;he(t.charCodeAt(k));)H();if(\"]\"===t.charAt(k++)){s=!0;for(var c=0;c<i;++c)\"=\"!==t.charAt(k+c)&&(s=!1);\"]\"!==t.charAt(k+i)&&(s=!1)}if(s)return o+=t.slice(n,k-1),k+=i+1,o}F(null,e?b.unfinishedLongComment:b.unfinishedLongString,a,\"<eof>\")}function ae(){P=D,D=M,M=B()}function ce(e){return e===D.value&&(ae(),!0)}function ue(e){e===D.value?ae():F(D,b.expected,e,q(D))}function le(e){return 9===e||32===e||11===e||12===e}function he(e){return 10===e||13===e}function pe(e){return e>=48&&e<=57}function fe(e){return e>=48&&e<=57||e>=97&&e<=102||e>=65&&e<=70}function de(e){return e>=65&&e<=90||e>=97&&e<=122||95===e||!!(i.extendedIdentifiers&&e>=128)}function me(e){return e>=65&&e<=90||e>=97&&e<=122||95===e||e>=48&&e<=57||!!(i.extendedIdentifiers&&e>=128)}function ge(e){switch(e.length){case 2:return\"do\"===e||\"if\"===e||\"in\"===e||\"or\"===e;case 3:return\"and\"===e||\"end\"===e||\"for\"===e||\"not\"===e;case 4:return\"else\"===e||\"then\"===e||!(!i.labels||i.contextualGoto)&&\"goto\"===e;case 5:return\"break\"===e||\"local\"===e||\"until\"===e||\"while\"===e;case 6:return\"elseif\"===e||\"repeat\"===e||\"return\"===e;case 8:return\"function\"===e}return!1}function ve(e){return g===e.type?\"#-~\".indexOf(e.value)>=0:f===e.type&&\"not\"===e.value}function we(e){if(h===e.type)return!0;if(f!==e.type)return!1;switch(e.value){case\"else\":case\"elseif\":case\"end\":case\"until\":return!0;default:return!1}}function ye(){var e=T[R++].slice();T.push(e),n.onCreateScope&&n.onCreateScope()}function be(){T.pop(),--R,n.onDestroyScope&&n.onDestroyScope()}function xe(e){n.onLocalDeclaration&&n.onLocalDeclaration(e),-1===C(T[R],e)&&T[R].push(e)}function Le(e){xe(e.name),Se(e,!0)}function Se(e,t){t||-1!==E(j,\"name\",e.name)||j.push(e),e.isLocal=t}function Ce(e){return-1!==C(T[R],e)}Object.assign&&(U=Object.assign),e.SyntaxError=SyntaxError,e.lex=B;var Ee,Ae=[];function ke(){return new De(D)}function De(e){n.locations&&(this.loc={start:{line:e.line,column:e.range[0]-e.lineStart},end:{line:0,column:0}}),n.ranges&&(this.range=[e.range[0],0])}function Pe(){Ee&&Ae.push(ke())}function Me(e){Ee&&Ae.push(e)}function Oe(){this.scopes=[],this.pendingGotos=[]}function $e(){this.level=0,this.loopLevels=[]}function _e(){return i.labels?new Oe:new $e}function Ne(){ae(),Pe(),n.scope&&ye();var e=_e();e.allowVararg=!0,e.pushScope();var t=Te(e);return e.popScope(),n.scope&&be(),h!==D.type&&G(D),Ee&&!t.length&&(P=D),L(x.chunk(t))}function Te(e){for(var t,n=[];!we(D);){if(\"return\"===D.value||!i.relaxedBreak&&\"break\"===D.value){n.push(Re(e));break}t=Re(e),ce(\";\"),t&&n.push(t)}return n}function Re(e){if(Pe(),g===D.type&&ce(\"::\"))return je(e);if(!i.emptyStatement||!ce(\";\")){if(e.raiseDeferredErrors(),f===D.type)switch(D.value){case\"local\":return ae(),ze(e);case\"if\":return ae(),Be(e);case\"return\":return ae(),Ge(e);case\"function\":return ae(),Je(Xe());case\"while\":return ae(),qe(e);case\"for\":return ae(),He(e);case\"repeat\":return ae(),Ve(e);case\"break\":return ae(),e.isInLoop()||F(D,b.noLoopToBreak,D.value),Ue();case\"do\":return ae(),Fe(e);case\"goto\":return ae(),Ie(e)}return i.contextualGoto&&D.type===d&&\"goto\"===D.value&&M.type===d&&\"goto\"!==M.value?(ae(),Ie(e)):(Ee&&Ae.pop(),Ke(e))}Ee&&Ae.pop()}function je(e){var t=D,r=We();return n.scope&&(xe(\"::\"+t.value+\"::\"),Se(r,!0)),ue(\"::\"),e.addLabel(t.value,t),L(x.labelStatement(r))}function Ue(){return L(x.breakStatement())}function Ie(e){var t=D.value,n=P,r=We();return e.addGoto(t,n),L(x.gotoStatement(r))}function Fe(e){n.scope&&ye(),e.pushScope();var t=Te(e);return e.popScope(),n.scope&&be(),ue(\"end\"),L(x.doStatement(t))}function qe(e){var t=Ze(e);ue(\"do\"),n.scope&&ye(),e.pushScope(!0);var r=Te(e);return e.popScope(),n.scope&&be(),ue(\"end\"),L(x.whileStatement(t,r))}function Ve(e){n.scope&&ye(),e.pushScope(!0);var t=Te(e);ue(\"until\"),e.raiseDeferredErrors();var r=Ze(e);return e.popScope(),n.scope&&be(),L(x.repeatStatement(r,t))}function Ge(e){var t=[];if(\"end\"!==D.value){var n=Ye(e);for(null!=n&&t.push(n);ce(\",\");)n=Ze(e),t.push(n);ce(\";\")}return L(x.returnStatement(t))}function Be(e){var t,r,i,o=[];for(Ee&&(i=Ae[Ae.length-1],Ae.push(i)),t=Ze(e),ue(\"then\"),n.scope&&ye(),e.pushScope(),r=Te(e),e.popScope(),n.scope&&be(),o.push(L(x.ifClause(t,r))),Ee&&(i=ke());ce(\"elseif\");)Me(i),t=Ze(e),ue(\"then\"),n.scope&&ye(),e.pushScope(),r=Te(e),e.popScope(),n.scope&&be(),o.push(L(x.elseifClause(t,r))),Ee&&(i=ke());return ce(\"else\")&&(Ee&&(i=new De(P),Ae.push(i)),n.scope&&ye(),e.pushScope(),r=Te(e),e.popScope(),n.scope&&be(),o.push(L(x.elseClause(r)))),ue(\"end\"),L(x.ifStatement(o))}function He(e){var t,r=We();if(n.scope&&(ye(),Le(r)),ce(\"=\")){var i=Ze(e);ue(\",\");var o=Ze(e),s=ce(\",\")?Ze(e):null;return ue(\"do\"),e.pushScope(!0),t=Te(e),e.popScope(),ue(\"end\"),n.scope&&be(),L(x.forNumericStatement(r,i,o,s,t))}for(var a=[r];ce(\",\");)r=We(),n.scope&&Le(r),a.push(r);ue(\"in\");var c=[];do{var u=Ze(e);c.push(u)}while(ce(\",\"));return ue(\"do\"),e.pushScope(!0),t=Te(e),e.popScope(),ue(\"end\"),n.scope&&be(),L(x.forGenericStatement(a,c,t))}function ze(e){var t,r=P;if(d===D.type){var i=[],o=[];do{t=We(),i.push(t),e.addLocal(t.name,r)}while(ce(\",\"));if(ce(\"=\"))do{var s=Ze(e);o.push(s)}while(ce(\",\"));if(n.scope)for(var a=0,c=i.length;a<c;++a)Le(i[a]);return L(x.localStatement(i,o))}if(ce(\"function\"))return t=We(),e.addLocal(t.name,r),n.scope&&(Le(t),ye()),Je(t,!0);V(\"<name>\",D)}function Ke(e){var t,r,i,o,s,a=[];for(Ee&&(r=ke());;){if(Ee&&(t=ke()),d===D.type)s=D.value,o=We(),n.scope&&Se(o,Ce(s)),i=!0;else{if(\"(\"!==D.value)return G(D);ae(),o=Ze(e),ue(\")\"),i=!1}e:for(;;){switch(p===D.type?'\"':D.value){case\".\":case\"[\":i=!0;break;case\":\":case\"(\":case\"{\":case'\"':i=null;break;default:break e}o=nt(o,t,e)}if(a.push(o),\",\"!==D.value)break;if(!i)return G(D);ae()}if(1===a.length&&null===i)return Me(t),L(x.callStatement(a[0]));if(!i)return G(D);ue(\"=\");var c=[];do{c.push(Ze(e))}while(ce(\",\"));return Me(r),L(x.assignmentStatement(a,c))}function We(){Pe();var e=D.value;return d!==D.type&&V(\"<name>\",D),ae(),L(x.identifier(e))}function Je(e,t){var r=_e();r.pushScope();var i=[];if(ue(\"(\"),!ce(\")\"))for(;;){if(d===D.type){var o=We();if(n.scope&&Le(o),i.push(o),ce(\",\"))continue}else y===D.type?(r.allowVararg=!0,i.push(ot(r))):V(\"<name> or '...'\",D);ue(\")\");break}var s=Te(r);return r.popScope(),ue(\"end\"),n.scope&&be(),t=t||!1,L(x.functionStatement(e,i,t,s))}function Xe(){var e,t,r;for(Ee&&(r=ke()),e=We(),n.scope&&(Se(e,Ce(e.name)),ye());ce(\".\");)Me(r),t=We(),e=L(x.memberExpression(e,\".\",t));return ce(\":\")&&(Me(r),t=We(),e=L(x.memberExpression(e,\":\",t)),n.scope&&xe(\"self\")),e}function Qe(e){for(var t,n,r=[];;){if(Pe(),g===D.type&&ce(\"[\"))t=Ze(e),ue(\"]\"),ue(\"=\"),n=Ze(e),r.push(L(x.tableKey(t,n)));else if(d===D.type)\"=\"===M.value?(t=We(),ae(),n=Ze(e),r.push(L(x.tableKeyString(t,n)))):(n=Ze(e),r.push(L(x.tableValue(n))));else{if(null==(n=Ye(e))){Ae.pop();break}r.push(L(x.tableValue(n)))}if(!(\",;\".indexOf(D.value)>=0))break;ae()}return ue(\"}\"),L(x.tableConstructorExpression(r))}function Ye(e){return tt(0,e)}function Ze(e){var t=Ye(e);if(null!=t)return t;V(\"<expression>\",D)}function et(e){var t=e.charCodeAt(0),n=e.length;if(1===n)switch(t){case 94:return 12;case 42:case 47:case 37:return 10;case 43:case 45:return 9;case 38:return 6;case 126:return 5;case 124:return 4;case 60:case 62:return 3}else if(2===n)switch(t){case 47:return 10;case 46:return 8;case 60:case 62:return\"<<\"===e||\">>\"===e?7:3;case 61:case 126:return 3;case 111:return 1}else if(97===t&&\"and\"===e)return 2;return 0}function tt(e,t){var n,r,i,o=D.value;if(Ee&&(r=ke()),ve(D)){Pe(),ae();var s=tt(10,t);null==s&&V(\"<expression>\",D),n=L(x.unaryExpression(o,s))}if(null==n&&null==(n=ot(t))&&(n=rt(t)),null==n)return null;for(;o=D.value,!(0===(i=g===D.type||f===D.type?et(o):0)||i<=e);){\"^\"!==o&&\"..\"!==o||--i,ae();var a=tt(i,t);null==a&&V(\"<expression>\",D),Ee&&Ae.push(r),n=L(x.binaryExpression(o,n,a))}return n}function nt(e,t,n){var r,i;if(g===D.type)switch(D.value){case\"[\":return Me(t),ae(),r=Ze(n),ue(\"]\"),L(x.indexExpression(e,r));case\".\":return Me(t),ae(),i=We(),L(x.memberExpression(e,\".\",i));case\":\":return Me(t),ae(),i=We(),e=L(x.memberExpression(e,\":\",i)),Me(t),it(e,n);case\"(\":case\"{\":return Me(t),it(e,n)}else if(p===D.type)return Me(t),it(e,n);return null}function rt(e){var t,r,i;if(Ee&&(i=ke()),d===D.type)r=D.value,t=We(),n.scope&&Se(t,Ce(r));else{if(!ce(\"(\"))return null;t=Ze(e),ue(\")\")}for(;;){var o=nt(t,i,e);if(null===o)break;t=o}return t}function it(e,t){if(g===D.type)switch(D.value){case\"(\":i.emptyStatement||D.line!==P.line&&F(null,b.ambiguousSyntax,D.value),ae();var n=[],r=Ye(t);for(null!=r&&n.push(r);ce(\",\");)r=Ze(t),n.push(r);return ue(\")\"),L(x.callExpression(e,n));case\"{\":Pe(),ae();var o=Qe(t);return L(x.tableCallExpression(e,o))}else if(p===D.type)return L(x.stringCallExpression(e,ot(t)));V(\"function arguments\",D)}function ot(e){var r,i=p|m|v|w|y,o=D.value,s=D.type;if(Ee&&(r=ke()),s!==y||e.allowVararg||F(D,b.cannotUseVararg,D.value),s&i){Me(r);var a=t.slice(D.range[0],D.range[1]);return ae(),L(x.literal(s,o,a))}return f===s&&\"function\"===o?(Me(r),ae(),n.scope&&ye(),Je(null)):ce(\"{\")?(Me(r),Qe(e)):void 0}De.prototype.complete=function(){n.locations&&(this.loc.end.line=P.lastLine||P.line,this.loc.end.column=P.range[1]-(P.lastLineStart||P.lineStart)),n.ranges&&(this.range[1]=P.range[1])},De.prototype.bless=function(e){if(this.loc){var t=this.loc;e.loc={start:{line:t.start.line,column:t.start.column},end:{line:t.end.line,column:t.end.column}}}this.range&&(e.range=[this.range[0],this.range[1]])},Oe.prototype.isInLoop=function(){for(var e=this.scopes.length;e-- >0;)if(this.scopes[e].isLoop)return!0;return!1},Oe.prototype.pushScope=function(e){var t={labels:{},locals:[],deferredGotos:[],isLoop:!!e};this.scopes.push(t)},Oe.prototype.popScope=function(){for(var e=0;e<this.pendingGotos.length;++e){var t=this.pendingGotos[e];t.maxDepth>=this.scopes.length&&--t.maxDepth<=0&&F(t.token,b.labelNotVisible,t.target)}this.scopes.pop()},Oe.prototype.addGoto=function(e,t){for(var n=[],r=0;r<this.scopes.length;++r){var i=this.scopes[r];if(n.push(i.locals.length),Object.prototype.hasOwnProperty.call(i.labels,e))return}this.pendingGotos.push({maxDepth:this.scopes.length,target:e,token:t,localCounts:n})},Oe.prototype.addLabel=function(e,t){var n=this.currentScope();if(Object.prototype.hasOwnProperty.call(n.labels,e))F(t,b.labelAlreadyDefined,e,n.labels[e].line);else{for(var r=[],i=0;i<this.pendingGotos.length;++i){var o=this.pendingGotos[i];o.maxDepth>=this.scopes.length&&o.target===e?o.localCounts[this.scopes.length-1]<n.locals.length&&n.deferredGotos.push(o):r.push(o)}this.pendingGotos=r}n.labels[e]={localCount:n.locals.length,line:t.line}},Oe.prototype.addLocal=function(e,t){this.currentScope().locals.push({name:e,token:t})},Oe.prototype.currentScope=function(){return this.scopes[this.scopes.length-1]},Oe.prototype.raiseDeferredErrors=function(){for(var e=this.currentScope(),t=e.deferredGotos,n=0;n<t.length;++n){var r=t[n];F(r.token,b.gotoJumpInLocalScope,r.target,e.locals[r.localCounts[this.scopes.length-1]].name)}},$e.prototype.isInLoop=function(){return!!this.loopLevels.length},$e.prototype.pushScope=function(e){++this.level,e&&this.loopLevels.push(this.level)},$e.prototype.popScope=function(){var e=this.loopLevels,t=e.length;t&&e[t-1]===this.level&&e.pop(),--this.level},$e.prototype.addGoto=$e.prototype.addLabel=function(){throw new Error(\"This should never happen\")},$e.prototype.addLocal=$e.prototype.raiseDeferredErrors=function(){},e.parse=at;var st={5.1:{},5.2:{labels:!0,emptyStatement:!0,hexEscapes:!0,skipWhitespaceEscape:!0,strictEscapes:!0,relaxedBreak:!0},5.3:{labels:!0,emptyStatement:!0,hexEscapes:!0,skipWhitespaceEscape:!0,strictEscapes:!0,unicodeEscapes:!0,bitwiseOperators:!0,integerDivision:!0,relaxedBreak:!0},LuaJIT:{labels:!0,contextualGoto:!0,hexEscapes:!0,skipWhitespaceEscape:!0,strictEscapes:!0,unicodeEscapes:!0,imaginaryNumbers:!0,integerSuffixes:!0}};function at(a,c){if(\"undefined\"===typeof c&&\"object\"===typeof a&&(c=a,a=void 0),c||(c={}),t=a||\"\",n=U({},s,c),k=0,_=1,N=0,r=t.length,T=[[]],R=0,j=[],Ae=[],!Object.prototype.hasOwnProperty.call(st,n.luaVersion))throw new Error(A(\"Lua version '%1' not supported\",n.luaVersion));if(i=U({},st[n.luaVersion]),void 0!==n.extendedIdentifiers&&(i.extendedIdentifiers=!!n.extendedIdentifiers),!Object.prototype.hasOwnProperty.call(l,n.encodingMode))throw new Error(A(\"Encoding mode '%1' not supported\",n.encodingMode));return o=l[n.encodingMode],n.comments&&(O=[]),n.wait?e:ut()}function ct(n){return t+=String(n),r=t.length,e}function ut(e){\"undefined\"!==typeof e&&ct(e),t&&\"#!\"===t.substr(0,2)&&(t=t.replace(/^.*/,(function(e){return e.replace(/./g,\" \")}))),r=t.length,Ee=n.locations||n.ranges,M=B();var i=Ne();if(n.comments&&(i.comments=O),n.scope&&(i.globals=j),Ae.length>0)throw new Error(\"Location tracking failed. This is most likely a bug in luaparse\");return i}e.write=ct,e.end=ut}(t)})),ace.define(\"ace/mode/lua_worker\",[],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),i=e(\"../worker/mirror\").Mirror,o=e(\"../mode/lua/luaparse\"),s=t.Worker=function(e){i.call(this,e),this.setTimeout(500)};r.inherits(s,i),function(){this.onUpdate=function(){var e=this.doc.getValue(),t=[];try{o.parse(e)}catch(n){n instanceof o.SyntaxError&&t.push({row:n.line-1,column:n.column,text:n.message,type:\"error\"})}this.sender.emit(\"annotate\",t)}}.call(s.prototype)}));","name":"c4e1812b01dcf14f11e8b553051eb7e3.js","input":"\"no use strict\";\n\n!function (window) {\n  if (typeof window.window != \"undefined\" && window.document) return;\n  if (window.require && window.define) return;\n  if (!window.console) {\n    window.console = function () {\n      var msgs = Array.prototype.slice.call(arguments, 0);\n      postMessage({\n        type: \"log\",\n        data: msgs\n      });\n    };\n    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;\n  }\n  window.window = window;\n  window.ace = window;\n  window.onerror = function (message, file, line, col, err) {\n    postMessage({\n      type: \"error\",\n      data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line,\n        col: col,\n        stack: err && err.stack\n      }\n    });\n  };\n  window.normalizeModule = function (parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n      var chunks = moduleName.split(\"!\");\n      return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n      var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n      moduleName = (base ? base + \"/\" : \"\") + moduleName;\n      while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n        var previous = moduleName;\n        moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n      }\n    }\n    return moduleName;\n  };\n  window.require = function require(parentId, id) {\n    if (!id) {\n      id = parentId;\n      parentId = null;\n    }\n    if (!id.charAt) throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n    id = window.normalizeModule(parentId, id);\n    var module = window.require.modules[id];\n    if (module) {\n      if (!module.initialized) {\n        module.initialized = true;\n        module.exports = module.factory().exports;\n      }\n      return module.exports;\n    }\n    if (!window.require.tlns) return console.log(\"unable to load \" + id);\n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n  };\n  function resolveModuleId(id, paths) {\n    var testPath = id,\n      tail = \"\";\n    while (testPath) {\n      var alias = paths[testPath];\n      if (typeof alias == \"string\") {\n        return alias + tail;\n      } else if (alias) {\n        return alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n      } else if (alias === false) {\n        return \"\";\n      }\n      var i = testPath.lastIndexOf(\"/\");\n      if (i === -1) break;\n      tail = testPath.substr(i) + tail;\n      testPath = testPath.slice(0, i);\n    }\n    return id;\n  }\n  window.require.modules = {};\n  window.require.tlns = {};\n  window.define = function (id, deps, _factory) {\n    if (arguments.length == 2) {\n      _factory = deps;\n      if (typeof id != \"string\") {\n        deps = id;\n        id = window.require.id;\n      }\n    } else if (arguments.length == 1) {\n      _factory = id;\n      deps = [];\n      id = window.require.id;\n    }\n    if (typeof _factory != \"function\") {\n      window.require.modules[id] = {\n        exports: _factory,\n        initialized: true\n      };\n      return;\n    }\n    if (!deps.length)\n      // If there is no dependencies, we inject \"require\", \"exports\" and\n      // \"module\" as dependencies, to provide CommonJS compatibility.\n      deps = [\"require\", \"exports\", \"module\"];\n    var req = function req(childId) {\n      return window.require(id, childId);\n    };\n    window.require.modules[id] = {\n      exports: {},\n      factory: function factory() {\n        var module = this;\n        var returnExports = _factory.apply(this, deps.slice(0, _factory.length).map(function (dep) {\n          switch (dep) {\n            // Because \"require\", \"exports\" and \"module\" aren't actual\n            // dependencies, we must handle them seperately.\n            case \"require\":\n              return req;\n            case \"exports\":\n              return module.exports;\n            case \"module\":\n              return module;\n            // But for all other dependencies, we can just go ahead and\n            // require them.\n            default:\n              return req(dep);\n          }\n        }));\n        if (returnExports) module.exports = returnExports;\n        return module;\n      }\n    };\n  };\n  window.define.amd = {};\n  window.require.tlns = {};\n  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces) this.require.tlns[i] = topLevelNamespaces[i];\n  };\n  window.initSender = function initSender() {\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    var Sender = function Sender() {};\n    (function () {\n      oop.implement(this, EventEmitter);\n      this.callback = function (data, callbackId) {\n        postMessage({\n          type: \"call\",\n          id: callbackId,\n          data: data\n        });\n      };\n      this.emit = function (name, data) {\n        postMessage({\n          type: \"event\",\n          name: name,\n          data: data\n        });\n      };\n    }).call(Sender.prototype);\n    return new Sender();\n  };\n  var main = window.main = null;\n  var sender = window.sender = null;\n  window.onmessage = function (e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n      sender._signal(msg.event, msg.data);\n    } else if (msg.command) {\n      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error(\"Unknown command:\" + msg.command);\n    } else if (msg.init) {\n      window.initBaseUrls(msg.tlns);\n      sender = window.sender = window.initSender();\n      var clazz = this.require(msg.module)[msg.classname];\n      main = window.main = new clazz(sender);\n    }\n  };\n}(this);\nace.define(\"ace/lib/oop\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n  exports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n      obj[key] = mixin[key];\n    }\n    return obj;\n  };\n  exports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n  };\n});\nace.define(\"ace/apply_delta\", [], function (require, exports, module) {\n  \"use strict\";\n\n  function throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n  }\n  function positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;\n  }\n  function validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\") throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array)) throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end) throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end)) throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, \"delta.range must match delta lines\");\n  }\n  exports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n      case \"insert\":\n        var lines = delta.lines;\n        if (lines.length === 1) {\n          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n        } else {\n          var args = [row, 1].concat(delta.lines);\n          docLines.splice.apply(docLines, args);\n          docLines[row] = line.substring(0, startColumn) + docLines[row];\n          docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n        }\n        break;\n      case \"remove\":\n        var endColumn = delta.end.column;\n        var endRow = delta.end.row;\n        if (row === endRow) {\n          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n        } else {\n          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n        }\n        break;\n    }\n  };\n});\nace.define(\"ace/lib/event_emitter\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var EventEmitter = {};\n  var stopPropagation = function stopPropagation() {\n    this.propagationStopped = true;\n  };\n  var preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler) return;\n    if (typeof e != \"object\" || !e) e = {};\n    if (!e.type) e.type = eventName;\n    if (!e.stopPropagation) e.stopPropagation = stopPropagation;\n    if (!e.preventDefault) e.preventDefault = preventDefault;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](e, this);\n      if (e.propagationStopped) break;\n    }\n    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);\n  };\n  EventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) listeners[i](e, this);\n  };\n  EventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n      _self.off(eventName, newCallback);\n      callback.apply(null, arguments);\n    });\n    if (!callback) {\n      return new Promise(function (resolve) {\n        callback = resolve;\n      });\n    }\n  };\n  EventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) handlers = this._defaultHandlers = {\n      _disabled_: {}\n    };\n    if (handlers[eventName]) {\n      var old = handlers[eventName];\n      var disabled = handlers._disabled_[eventName];\n      if (!disabled) handlers._disabled_[eventName] = disabled = [];\n      disabled.push(old);\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n  };\n  EventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n      if (disabled) this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n  };\n  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) listeners = this._eventRegistry[eventName] = [];\n    if (listeners.indexOf(callback) == -1) listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n  };\n  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) return;\n    var index = listeners.indexOf(callback);\n    if (index !== -1) listeners.splice(index, 1);\n  };\n  EventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n  };\n  exports.EventEmitter = EventEmitter;\n});\nace.define(\"ace/range\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var comparePoints = function comparePoints(p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  var Range = function Range(startRow, startColumn, endRow, endColumn) {\n    this.start = {\n      row: startRow,\n      column: startColumn\n    };\n    this.end = {\n      row: endRow,\n      column: endColumn\n    };\n  };\n  (function () {\n    this.isEqual = function (range) {\n      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;\n    };\n    this.toString = function () {\n      return \"Range: [\" + this.start.row + \"/\" + this.start.column + \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\";\n    };\n    this.contains = function (row, column) {\n      return this.compare(row, column) == 0;\n    };\n    this.compareRange = function (range) {\n      var cmp,\n        end = range.end,\n        start = range.start;\n      cmp = this.compare(end.row, end.column);\n      if (cmp == 1) {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == 1) {\n          return 2;\n        } else if (cmp == 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      } else if (cmp == -1) {\n        return -2;\n      } else {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == -1) {\n          return -1;\n        } else if (cmp == 1) {\n          return 42;\n        } else {\n          return 0;\n        }\n      }\n    };\n    this.comparePoint = function (p) {\n      return this.compare(p.row, p.column);\n    };\n    this.containsRange = function (range) {\n      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    this.intersects = function (range) {\n      var cmp = this.compareRange(range);\n      return cmp == -1 || cmp == 0 || cmp == 1;\n    };\n    this.isEnd = function (row, column) {\n      return this.end.row == row && this.end.column == column;\n    };\n    this.isStart = function (row, column) {\n      return this.start.row == row && this.start.column == column;\n    };\n    this.setStart = function (row, column) {\n      if (typeof row == \"object\") {\n        this.start.column = row.column;\n        this.start.row = row.row;\n      } else {\n        this.start.row = row;\n        this.start.column = column;\n      }\n    };\n    this.setEnd = function (row, column) {\n      if (typeof row == \"object\") {\n        this.end.column = row.column;\n        this.end.row = row.row;\n      } else {\n        this.end.row = row;\n        this.end.column = column;\n      }\n    };\n    this.inside = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column) || this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideStart = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.insideEnd = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.compare = function (row, column) {\n      if (!this.isMultiLine()) {\n        if (row === this.start.row) {\n          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;\n        }\n      }\n      if (row < this.start.row) return -1;\n      if (row > this.end.row) return 1;\n      if (this.start.row === row) return column >= this.start.column ? 0 : -1;\n      if (this.end.row === row) return column <= this.end.column ? 0 : 1;\n      return 0;\n    };\n    this.compareStart = function (row, column) {\n      if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareEnd = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.compareInside = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    this.clipRows = function (firstRow, lastRow) {\n      if (this.end.row > lastRow) var end = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.end.row < firstRow) var end = {\n        row: firstRow,\n        column: 0\n      };\n      if (this.start.row > lastRow) var start = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.start.row < firstRow) var start = {\n        row: firstRow,\n        column: 0\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.extend = function (row, column) {\n      var cmp = this.compare(row, column);\n      if (cmp == 0) return this;else if (cmp == -1) var start = {\n        row: row,\n        column: column\n      };else var end = {\n        row: row,\n        column: column\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    this.isEmpty = function () {\n      return this.start.row === this.end.row && this.start.column === this.end.column;\n    };\n    this.isMultiLine = function () {\n      return this.start.row !== this.end.row;\n    };\n    this.clone = function () {\n      return Range.fromPoints(this.start, this.end);\n    };\n    this.collapseRows = function () {\n      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    this.toScreenRange = function (session) {\n      var screenPosStart = session.documentToScreenPosition(this.start);\n      var screenPosEnd = session.documentToScreenPosition(this.end);\n      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    this.moveBy = function (row, column) {\n      this.start.row += row;\n      this.start.column += column;\n      this.end.row += row;\n      this.end.column += column;\n    };\n  }).call(Range.prototype);\n  Range.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n  };\n  Range.comparePoints = comparePoints;\n  Range.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  exports.Range = Range;\n});\nace.define(\"ace/anchor\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Anchor = exports.Anchor = function (doc, row, column) {\n    this.$onChange = this.onChange.bind(this);\n    this.attach(doc);\n    if (typeof column == \"undefined\") this.setPosition(row.row, row.column);else this.setPosition(row, column);\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.getPosition = function () {\n      return this.$clipPositionToDocument(this.row, this.column);\n    };\n    this.getDocument = function () {\n      return this.document;\n    };\n    this.$insertRight = false;\n    this.onChange = function (delta) {\n      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;\n      if (delta.start.row > this.row) return;\n      var point = $getTransformedPoint(delta, {\n        row: this.row,\n        column: this.column\n      }, this.$insertRight);\n      this.setPosition(point.row, point.column, true);\n    };\n    function $pointsInOrder(point1, point2, equalPointsInOrder) {\n      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;\n    }\n    function $getTransformedPoint(delta, point, moveIfEqual) {\n      var deltaIsInsert = delta.action == \"insert\";\n      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n      var deltaStart = delta.start;\n      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n        return {\n          row: point.row,\n          column: point.column\n        };\n      }\n      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n        return {\n          row: point.row + deltaRowShift,\n          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n        };\n      }\n      return {\n        row: deltaStart.row,\n        column: deltaStart.column\n      };\n    }\n    this.setPosition = function (row, column, noClip) {\n      var pos;\n      if (noClip) {\n        pos = {\n          row: row,\n          column: column\n        };\n      } else {\n        pos = this.$clipPositionToDocument(row, column);\n      }\n      if (this.row == pos.row && this.column == pos.column) return;\n      var old = {\n        row: this.row,\n        column: this.column\n      };\n      this.row = pos.row;\n      this.column = pos.column;\n      this._signal(\"change\", {\n        old: old,\n        value: pos\n      });\n    };\n    this.detach = function () {\n      this.document.off(\"change\", this.$onChange);\n    };\n    this.attach = function (doc) {\n      this.document = doc || this.document;\n      this.document.on(\"change\", this.$onChange);\n    };\n    this.$clipPositionToDocument = function (row, column) {\n      var pos = {};\n      if (row >= this.document.getLength()) {\n        pos.row = Math.max(0, this.document.getLength() - 1);\n        pos.column = this.document.getLine(pos.row).length;\n      } else if (row < 0) {\n        pos.row = 0;\n        pos.column = 0;\n      } else {\n        pos.row = row;\n        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n      }\n      if (column < 0) pos.column = 0;\n      return pos;\n    };\n  }).call(Anchor.prototype);\n});\nace.define(\"ace/document\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var applyDelta = require(\"./apply_delta\").applyDelta;\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Range = require(\"./range\").Range;\n  var Anchor = require(\"./anchor\").Anchor;\n  var Document = function Document(textOrLines) {\n    this.$lines = [\"\"];\n    if (textOrLines.length === 0) {\n      this.$lines = [\"\"];\n    } else if (Array.isArray(textOrLines)) {\n      this.insertMergedLines({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    } else {\n      this.insert({\n        row: 0,\n        column: 0\n      }, textOrLines);\n    }\n  };\n  (function () {\n    oop.implement(this, EventEmitter);\n    this.setValue = function (text) {\n      var len = this.getLength() - 1;\n      this.remove(new Range(0, 0, len, this.getLine(len).length));\n      this.insert({\n        row: 0,\n        column: 0\n      }, text || \"\");\n    };\n    this.getValue = function () {\n      return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    this.createAnchor = function (row, column) {\n      return new Anchor(this, row, column);\n    };\n    if (\"aaa\".split(/a/).length === 0) {\n      this.$split = function (text) {\n        return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n      };\n    } else {\n      this.$split = function (text) {\n        return text.split(/\\r\\n|\\r|\\n/);\n      };\n    }\n    this.$detectNewLine = function (text) {\n      var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n      this.$autoNewLine = match ? match[1] : \"\\n\";\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineCharacter = function () {\n      switch (this.$newLineMode) {\n        case \"windows\":\n          return \"\\r\\n\";\n        case \"unix\":\n          return \"\\n\";\n        default:\n          return this.$autoNewLine || \"\\n\";\n      }\n    };\n    this.$autoNewLine = \"\";\n    this.$newLineMode = \"auto\";\n    this.setNewLineMode = function (newLineMode) {\n      if (this.$newLineMode === newLineMode) return;\n      this.$newLineMode = newLineMode;\n      this._signal(\"changeNewLineMode\");\n    };\n    this.getNewLineMode = function () {\n      return this.$newLineMode;\n    };\n    this.isNewLine = function (text) {\n      return text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\";\n    };\n    this.getLine = function (row) {\n      return this.$lines[row] || \"\";\n    };\n    this.getLines = function (firstRow, lastRow) {\n      return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    this.getAllLines = function () {\n      return this.getLines(0, this.getLength());\n    };\n    this.getLength = function () {\n      return this.$lines.length;\n    };\n    this.getTextRange = function (range) {\n      return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    this.getLinesForRange = function (range) {\n      var lines;\n      if (range.start.row === range.end.row) {\n        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n      } else {\n        lines = this.getLines(range.start.row, range.end.row);\n        lines[0] = (lines[0] || \"\").substring(range.start.column);\n        var l = lines.length - 1;\n        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);\n      }\n      return lines;\n    };\n    this.insertLines = function (row, lines) {\n      console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n      return this.insertFullLines(row, lines);\n    };\n    this.removeLines = function (firstRow, lastRow) {\n      console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n      return this.removeFullLines(firstRow, lastRow);\n    };\n    this.insertNewLine = function (position) {\n      console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n      return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    this.insert = function (position, text) {\n      if (this.getLength() <= 1) this.$detectNewLine(text);\n      return this.insertMergedLines(position, this.$split(text));\n    };\n    this.insertInLine = function (position, text) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = this.pos(position.row, position.column + text.length);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: [text]\n      }, true);\n      return this.clonePos(end);\n    };\n    this.clippedPos = function (row, column) {\n      var length = this.getLength();\n      if (row === undefined) {\n        row = length;\n      } else if (row < 0) {\n        row = 0;\n      } else if (row >= length) {\n        row = length - 1;\n        column = undefined;\n      }\n      var line = this.getLine(row);\n      if (column == undefined) column = line.length;\n      column = Math.min(Math.max(column, 0), line.length);\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.clonePos = function (pos) {\n      return {\n        row: pos.row,\n        column: pos.column\n      };\n    };\n    this.pos = function (row, column) {\n      return {\n        row: row,\n        column: column\n      };\n    };\n    this.$clipPosition = function (position) {\n      var length = this.getLength();\n      if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = this.getLine(length - 1).length;\n      } else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n      }\n      return position;\n    };\n    this.insertFullLines = function (row, lines) {\n      row = Math.min(Math.max(row, 0), this.getLength());\n      var column = 0;\n      if (row < this.getLength()) {\n        lines = lines.concat([\"\"]);\n        column = 0;\n      } else {\n        lines = [\"\"].concat(lines);\n        row--;\n        column = this.$lines[row].length;\n      }\n      this.insertMergedLines({\n        row: row,\n        column: column\n      }, lines);\n    };\n    this.insertMergedLines = function (position, lines) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = {\n        row: start.row + lines.length - 1,\n        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n      };\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: lines\n      });\n      return this.clonePos(end);\n    };\n    this.remove = function (range) {\n      var start = this.clippedPos(range.start.row, range.start.column);\n      var end = this.clippedPos(range.end.row, range.end.column);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      });\n      return this.clonePos(start);\n    };\n    this.removeInLine = function (row, startColumn, endColumn) {\n      var start = this.clippedPos(row, startColumn);\n      var end = this.clippedPos(row, endColumn);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      }, true);\n      return this.clonePos(start);\n    };\n    this.removeFullLines = function (firstRow, lastRow) {\n      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n      var deleteLastNewLine = lastRow < this.getLength() - 1;\n      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;\n      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;\n      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;\n      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;\n      var range = new Range(startRow, startCol, endRow, endCol);\n      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n      this.applyDelta({\n        start: range.start,\n        end: range.end,\n        action: \"remove\",\n        lines: this.getLinesForRange(range)\n      });\n      return deletedLines;\n    };\n    this.removeNewLine = function (row) {\n      if (row < this.getLength() - 1 && row >= 0) {\n        this.applyDelta({\n          start: this.pos(row, this.getLine(row).length),\n          end: this.pos(row + 1, 0),\n          action: \"remove\",\n          lines: [\"\", \"\"]\n        });\n      }\n    };\n    this.replace = function (range, text) {\n      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);\n      if (text.length === 0 && range.isEmpty()) return range.start;\n      if (text == this.getTextRange(range)) return range.end;\n      this.remove(range);\n      var end;\n      if (text) {\n        end = this.insert(range.start, text);\n      } else {\n        end = range.start;\n      }\n      return end;\n    };\n    this.applyDeltas = function (deltas) {\n      for (var i = 0; i < deltas.length; i++) {\n        this.applyDelta(deltas[i]);\n      }\n    };\n    this.revertDeltas = function (deltas) {\n      for (var i = deltas.length - 1; i >= 0; i--) {\n        this.revertDelta(deltas[i]);\n      }\n    };\n    this.applyDelta = function (delta, doNotValidate) {\n      var isInsert = delta.action == \"insert\";\n      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {\n        return;\n      }\n      if (isInsert && delta.lines.length > 20000) {\n        this.$splitAndapplyLargeDelta(delta, 20000);\n      } else {\n        applyDelta(this.$lines, delta, doNotValidate);\n        this._signal(\"change\", delta);\n      }\n    };\n    this.$safeApplyDelta = function (delta) {\n      var docLength = this.$lines.length;\n      if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength || delta.action == \"insert\" && delta.start.row <= docLength) {\n        this.applyDelta(delta);\n      }\n    };\n    this.$splitAndapplyLargeDelta = function (delta, MAX) {\n      var lines = delta.lines;\n      var l = lines.length - MAX + 1;\n      var row = delta.start.row;\n      var column = delta.start.column;\n      for (var from = 0, to = 0; from < l; from = to) {\n        to += MAX - 1;\n        var chunk = lines.slice(from, to);\n        chunk.push(\"\");\n        this.applyDelta({\n          start: this.pos(row + from, column),\n          end: this.pos(row + to, column = 0),\n          action: delta.action,\n          lines: chunk\n        }, true);\n      }\n      delta.lines = lines.slice(from);\n      delta.start.row = row + from;\n      delta.start.column = column;\n      this.applyDelta(delta, true);\n    };\n    this.revertDelta = function (delta) {\n      this.$safeApplyDelta({\n        start: this.clonePos(delta.start),\n        end: this.clonePos(delta.end),\n        action: delta.action == \"insert\" ? \"remove\" : \"insert\",\n        lines: delta.lines.slice()\n      });\n    };\n    this.indexToPosition = function (index, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      for (var i = startRow || 0, l = lines.length; i < l; i++) {\n        index -= lines[i].length + newlineLength;\n        if (index < 0) return {\n          row: i,\n          column: index + lines[i].length + newlineLength\n        };\n      }\n      return {\n        row: l - 1,\n        column: index + lines[l - 1].length + newlineLength\n      };\n    };\n    this.positionToIndex = function (pos, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      var index = 0;\n      var row = Math.min(pos.row, lines.length);\n      for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;\n      return index + pos.column;\n    };\n  }).call(Document.prototype);\n  exports.Document = Document;\n});\nace.define(\"ace/lib/lang\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.last = function (a) {\n    return a[a.length - 1];\n  };\n  exports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n  };\n  exports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n      if (count & 1) result += string;\n      if (count >>= 1) string += string;\n    }\n    return result;\n  };\n  var trimBeginRegexp = /^\\s\\s*/;\n  var trimEndRegexp = /\\s\\s*$/;\n  exports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n  };\n  exports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n  };\n  exports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n      copy[key] = obj[key];\n    }\n    return copy;\n  };\n  exports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (array[i] && typeof array[i] == \"object\") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];\n    }\n    return copy;\n  };\n  exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj) return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n      copy = [];\n      for (var key = 0; key < obj.length; key++) {\n        copy[key] = deepCopy(obj[key]);\n      }\n      return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\") return obj;\n    copy = {};\n    for (var key in obj) copy[key] = deepCopy(obj[key]);\n    return copy;\n  };\n  exports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n      map[arr[i]] = 1;\n    }\n    return map;\n  };\n  exports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n      map[i] = props[i];\n    }\n    return map;\n  };\n  exports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n      if (value === array[i]) {\n        array.splice(i, 1);\n      }\n    }\n  };\n  exports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  };\n  exports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n  };\n  exports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n      matches.push({\n        offset: arguments[arguments.length - 2],\n        length: str.length\n      });\n    });\n    return matches;\n  };\n  exports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var deferred = function deferred(timeout) {\n      deferred.cancel();\n      timer = setTimeout(callback, timeout || 0);\n      return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n      this.cancel();\n      fcn();\n      return deferred;\n    };\n    deferred.cancel = function () {\n      clearTimeout(timer);\n      timer = null;\n      return deferred;\n    };\n    deferred.isPending = function () {\n      return timer;\n    };\n    return deferred;\n  };\n  exports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function callback() {\n      timer = null;\n      fcn();\n    };\n    var _self = function _self(timeout) {\n      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n      timer && clearTimeout(timer);\n      timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n      this.cancel();\n      fcn();\n    };\n    _self.cancel = function () {\n      timer && clearTimeout(timer);\n      timer = null;\n    };\n    _self.isPending = function () {\n      return timer;\n    };\n    return _self;\n  };\n});\nace.define(\"ace/worker/mirror\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Document = require(\"../document\").Document;\n  var lang = require(\"../lib/lang\");\n  var Mirror = exports.Mirror = function (sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    var _self = this;\n    sender.on(\"change\", function (e) {\n      var data = e.data;\n      if (data[0].start) {\n        doc.applyDeltas(data);\n      } else {\n        for (var i = 0; i < data.length; i += 2) {\n          var d, err;\n          if (Array.isArray(data[i + 1])) {\n            d = {\n              action: \"insert\",\n              start: data[i],\n              lines: data[i + 1]\n            };\n          } else {\n            d = {\n              action: \"remove\",\n              start: data[i],\n              end: data[i + 1]\n            };\n          }\n          if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n            err = new Error(\"Invalid delta\");\n            err.data = {\n              path: _self.$path,\n              linesLength: doc.$lines.length,\n              start: d.start,\n              end: d.end\n            };\n            throw err;\n          }\n          doc.applyDelta(d, true);\n        }\n      }\n      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);\n      _self.onUpdate();\n    });\n  };\n  (function () {\n    this.$timeout = 500;\n    this.setTimeout = function (timeout) {\n      this.$timeout = timeout;\n    };\n    this.setValue = function (value) {\n      this.doc.setValue(value);\n      this.deferredUpdate.schedule(this.$timeout);\n    };\n    this.getValue = function (callbackId) {\n      this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    this.onUpdate = function () {};\n    this.isPending = function () {\n      return this.deferredUpdate.isPending();\n    };\n  }).call(Mirror.prototype);\n});\nace.define(\"ace/mode/lua/luaparse\", [], function (require, exports, module) {\n  (function (root, name, factory) {\n    factory(exports);\n  })(this, 'luaparse', function (exports) {\n    'use strict';\n\n    exports.version = \"0.3.1\";\n    var input, options, length, features, encodingMode;\n    var defaultOptions = exports.defaultOptions = {\n      wait: false,\n      comments: true,\n      scope: false,\n      locations: false,\n      ranges: false,\n      onCreateNode: null,\n      onCreateScope: null,\n      onDestroyScope: null,\n      onLocalDeclaration: null,\n      luaVersion: '5.3',\n      encodingMode: 'none'\n    };\n    function _encodeUTF(codepoint, highMask) {\n      highMask = highMask || 0;\n      if (codepoint < 0x80) {\n        return String.fromCharCode(codepoint);\n      } else if (codepoint < 0x800) {\n        return String.fromCharCode(highMask | 0xc0 | codepoint >> 6, highMask | 0x80 | codepoint & 0x3f);\n      } else if (codepoint < 0x10000) {\n        return String.fromCharCode(highMask | 0xe0 | codepoint >> 12, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);\n      } else /* istanbul ignore else */if (codepoint < 0x110000) {\n          return String.fromCharCode(highMask | 0xf0 | codepoint >> 18, highMask | 0x80 | codepoint >> 12 & 0x3f, highMask | 0x80 | codepoint >> 6 & 0x3f, highMask | 0x80 | codepoint & 0x3f);\n        } else {\n          return null;\n        }\n    }\n    function toHex(num, digits) {\n      var result = num.toString(16);\n      while (result.length < digits) result = '0' + result;\n      return result;\n    }\n    function checkChars(rx) {\n      return function (s) {\n        var m = rx.exec(s);\n        if (!m) return s;\n        raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n      };\n    }\n    var encodingModes = {\n      'pseudo-latin1': {\n        fixup: checkChars(/[^\\x00-\\xff]/),\n        encodeByte: function encodeByte(value) {\n          if (value === null) return '';\n          return String.fromCharCode(value);\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return _encodeUTF(codepoint);\n        }\n      },\n      'x-user-defined': {\n        fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n        encodeByte: function encodeByte(value) {\n          if (value === null) return '';\n          if (value >= 0x80) return String.fromCharCode(value | 0xf700);\n          return String.fromCharCode(value);\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return _encodeUTF(codepoint, 0xf700);\n        }\n      },\n      'none': {\n        discardStrings: true,\n        fixup: function fixup(s) {\n          return s;\n        },\n        encodeByte: function encodeByte(value) {\n          return '';\n        },\n        encodeUTF8: function encodeUTF8(codepoint) {\n          return '';\n        }\n      }\n    };\n    var EOF = 1,\n      StringLiteral = 2,\n      Keyword = 4,\n      Identifier = 8,\n      NumericLiteral = 16,\n      Punctuator = 32,\n      BooleanLiteral = 64,\n      NilLiteral = 128,\n      VarargLiteral = 256;\n    exports.tokenTypes = {\n      EOF: EOF,\n      StringLiteral: StringLiteral,\n      Keyword: Keyword,\n      Identifier: Identifier,\n      NumericLiteral: NumericLiteral,\n      Punctuator: Punctuator,\n      BooleanLiteral: BooleanLiteral,\n      NilLiteral: NilLiteral,\n      VarargLiteral: VarargLiteral\n    };\n    var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\'',\n      unexpectedEOF: 'unexpected symbol near \\'<eof>\\'',\n      expected: '\\'%1\\' expected near \\'%2\\'',\n      expectedToken: '%1 expected near \\'%2\\'',\n      unfinishedString: 'unfinished string near \\'%1\\'',\n      malformedNumber: 'malformed number near \\'%1\\'',\n      decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\'',\n      invalidEscape: 'invalid escape sequence near \\'%1\\'',\n      hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\'',\n      braceExpected: 'missing \\'%1\\' near \\'%2\\'',\n      tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\'',\n      unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\'',\n      unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\'',\n      ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\'',\n      noLoopToBreak: 'no loop to break near \\'%1\\'',\n      labelAlreadyDefined: 'label \\'%1\\' already defined on line %2',\n      labelNotVisible: 'no visible label \\'%1\\' for <goto>',\n      gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\'',\n      cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\'',\n      invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n    };\n    var ast = exports.ast = {\n      labelStatement: function labelStatement(label) {\n        return {\n          type: 'LabelStatement',\n          label: label\n        };\n      },\n      breakStatement: function breakStatement() {\n        return {\n          type: 'BreakStatement'\n        };\n      },\n      gotoStatement: function gotoStatement(label) {\n        return {\n          type: 'GotoStatement',\n          label: label\n        };\n      },\n      returnStatement: function returnStatement(args) {\n        return {\n          type: 'ReturnStatement',\n          'arguments': args\n        };\n      },\n      ifStatement: function ifStatement(clauses) {\n        return {\n          type: 'IfStatement',\n          clauses: clauses\n        };\n      },\n      ifClause: function ifClause(condition, body) {\n        return {\n          type: 'IfClause',\n          condition: condition,\n          body: body\n        };\n      },\n      elseifClause: function elseifClause(condition, body) {\n        return {\n          type: 'ElseifClause',\n          condition: condition,\n          body: body\n        };\n      },\n      elseClause: function elseClause(body) {\n        return {\n          type: 'ElseClause',\n          body: body\n        };\n      },\n      whileStatement: function whileStatement(condition, body) {\n        return {\n          type: 'WhileStatement',\n          condition: condition,\n          body: body\n        };\n      },\n      doStatement: function doStatement(body) {\n        return {\n          type: 'DoStatement',\n          body: body\n        };\n      },\n      repeatStatement: function repeatStatement(condition, body) {\n        return {\n          type: 'RepeatStatement',\n          condition: condition,\n          body: body\n        };\n      },\n      localStatement: function localStatement(variables, init) {\n        return {\n          type: 'LocalStatement',\n          variables: variables,\n          init: init\n        };\n      },\n      assignmentStatement: function assignmentStatement(variables, init) {\n        return {\n          type: 'AssignmentStatement',\n          variables: variables,\n          init: init\n        };\n      },\n      callStatement: function callStatement(expression) {\n        return {\n          type: 'CallStatement',\n          expression: expression\n        };\n      },\n      functionStatement: function functionStatement(identifier, parameters, isLocal, body) {\n        return {\n          type: 'FunctionDeclaration',\n          identifier: identifier,\n          isLocal: isLocal,\n          parameters: parameters,\n          body: body\n        };\n      },\n      forNumericStatement: function forNumericStatement(variable, start, end, step, body) {\n        return {\n          type: 'ForNumericStatement',\n          variable: variable,\n          start: start,\n          end: end,\n          step: step,\n          body: body\n        };\n      },\n      forGenericStatement: function forGenericStatement(variables, iterators, body) {\n        return {\n          type: 'ForGenericStatement',\n          variables: variables,\n          iterators: iterators,\n          body: body\n        };\n      },\n      chunk: function chunk(body) {\n        return {\n          type: 'Chunk',\n          body: body\n        };\n      },\n      identifier: function identifier(name) {\n        return {\n          type: 'Identifier',\n          name: name\n        };\n      },\n      literal: function literal(type, value, raw) {\n        type = type === StringLiteral ? 'StringLiteral' : type === NumericLiteral ? 'NumericLiteral' : type === BooleanLiteral ? 'BooleanLiteral' : type === NilLiteral ? 'NilLiteral' : 'VarargLiteral';\n        return {\n          type: type,\n          value: value,\n          raw: raw\n        };\n      },\n      tableKey: function tableKey(key, value) {\n        return {\n          type: 'TableKey',\n          key: key,\n          value: value\n        };\n      },\n      tableKeyString: function tableKeyString(key, value) {\n        return {\n          type: 'TableKeyString',\n          key: key,\n          value: value\n        };\n      },\n      tableValue: function tableValue(value) {\n        return {\n          type: 'TableValue',\n          value: value\n        };\n      },\n      tableConstructorExpression: function tableConstructorExpression(fields) {\n        return {\n          type: 'TableConstructorExpression',\n          fields: fields\n        };\n      },\n      binaryExpression: function binaryExpression(operator, left, right) {\n        var type = 'and' === operator || 'or' === operator ? 'LogicalExpression' : 'BinaryExpression';\n        return {\n          type: type,\n          operator: operator,\n          left: left,\n          right: right\n        };\n      },\n      unaryExpression: function unaryExpression(operator, argument) {\n        return {\n          type: 'UnaryExpression',\n          operator: operator,\n          argument: argument\n        };\n      },\n      memberExpression: function memberExpression(base, indexer, identifier) {\n        return {\n          type: 'MemberExpression',\n          indexer: indexer,\n          identifier: identifier,\n          base: base\n        };\n      },\n      indexExpression: function indexExpression(base, index) {\n        return {\n          type: 'IndexExpression',\n          base: base,\n          index: index\n        };\n      },\n      callExpression: function callExpression(base, args) {\n        return {\n          type: 'CallExpression',\n          base: base,\n          'arguments': args\n        };\n      },\n      tableCallExpression: function tableCallExpression(base, args) {\n        return {\n          type: 'TableCallExpression',\n          base: base,\n          'arguments': args\n        };\n      },\n      stringCallExpression: function stringCallExpression(base, argument) {\n        return {\n          type: 'StringCallExpression',\n          base: base,\n          argument: argument\n        };\n      },\n      comment: function comment(value, raw) {\n        return {\n          type: 'Comment',\n          value: value,\n          raw: raw\n        };\n      }\n    };\n    function finishNode(node) {\n      if (trackLocations) {\n        var location = locations.pop();\n        location.complete();\n        location.bless(node);\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      return node;\n    }\n    var slice = Array.prototype.slice,\n      toString = Object.prototype.toString;\n    var indexOf = /* istanbul ignore next */function indexOf(array, element) {\n      for (var i = 0, length = array.length; i < length; ++i) {\n        if (array[i] === element) return i;\n      }\n      return -1;\n    };\n    if (Array.prototype.indexOf) indexOf = function indexOf(array, element) {\n      return array.indexOf(element);\n    };\n    function indexOfObject(array, property, element) {\n      for (var i = 0, length = array.length; i < length; ++i) {\n        if (array[i][property] === element) return i;\n      }\n      return -1;\n    }\n    function sprintf(format) {\n      var args = slice.call(arguments, 1);\n      format = format.replace(/%(\\d)/g, function (match, index) {\n        return '' + args[index - 1] || /* istanbul ignore next */'';\n      });\n      return format;\n    }\n    var assign = /* istanbul ignore next */function assign(dest) {\n      var args = slice.call(arguments, 1),\n        src,\n        prop;\n      for (var i = 0, length = args.length; i < length; ++i) {\n        src = args[i];\n        for (prop in src) if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n      }\n      return dest;\n    };\n    if (Object.assign) assign = Object.assign;\n    exports.SyntaxError = SyntaxError;\n    function fixupError(e) {\n      if (!Object.create) return e;\n      return Object.create(e, {\n        'line': {\n          'writable': true,\n          value: e.line\n        },\n        'index': {\n          'writable': true,\n          value: e.index\n        },\n        'column': {\n          'writable': true,\n          value: e.column\n        }\n      });\n    }\n    function raise(token) {\n      var message = sprintf.apply(null, slice.call(arguments, 1)),\n        error,\n        col;\n      if (token === null || typeof token.line === 'undefined') {\n        col = index - lineStart + 1;\n        error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n        error.index = index;\n        error.line = line;\n        error.column = col;\n      } else {\n        col = token.range[0] - token.lineStart;\n        error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n        error.line = token.line;\n        error.index = token.range[0];\n        error.column = col;\n      }\n      throw error;\n    }\n    function tokenValue(token) {\n      var raw = input.slice(token.range[0], token.range[1]);\n      if (raw) return raw;\n      return token.value;\n    }\n    function raiseUnexpectedToken(type, token) {\n      raise(token, errors.expectedToken, type, tokenValue(token));\n    }\n    function unexpected(found) {\n      var near = tokenValue(lookahead);\n      if ('undefined' !== typeof found.type) {\n        var type;\n        switch (found.type) {\n          case StringLiteral:\n            type = 'string';\n            break;\n          case Keyword:\n            type = 'keyword';\n            break;\n          case Identifier:\n            type = 'identifier';\n            break;\n          case NumericLiteral:\n            type = 'number';\n            break;\n          case Punctuator:\n            type = 'symbol';\n            break;\n          case BooleanLiteral:\n            type = 'boolean';\n            break;\n          case NilLiteral:\n            return raise(found, errors.unexpected, 'symbol', 'nil', near);\n          case EOF:\n            return raise(found, errors.unexpectedEOF);\n        }\n        return raise(found, errors.unexpected, type, tokenValue(found), near);\n      }\n      return raise(found, errors.unexpected, 'symbol', found, near);\n    }\n    var index, token, previousToken, lookahead, comments, tokenStart, line, lineStart;\n    exports.lex = lex;\n    function lex() {\n      skipWhiteSpace();\n      while (45 === input.charCodeAt(index) && 45 === input.charCodeAt(index + 1)) {\n        scanComment();\n        skipWhiteSpace();\n      }\n      if (index >= length) return {\n        type: EOF,\n        value: '<eof>',\n        line: line,\n        lineStart: lineStart,\n        range: [index, index]\n      };\n      var charCode = input.charCodeAt(index),\n        next = input.charCodeAt(index + 1);\n      tokenStart = index;\n      if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n      switch (charCode) {\n        case 39:\n        case 34:\n          // '\"\n          return scanStringLiteral();\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          // 0-9\n          return scanNumericLiteral();\n        case 46:\n          // .\n          if (isDecDigit(next)) return scanNumericLiteral();\n          if (46 === next) {\n            if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n            return scanPunctuator('..');\n          }\n          return scanPunctuator('.');\n        case 61:\n          // =\n          if (61 === next) return scanPunctuator('==');\n          return scanPunctuator('=');\n        case 62:\n          // >\n          if (features.bitwiseOperators) if (62 === next) return scanPunctuator('>>');\n          if (61 === next) return scanPunctuator('>=');\n          return scanPunctuator('>');\n        case 60:\n          // <\n          if (features.bitwiseOperators) if (60 === next) return scanPunctuator('<<');\n          if (61 === next) return scanPunctuator('<=');\n          return scanPunctuator('<');\n        case 126:\n          // ~\n          if (61 === next) return scanPunctuator('~=');\n          if (!features.bitwiseOperators) break;\n          return scanPunctuator('~');\n        case 58:\n          // :\n          if (features.labels) if (58 === next) return scanPunctuator('::');\n          return scanPunctuator(':');\n        case 91:\n          // [\n          if (91 === next || 61 === next) return scanLongStringLiteral();\n          return scanPunctuator('[');\n        case 47:\n          // /\n          if (features.integerDivision) if (47 === next) return scanPunctuator('//');\n          return scanPunctuator('/');\n        case 38:\n        case 124:\n          // & |\n          if (!features.bitwiseOperators) break;\n        case 42:\n        case 94:\n        case 37:\n        case 44:\n        case 123:\n        case 125:\n        case 93:\n        case 40:\n        case 41:\n        case 59:\n        case 35:\n        case 45:\n        case 43:\n          // * ^ % , { } ] ( ) ; # - +\n          return scanPunctuator(input.charAt(index));\n      }\n      return unexpected(input.charAt(index));\n    }\n    function consumeEOL() {\n      var charCode = input.charCodeAt(index),\n        peekCharCode = input.charCodeAt(index + 1);\n      if (isLineTerminator(charCode)) {\n        if (10 === charCode && 13 === peekCharCode) ++index;\n        if (13 === charCode && 10 === peekCharCode) ++index;\n        ++line;\n        lineStart = ++index;\n        return true;\n      }\n      return false;\n    }\n    function skipWhiteSpace() {\n      while (index < length) {\n        var charCode = input.charCodeAt(index);\n        if (isWhiteSpace(charCode)) {\n          ++index;\n        } else if (!consumeEOL()) {\n          break;\n        }\n      }\n    }\n    function scanIdentifierOrKeyword() {\n      var value, type;\n      while (isIdentifierPart(input.charCodeAt(++index)));\n      value = encodingMode.fixup(input.slice(tokenStart, index));\n      if (isKeyword(value)) {\n        type = Keyword;\n      } else if ('true' === value || 'false' === value) {\n        type = BooleanLiteral;\n        value = 'true' === value;\n      } else if ('nil' === value) {\n        type = NilLiteral;\n        value = null;\n      } else {\n        type = Identifier;\n      }\n      return {\n        type: type,\n        value: value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanPunctuator(value) {\n      index += value.length;\n      return {\n        type: Punctuator,\n        value: value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanVarargLiteral() {\n      index += 3;\n      return {\n        type: VarargLiteral,\n        value: '...',\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanStringLiteral() {\n      var delimiter = input.charCodeAt(index++),\n        beginLine = line,\n        beginLineStart = lineStart,\n        stringStart = index,\n        string = encodingMode.discardStrings ? null : '',\n        charCode;\n      for (;;) {\n        charCode = input.charCodeAt(index++);\n        if (delimiter === charCode) break;\n        if (index > length || isLineTerminator(charCode)) {\n          string += input.slice(stringStart, index - 1);\n          raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n        }\n        if (92 === charCode) {\n          // backslash\n          if (!encodingMode.discardStrings) {\n            var beforeEscape = input.slice(stringStart, index - 1);\n            string += encodingMode.fixup(beforeEscape);\n          }\n          var escapeValue = readEscapeSequence();\n          if (!encodingMode.discardStrings) string += escapeValue;\n          stringStart = index;\n        }\n      }\n      if (!encodingMode.discardStrings) {\n        string += encodingMode.encodeByte(null);\n        string += encodingMode.fixup(input.slice(stringStart, index - 1));\n      }\n      return {\n        type: StringLiteral,\n        value: string,\n        line: beginLine,\n        lineStart: beginLineStart,\n        lastLine: line,\n        lastLineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanLongStringLiteral() {\n      var beginLine = line,\n        beginLineStart = lineStart,\n        string = readLongString(false);\n      if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n      return {\n        type: StringLiteral,\n        value: encodingMode.discardStrings ? null : encodingMode.fixup(string),\n        line: beginLine,\n        lineStart: beginLineStart,\n        lastLine: line,\n        lastLineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function scanNumericLiteral() {\n      var character = input.charAt(index),\n        next = input.charAt(index + 1);\n      var literal = '0' === character && 'xX'.indexOf(next || null) >= 0 ? readHexLiteral() : readDecLiteral();\n      var foundImaginaryUnit = readImaginaryUnitSuffix(),\n        foundInt64Suffix = readInt64Suffix();\n      if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n      return {\n        type: NumericLiteral,\n        value: literal.value,\n        line: line,\n        lineStart: lineStart,\n        range: [tokenStart, index]\n      };\n    }\n    function readImaginaryUnitSuffix() {\n      if (!features.imaginaryNumbers) return;\n      if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        return true;\n      } else {\n        return false;\n      }\n    }\n    function readInt64Suffix() {\n      if (!features.integerSuffixes) return;\n      if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n            ++index;\n            return 'ULL';\n          } else {\n            raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n          }\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      }\n    }\n    function readHexLiteral() {\n      var fraction = 0 // defaults to 0 as it gets summed\n        ,\n        binaryExponent = 1 // defaults to 1 as it gets multiplied\n        ,\n        binarySign = 1 // positive\n        ,\n        digit,\n        fractionStart,\n        exponentStart,\n        digitStart;\n      digitStart = index += 2; // Skip 0x part\n      if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      digit = parseInt(input.slice(digitStart, index), 16);\n      var foundFraction = false;\n      if ('.' === input.charAt(index)) {\n        foundFraction = true;\n        fractionStart = ++index;\n        while (isHexDigit(input.charCodeAt(index))) ++index;\n        fraction = input.slice(fractionStart, index);\n        fraction = fractionStart === index ? 0 : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n      }\n      var foundBinaryExponent = false;\n      if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n        foundBinaryExponent = true;\n        ++index;\n        if ('+-'.indexOf(input.charAt(index) || null) >= 0) binarySign = '+' === input.charAt(index++) ? 1 : -1;\n        exponentStart = index;\n        if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n        binaryExponent = input.slice(exponentStart, index);\n        binaryExponent = Math.pow(2, binaryExponent * binarySign);\n      }\n      return {\n        value: (digit + fraction) * binaryExponent,\n        hasFractionPart: foundFraction || foundBinaryExponent\n      };\n    }\n    function readDecLiteral() {\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      var foundFraction = false;\n      if ('.' === input.charAt(index)) {\n        foundFraction = true;\n        ++index;\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n      }\n      var foundExponent = false;\n      if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n        foundExponent = true;\n        ++index;\n        if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n        if (!isDecDigit(input.charCodeAt(index))) raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        while (isDecDigit(input.charCodeAt(index))) ++index;\n      }\n      return {\n        value: parseFloat(input.slice(tokenStart, index)),\n        hasFractionPart: foundFraction || foundExponent\n      };\n    }\n    function readUnicodeEscapeSequence() {\n      var sequenceStart = index++;\n      if (input.charAt(index++) !== '{') raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n      if (!isHexDigit(input.charCodeAt(index))) raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n      while (input.charCodeAt(index) === 0x30) ++index;\n      var escStart = index;\n      while (isHexDigit(input.charCodeAt(index))) {\n        ++index;\n        if (index - escStart > 6) raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n      }\n      var b = input.charAt(index++);\n      if (b !== '}') {\n        if (b === '\"' || b === \"'\") raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));else raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n      }\n      var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n      var frag = '\\\\' + input.slice(sequenceStart, index);\n      if (codepoint > 0x10ffff) {\n        raise(null, errors.tooLargeCodepoint, frag);\n      }\n      return encodingMode.encodeUTF8(codepoint, frag);\n    }\n    function readEscapeSequence() {\n      var sequenceStart = index;\n      switch (input.charAt(index)) {\n        case 'a':\n          ++index;\n          return '\\x07';\n        case 'n':\n          ++index;\n          return '\\n';\n        case 'r':\n          ++index;\n          return '\\r';\n        case 't':\n          ++index;\n          return '\\t';\n        case 'v':\n          ++index;\n          return '\\x0b';\n        case 'b':\n          ++index;\n          return '\\b';\n        case 'f':\n          ++index;\n          return '\\f';\n        case '\\r':\n        case '\\n':\n          consumeEOL();\n          return '\\n';\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n          var frag = input.slice(sequenceStart, index);\n          var ddd = parseInt(frag, 10);\n          if (ddd > 255) {\n            raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n          }\n          return encodingMode.encodeByte(ddd, '\\\\' + frag);\n        case 'z':\n          if (features.skipWhitespaceEscape) {\n            ++index;\n            skipWhiteSpace();\n            return '';\n          }\n          break;\n        case 'x':\n          if (features.hexEscapes) {\n            if (isHexDigit(input.charCodeAt(index + 1)) && isHexDigit(input.charCodeAt(index + 2))) {\n              index += 3;\n              return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n            }\n            raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n          }\n          break;\n        case 'u':\n          if (features.unicodeEscapes) return readUnicodeEscapeSequence();\n          break;\n        case '\\\\':\n        case '\"':\n        case \"'\":\n          return input.charAt(index++);\n      }\n      if (features.strictEscapes) raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n      return input.charAt(index++);\n    }\n    function scanComment() {\n      tokenStart = index;\n      index += 2; // --\n\n      var character = input.charAt(index),\n        content = '',\n        isLong = false,\n        commentStart = index,\n        lineStartComment = lineStart,\n        lineComment = line;\n      if ('[' === character) {\n        content = readLongString(true);\n        if (false === content) content = character;else isLong = true;\n      }\n      if (!isLong) {\n        while (index < length) {\n          if (isLineTerminator(input.charCodeAt(index))) break;\n          ++index;\n        }\n        if (options.comments) content = input.slice(commentStart, index);\n      }\n      if (options.comments) {\n        var node = ast.comment(content, input.slice(tokenStart, index));\n        if (options.locations) {\n          node.loc = {\n            start: {\n              line: lineComment,\n              column: tokenStart - lineStartComment\n            },\n            end: {\n              line: line,\n              column: index - lineStart\n            }\n          };\n        }\n        if (options.ranges) {\n          node.range = [tokenStart, index];\n        }\n        if (options.onCreateNode) options.onCreateNode(node);\n        comments.push(node);\n      }\n    }\n    function readLongString(isComment) {\n      var level = 0,\n        content = '',\n        terminator = false,\n        character,\n        stringStart,\n        firstLine = line;\n      ++index; // [\n      while ('=' === input.charAt(index + level)) ++level;\n      if ('[' !== input.charAt(index + level)) return false;\n      index += level + 1;\n      if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n      stringStart = index;\n      while (index < length) {\n        while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n        character = input.charAt(index++);\n        if (']' === character) {\n          terminator = true;\n          for (var i = 0; i < level; ++i) {\n            if ('=' !== input.charAt(index + i)) terminator = false;\n          }\n          if (']' !== input.charAt(index + level)) terminator = false;\n        }\n        if (terminator) {\n          content += input.slice(stringStart, index - 1);\n          index += level + 1;\n          return content;\n        }\n      }\n      raise(null, isComment ? errors.unfinishedLongComment : errors.unfinishedLongString, firstLine, '<eof>');\n    }\n    function next() {\n      previousToken = token;\n      token = lookahead;\n      lookahead = lex();\n    }\n    function consume(value) {\n      if (value === token.value) {\n        next();\n        return true;\n      }\n      return false;\n    }\n    function expect(value) {\n      if (value === token.value) next();else raise(token, errors.expected, value, tokenValue(token));\n    }\n    function isWhiteSpace(charCode) {\n      return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n    }\n    function isLineTerminator(charCode) {\n      return 10 === charCode || 13 === charCode;\n    }\n    function isDecDigit(charCode) {\n      return charCode >= 48 && charCode <= 57;\n    }\n    function isHexDigit(charCode) {\n      return charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70;\n    }\n    function isIdentifierStart(charCode) {\n      if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode) return true;\n      if (features.extendedIdentifiers && charCode >= 128) return true;\n      return false;\n    }\n    function isIdentifierPart(charCode) {\n      if (charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122 || 95 === charCode || charCode >= 48 && charCode <= 57) return true;\n      if (features.extendedIdentifiers && charCode >= 128) return true;\n      return false;\n    }\n    function isKeyword(id) {\n      switch (id.length) {\n        case 2:\n          return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n        case 3:\n          return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n        case 4:\n          if ('else' === id || 'then' === id) return true;\n          if (features.labels && !features.contextualGoto) return 'goto' === id;\n          return false;\n        case 5:\n          return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n        case 6:\n          return 'elseif' === id || 'repeat' === id || 'return' === id;\n        case 8:\n          return 'function' === id;\n      }\n      return false;\n    }\n    function isUnary(token) {\n      if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n      if (Keyword === token.type) return 'not' === token.value;\n      return false;\n    }\n    function isBlockFollow(token) {\n      if (EOF === token.type) return true;\n      if (Keyword !== token.type) return false;\n      switch (token.value) {\n        case 'else':\n        case 'elseif':\n        case 'end':\n        case 'until':\n          return true;\n        default:\n          return false;\n      }\n    }\n    var scopes, scopeDepth, globals;\n    function createScope() {\n      var scope = scopes[scopeDepth++].slice();\n      scopes.push(scope);\n      if (options.onCreateScope) options.onCreateScope();\n    }\n    function destroyScope() {\n      var scope = scopes.pop();\n      --scopeDepth;\n      if (options.onDestroyScope) options.onDestroyScope();\n    }\n    function scopeIdentifierName(name) {\n      if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n      if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n      scopes[scopeDepth].push(name);\n    }\n    function scopeIdentifier(node) {\n      scopeIdentifierName(node.name);\n      attachScope(node, true);\n    }\n    function attachScope(node, isLocal) {\n      if (!isLocal && -1 === indexOfObject(globals, 'name', node.name)) globals.push(node);\n      node.isLocal = isLocal;\n    }\n    function scopeHasName(name) {\n      return -1 !== indexOf(scopes[scopeDepth], name);\n    }\n    var locations = [],\n      trackLocations;\n    function createLocationMarker() {\n      return new Marker(token);\n    }\n    function Marker(token) {\n      if (options.locations) {\n        this.loc = {\n          start: {\n            line: token.line,\n            column: token.range[0] - token.lineStart\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        };\n      }\n      if (options.ranges) this.range = [token.range[0], 0];\n    }\n    Marker.prototype.complete = function () {\n      if (options.locations) {\n        this.loc.end.line = previousToken.lastLine || previousToken.line;\n        this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n      }\n      if (options.ranges) {\n        this.range[1] = previousToken.range[1];\n      }\n    };\n    Marker.prototype.bless = function (node) {\n      if (this.loc) {\n        var loc = this.loc;\n        node.loc = {\n          start: {\n            line: loc.start.line,\n            column: loc.start.column\n          },\n          end: {\n            line: loc.end.line,\n            column: loc.end.column\n          }\n        };\n      }\n      if (this.range) {\n        node.range = [this.range[0], this.range[1]];\n      }\n    };\n    function markLocation() {\n      if (trackLocations) locations.push(createLocationMarker());\n    }\n    function pushLocation(marker) {\n      if (trackLocations) locations.push(marker);\n    }\n    function FullFlowContext() {\n      this.scopes = [];\n      this.pendingGotos = [];\n    }\n    FullFlowContext.prototype.isInLoop = function () {\n      var i = this.scopes.length;\n      while (i-- > 0) {\n        if (this.scopes[i].isLoop) return true;\n      }\n      return false;\n    };\n    FullFlowContext.prototype.pushScope = function (isLoop) {\n      var scope = {\n        labels: {},\n        locals: [],\n        deferredGotos: [],\n        isLoop: !!isLoop\n      };\n      this.scopes.push(scope);\n    };\n    FullFlowContext.prototype.popScope = function () {\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n        if (theGoto.maxDepth >= this.scopes.length) if (--theGoto.maxDepth <= 0) raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n      }\n      this.scopes.pop();\n    };\n    FullFlowContext.prototype.addGoto = function (target, token) {\n      var localCounts = [];\n      for (var i = 0; i < this.scopes.length; ++i) {\n        var scope = this.scopes[i];\n        localCounts.push(scope.locals.length);\n        if (Object.prototype.hasOwnProperty.call(scope.labels, target)) return;\n      }\n      this.pendingGotos.push({\n        maxDepth: this.scopes.length,\n        target: target,\n        token: token,\n        localCounts: localCounts\n      });\n    };\n    FullFlowContext.prototype.addLabel = function (name, token) {\n      var scope = this.currentScope();\n      if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n        raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n      } else {\n        var newGotos = [];\n        for (var i = 0; i < this.pendingGotos.length; ++i) {\n          var theGoto = this.pendingGotos[i];\n          if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n            if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n              scope.deferredGotos.push(theGoto);\n            }\n            continue;\n          }\n          newGotos.push(theGoto);\n        }\n        this.pendingGotos = newGotos;\n      }\n      scope.labels[name] = {\n        localCount: scope.locals.length,\n        line: token.line\n      };\n    };\n    FullFlowContext.prototype.addLocal = function (name, token) {\n      this.currentScope().locals.push({\n        name: name,\n        token: token\n      });\n    };\n    FullFlowContext.prototype.currentScope = function () {\n      return this.scopes[this.scopes.length - 1];\n    };\n    FullFlowContext.prototype.raiseDeferredErrors = function () {\n      var scope = this.currentScope();\n      var bads = scope.deferredGotos;\n      for (var i = 0; i < bads.length; ++i) {\n        var theGoto = bads[i];\n        raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n      }\n    };\n    function LoopFlowContext() {\n      this.level = 0;\n      this.loopLevels = [];\n    }\n    LoopFlowContext.prototype.isInLoop = function () {\n      return !!this.loopLevels.length;\n    };\n    LoopFlowContext.prototype.pushScope = function (isLoop) {\n      ++this.level;\n      if (isLoop) this.loopLevels.push(this.level);\n    };\n    LoopFlowContext.prototype.popScope = function () {\n      var levels = this.loopLevels;\n      var levlen = levels.length;\n      if (levlen) {\n        if (levels[levlen - 1] === this.level) levels.pop();\n      }\n      --this.level;\n    };\n    LoopFlowContext.prototype.addGoto = LoopFlowContext.prototype.addLabel = function () {\n      throw new Error('This should never happen');\n    };\n    LoopFlowContext.prototype.addLocal = LoopFlowContext.prototype.raiseDeferredErrors = function () {};\n    function makeFlowContext() {\n      return features.labels ? new FullFlowContext() : new LoopFlowContext();\n    }\n    function parseChunk() {\n      next();\n      markLocation();\n      if (options.scope) createScope();\n      var flowContext = makeFlowContext();\n      flowContext.allowVararg = true;\n      flowContext.pushScope();\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      if (EOF !== token.type) unexpected(token);\n      if (trackLocations && !body.length) previousToken = token;\n      return finishNode(ast.chunk(body));\n    }\n    function parseBlock(flowContext) {\n      var block = [],\n        statement;\n      while (!isBlockFollow(token)) {\n        if ('return' === token.value || !features.relaxedBreak && 'break' === token.value) {\n          block.push(parseStatement(flowContext));\n          break;\n        }\n        statement = parseStatement(flowContext);\n        consume(';');\n        if (statement) block.push(statement);\n      }\n      return block;\n    }\n    function parseStatement(flowContext) {\n      markLocation();\n      if (Punctuator === token.type) {\n        if (consume('::')) return parseLabelStatement(flowContext);\n      }\n      if (features.emptyStatement) {\n        if (consume(';')) {\n          if (trackLocations) locations.pop();\n          return;\n        }\n      }\n      flowContext.raiseDeferredErrors();\n      if (Keyword === token.type) {\n        switch (token.value) {\n          case 'local':\n            next();\n            return parseLocalStatement(flowContext);\n          case 'if':\n            next();\n            return parseIfStatement(flowContext);\n          case 'return':\n            next();\n            return parseReturnStatement(flowContext);\n          case 'function':\n            next();\n            var name = parseFunctionName();\n            return parseFunctionDeclaration(name);\n          case 'while':\n            next();\n            return parseWhileStatement(flowContext);\n          case 'for':\n            next();\n            return parseForStatement(flowContext);\n          case 'repeat':\n            next();\n            return parseRepeatStatement(flowContext);\n          case 'break':\n            next();\n            if (!flowContext.isInLoop()) raise(token, errors.noLoopToBreak, token.value);\n            return parseBreakStatement();\n          case 'do':\n            next();\n            return parseDoStatement(flowContext);\n          case 'goto':\n            next();\n            return parseGotoStatement(flowContext);\n        }\n      }\n      if (features.contextualGoto && token.type === Identifier && token.value === 'goto' && lookahead.type === Identifier && lookahead.value !== 'goto') {\n        next();\n        return parseGotoStatement(flowContext);\n      }\n      if (trackLocations) locations.pop();\n      return parseAssignmentOrCallStatement(flowContext);\n    }\n    function parseLabelStatement(flowContext) {\n      var nameToken = token,\n        label = parseIdentifier();\n      if (options.scope) {\n        scopeIdentifierName('::' + nameToken.value + '::');\n        attachScope(label, true);\n      }\n      expect('::');\n      flowContext.addLabel(nameToken.value, nameToken);\n      return finishNode(ast.labelStatement(label));\n    }\n    function parseBreakStatement() {\n      return finishNode(ast.breakStatement());\n    }\n    function parseGotoStatement(flowContext) {\n      var name = token.value,\n        gotoToken = previousToken,\n        label = parseIdentifier();\n      flowContext.addGoto(name, gotoToken);\n      return finishNode(ast.gotoStatement(label));\n    }\n    function parseDoStatement(flowContext) {\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      expect('end');\n      return finishNode(ast.doStatement(body));\n    }\n    function parseWhileStatement(flowContext) {\n      var condition = parseExpectedExpression(flowContext);\n      expect('do');\n      if (options.scope) createScope();\n      flowContext.pushScope(true);\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      expect('end');\n      return finishNode(ast.whileStatement(condition, body));\n    }\n    function parseRepeatStatement(flowContext) {\n      if (options.scope) createScope();\n      flowContext.pushScope(true);\n      var body = parseBlock(flowContext);\n      expect('until');\n      flowContext.raiseDeferredErrors();\n      var condition = parseExpectedExpression(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      return finishNode(ast.repeatStatement(condition, body));\n    }\n    function parseReturnStatement(flowContext) {\n      var expressions = [];\n      if ('end' !== token.value) {\n        var expression = parseExpression(flowContext);\n        if (null != expression) expressions.push(expression);\n        while (consume(',')) {\n          expression = parseExpectedExpression(flowContext);\n          expressions.push(expression);\n        }\n        consume(';'); // grammar tells us ; is optional here.\n      }\n\n      return finishNode(ast.returnStatement(expressions));\n    }\n    function parseIfStatement(flowContext) {\n      var clauses = [],\n        condition,\n        body,\n        marker;\n      if (trackLocations) {\n        marker = locations[locations.length - 1];\n        locations.push(marker);\n      }\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.ifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n      while (consume('elseif')) {\n        pushLocation(marker);\n        condition = parseExpectedExpression(flowContext);\n        expect('then');\n        if (options.scope) createScope();\n        flowContext.pushScope();\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        if (options.scope) destroyScope();\n        clauses.push(finishNode(ast.elseifClause(condition, body)));\n        if (trackLocations) marker = createLocationMarker();\n      }\n      if (consume('else')) {\n        if (trackLocations) {\n          marker = new Marker(previousToken);\n          locations.push(marker);\n        }\n        if (options.scope) createScope();\n        flowContext.pushScope();\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        if (options.scope) destroyScope();\n        clauses.push(finishNode(ast.elseClause(body)));\n      }\n      expect('end');\n      return finishNode(ast.ifStatement(clauses));\n    }\n    function parseForStatement(flowContext) {\n      var variable = parseIdentifier(),\n        body;\n      if (options.scope) {\n        createScope();\n        scopeIdentifier(variable);\n      }\n      if (consume('=')) {\n        var start = parseExpectedExpression(flowContext);\n        expect(',');\n        var end = parseExpectedExpression(flowContext);\n        var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n        expect('do');\n        flowContext.pushScope(true);\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        expect('end');\n        if (options.scope) destroyScope();\n        return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n      } else {\n        var variables = [variable];\n        while (consume(',')) {\n          variable = parseIdentifier();\n          if (options.scope) scopeIdentifier(variable);\n          variables.push(variable);\n        }\n        expect('in');\n        var iterators = [];\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          iterators.push(expression);\n        } while (consume(','));\n        expect('do');\n        flowContext.pushScope(true);\n        body = parseBlock(flowContext);\n        flowContext.popScope();\n        expect('end');\n        if (options.scope) destroyScope();\n        return finishNode(ast.forGenericStatement(variables, iterators, body));\n      }\n    }\n    function parseLocalStatement(flowContext) {\n      var name,\n        declToken = previousToken;\n      if (Identifier === token.type) {\n        var variables = [],\n          init = [];\n        do {\n          name = parseIdentifier();\n          variables.push(name);\n          flowContext.addLocal(name.name, declToken);\n        } while (consume(','));\n        if (consume('=')) {\n          do {\n            var expression = parseExpectedExpression(flowContext);\n            init.push(expression);\n          } while (consume(','));\n        }\n        if (options.scope) {\n          for (var i = 0, l = variables.length; i < l; ++i) {\n            scopeIdentifier(variables[i]);\n          }\n        }\n        return finishNode(ast.localStatement(variables, init));\n      }\n      if (consume('function')) {\n        name = parseIdentifier();\n        flowContext.addLocal(name.name, declToken);\n        if (options.scope) {\n          scopeIdentifier(name);\n          createScope();\n        }\n        return parseFunctionDeclaration(name, true);\n      } else {\n        raiseUnexpectedToken('<name>', token);\n      }\n    }\n    function parseAssignmentOrCallStatement(flowContext) {\n      var previous = token,\n        marker,\n        startMarker;\n      var lvalue, base, name;\n      var targets = [];\n      if (trackLocations) startMarker = createLocationMarker();\n      do {\n        if (trackLocations) marker = createLocationMarker();\n        if (Identifier === token.type) {\n          name = token.value;\n          base = parseIdentifier();\n          if (options.scope) attachScope(base, scopeHasName(name));\n          lvalue = true;\n        } else if ('(' === token.value) {\n          next();\n          base = parseExpectedExpression(flowContext);\n          expect(')');\n          lvalue = false;\n        } else {\n          return unexpected(token);\n        }\n        both: for (;;) {\n          var newBase;\n          switch (StringLiteral === token.type ? '\"' : token.value) {\n            case '.':\n            case '[':\n              lvalue = true;\n              break;\n            case ':':\n            case '(':\n            case '{':\n            case '\"':\n              lvalue = null;\n              break;\n            default:\n              break both;\n          }\n          base = parsePrefixExpressionPart(base, marker, flowContext);\n        }\n        targets.push(base);\n        if (',' !== token.value) break;\n        if (!lvalue) {\n          return unexpected(token);\n        }\n        next();\n      } while (true);\n      if (targets.length === 1 && lvalue === null) {\n        pushLocation(marker);\n        return finishNode(ast.callStatement(targets[0]));\n      } else if (!lvalue) {\n        return unexpected(token);\n      }\n      expect('=');\n      var values = [];\n      do {\n        values.push(parseExpectedExpression(flowContext));\n      } while (consume(','));\n      pushLocation(startMarker);\n      return finishNode(ast.assignmentStatement(targets, values));\n    }\n    function parseIdentifier() {\n      markLocation();\n      var identifier = token.value;\n      if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n      next();\n      return finishNode(ast.identifier(identifier));\n    }\n    function parseFunctionDeclaration(name, isLocal) {\n      var flowContext = makeFlowContext();\n      flowContext.pushScope();\n      var parameters = [];\n      expect('(');\n      if (!consume(')')) {\n        while (true) {\n          if (Identifier === token.type) {\n            var parameter = parseIdentifier();\n            if (options.scope) scopeIdentifier(parameter);\n            parameters.push(parameter);\n            if (consume(',')) continue;\n          } else if (VarargLiteral === token.type) {\n            flowContext.allowVararg = true;\n            parameters.push(parsePrimaryExpression(flowContext));\n          } else {\n            raiseUnexpectedToken('<name> or \\'...\\'', token);\n          }\n          expect(')');\n          break;\n        }\n      }\n      var body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n      isLocal = isLocal || false;\n      return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n    }\n    function parseFunctionName() {\n      var base, name, marker;\n      if (trackLocations) marker = createLocationMarker();\n      base = parseIdentifier();\n      if (options.scope) {\n        attachScope(base, scopeHasName(base.name));\n        createScope();\n      }\n      while (consume('.')) {\n        pushLocation(marker);\n        name = parseIdentifier();\n        base = finishNode(ast.memberExpression(base, '.', name));\n      }\n      if (consume(':')) {\n        pushLocation(marker);\n        name = parseIdentifier();\n        base = finishNode(ast.memberExpression(base, ':', name));\n        if (options.scope) scopeIdentifierName('self');\n      }\n      return base;\n    }\n    function parseTableConstructor(flowContext) {\n      var fields = [],\n        key,\n        value;\n      while (true) {\n        markLocation();\n        if (Punctuator === token.type && consume('[')) {\n          key = parseExpectedExpression(flowContext);\n          expect(']');\n          expect('=');\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKey(key, value)));\n        } else if (Identifier === token.type) {\n          if ('=' === lookahead.value) {\n            key = parseIdentifier();\n            next();\n            value = parseExpectedExpression(flowContext);\n            fields.push(finishNode(ast.tableKeyString(key, value)));\n          } else {\n            value = parseExpectedExpression(flowContext);\n            fields.push(finishNode(ast.tableValue(value)));\n          }\n        } else {\n          if (null == (value = parseExpression(flowContext))) {\n            locations.pop();\n            break;\n          }\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n        if (',;'.indexOf(token.value) >= 0) {\n          next();\n          continue;\n        }\n        break;\n      }\n      expect('}');\n      return finishNode(ast.tableConstructorExpression(fields));\n    }\n    function parseExpression(flowContext) {\n      var expression = parseSubExpression(0, flowContext);\n      return expression;\n    }\n    function parseExpectedExpression(flowContext) {\n      var expression = parseExpression(flowContext);\n      if (null == expression) raiseUnexpectedToken('<expression>', token);else return expression;\n    }\n    function binaryPrecedence(operator) {\n      var charCode = operator.charCodeAt(0),\n        length = operator.length;\n      if (1 === length) {\n        switch (charCode) {\n          case 94:\n            return 12;\n          // ^\n          case 42:\n          case 47:\n          case 37:\n            return 10;\n          // * / %\n          case 43:\n          case 45:\n            return 9;\n          // + -\n          case 38:\n            return 6;\n          // &\n          case 126:\n            return 5;\n          // ~\n          case 124:\n            return 4;\n          // |\n          case 60:\n          case 62:\n            return 3;\n          // < >\n        }\n      } else if (2 === length) {\n        switch (charCode) {\n          case 47:\n            return 10;\n          // //\n          case 46:\n            return 8;\n          // ..\n          case 60:\n          case 62:\n            if ('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3;\n          // <= >=\n          case 61:\n          case 126:\n            return 3;\n          // == ~=\n          case 111:\n            return 1;\n          // or\n        }\n      } else if (97 === charCode && 'and' === operator) return 2;\n      return 0;\n    }\n    function parseSubExpression(minPrecedence, flowContext) {\n      var operator = token.value,\n        expression,\n        marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (isUnary(token)) {\n        markLocation();\n        next();\n        var argument = parseSubExpression(10, flowContext);\n        if (argument == null) raiseUnexpectedToken('<expression>', token);\n        expression = finishNode(ast.unaryExpression(operator, argument));\n      }\n      if (null == expression) {\n        expression = parsePrimaryExpression(flowContext);\n        if (null == expression) {\n          expression = parsePrefixExpression(flowContext);\n        }\n      }\n      if (null == expression) return null;\n      var precedence;\n      while (true) {\n        operator = token.value;\n        precedence = Punctuator === token.type || Keyword === token.type ? binaryPrecedence(operator) : 0;\n        if (precedence === 0 || precedence <= minPrecedence) break;\n        if ('^' === operator || '..' === operator) --precedence;\n        next();\n        var right = parseSubExpression(precedence, flowContext);\n        if (null == right) raiseUnexpectedToken('<expression>', token);\n        if (trackLocations) locations.push(marker);\n        expression = finishNode(ast.binaryExpression(operator, expression, right));\n      }\n      return expression;\n    }\n    function parsePrefixExpressionPart(base, marker, flowContext) {\n      var expression, identifier;\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '[':\n            pushLocation(marker);\n            next();\n            expression = parseExpectedExpression(flowContext);\n            expect(']');\n            return finishNode(ast.indexExpression(base, expression));\n          case '.':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            return finishNode(ast.memberExpression(base, '.', identifier));\n          case ':':\n            pushLocation(marker);\n            next();\n            identifier = parseIdentifier();\n            base = finishNode(ast.memberExpression(base, ':', identifier));\n            pushLocation(marker);\n            return parseCallExpression(base, flowContext);\n          case '(':\n          case '{':\n            // args\n            pushLocation(marker);\n            return parseCallExpression(base, flowContext);\n        }\n      } else if (StringLiteral === token.type) {\n        pushLocation(marker);\n        return parseCallExpression(base, flowContext);\n      }\n      return null;\n    }\n    function parsePrefixExpression(flowContext) {\n      var base, name, marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        if (options.scope) attachScope(base, scopeHasName(name));\n      } else if (consume('(')) {\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n      } else {\n        return null;\n      }\n      for (;;) {\n        var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n        if (newBase === null) break;\n        base = newBase;\n      }\n      return base;\n    }\n    function parseCallExpression(base, flowContext) {\n      if (Punctuator === token.type) {\n        switch (token.value) {\n          case '(':\n            if (!features.emptyStatement) {\n              if (token.line !== previousToken.line) raise(null, errors.ambiguousSyntax, token.value);\n            }\n            next();\n            var expressions = [];\n            var expression = parseExpression(flowContext);\n            if (null != expression) expressions.push(expression);\n            while (consume(',')) {\n              expression = parseExpectedExpression(flowContext);\n              expressions.push(expression);\n            }\n            expect(')');\n            return finishNode(ast.callExpression(base, expressions));\n          case '{':\n            markLocation();\n            next();\n            var table = parseTableConstructor(flowContext);\n            return finishNode(ast.tableCallExpression(base, table));\n        }\n      } else if (StringLiteral === token.type) {\n        return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n      }\n      raiseUnexpectedToken('function arguments', token);\n    }\n    function parsePrimaryExpression(flowContext) {\n      var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral,\n        value = token.value,\n        type = token.type,\n        marker;\n      if (trackLocations) marker = createLocationMarker();\n      if (type === VarargLiteral && !flowContext.allowVararg) {\n        raise(token, errors.cannotUseVararg, token.value);\n      }\n      if (type & literals) {\n        pushLocation(marker);\n        var raw = input.slice(token.range[0], token.range[1]);\n        next();\n        return finishNode(ast.literal(type, value, raw));\n      } else if (Keyword === type && 'function' === value) {\n        pushLocation(marker);\n        next();\n        if (options.scope) createScope();\n        return parseFunctionDeclaration(null);\n      } else if (consume('{')) {\n        pushLocation(marker);\n        return parseTableConstructor(flowContext);\n      }\n    }\n    exports.parse = parse;\n    var versionFeatures = {\n      '5.1': {},\n      '5.2': {\n        labels: true,\n        emptyStatement: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        relaxedBreak: true\n      },\n      '5.3': {\n        labels: true,\n        emptyStatement: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        unicodeEscapes: true,\n        bitwiseOperators: true,\n        integerDivision: true,\n        relaxedBreak: true\n      },\n      'LuaJIT': {\n        labels: true,\n        contextualGoto: true,\n        hexEscapes: true,\n        skipWhitespaceEscape: true,\n        strictEscapes: true,\n        unicodeEscapes: true,\n        imaginaryNumbers: true,\n        integerSuffixes: true\n      }\n    };\n    function parse(_input, _options) {\n      if ('undefined' === typeof _options && 'object' === typeof _input) {\n        _options = _input;\n        _input = undefined;\n      }\n      if (!_options) _options = {};\n      input = _input || '';\n      options = assign({}, defaultOptions, _options);\n      index = 0;\n      line = 1;\n      lineStart = 0;\n      length = input.length;\n      scopes = [[]];\n      scopeDepth = 0;\n      globals = [];\n      locations = [];\n      if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n        throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n      }\n      features = assign({}, versionFeatures[options.luaVersion]);\n      if (options.extendedIdentifiers !== void 0) features.extendedIdentifiers = !!options.extendedIdentifiers;\n      if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n        throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n      }\n      encodingMode = encodingModes[options.encodingMode];\n      if (options.comments) comments = [];\n      if (!options.wait) return end();\n      return exports;\n    }\n    exports.write = write;\n    function write(_input) {\n      input += String(_input);\n      length = input.length;\n      return exports;\n    }\n    exports.end = end;\n    function end(_input) {\n      if ('undefined' !== typeof _input) write(_input);\n      if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n        return line.replace(/./g, ' ');\n      });\n      length = input.length;\n      trackLocations = options.locations || options.ranges;\n      lookahead = lex();\n      var chunk = parseChunk();\n      if (options.comments) chunk.comments = comments;\n      if (options.scope) chunk.globals = globals;\n      if (locations.length > 0) throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n      return chunk;\n    }\n  });\n});\nace.define(\"ace/mode/lua_worker\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var Mirror = require(\"../worker/mirror\").Mirror;\n  var luaparse = require(\"../mode/lua/luaparse\");\n  var Worker = exports.Worker = function (sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(500);\n  };\n  oop.inherits(Worker, Mirror);\n  (function () {\n    this.onUpdate = function () {\n      var value = this.doc.getValue();\n      var errors = [];\n      try {\n        luaparse.parse(value);\n      } catch (e) {\n        if (e instanceof luaparse.SyntaxError) {\n          errors.push({\n            row: e.line - 1,\n            column: e.column,\n            text: e.message,\n            type: \"error\"\n          });\n        }\n      }\n      this.sender.emit(\"annotate\", errors);\n    };\n  }).call(Worker.prototype);\n});"}