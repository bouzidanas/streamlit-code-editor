{"code":"ace.define(\"ace/ext/hardwrap\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/editor\",\"ace/config\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range;function o(e,t){for(var n=t.column||e.getOption(\"printMarginColumn\"),o=0!=t.allowMerge,i=Math.min(t.startRow,t.endRow),a=Math.max(t.startRow,t.endRow),s=e.session;i<=a;){var c=s.getLine(i);if(c.length>n){if(h=g(c,n,5)){var l=/^\\s*/.exec(c)[0];s.replace(new r(i,h.start,i,h.end),\"\\n\"+l)}a++}else if(o&&/\\S/.test(c)&&i!=a){var u=s.getLine(i+1);if(u&&/\\S/.test(u)){var h,p=c.replace(/\\s+$/,\"\"),d=u.replace(/^\\s+/,\"\"),f=p+\" \"+d;if((h=g(f,n,5))&&h.start>p.length||f.length<n){var m=new r(i,p.length,i+1,u.length-d.length);s.replace(m,\" \"),i--,a--}else p.length<c.length&&s.remove(new r(i,p.length,i,c.length))}}i++}function g(e,t,n){if(!(e.length<t)){var r=e.slice(0,t),o=e.slice(t),i=/^(?:(\\s+)|(\\S+)(\\s+))/.exec(o),a=/(?:(\\s+)|(\\s+)(\\S+))$/.exec(r),s=0,c=0;return a&&!a[2]&&(s=t-a[1].length,c=t),i&&!i[2]&&(s||(s=t),c=t+i[1].length),s?{start:s,end:c}:a&&a[2]&&a.index>n?{start:a.index,end:a.index+a[2].length}:i&&i[2]?{start:s=t+i[2].length,end:s+i[3].length}:void 0}}}function i(e){if(\"insertstring\"==e.command.name&&/\\S/.test(e.args)){var t=e.editor,n=t.selection.cursor;if(n.column<=t.renderer.$printMarginColumn)return;var r=t.session.$undoManager.$lastDelta;o(t,{startRow:n.row,endRow:n.row,allowMerge:!1}),r!=t.session.$undoManager.$lastDelta&&t.session.markUndoGroup()}}var a=e(\"../editor\").Editor;e(\"../config\").defineOptions(a.prototype,\"editor\",{hardWrap:{set:function(e){e?this.commands.on(\"afterExec\",i):this.commands.off(\"afterExec\",i)},value:!1}}),t.hardWrap=o})),ace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/ext/hardwrap\",\"ace/multi_select\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range,o=e(\"../lib/event_emitter\").EventEmitter,i=e(\"../lib/dom\"),a=e(\"../lib/oop\"),s=e(\"../lib/keys\"),c=e(\"../lib/event\"),l=e(\"../search\").Search,u=e(\"../lib/useragent\"),h=e(\"../search_highlight\").SearchHighlight,p=e(\"../commands/multi_select_commands\"),d=e(\"../mode/text\").Mode.prototype.tokenRe,f=e(\"../ext/hardwrap\").hardWrap;e(\"../multi_select\");var m=function(e){this.ace=e,this.state={},this.marks={},this.options={},this.$uid=0,this.onChange=this.onChange.bind(this),this.onSelectionChange=this.onSelectionChange.bind(this),this.onBeforeEndOperation=this.onBeforeEndOperation.bind(this),this.ace.on(\"change\",this.onChange),this.ace.on(\"changeSelection\",this.onSelectionChange),this.ace.on(\"beforeEndOperation\",this.onBeforeEndOperation)};function g(e){return{row:e.line,column:e.ch}}function v(e){return new y(e.row,e.column)}m.Pos=function(e,t){if(!(this instanceof y))return new y(e,t);this.line=e,this.ch=t},m.defineOption=function(e,t,n){},m.commands={redo:function(e){e.ace.redo()},undo:function(e){e.ace.undo()},newlineAndIndent:function(e){e.ace.insert(\"\\n\")},goLineLeft:function(e){e.ace.selection.moveCursorLineStart()},goLineRight:function(e){e.ace.selection.moveCursorLineEnd()}},m.keyMap={},m.addClass=m.rmClass=function(){},m.e_stop=m.e_preventDefault=c.stopEvent,m.keyName=function(e){var t=s[e.keyCode]||e.key||\"\";return 1==t.length&&(t=t.toUpperCase()),t=c.getModifierString(e).replace(/(^|-)\\w/g,(function(e){return e.toUpperCase()}))+t},m.keyMap.default=function(e){return function(t){var n=t.ace.commands.commandKeyBinding[e.toLowerCase()];return n&&!1!==t.ace.execCommand(n)}},m.lookupKey=function e(t,n,r){n||(n=\"default\"),\"string\"==typeof n&&(n=m.keyMap[n]);var o=\"function\"==typeof n?n(t):n[t];if(!1===o)return\"nothing\";if(\"...\"===o)return\"multi\";if(null!=o&&r(o))return\"handled\";if(n.fallthrough){if(!Array.isArray(n.fallthrough))return e(t,n.fallthrough,r);for(var i=0;i<n.fallthrough.length;i++){var a=e(t,n.fallthrough[i],r);if(a)return a}}},m.findMatchingTag=function(e,t){return e.findMatchingTag(t)},m.findEnclosingTag=function(e,t){},m.signal=function(e,t,n){return e._signal(t,n)},m.on=c.addListener,m.off=c.removeListener,m.isWordChar=function(e){return e<\"\\x7f\"?/^\\w$/.test(e):(d.lastIndex=0,d.test(e))},function(){a.implement(m.prototype,o),this.destroy=function(){this.ace.off(\"change\",this.onChange),this.ace.off(\"changeSelection\",this.onSelectionChange),this.ace.off(\"beforeEndOperation\",this.onBeforeEndOperation),this.removeOverlay()},this.virtualSelectionMode=function(){return this.ace.inVirtualSelectionMode&&this.ace.selection.index},this.onChange=function(e){var t={text:\"i\"==e.action[0]?e.lines:[]},n=this.curOp=this.curOp||{};n.changeHandlers||(n.changeHandlers=this._eventRegistry.change&&this._eventRegistry.change.slice()),n.lastChange?n.lastChange.next=n.lastChange=t:n.lastChange=n.change=t,this.$updateMarkers(e)},this.onSelectionChange=function(){var e=this.curOp=this.curOp||{};e.cursorActivityHandlers||(e.cursorActivityHandlers=this._eventRegistry.cursorActivity&&this._eventRegistry.cursorActivity.slice()),this.curOp.cursorActivity=!0,this.ace.inMultiSelectMode&&this.ace.keyBinding.removeKeyboardHandler(p.keyboardHandler)},this.operation=function(e,t){if(!t&&this.curOp||t&&this.curOp&&this.curOp.force)return e();if(!t&&this.ace.curOp||this.curOp&&this.onBeforeEndOperation(),!this.ace.curOp){var n=this.ace.prevOp;this.ace.startOperation({command:{name:\"vim\",scrollIntoView:\"cursor\"}})}var r=this.curOp=this.curOp||{};this.curOp.force=t;var o=e();return this.ace.curOp&&\"vim\"==this.ace.curOp.command.name&&(this.state.dialog&&(this.ace.curOp.command.scrollIntoView=this.ace.curOp.vimDialogScroll),this.ace.endOperation(),r.cursorActivity||r.lastChange||!n||(this.ace.prevOp=n)),!t&&this.ace.curOp||this.curOp&&this.onBeforeEndOperation(),o},this.onBeforeEndOperation=function(){var e=this.curOp;e&&(e.change&&this.signal(\"change\",e.change,e),e&&e.cursorActivity&&this.signal(\"cursorActivity\",null,e),this.curOp=null)},this.signal=function(e,t,n){var r=n?n[e+\"Handlers\"]:(this._eventRegistry||{})[e];if(r){r=r.slice();for(var o=0;o<r.length;o++)r[o](this,t)}},this.firstLine=function(){return 0},this.lastLine=function(){return this.ace.session.getLength()-1},this.lineCount=function(){return this.ace.session.getLength()},this.setCursor=function(e,t){\"object\"===typeof e&&(t=e.ch,e=e.line);var n=!this.curOp&&!this.ace.inVirtualSelectionMode;this.ace.inVirtualSelectionMode||this.ace.exitMultiSelectMode(),this.ace.session.unfold({row:e,column:t}),this.ace.selection.moveTo(e,t),n&&(this.ace.renderer.scrollCursorIntoView(),this.ace.endOperation())},this.getCursor=function(e){var t=this.ace.selection;return v(\"anchor\"==e?t.isEmpty()?t.lead:t.anchor:\"head\"!=e&&e?t.getRange()[e]:t.lead)},this.listSelections=function(e){var t=this.ace.multiSelect.rangeList.ranges;return!t.length||this.ace.inVirtualSelectionMode?[{anchor:this.getCursor(\"anchor\"),head:this.getCursor(\"head\")}]:t.map((function(e){return{anchor:this.clipPos(v(e.cursor==e.end?e.start:e.end)),head:this.clipPos(v(e.cursor))}}),this)},this.setSelections=function(e,t){var n=this.ace.multiSelect,o=e.map((function(e){var t=g(e.anchor),n=g(e.head),o=r.comparePoints(t,n)<0?new r.fromPoints(t,n):new r.fromPoints(n,t);return o.cursor=r.comparePoints(o.start,n)?o.end:o.start,o}));if(this.ace.inVirtualSelectionMode)this.ace.selection.fromOrientedRange(o[0]);else{t?o[t]&&o.push(o.splice(t,1)[0]):o=o.reverse(),n.toSingleRange(o[0].clone());for(var i=this.ace.session,a=0;a<o.length;a++){var s=i.$clipRangeToDocument(o[a]);n.addRange(s)}}},this.setSelection=function(e,t,n){var r=this.ace.selection;r.moveTo(e.line,e.ch),r.selectTo(t.line,t.ch),n&&\"*mouse\"==n.origin&&this.onBeforeEndOperation()},this.somethingSelected=function(e){return!this.ace.selection.isEmpty()},this.clipPos=function(e){return v(this.ace.session.$clipPositionToDocument(e.line,e.ch))},this.foldCode=function(e){this.ace.session.$toggleFoldWidget(e.line,{})},this.markText=function(e){return{clear:function(){},find:function(){}}},this.$updateMarkers=function(e){var t=\"insert\"==e.action,n=e.start,o=e.end,i=(o.row-n.row)*(t?1:-1),a=(o.column-n.column)*(t?1:-1);for(var s in t&&(o=n),this.marks){var c=this.marks[s],l=r.comparePoints(c,n);if(!(l<0)){if(0===l&&t){if(1!=c.bias){c.bias=-1;continue}l=1}var u=t?l:r.comparePoints(c,o);u>0?(c.row+=i,c.column+=c.row==o.row?a:0):!t&&u<=0&&(c.row=n.row,c.column=n.column,0===u&&(c.bias=1))}}};var e=function(e,t,n,r){this.cm=e,this.id=t,this.row=n,this.column=r,e.marks[this.id]=this};e.prototype.clear=function(){delete this.cm.marks[this.id]},e.prototype.find=function(){return v(this)},this.setBookmark=function(t,n){var r=new e(this,this.$uid++,t.line,t.ch);return n&&n.insertLeft||(r.$insertRight=!0),this.marks[r.id]=r,r},this.moveH=function(e,t){if(\"char\"==t){var n=this.ace.selection;n.clearSelection(),n.moveCursorBy(0,e)}},this.findPosV=function(e,t,n,r){if(\"page\"==n){var o=this.ace.renderer.layerConfig;t*=Math.floor(o.height/o.lineHeight),n=\"line\"}if(\"line\"==n){var i=this.ace.session.documentToScreenPosition(e.line,e.ch);return null!=r&&(i.column=r),i.row+=t,i.row=Math.min(Math.max(0,i.row),this.ace.session.getScreenLength()-1),v(this.ace.session.screenToDocumentPosition(i.row,i.column))}},this.charCoords=function(e,t){if(\"div\"==t||!t)return{left:(r=this.ace.session.documentToScreenPosition(e.line,e.ch)).column,top:r.row};if(\"local\"==t){var n=this.ace.renderer,r=this.ace.session.documentToScreenPosition(e.line,e.ch),o=n.layerConfig.lineHeight,i=n.layerConfig.characterWidth,a=o*r.row;return{left:r.column*i,top:a,bottom:a+o}}},this.coordsChar=function(e,t){var n=this.ace.renderer;if(\"local\"==t){var r=Math.max(0,Math.floor(e.top/n.lineHeight)),o=Math.max(0,Math.floor(e.left/n.characterWidth));return v(n.session.screenToDocumentPosition(r,o))}if(\"div\"==t)throw\"not implemented\"},this.getSearchCursor=function(e,t,n){var r=!1,o=!1;e instanceof RegExp&&!e.global&&(r=!e.ignoreCase,e=e.source,o=!0),\"\\\\n\"==e&&(e=\"\\n\",o=!1);var i=new l;void 0==t.ch&&(t.ch=Number.MAX_VALUE);var a={row:t.line,column:t.ch},s=this,c=null;return{findNext:function(){return this.find(!1)},findPrevious:function(){return this.find(!0)},find:function(t){i.setOptions({needle:e,caseSensitive:r,wrap:!1,backwards:t,regExp:o,start:c||a});var n=i.find(s.ace.session);return(c=n)&&[!c.isEmpty()]},from:function(){return c&&v(c.start)},to:function(){return c&&v(c.end)},replace:function(e){c&&(c.end=s.ace.session.doc.replace(c,e))}}},this.scrollTo=function(e,t){var n=this.ace.renderer,r=n.layerConfig,o=r.maxHeight;o-=(n.$size.scrollerHeight-n.lineHeight)*n.$scrollPastEnd,null!=t&&this.ace.session.setScrollTop(Math.max(0,Math.min(t,o))),null!=e&&this.ace.session.setScrollLeft(Math.max(0,Math.min(e,r.width)))},this.scrollInfo=function(){return 0},this.scrollIntoView=function(e,t){if(e){var n=this.ace.renderer,r={top:0,bottom:t};n.scrollCursorIntoView(g(e),2*n.lineHeight/n.$size.scrollerHeight,r)}},this.getLine=function(e){return this.ace.session.getLine(e)},this.getRange=function(e,t){return this.ace.session.getTextRange(new r(e.line,e.ch,t.line,t.ch))},this.replaceRange=function(e,t,n){n||(n=t);var o=new r(t.line,t.ch,n.line,n.ch);return this.ace.session.$clipRangeToDocument(o),this.ace.session.replace(o,e)},this.replaceSelection=this.replaceSelections=function(e){var t=this.ace.selection;if(this.ace.inVirtualSelectionMode)this.ace.session.replace(t.getRange(),e[0]||\"\");else{t.inVirtualSelectionMode=!0;var n=t.rangeList.ranges;n.length||(n=[this.ace.multiSelect.getRange()]);for(var r=n.length;r--;)this.ace.session.replace(n[r],e[r]||\"\");t.inVirtualSelectionMode=!1}},this.getSelection=function(){return this.ace.getSelectedText()},this.getSelections=function(){return this.listSelections().map((function(e){return this.getRange(e.anchor,e.head)}),this)},this.getInputField=function(){return this.ace.textInput.getElement()},this.getWrapperElement=function(){return this.ace.container};var t={indentWithTabs:\"useSoftTabs\",indentUnit:\"tabSize\",tabSize:\"tabSize\",firstLineNumber:\"firstLineNumber\",readOnly:\"readOnly\"};this.setOption=function(e,n){switch(this.state[e]=n,e){case\"indentWithTabs\":e=t[e],n=!n;break;case\"keyMap\":return void(this.state.$keyMap=n);default:e=t[e]}e&&this.ace.setOption(e,n)},this.getOption=function(e){var n,r=t[e];switch(r&&(n=this.ace.getOption(r)),e){case\"indentWithTabs\":return e=t[e],!n;case\"keyMap\":return this.state.$keyMap||\"vim\"}return r?n:this.state[e]},this.toggleOverwrite=function(e){return this.state.overwrite=e,this.ace.setOverwrite(e)},this.addOverlay=function(e){if(!this.$searchHighlight||!this.$searchHighlight.session){var t=new h(null,\"ace_highlight-marker\",\"text\"),n=this.ace.session.addDynamicMarker(t);t.id=n.id,t.session=this.ace.session,t.destroy=function(e){t.session.off(\"change\",t.updateOnChange),t.session.off(\"changeEditor\",t.destroy),t.session.removeMarker(t.id),t.session=null},t.updateOnChange=function(e){var n=e.start.row;n==e.end.row?t.cache[n]=void 0:t.cache.splice(n,t.cache.length)},t.session.on(\"changeEditor\",t.destroy),t.session.on(\"change\",t.updateOnChange)}var r=new RegExp(e.query.source,\"gmi\");this.$searchHighlight=e.highlight=t,this.$searchHighlight.setRegexp(r),this.ace.renderer.updateBackMarkers()},this.removeOverlay=function(e){this.$searchHighlight&&this.$searchHighlight.session&&this.$searchHighlight.destroy()},this.getScrollInfo=function(){var e=this.ace.renderer,t=e.layerConfig;return{left:e.scrollLeft,top:e.scrollTop,height:t.maxHeight,width:t.width,clientHeight:t.height,clientWidth:t.width}},this.getValue=function(){return this.ace.getValue()},this.setValue=function(e){return this.ace.setValue(e,-1)},this.getTokenTypeAt=function(e){var t=this.ace.session.getTokenAt(e.line,e.ch);return t&&/comment|string/.test(t.type)?\"string\":\"\"},this.findMatchingBracket=function(e){var t=this.ace.session.findMatchingBracket(g(e));return{to:t&&v(t)}},this.findMatchingTag=function(e){var t=this.ace.session.getMatchingTags(g(e));if(t)return{open:{from:v(t.openTag.start),to:v(t.openTag.end)},close:{from:v(t.closeTag.start),to:v(t.closeTag.end)}}},this.indentLine=function(e,t){!0===t?this.ace.session.indentRows(e,e,\"\\t\"):!1===t&&this.ace.session.outdentRows(new r(e,0,e,0))},this.indexFromPos=function(e){return this.ace.session.doc.positionToIndex(g(e))},this.posFromIndex=function(e){return v(this.ace.session.doc.indexToPosition(e))},this.focus=function(e){return this.ace.textInput.focus()},this.blur=function(e){return this.ace.blur()},this.defaultTextHeight=function(e){return this.ace.renderer.layerConfig.lineHeight},this.scanForBracket=function(e,t,n,r){var o=r.bracketRegex.source,i=/paren|text|operator|tag/;if(1==t)var a=this.ace.session.$findClosingBracket(o.slice(1,2),g(e),i);else a=this.ace.session.$findOpeningBracket(o.slice(-2,-1),{row:e.line,column:e.ch+1},i);return a&&{pos:v(a)}},this.refresh=function(){return this.ace.resize(!0)},this.getMode=function(){return{name:this.getOption(\"mode\")}},this.execCommand=function(e){return m.commands.hasOwnProperty(e)?m.commands[e](this):\"indentAuto\"==e?this.ace.execCommand(\"autoindent\"):void console.log(e+\" is not implemented\")},this.getLineNumber=function(e){return e.row},this.getLineHandle=function(e){return{text:this.ace.session.getLine(e),row:e}}}.call(m.prototype),(m.StringStream=function(e,t){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0}).prototype={eol:function(){return this.pos>=this.string.length},sol:function(){return this.pos==this.lineStart},peek:function(){return this.string.charAt(this.pos)||void 0},next:function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},eat:function(e){var t=this.string.charAt(this.pos);if(\"string\"==typeof e)var n=t==e;else n=t&&(e.test?e.test(t):e(t));if(n)return++this.pos,t},eatWhile:function(e){for(var t=this.pos;this.eat(e););return this.pos>t},eatSpace:function(){for(var e=this.pos;/[\\s\\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>e},skipToEnd:function(){this.pos=this.string.length},skipTo:function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},backUp:function(e){this.pos-=e},column:function(){throw\"not implemented\"},indentation:function(){throw\"not implemented\"},match:function(e,t,n){if(\"string\"!=typeof e){var r=this.string.slice(this.pos).match(e);return r&&r.index>0?null:(r&&!1!==t&&(this.pos+=r[0].length),r)}var o=function(e){return n?e.toLowerCase():e};if(o(this.string.substr(this.pos,e.length))==o(e))return!1!==t&&(this.pos+=e.length),!0},current:function(){return this.string.slice(this.start,this.pos)},hideFirstChars:function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}}},m.defineExtension=function(e,t){m.prototype[e]=t},i.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\",\"vimMode\",!1),function(){function e(e,t,n){var r;return(r=e.ace.container.appendChild(document.createElement(\"div\"))).className=n?\"ace_dialog ace_dialog-bottom\":\"ace_dialog ace_dialog-top\",\"string\"==typeof t?r.innerHTML=t:r.appendChild(t),r}function t(e,t){e.state.currentNotificationClose&&e.state.currentNotificationClose(),e.state.currentNotificationClose=t}m.defineExtension(\"openDialog\",(function(n,r,o){if(!this.virtualSelectionMode()){o||(o={}),t(this,null);var i=e(this,n,o.bottom),a=!1,s=this;this.state.dialog=i;var c,l=i.getElementsByTagName(\"input\")[0];return l?(o.value&&(l.value=o.value,!1!==o.selectValueOnOpen&&l.select()),o.onInput&&m.on(l,\"input\",(function(e){o.onInput(e,l.value,u)})),o.onKeyUp&&m.on(l,\"keyup\",(function(e){o.onKeyUp(e,l.value,u)})),m.on(l,\"keydown\",(function(e){o&&o.onKeyDown&&o.onKeyDown(e,l.value,u)||(13==e.keyCode&&r(l.value),(27==e.keyCode||!1!==o.closeOnEnter&&13==e.keyCode)&&(m.e_stop(e),u()))})),!1!==o.closeOnBlur&&m.on(l,\"blur\",u),l.focus()):(c=i.getElementsByTagName(\"button\")[0])&&(m.on(c,\"click\",(function(){u(),s.focus()})),!1!==o.closeOnBlur&&m.on(c,\"blur\",u),c.focus()),u}function u(e){if(\"string\"==typeof e)l.value=e;else{if(a)return;if(e&&\"blur\"==e.type&&document.activeElement===l)return;s.state.dialog==i&&(s.state.dialog=null,s.focus()),a=!0,i.remove(),o.onClose&&o.onClose(i);var t=s;t.state.vim&&(t.state.vim.status=null,t.ace._signal(\"changeStatus\"),t.ace.renderer.$loop.schedule(t.ace.renderer.CHANGE_CURSOR))}}})),m.defineExtension(\"openNotification\",(function(n,r){if(!this.virtualSelectionMode()){t(this,c);var o,i=e(this,n,r&&r.bottom),a=!1,s=r&&\"undefined\"!==typeof r.duration?r.duration:5e3;return m.on(i,\"click\",(function(e){m.e_preventDefault(e),c()})),s&&(o=setTimeout(c,s)),c}function c(){a||(a=!0,clearTimeout(o),i.remove())}}))}();var y=m.Pos;function C(e,t){var n=e.state.vim;if(!n||n.insertMode)return t.head;var r=n.sel.head;return r?n.visualBlock&&t.head.line!=r.line?void 0:t.from()!=t.anchor||t.empty()||t.head.line!=r.line||t.head.ch==r.ch?t.head:new y(t.head.line,t.head.ch-1):t.head}function k(e,t,n){if(t.line===n.line&&t.ch>=n.ch-1){var r=e.getLine(t.line).charCodeAt(t.ch);55296<=r&&r<=55551&&(n.ch+=1)}return{start:t,end:n}}var w=[{keys:\"<Left>\",type:\"keyToKey\",toKeys:\"h\"},{keys:\"<Right>\",type:\"keyToKey\",toKeys:\"l\"},{keys:\"<Up>\",type:\"keyToKey\",toKeys:\"k\"},{keys:\"<Down>\",type:\"keyToKey\",toKeys:\"j\"},{keys:\"g<Up>\",type:\"keyToKey\",toKeys:\"gk\"},{keys:\"g<Down>\",type:\"keyToKey\",toKeys:\"gj\"},{keys:\"<Space>\",type:\"keyToKey\",toKeys:\"l\"},{keys:\"<BS>\",type:\"keyToKey\",toKeys:\"h\",context:\"normal\"},{keys:\"<Del>\",type:\"keyToKey\",toKeys:\"x\",context:\"normal\"},{keys:\"<C-Space>\",type:\"keyToKey\",toKeys:\"W\"},{keys:\"<C-BS>\",type:\"keyToKey\",toKeys:\"B\",context:\"normal\"},{keys:\"<S-Space>\",type:\"keyToKey\",toKeys:\"w\"},{keys:\"<S-BS>\",type:\"keyToKey\",toKeys:\"b\",context:\"normal\"},{keys:\"<C-n>\",type:\"keyToKey\",toKeys:\"j\"},{keys:\"<C-p>\",type:\"keyToKey\",toKeys:\"k\"},{keys:\"<C-[>\",type:\"keyToKey\",toKeys:\"<Esc>\"},{keys:\"<C-c>\",type:\"keyToKey\",toKeys:\"<Esc>\"},{keys:\"<C-[>\",type:\"keyToKey\",toKeys:\"<Esc>\",context:\"insert\"},{keys:\"<C-c>\",type:\"keyToKey\",toKeys:\"<Esc>\",context:\"insert\"},{keys:\"<C-Esc>\",type:\"keyToKey\",toKeys:\"<Esc>\"},{keys:\"<C-Esc>\",type:\"keyToKey\",toKeys:\"<Esc>\",context:\"insert\"},{keys:\"s\",type:\"keyToKey\",toKeys:\"cl\",context:\"normal\"},{keys:\"s\",type:\"keyToKey\",toKeys:\"c\",context:\"visual\"},{keys:\"S\",type:\"keyToKey\",toKeys:\"cc\",context:\"normal\"},{keys:\"S\",type:\"keyToKey\",toKeys:\"VdO\",context:\"visual\"},{keys:\"<Home>\",type:\"keyToKey\",toKeys:\"0\"},{keys:\"<End>\",type:\"keyToKey\",toKeys:\"$\"},{keys:\"<PageUp>\",type:\"keyToKey\",toKeys:\"<C-b>\"},{keys:\"<PageDown>\",type:\"keyToKey\",toKeys:\"<C-f>\"},{keys:\"<CR>\",type:\"keyToKey\",toKeys:\"j^\",context:\"normal\"},{keys:\"<Ins>\",type:\"keyToKey\",toKeys:\"i\",context:\"normal\"},{keys:\"<Ins>\",type:\"action\",action:\"toggleOverwrite\",context:\"insert\"},{keys:\"H\",type:\"motion\",motion:\"moveToTopLine\",motionArgs:{linewise:!0,toJumplist:!0}},{keys:\"M\",type:\"motion\",motion:\"moveToMiddleLine\",motionArgs:{linewise:!0,toJumplist:!0}},{keys:\"L\",type:\"motion\",motion:\"moveToBottomLine\",motionArgs:{linewise:!0,toJumplist:!0}},{keys:\"h\",type:\"motion\",motion:\"moveByCharacters\",motionArgs:{forward:!1}},{keys:\"l\",type:\"motion\",motion:\"moveByCharacters\",motionArgs:{forward:!0}},{keys:\"j\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!0,linewise:!0}},{keys:\"k\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!1,linewise:!0}},{keys:\"gj\",type:\"motion\",motion:\"moveByDisplayLines\",motionArgs:{forward:!0}},{keys:\"gk\",type:\"motion\",motion:\"moveByDisplayLines\",motionArgs:{forward:!1}},{keys:\"w\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!1}},{keys:\"W\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!1,bigWord:!0}},{keys:\"e\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!0,inclusive:!0}},{keys:\"E\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!0,bigWord:!0,inclusive:!0}},{keys:\"b\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!1}},{keys:\"B\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!1,bigWord:!0}},{keys:\"ge\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!0,inclusive:!0}},{keys:\"gE\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!0,bigWord:!0,inclusive:!0}},{keys:\"{\",type:\"motion\",motion:\"moveByParagraph\",motionArgs:{forward:!1,toJumplist:!0}},{keys:\"}\",type:\"motion\",motion:\"moveByParagraph\",motionArgs:{forward:!0,toJumplist:!0}},{keys:\"(\",type:\"motion\",motion:\"moveBySentence\",motionArgs:{forward:!1}},{keys:\")\",type:\"motion\",motion:\"moveBySentence\",motionArgs:{forward:!0}},{keys:\"<C-f>\",type:\"motion\",motion:\"moveByPage\",motionArgs:{forward:!0}},{keys:\"<C-b>\",type:\"motion\",motion:\"moveByPage\",motionArgs:{forward:!1}},{keys:\"<C-d>\",type:\"motion\",motion:\"moveByScroll\",motionArgs:{forward:!0,explicitRepeat:!0}},{keys:\"<C-u>\",type:\"motion\",motion:\"moveByScroll\",motionArgs:{forward:!1,explicitRepeat:!0}},{keys:\"gg\",type:\"motion\",motion:\"moveToLineOrEdgeOfDocument\",motionArgs:{forward:!1,explicitRepeat:!0,linewise:!0,toJumplist:!0}},{keys:\"G\",type:\"motion\",motion:\"moveToLineOrEdgeOfDocument\",motionArgs:{forward:!0,explicitRepeat:!0,linewise:!0,toJumplist:!0}},{keys:\"g$\",type:\"motion\",motion:\"moveToEndOfDisplayLine\"},{keys:\"g^\",type:\"motion\",motion:\"moveToStartOfDisplayLine\"},{keys:\"g0\",type:\"motion\",motion:\"moveToStartOfDisplayLine\"},{keys:\"0\",type:\"motion\",motion:\"moveToStartOfLine\"},{keys:\"^\",type:\"motion\",motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\"+\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!0,toFirstChar:!0}},{keys:\"-\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!1,toFirstChar:!0}},{keys:\"_\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!0,toFirstChar:!0,repeatOffset:-1}},{keys:\"$\",type:\"motion\",motion:\"moveToEol\",motionArgs:{inclusive:!0}},{keys:\"%\",type:\"motion\",motion:\"moveToMatchedSymbol\",motionArgs:{inclusive:!0,toJumplist:!0}},{keys:\"f<character>\",type:\"motion\",motion:\"moveToCharacter\",motionArgs:{forward:!0,inclusive:!0}},{keys:\"F<character>\",type:\"motion\",motion:\"moveToCharacter\",motionArgs:{forward:!1}},{keys:\"t<character>\",type:\"motion\",motion:\"moveTillCharacter\",motionArgs:{forward:!0,inclusive:!0}},{keys:\"T<character>\",type:\"motion\",motion:\"moveTillCharacter\",motionArgs:{forward:!1}},{keys:\";\",type:\"motion\",motion:\"repeatLastCharacterSearch\",motionArgs:{forward:!0}},{keys:\",\",type:\"motion\",motion:\"repeatLastCharacterSearch\",motionArgs:{forward:!1}},{keys:\"'<character>\",type:\"motion\",motion:\"goToMark\",motionArgs:{toJumplist:!0,linewise:!0}},{keys:\"`<character>\",type:\"motion\",motion:\"goToMark\",motionArgs:{toJumplist:!0}},{keys:\"]`\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!0}},{keys:\"[`\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!1}},{keys:\"]'\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!0,linewise:!0}},{keys:\"['\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!1,linewise:!0}},{keys:\"]p\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!0,isEdit:!0,matchIndent:!0}},{keys:\"[p\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!1,isEdit:!0,matchIndent:!0}},{keys:\"]<character>\",type:\"motion\",motion:\"moveToSymbol\",motionArgs:{forward:!0,toJumplist:!0}},{keys:\"[<character>\",type:\"motion\",motion:\"moveToSymbol\",motionArgs:{forward:!1,toJumplist:!0}},{keys:\"|\",type:\"motion\",motion:\"moveToColumn\"},{keys:\"o\",type:\"motion\",motion:\"moveToOtherHighlightedEnd\",context:\"visual\"},{keys:\"O\",type:\"motion\",motion:\"moveToOtherHighlightedEnd\",motionArgs:{sameLine:!0},context:\"visual\"},{keys:\"d\",type:\"operator\",operator:\"delete\"},{keys:\"y\",type:\"operator\",operator:\"yank\"},{keys:\"c\",type:\"operator\",operator:\"change\"},{keys:\"=\",type:\"operator\",operator:\"indentAuto\"},{keys:\">\",type:\"operator\",operator:\"indent\",operatorArgs:{indentRight:!0}},{keys:\"<\",type:\"operator\",operator:\"indent\",operatorArgs:{indentRight:!1}},{keys:\"g~\",type:\"operator\",operator:\"changeCase\"},{keys:\"gu\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!0},isEdit:!0},{keys:\"gU\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!1},isEdit:!0},{keys:\"n\",type:\"motion\",motion:\"findNext\",motionArgs:{forward:!0,toJumplist:!0}},{keys:\"N\",type:\"motion\",motion:\"findNext\",motionArgs:{forward:!1,toJumplist:!0}},{keys:\"gn\",type:\"motion\",motion:\"findAndSelectNextInclusive\",motionArgs:{forward:!0}},{keys:\"gN\",type:\"motion\",motion:\"findAndSelectNextInclusive\",motionArgs:{forward:!1}},{keys:\"x\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveByCharacters\",motionArgs:{forward:!0},operatorMotionArgs:{visualLine:!1}},{keys:\"X\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveByCharacters\",motionArgs:{forward:!1},operatorMotionArgs:{visualLine:!0}},{keys:\"D\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveToEol\",motionArgs:{inclusive:!0},context:\"normal\"},{keys:\"D\",type:\"operator\",operator:\"delete\",operatorArgs:{linewise:!0},context:\"visual\"},{keys:\"Y\",type:\"operatorMotion\",operator:\"yank\",motion:\"expandToLine\",motionArgs:{linewise:!0},context:\"normal\"},{keys:\"Y\",type:\"operator\",operator:\"yank\",operatorArgs:{linewise:!0},context:\"visual\"},{keys:\"C\",type:\"operatorMotion\",operator:\"change\",motion:\"moveToEol\",motionArgs:{inclusive:!0},context:\"normal\"},{keys:\"C\",type:\"operator\",operator:\"change\",operatorArgs:{linewise:!0},context:\"visual\"},{keys:\"~\",type:\"operatorMotion\",operator:\"changeCase\",motion:\"moveByCharacters\",motionArgs:{forward:!0},operatorArgs:{shouldMoveCursor:!0},context:\"normal\"},{keys:\"~\",type:\"operator\",operator:\"changeCase\",context:\"visual\"},{keys:\"<C-u>\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveToStartOfLine\",context:\"insert\"},{keys:\"<C-w>\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!1},context:\"insert\"},{keys:\"<C-w>\",type:\"idle\",context:\"normal\"},{keys:\"<C-i>\",type:\"action\",action:\"jumpListWalk\",actionArgs:{forward:!0}},{keys:\"<C-o>\",type:\"action\",action:\"jumpListWalk\",actionArgs:{forward:!1}},{keys:\"<C-e>\",type:\"action\",action:\"scroll\",actionArgs:{forward:!0,linewise:!0}},{keys:\"<C-y>\",type:\"action\",action:\"scroll\",actionArgs:{forward:!1,linewise:!0}},{keys:\"a\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"charAfter\"},context:\"normal\"},{keys:\"A\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"eol\"},context:\"normal\"},{keys:\"A\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"endOfSelectedArea\"},context:\"visual\"},{keys:\"i\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"inplace\"},context:\"normal\"},{keys:\"gi\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"lastEdit\"},context:\"normal\"},{keys:\"I\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"firstNonBlank\"},context:\"normal\"},{keys:\"gI\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"bol\"},context:\"normal\"},{keys:\"I\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"startOfSelectedArea\"},context:\"visual\"},{keys:\"o\",type:\"action\",action:\"newLineAndEnterInsertMode\",isEdit:!0,interlaceInsertRepeat:!0,actionArgs:{after:!0},context:\"normal\"},{keys:\"O\",type:\"action\",action:\"newLineAndEnterInsertMode\",isEdit:!0,interlaceInsertRepeat:!0,actionArgs:{after:!1},context:\"normal\"},{keys:\"v\",type:\"action\",action:\"toggleVisualMode\"},{keys:\"V\",type:\"action\",action:\"toggleVisualMode\",actionArgs:{linewise:!0}},{keys:\"<C-v>\",type:\"action\",action:\"toggleVisualMode\",actionArgs:{blockwise:!0}},{keys:\"<C-q>\",type:\"action\",action:\"toggleVisualMode\",actionArgs:{blockwise:!0}},{keys:\"gv\",type:\"action\",action:\"reselectLastSelection\"},{keys:\"J\",type:\"action\",action:\"joinLines\",isEdit:!0},{keys:\"gJ\",type:\"action\",action:\"joinLines\",actionArgs:{keepSpaces:!0},isEdit:!0},{keys:\"p\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!0,isEdit:!0}},{keys:\"P\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!1,isEdit:!0}},{keys:\"r<character>\",type:\"action\",action:\"replace\",isEdit:!0},{keys:\"@<character>\",type:\"action\",action:\"replayMacro\"},{keys:\"q<character>\",type:\"action\",action:\"enterMacroRecordMode\"},{keys:\"R\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{replace:!0},context:\"normal\"},{keys:\"R\",type:\"operator\",operator:\"change\",operatorArgs:{linewise:!0,fullLine:!0},context:\"visual\",exitVisualBlock:!0},{keys:\"u\",type:\"action\",action:\"undo\",context:\"normal\"},{keys:\"u\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!0},context:\"visual\",isEdit:!0},{keys:\"U\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!1},context:\"visual\",isEdit:!0},{keys:\"<C-r>\",type:\"action\",action:\"redo\"},{keys:\"m<character>\",type:\"action\",action:\"setMark\"},{keys:'\"<character>',type:\"action\",action:\"setRegister\"},{keys:\"zz\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"center\"}},{keys:\"z.\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"center\"},motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\"zt\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"top\"}},{keys:\"z<CR>\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"top\"},motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\"zb\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"bottom\"}},{keys:\"z-\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"bottom\"},motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\".\",type:\"action\",action:\"repeatLastEdit\"},{keys:\"<C-a>\",type:\"action\",action:\"incrementNumberToken\",isEdit:!0,actionArgs:{increase:!0,backtrack:!1}},{keys:\"<C-x>\",type:\"action\",action:\"incrementNumberToken\",isEdit:!0,actionArgs:{increase:!1,backtrack:!1}},{keys:\"<C-t>\",type:\"action\",action:\"indent\",actionArgs:{indentRight:!0},context:\"insert\"},{keys:\"<C-d>\",type:\"action\",action:\"indent\",actionArgs:{indentRight:!1},context:\"insert\"},{keys:\"a<character>\",type:\"motion\",motion:\"textObjectManipulation\"},{keys:\"i<character>\",type:\"motion\",motion:\"textObjectManipulation\",motionArgs:{textObjectInner:!0}},{keys:\"/\",type:\"search\",searchArgs:{forward:!0,querySrc:\"prompt\",toJumplist:!0}},{keys:\"?\",type:\"search\",searchArgs:{forward:!1,querySrc:\"prompt\",toJumplist:!0}},{keys:\"*\",type:\"search\",searchArgs:{forward:!0,querySrc:\"wordUnderCursor\",wholeWordOnly:!0,toJumplist:!0}},{keys:\"#\",type:\"search\",searchArgs:{forward:!1,querySrc:\"wordUnderCursor\",wholeWordOnly:!0,toJumplist:!0}},{keys:\"g*\",type:\"search\",searchArgs:{forward:!0,querySrc:\"wordUnderCursor\",toJumplist:!0}},{keys:\"g#\",type:\"search\",searchArgs:{forward:!1,querySrc:\"wordUnderCursor\",toJumplist:!0}},{keys:\":\",type:\"ex\"}],x=w.length,S=[{name:\"colorscheme\",shortName:\"colo\"},{name:\"map\"},{name:\"imap\",shortName:\"im\"},{name:\"nmap\",shortName:\"nm\"},{name:\"vmap\",shortName:\"vm\"},{name:\"unmap\"},{name:\"write\",shortName:\"w\"},{name:\"undo\",shortName:\"u\"},{name:\"redo\",shortName:\"red\"},{name:\"set\",shortName:\"se\"},{name:\"setlocal\",shortName:\"setl\"},{name:\"setglobal\",shortName:\"setg\"},{name:\"sort\",shortName:\"sor\"},{name:\"substitute\",shortName:\"s\",possiblyAsync:!0},{name:\"nohlsearch\",shortName:\"noh\"},{name:\"yank\",shortName:\"y\"},{name:\"delmarks\",shortName:\"delm\"},{name:\"registers\",shortName:\"reg\",excludeFromCommandHistory:!0},{name:\"vglobal\",shortName:\"v\"},{name:\"global\",shortName:\"g\"}];function M(e){e.setOption(\"disableInput\",!0),e.setOption(\"showCursorWhenSelecting\",!1),m.signal(e,\"vim-mode-change\",{mode:\"normal\"}),e.on(\"cursorActivity\",wt),re(e),m.on(e.getInputField(),\"paste\",R(e))}function A(e){e.setOption(\"disableInput\",!1),e.off(\"cursorActivity\",wt),m.off(e.getInputField(),\"paste\",R(e)),e.state.vim=null,at&&clearTimeout(at)}function b(e,t){this==m.keyMap.vim&&(e.options.$customCursor=null,m.rmClass(e.getWrapperElement(),\"cm-fat-cursor\")),t&&t.attach==L||A(e)}function L(e,t){this==m.keyMap.vim&&(e.curOp&&(e.curOp.selectionChanged=!0),e.options.$customCursor=C,m.addClass(e.getWrapperElement(),\"cm-fat-cursor\")),t&&t.attach==L||M(e)}function O(e,t){if(t){if(this[e])return this[e];var n=function(e){if(\"'\"==e.charAt(0))return e.charAt(1);var t=e.split(/-(?!$)/),n=t[t.length-1];if(1==t.length&&1==t[0].length)return!1;if(2==t.length&&\"Shift\"==t[0]&&1==n.length)return!1;for(var r=!1,o=0;o<t.length;o++){var i=t[o];i in T?t[o]=T[i]:r=!0,i in E&&(t[o]=E[i])}if(!r)return!1;W(n)&&(t[t.length-1]=n.toLowerCase());return\"<\"+t.join(\"-\")+\">\"}(e);if(!n)return!1;var r=ie.findKey(t,n);return\"function\"==typeof r&&m.signal(t,\"vim-keypress\",n),r}}m.defineOption(\"vimMode\",!1,(function(e,t,n){t&&\"vim\"!=e.getOption(\"keyMap\")?e.setOption(\"keyMap\",\"vim\"):!t&&n!=m.Init&&/^vim/.test(e.getOption(\"keyMap\"))&&e.setOption(\"keyMap\",\"default\")}));var T={Shift:\"S\",Ctrl:\"C\",Alt:\"A\",Cmd:\"D\",Mod:\"A\",CapsLock:\"\"},E={Enter:\"CR\",Backspace:\"BS\",Delete:\"Del\",Insert:\"Ins\"};function R(e){var t=e.state.vim;return t.onPasteFn||(t.onPasteFn=function(){t.insertMode||(e.setCursor(ye(e.getCursor(),0,1)),me.enterInsertMode(e,{},t))}),t.onPasteFn}var B=/[\\d]/,I=[m.isWordChar,function(e){return e&&!m.isWordChar(e)&&!/\\s/.test(e)}],K=[function(e){return/\\S/.test(e)}];function P(e,t){for(var n=[],r=e;r<e+t;r++)n.push(String.fromCharCode(r));return n}var N,_=P(65,26),H=P(97,26),$=P(48,10),D=[].concat(_,H,$,[\"<\",\">\"]),V=[].concat(_,H,$,[\"-\",'\"',\".\",\":\",\"_\",\"/\",\"+\"]);try{N=new RegExp(\"^[\\\\p{Lu}]$\",\"u\")}catch(It){N=/^[A-Z]$/}function F(e,t){return t>=e.firstLine()&&t<=e.lastLine()}function j(e){return/^[a-z]$/.test(e)}function W(e){return N.test(e)}function U(e){return/^\\s*$/.test(e)}function z(e){return-1!=\".?!\".indexOf(e)}function J(e,t){for(var n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}var q={};function Q(e,t,n,r,o){if(void 0===t&&!o)throw Error(\"defaultValue is required unless callback is provided\");if(n||(n=\"string\"),q[e]={type:n,defaultValue:t,callback:o},r)for(var i=0;i<r.length;i++)q[r[i]]=q[e];t&&G(e,t)}function G(e,t,n,r){var o=q[e],i=(r=r||{}).scope;if(!o)return new Error(\"Unknown option: \"+e);if(\"boolean\"==o.type){if(t&&!0!==t)return new Error(\"Invalid argument: \"+e+\"=\"+t);!1!==t&&(t=!0)}o.callback?(\"local\"!==i&&o.callback(t,void 0),\"global\"!==i&&n&&o.callback(t,n)):(\"local\"!==i&&(o.value=\"boolean\"==o.type?!!t:t),\"global\"!==i&&n&&(n.state.vim.options[e]={value:t}))}function X(e,t,n){var r=q[e],o=(n=n||{}).scope;if(!r)return new Error(\"Unknown option: \"+e);if(r.callback){var i=t&&r.callback(void 0,t);return\"global\"!==o&&void 0!==i?i:\"local\"!==o?r.callback():void 0}return((i=\"global\"!==o&&t&&t.state.vim.options[e])||\"local\"!==o&&r||{}).value}Q(\"filetype\",void 0,\"string\",[\"ft\"],(function(e,t){if(void 0!==t){if(void 0===e)return\"null\"==(n=t.getOption(\"mode\"))?\"\":n;var n=\"\"==e?\"null\":e;t.setOption(\"mode\",n)}}));var Z,Y,ee=function(){var e=100,t=-1,n=0,r=0,o=new Array(e);function i(i,a){(t+=a)>n?t=n:t<r&&(t=r);var s=o[(e+t)%e];if(s&&!s.find()){var c,l=a>0?1:-1,u=i.getCursor();do{if((s=o[(e+(t+=l))%e])&&(c=s.find())&&!xe(u,c))break}while(t<n&&t>r)}return s}return{cachedCursor:void 0,add:function(i,a,s){var c=o[t%e];function l(n){var r=++t%e,a=o[r];a&&a.clear(),o[r]=i.setBookmark(n)}if(c){var u=c.find();u&&!xe(u,a)&&l(a)}else l(a);l(s),n=t,(r=t-e+1)<0&&(r=0)},find:function(e,n){var r=t,o=i(e,n);return t=r,o&&o.find()},move:i}},te=function(e){return e?{changes:e.changes,expectCursorActivityForChange:e.expectCursorActivityForChange}:{changes:[],expectCursorActivityForChange:!1}};function ne(){this.latestRegister=void 0,this.isPlaying=!1,this.isRecording=!1,this.replaySearchQueries=[],this.onRecordingDone=void 0,this.lastInsertModeChanges=te()}function re(e){return e.state.vim||(e.state.vim={inputState:new ae,lastEditInputState:void 0,lastEditActionCommand:void 0,lastHPos:-1,lastHSPos:-1,lastMotion:null,marks:{},insertMode:!1,insertModeRepeat:void 0,visualMode:!1,visualLine:!1,visualBlock:!1,lastSelection:null,lastPastedText:null,sel:{},options:{}}),e.state.vim}function oe(){for(var e in Z={searchQuery:null,searchIsReversed:!1,lastSubstituteReplacePart:void 0,jumpList:ee(),macroModeState:new ne,lastCharacterSearch:{increment:0,forward:!0,selectedCharacter:\"\"},registerController:new le({}),searchHistoryController:new ue,exCommandHistoryController:new ue},q){var t=q[e];t.value=t.defaultValue}}ne.prototype={exitMacroRecordMode:function(){var e=Z.macroModeState;e.onRecordingDone&&e.onRecordingDone(),e.onRecordingDone=void 0,e.isRecording=!1},enterMacroRecordMode:function(e,t){var n=Z.registerController.getRegister(t);if(n){if(n.clear(),this.latestRegister=t,e.openDialog){var r=nt(\"span\",{class:\"cm-vim-message\"},\"recording @\"+t);this.onRecordingDone=e.openDialog(r,null,{bottom:!0})}this.isRecording=!0}}};var ie={enterVimMode:M,leaveVimMode:A,buildKeyMap:function(){},getRegisterController:function(){return Z.registerController},resetVimGlobalState_:oe,getVimGlobalState_:function(){return Z},maybeInitVimState_:re,suppressErrorLogging:!1,InsertModeKey:St,map:function(e,t,n){gt.map(e,t,n)},unmap:function(e,t){return gt.unmap(e,t)},noremap:function(e,t,n){function r(e){return e?[e]:[\"normal\",\"insert\",\"visual\"]}for(var o=r(n),i=w.length,a=i-x;a<i&&o.length;a++){var s=w[a];if(s.keys==t&&(!n||!s.context||s.context===n)&&\"ex\"!==s.type.substr(0,2)&&\"key\"!==s.type.substr(0,3)){var c={};for(var l in s)c[l]=s[l];c.keys=e,n&&!c.context&&(c.context=n),this._mapCommand(c);var u=r(s.context);o=o.filter((function(e){return-1===u.indexOf(e)}))}}},mapclear:function(e){var t=w.length,n=x,r=w.slice(0,t-n);if(w=w.slice(t-n),e)for(var o=r.length-1;o>=0;o--){var i=r[o];if(e!==i.context)if(i.context)this._mapCommand(i);else{var a=[\"normal\",\"insert\",\"visual\"];for(var s in a)if(a[s]!==e){var c={};for(var l in i)c[l]=i[l];c.context=a[s],this._mapCommand(c)}}}},setOption:G,getOption:X,defineOption:Q,defineEx:function(e,t,n){if(t){if(0!==e.indexOf(t))throw new Error('(Vim.defineEx) \"'+t+'\" is not a prefix of \"'+e+'\", command not registered')}else t=e;mt[e]=n,gt.commandMap_[t]={name:e,shortName:t,type:\"api\"}},handleKey:function(e,t,n){var r=this.findKey(e,t,n);if(\"function\"===typeof r)return r()},multiSelectHandleKey:Et,findKey:function(e,t,n){var r,o=re(e);function i(){var r=Z.macroModeState;if(r.isRecording){if(\"q\"==t)return r.exitMacroRecordMode(),se(e),!0;\"mapping\"!=n&&function(e,t){if(e.isPlaying)return;var n=e.latestRegister,r=Z.registerController.getRegister(n);r&&r.pushText(t)}(r,t)}}function a(){if(\"<Esc>\"==t){if(o.visualMode)Pe(e);else{if(!o.insertMode)return;vt(e)}return se(e),!0}}return!1===(r=o.insertMode?function(){if(a())return!0;for(var n=o.inputState.keyBuffer=o.inputState.keyBuffer+t,r=1==t.length,i=he.matchCommand(n,w,o.inputState,\"insert\");n.length>1&&\"full\"!=i.type;){n=o.inputState.keyBuffer=n.slice(1);var s=he.matchCommand(n,w,o.inputState,\"insert\");\"none\"!=s.type&&(i=s)}if(\"none\"==i.type)return se(e),!1;if(\"partial\"==i.type)return Y&&window.clearTimeout(Y),Y=window.setTimeout((function(){o.insertMode&&o.inputState.keyBuffer&&se(e)}),X(\"insertModeEscKeysTimeout\")),!r;if(Y&&window.clearTimeout(Y),r){for(var c=e.listSelections(),l=0;l<c.length;l++){var u=c[l].head;e.replaceRange(\"\",ye(u,0,-(n.length-1)),u,\"+input\")}Z.macroModeState.lastInsertModeChanges.changes.pop()}return se(e),i.command}():function(){if(i()||a())return!0;var n=o.inputState.keyBuffer=o.inputState.keyBuffer+t;if(/^[1-9]\\d*$/.test(n))return!0;var r=/^(\\d*)(.*)$/.exec(n);if(!r)return se(e),!1;var s=o.visualMode?\"visual\":\"normal\",c=r[2]||r[1];o.inputState.operatorShortcut&&o.inputState.operatorShortcut.slice(-1)==c&&(c=o.inputState.operatorShortcut);var l=he.matchCommand(c,w,o.inputState,s);return\"none\"==l.type?(se(e),!1):\"partial\"==l.type||(\"clear\"==l.type?(se(e),!0):(o.inputState.keyBuffer=\"\",(r=/^(\\d*)(.*)$/.exec(n))[1]&&\"0\"!=r[1]&&o.inputState.pushRepeatDigit(r[1]),l.command))}())?void 0:!0===r?function(){return!0}:function(){if(!r.operator&&!r.isEdit||!e.getOption(\"readOnly\"))return e.operation((function(){e.curOp.isVimOp=!0;try{\"keyToKey\"==r.type?function(n){for(var r;n;)r=/<\\w+-.+?>|<\\w+>|./.exec(n),t=r[0],n=n.substring(r.index+t.length),ie.handleKey(e,t,\"mapping\")}(r.toKeys):he.processCommand(e,o,r)}catch(n){throw e.state.vim=void 0,re(e),ie.suppressErrorLogging||console.log(n),n}return!0}))}},handleEx:function(e,t){gt.processCommand(e,t)},defineMotion:function(e,t){pe[e]=t},defineAction:function(e,t){me[e]=t},defineOperator:function(e,t){fe[e]=t},mapCommand:function(e,t,n,r,o){var i={keys:e,type:t};for(var a in i[t]=n,i[t+\"Args\"]=r,o)i[a]=o[a];yt(i)},_mapCommand:yt,defineRegister:function(e,t){var n=Z.registerController.registers;if(!e||1!=e.length)throw Error(\"Register name must be 1 character\");n[e]=t,V.push(e)},exitVisualMode:Pe,exitInsertMode:vt};function ae(){this.prefixRepeat=[],this.motionRepeat=[],this.operator=null,this.operatorArgs=null,this.motion=null,this.motionArgs=null,this.keyBuffer=[],this.registerName=null}function se(e,t){e.state.vim.inputState=new ae,m.signal(e,\"vim-command-done\",t)}function ce(e,t,n){this.clear(),this.keyBuffer=[e||\"\"],this.insertModeChanges=[],this.searchQueries=[],this.linewise=!!t,this.blockwise=!!n}function le(e){this.registers=e,this.unnamedRegister=e['\"']=new ce,e[\".\"]=new ce,e[\":\"]=new ce,e[\"/\"]=new ce,e[\"+\"]=new ce}function ue(){this.historyBuffer=[],this.iterator=0,this.initialPrefix=null}ae.prototype.pushRepeatDigit=function(e){this.operator?this.motionRepeat=this.motionRepeat.concat(e):this.prefixRepeat=this.prefixRepeat.concat(e)},ae.prototype.getRepeat=function(){var e=0;return(this.prefixRepeat.length>0||this.motionRepeat.length>0)&&(e=1,this.prefixRepeat.length>0&&(e*=parseInt(this.prefixRepeat.join(\"\"),10)),this.motionRepeat.length>0&&(e*=parseInt(this.motionRepeat.join(\"\"),10))),e},ce.prototype={setText:function(e,t,n){this.keyBuffer=[e||\"\"],this.linewise=!!t,this.blockwise=!!n},pushText:function(e,t){t&&(this.linewise||this.keyBuffer.push(\"\\n\"),this.linewise=!0),this.keyBuffer.push(e)},pushInsertModeChanges:function(e){this.insertModeChanges.push(te(e))},pushSearchQuery:function(e){this.searchQueries.push(e)},clear:function(){this.keyBuffer=[],this.insertModeChanges=[],this.searchQueries=[],this.linewise=!1},toString:function(){return this.keyBuffer.join(\"\")}},le.prototype={pushText:function(e,t,n,r,o){if(\"_\"!==e){r&&\"\\n\"!==n.charAt(n.length-1)&&(n+=\"\\n\");var i=this.isValidRegister(e)?this.getRegister(e):null;if(i){W(e)?i.pushText(n,r):i.setText(n,r,o),\"+\"===e&&navigator.clipboard.writeText(n),this.unnamedRegister.setText(i.toString(),r)}else{switch(t){case\"yank\":this.registers[0]=new ce(n,r,o);break;case\"delete\":case\"change\":-1==n.indexOf(\"\\n\")?this.registers[\"-\"]=new ce(n,r):(this.shiftNumericRegisters_(),this.registers[1]=new ce(n,r))}this.unnamedRegister.setText(n,r,o)}}},getRegister:function(e){return this.isValidRegister(e)?(e=e.toLowerCase(),this.registers[e]||(this.registers[e]=new ce),this.registers[e]):this.unnamedRegister},isValidRegister:function(e){return e&&J(e,V)},shiftNumericRegisters_:function(){for(var e=9;e>=2;e--)this.registers[e]=this.getRegister(\"\"+(e-1))}},ue.prototype={nextMatch:function(e,t){var n=this.historyBuffer,r=t?-1:1;null===this.initialPrefix&&(this.initialPrefix=e);for(var o=this.iterator+r;t?o>=0:o<n.length;o+=r)for(var i=n[o],a=0;a<=i.length;a++)if(this.initialPrefix==i.substring(0,a))return this.iterator=o,i;return o>=n.length?(this.iterator=n.length,this.initialPrefix):o<0?e:void 0},pushInput:function(e){var t=this.historyBuffer.indexOf(e);t>-1&&this.historyBuffer.splice(t,1),e.length&&this.historyBuffer.push(e)},reset:function(){this.initialPrefix=null,this.iterator=this.historyBuffer.length}};var he={matchCommand:function(e,t,n,r){var o,i=function(e,t,n,r){for(var o,i=[],a=[],s=0;s<t.length;s++){var c=t[s];\"insert\"==n&&\"insert\"!=c.context||c.context&&c.context!=n||r.operator&&\"action\"==c.type||!(o=Ce(e,c.keys))||(\"partial\"==o&&i.push(c),\"full\"==o&&a.push(c))}return{partial:i.length&&i,full:a.length&&a}}(e,t,r,n);if(!i.full&&!i.partial)return{type:\"none\"};if(!i.full&&i.partial)return{type:\"partial\"};for(var a=0;a<i.full.length;a++){var s=i.full[a];o||(o=s)}if(\"<character>\"==o.keys.slice(-11)){var c=function(e){var t=/^.*(<[^>]+>)$/.exec(e),n=t?t[1]:e.slice(-1);if(n.length>1)switch(n){case\"<CR>\":n=\"\\n\";break;case\"<Space>\":n=\" \";break;default:n=\"\"}return n}(e);if(!c||c.length>1)return{type:\"clear\"};n.selectedCharacter=c}return{type:\"full\",command:o}},processCommand:function(e,t,n){switch(t.inputState.repeatOverride=n.repeatOverride,n.type){case\"motion\":this.processMotion(e,t,n);break;case\"operator\":this.processOperator(e,t,n);break;case\"operatorMotion\":this.processOperatorMotion(e,t,n);break;case\"action\":this.processAction(e,t,n);break;case\"search\":this.processSearch(e,t,n);break;case\"ex\":case\"keyToEx\":this.processEx(e,t,n)}},processMotion:function(e,t,n){t.inputState.motion=n.motion,t.inputState.motionArgs=ve(n.motionArgs),this.evalInput(e,t)},processOperator:function(e,t,n){var r=t.inputState;if(r.operator){if(r.operator==n.operator)return r.motion=\"expandToLine\",r.motionArgs={linewise:!0},void this.evalInput(e,t);se(e)}r.operator=n.operator,r.operatorArgs=ve(n.operatorArgs),n.keys.length>1&&(r.operatorShortcut=n.keys),n.exitVisualBlock&&(t.visualBlock=!1,Ie(e)),t.visualMode&&this.evalInput(e,t)},processOperatorMotion:function(e,t,n){var r=t.visualMode,o=ve(n.operatorMotionArgs);o&&r&&o.visualLine&&(t.visualLine=!0),this.processOperator(e,t,n),r||this.processMotion(e,t,n)},processAction:function(e,t,n){var r=t.inputState,o=r.getRepeat(),i=!!o,a=ve(n.actionArgs)||{};r.selectedCharacter&&(a.selectedCharacter=r.selectedCharacter),n.operator&&this.processOperator(e,t,n),n.motion&&this.processMotion(e,t,n),(n.motion||n.operator)&&this.evalInput(e,t),a.repeat=o||1,a.repeatIsExplicit=i,a.registerName=r.registerName,se(e),t.lastMotion=null,n.isEdit&&this.recordLastEdit(t,r,n),me[n.action](e,a,t)},processSearch:function(e,t,n){if(e.getSearchCursor){var r=n.searchArgs.forward,o=n.searchArgs.wholeWordOnly;Ge(e).setReversed(!r);var i=r?\"/\":\"?\",a=Ge(e).getQuery(),s=e.getScrollInfo();switch(n.searchArgs.querySrc){case\"prompt\":var c=Z.macroModeState;if(c.isPlaying)p(h=c.replaySearchQueries.shift(),!0,!1);else ot(e,{onClose:function(e){p(e,!0,!0);var t=Z.macroModeState;t.isRecording&&function(e,t){if(!e.isPlaying){var n=e.latestRegister,r=Z.registerController.getRegister(n);r&&r.pushSearchQuery&&r.pushSearchQuery(t)}}(t,e)},prefix:i,desc:\"(JavaScript regexp)\",onKeyUp:function(t,n,o){var i,a,c,l=m.keyName(t);\"Up\"==l||\"Down\"==l?(i=\"Up\"==l,a=t.target?t.target.selectionEnd:0,o(n=Z.searchHistoryController.nextMatch(n,i)||\"\"),a&&t.target&&(t.target.selectionEnd=t.target.selectionStart=Math.min(a,t.target.value.length))):\"Left\"!=l&&\"Right\"!=l&&\"Ctrl\"!=l&&\"Alt\"!=l&&\"Shift\"!=l&&Z.searchHistoryController.reset();try{c=it(e,n,!0,!0)}catch(t){}c?e.scrollIntoView(ct(e,!r,c),30):(lt(e),e.scrollTo(s.left,s.top))},onKeyDown:function(t,n,r){var o=m.keyName(t);\"Esc\"==o||\"Ctrl-C\"==o||\"Ctrl-[\"==o||\"Backspace\"==o&&\"\"==n?(Z.searchHistoryController.pushInput(n),Z.searchHistoryController.reset(),it(e,a),lt(e),e.scrollTo(s.left,s.top),m.e_stop(t),se(e),r(),e.focus()):\"Up\"==o||\"Down\"==o?m.e_stop(t):\"Ctrl-U\"==o&&(m.e_stop(t),r(\"\"))}});break;case\"wordUnderCursor\":var l=_e(e,!1,!0,!1,!0),u=!0;if(l||(l=_e(e,!1,!0,!1,!1),u=!1),!l)return;var h=e.getLine(l.start.line).substring(l.start.ch,l.end.ch);h=u&&o?\"\\\\b\"+h+\"\\\\b\":h.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g,\"\\\\$1\"),Z.jumpList.cachedCursor=e.getCursor(),e.setCursor(l.start),p(h,!0,!1)}}function p(r,o,i){Z.searchHistoryController.pushInput(r),Z.searchHistoryController.reset();try{it(e,r,o,i)}catch(a){return rt(e,\"Invalid regex: \"+r),void se(e)}he.processMotion(e,t,{type:\"motion\",motion:\"findNext\",motionArgs:{forward:!0,toJumplist:n.searchArgs.toJumplist}})}},processEx:function(e,t,n){function r(t){Z.exCommandHistoryController.pushInput(t),Z.exCommandHistoryController.reset(),gt.processCommand(e,t),e.state.vim&&se(e)}function o(t,n,r){var o,i,a=m.keyName(t);(\"Esc\"==a||\"Ctrl-C\"==a||\"Ctrl-[\"==a||\"Backspace\"==a&&\"\"==n)&&(Z.exCommandHistoryController.pushInput(n),Z.exCommandHistoryController.reset(),m.e_stop(t),se(e),r(),e.focus()),\"Up\"==a||\"Down\"==a?(m.e_stop(t),o=\"Up\"==a,i=t.target?t.target.selectionEnd:0,r(n=Z.exCommandHistoryController.nextMatch(n,o)||\"\"),i&&t.target&&(t.target.selectionEnd=t.target.selectionStart=Math.min(i,t.target.value.length))):\"Ctrl-U\"==a?(m.e_stop(t),r(\"\")):\"Left\"!=a&&\"Right\"!=a&&\"Ctrl\"!=a&&\"Alt\"!=a&&\"Shift\"!=a&&Z.exCommandHistoryController.reset()}\"keyToEx\"==n.type?gt.processCommand(e,n.exArgs.input):t.visualMode?ot(e,{onClose:r,prefix:\":\",value:\"'<,'>\",onKeyDown:o,selectValueOnOpen:!1}):ot(e,{onClose:r,prefix:\":\",onKeyDown:o})},evalInput:function(e,t){var n,r,o,i=t.inputState,a=i.motion,s=i.motionArgs||{},c=i.operator,l=i.operatorArgs||{},u=i.registerName,h=t.sel,p=we(t.visualMode?ge(e,h.head):e.getCursor(\"head\")),d=we(t.visualMode?ge(e,h.anchor):e.getCursor(\"anchor\")),f=we(p),m=we(d);if(c&&this.recordLastEdit(t,i),(o=void 0!==i.repeatOverride?i.repeatOverride:i.getRepeat())>0&&s.explicitRepeat?s.repeatIsExplicit=!0:(s.noRepeat||!s.explicitRepeat&&0===o)&&(o=1,s.repeatIsExplicit=!1),i.selectedCharacter&&(s.selectedCharacter=l.selectedCharacter=i.selectedCharacter),s.repeat=o,se(e),a){var g=pe[a](e,p,s,t,i);if(t.lastMotion=pe[a],!g)return;if(s.toJumplist){c||null==e.ace.curOp||(e.ace.curOp.command.scrollIntoView=\"center-animate\");var v=Z.jumpList,C=v.cachedCursor;C?(He(e,C,g),delete v.cachedCursor):He(e,p,g)}g instanceof Array?(r=g[0],n=g[1]):n=g,n||(n=we(p)),t.visualMode?(t.visualBlock&&n.ch===1/0||(n=ge(e,n,f)),r&&(r=ge(e,r)),r=r||m,h.anchor=r,h.head=n,Ie(e),Ue(e,t,\"<\",Se(r,n)?r:n),Ue(e,t,\">\",Se(r,n)?n:r)):c||(e.ace.curOp&&(e.ace.curOp.vimDialogScroll=\"center-animate\"),n=ge(e,n,f),e.setCursor(n.line,n.ch))}if(c){if(l.lastSel){r=m;var w=l.lastSel,x=Math.abs(w.head.line-w.anchor.line),S=Math.abs(w.head.ch-w.anchor.ch);n=w.visualLine?new y(m.line+x,m.ch):w.visualBlock?new y(m.line+x,m.ch+S):w.head.line==w.anchor.line?new y(m.line,m.ch+S):new y(m.line+x,m.ch),t.visualMode=!0,t.visualLine=w.visualLine,t.visualBlock=w.visualBlock,h=t.sel={anchor:r,head:n},Ie(e)}else t.visualMode&&(l.lastSel={anchor:we(h.anchor),head:we(h.head),visualBlock:t.visualBlock,visualLine:t.visualLine});var M,A,b,L,O;if(t.visualMode){if(M=Me(h.head,h.anchor),A=Ae(h.head,h.anchor),b=t.visualLine||l.linewise,L=t.visualBlock?\"block\":b?\"line\":\"char\",O=Ke(e,{anchor:(B=k(e,M,A)).start,head:B.end},L),b){var T=O.ranges;if(\"block\"==L)for(var E=0;E<T.length;E++)T[E].head.ch=Le(e,T[E].head.line);else\"line\"==L&&(T[0].head=new y(T[0].head.line+1,0))}}else{if(M=we(r||m),Se(A=we(n||f),M)){var R=M;M=A,A=R}(b=s.linewise||l.linewise)?function(e,t,n){t.ch=0,n.ch=0,n.line++}(0,M,A):s.forward&&function(e,t,n){var r=e.getRange(t,n);if(/\\n\\s*$/.test(r)){var o=r.split(\"\\n\");o.pop();for(var i=o.pop();o.length>0&&i&&U(i);i=o.pop())n.line--,n.ch=0;i?(n.line--,n.ch=Le(e,n.line)):n.ch=0}}(e,M,A),L=\"char\";var B,I=!s.inclusive||b;O=Ke(e,{anchor:(B=k(e,M,A)).start,head:B.end},L,I)}e.setSelections(O.ranges,O.primary),t.lastMotion=null,l.repeat=o,l.registerName=u,l.linewise=b;var K=fe[c](e,l,O.ranges,m,n);t.visualMode&&Pe(e,null!=K),K&&e.setCursor(K)}},recordLastEdit:function(e,t,n){var r=Z.macroModeState;r.isPlaying||(e.lastEditInputState=t,e.lastEditActionCommand=n,r.lastInsertModeChanges.changes=[],r.lastInsertModeChanges.expectCursorActivityForChange=!1,r.lastInsertModeChanges.visualBlock=e.visualBlock?e.sel.head.line-e.sel.anchor.line:0)}},pe={moveToTopLine:function(e,t,n){var r=ht(e).top+n.repeat-1;return new y(r,Ne(e.getLine(r)))},moveToMiddleLine:function(e){var t=ht(e),n=Math.floor(.5*(t.top+t.bottom));return new y(n,Ne(e.getLine(n)))},moveToBottomLine:function(e,t,n){var r=ht(e).bottom-n.repeat+1;return new y(r,Ne(e.getLine(r)))},expandToLine:function(e,t,n){return new y(t.line+n.repeat-1,1/0)},findNext:function(e,t,n){var r=Ge(e),o=r.getQuery();if(o){var i=!n.forward;return i=r.isReversed()?!i:i,st(e,o),ct(e,i,o,n.repeat)}},findAndSelectNextInclusive:function(e,t,n,r,o){var i=Ge(e),a=i.getQuery();if(a){var s=!n.forward,c=function(e,t,n,r,o){void 0===r&&(r=1);return e.operation((function(){var i=e.getCursor(),a=e.getSearchCursor(n,i),s=a.find(!t);!o.visualMode&&s&&xe(a.from(),i)&&a.find(!t);for(var c=0;c<r;c++)if(!(s=a.find(t))&&!(a=e.getSearchCursor(n,t?new y(e.lastLine()):new y(e.firstLine(),0))).find(t))return;return[a.from(),a.to()]}))}(e,s=i.isReversed()?!s:s,a,n.repeat,r);if(c){if(o.operator)return c;var l=c[0],u=new y(c[1].line,c[1].ch-1);if(r.visualMode){(r.visualLine||r.visualBlock)&&(r.visualLine=!1,r.visualBlock=!1,m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:\"\"}));var h=r.sel.anchor;if(h)return i.isReversed()?n.forward?[h,l]:[h,u]:n.forward?[h,u]:[h,l]}else r.visualMode=!0,r.visualLine=!1,r.visualBlock=!1,m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:\"\"});return s?[u,l]:[l,u]}}},goToMark:function(e,t,n,r){var o=pt(e,r,n.selectedCharacter);return o?n.linewise?{line:o.line,ch:Ne(e.getLine(o.line))}:o:null},moveToOtherHighlightedEnd:function(e,t,n,r){if(r.visualBlock&&n.sameLine){var o=r.sel;return[ge(e,new y(o.anchor.line,o.head.ch)),ge(e,new y(o.head.line,o.anchor.ch))]}return[r.sel.head,r.sel.anchor]},jumpToMark:function(e,t,n,r){for(var o=t,i=0;i<n.repeat;i++){var a=o;for(var s in r.marks)if(j(s)){var c=r.marks[s].find();if(!(n.forward?Se(c,a):Se(a,c))&&(!n.linewise||c.line!=a.line)){var l=xe(a,o),u=n.forward?be(a,c,o):be(o,c,a);(l||u)&&(o=c)}}}return n.linewise&&(o=new y(o.line,Ne(e.getLine(o.line)))),o},moveByCharacters:function(e,t,n){var r=t,o=n.repeat,i=n.forward?r.ch+o:r.ch-o;return new y(r.line,i)},moveByLines:function(e,t,n,r){var o=t,i=o.ch;switch(r.lastMotion){case this.moveByLines:case this.moveByDisplayLines:case this.moveByScroll:case this.moveToColumn:case this.moveToEol:i=r.lastHPos;break;default:r.lastHPos=i}var a=n.repeat+(n.repeatOffset||0),s=n.forward?o.line+a:o.line-a,c=e.firstLine(),l=e.lastLine();if(s<c&&o.line==c)return this.moveToStartOfLine(e,t,n,r);if(s>l&&o.line==l)return je(e,t,n,r,!0);var u=e.ace.session.getFoldLine(s);return u&&(n.forward?s>u.start.row&&(s=u.end.row+1):s=u.start.row),n.toFirstChar&&(i=Ne(e.getLine(s)),r.lastHPos=i),r.lastHSPos=e.charCoords(new y(s,i),\"div\").left,new y(s,i)},moveByDisplayLines:function(e,t,n,r){var o=t;switch(r.lastMotion){case this.moveByDisplayLines:case this.moveByScroll:case this.moveByLines:case this.moveToColumn:case this.moveToEol:break;default:r.lastHSPos=e.charCoords(o,\"div\").left}var i=n.repeat;if((s=e.findPosV(o,n.forward?i:-i,\"line\",r.lastHSPos)).hitSide)if(n.forward)var a={top:e.charCoords(s,\"div\").top+8,left:r.lastHSPos},s=e.coordsChar(a,\"div\");else{var c=e.charCoords(new y(e.firstLine(),0),\"div\");c.left=r.lastHSPos,s=e.coordsChar(c,\"div\")}return r.lastHPos=s.ch,s},moveByPage:function(e,t,n){var r=t,o=n.repeat;return e.findPosV(r,n.forward?o:-o,\"page\")},moveByParagraph:function(e,t,n){var r=n.forward?1:-1;return Je(e,t,n.repeat,r)},moveBySentence:function(e,t,n){var r=n.forward?1:-1;return function(e,t,n,r){function o(e,t){if(t.pos+t.dir<0||t.pos+t.dir>=t.line.length){if(t.ln+=t.dir,!F(e,t.ln))return t.line=null,t.ln=null,void(t.pos=null);t.line=e.getLine(t.ln),t.pos=t.dir>0?0:t.line.length-1}else t.pos+=t.dir}function i(e,t,n,r){var i=\"\"===(l=e.getLine(t)),a={line:l,ln:t,pos:n,dir:r},s={ln:a.ln,pos:a.pos},c=\"\"===a.line;for(o(e,a);null!==a.line;){if(s.ln=a.ln,s.pos=a.pos,\"\"===a.line&&!c)return{ln:a.ln,pos:a.pos};if(i&&\"\"!==a.line&&!U(a.line[a.pos]))return{ln:a.ln,pos:a.pos};!z(a.line[a.pos])||i||a.pos!==a.line.length-1&&!U(a.line[a.pos+1])||(i=!0),o(e,a)}var l=e.getLine(s.ln);s.pos=0;for(var u=l.length-1;u>=0;--u)if(!U(l[u])){s.pos=u;break}return s}function a(e,t,n,r){var i={line:c=e.getLine(t),ln:t,pos:n,dir:r},a={ln:i.ln,pos:null},s=\"\"===i.line;for(o(e,i);null!==i.line;){if(\"\"===i.line&&!s)return null!==a.pos?a:{ln:i.ln,pos:i.pos};if(z(i.line[i.pos])&&null!==a.pos&&(i.ln!==a.ln||i.pos+1!==a.pos))return a;\"\"===i.line||U(i.line[i.pos])||(s=!1,a={ln:i.ln,pos:i.pos}),o(e,i)}var c=e.getLine(a.ln);a.pos=0;for(var l=0;l<c.length;++l)if(!U(c[l])){a.pos=l;break}return a}var s={ln:t.line,pos:t.ch};for(;n>0;)s=r<0?a(e,s.ln,s.pos,r):i(e,s.ln,s.pos,r),n--;return new y(s.ln,s.pos)}(e,t,n.repeat,r)},moveByScroll:function(e,t,n,r){var o,i=e.getScrollInfo(),a=n.repeat;a||(a=i.clientHeight/(2*e.defaultTextHeight()));var s=e.charCoords(t,\"local\");if(n.repeat=a,!(o=pe.moveByDisplayLines(e,t,n,r)))return null;var c=e.charCoords(o,\"local\");return e.scrollTo(null,i.top+c.top-s.top),o},moveByWords:function(e,t,n){return function(e,t,n,r,o,i){var a=we(t),s=[];(r&&!o||!r&&o)&&n++;for(var c=!(r&&o),l=0;l<n;l++){var u=Fe(e,t,r,i,c);if(!u){var h=Le(e,e.lastLine());s.push(r?{line:e.lastLine(),from:h,to:h}:{line:0,from:0,to:0});break}s.push(u),t=new y(u.line,r?u.to-1:u.from)}var p=s.length!=n,d=s[0],f=s.pop();return r&&!o?(p||d.from==a.ch&&d.line==a.line||(f=s.pop()),new y(f.line,f.from)):r&&o?new y(f.line,f.to-1):!r&&o?(p||d.to==a.ch&&d.line==a.line||(f=s.pop()),new y(f.line,f.to)):new y(f.line,f.from)}(e,t,n.repeat,!!n.forward,!!n.wordEnd,!!n.bigWord)},moveTillCharacter:function(e,t,n){var r=We(e,n.repeat,n.forward,n.selectedCharacter),o=n.forward?-1:1;return $e(o,n),r?(r.ch+=o,r):null},moveToCharacter:function(e,t,n){var r=n.repeat;return $e(0,n),We(e,r,n.forward,n.selectedCharacter)||t},moveToSymbol:function(e,t,n){return function(e,t,n,r){var o=we(e.getCursor()),i=n?1:-1,a=n?e.lineCount():-1,s=o.ch,c=o.line,l=e.getLine(c),u={lineText:l,nextCh:l.charAt(s),lastCh:null,index:s,symb:r,reverseSymb:(n?{\")\":\"(\",\"}\":\"{\"}:{\"(\":\")\",\"{\":\"}\"})[r],forward:n,depth:0,curMoveThrough:!1},h=De[r];if(!h)return o;var p=Ve[h].init,d=Ve[h].isComplete;p&&p(u);for(;c!==a&&t;){if(u.index+=i,u.nextCh=u.lineText.charAt(u.index),!u.nextCh){if(c+=i,u.lineText=e.getLine(c)||\"\",i>0)u.index=0;else{var f=u.lineText.length;u.index=f>0?f-1:0}u.nextCh=u.lineText.charAt(u.index)}d(u)&&(o.line=c,o.ch=u.index,t--)}if(u.nextCh||u.curMoveThrough)return new y(c,u.index);return o}(e,n.repeat,n.forward,n.selectedCharacter)||t},moveToColumn:function(e,t,n,r){var o=n.repeat;return r.lastHPos=o-1,r.lastHSPos=e.charCoords(t,\"div\").left,function(e,t){var n=e.getCursor().line;return ge(e,new y(n,t-1))}(e,o)},moveToEol:function(e,t,n,r){return je(e,t,n,r,!1)},moveToFirstNonWhiteSpaceCharacter:function(e,t){var n=t;return new y(n.line,Ne(e.getLine(n.line)))},moveToMatchedSymbol:function(e,t){for(var n,r=t,o=r.line,i=r.ch,a=e.getLine(o);i<a.length;i++)if((n=a.charAt(i))&&-1!=\"()[]{}\".indexOf(n)){var s=e.getTokenTypeAt(new y(o,i+1));if(\"string\"!==s&&\"comment\"!==s)break}if(i<a.length){var c=/[<>]/.test(a[i])?/[(){}[\\]<>]/:/[(){}[\\]]/;return e.findMatchingBracket(new y(o,i+1),{bracketRegex:c}).to}return r},moveToStartOfLine:function(e,t){return new y(t.line,0)},moveToLineOrEdgeOfDocument:function(e,t,n){var r=n.forward?e.lastLine():e.firstLine();return n.repeatIsExplicit&&(r=n.repeat-e.getOption(\"firstLineNumber\")),new y(r,Ne(e.getLine(r)))},moveToStartOfDisplayLine:function(e){return e.execCommand(\"goLineLeft\"),e.getCursor()},moveToEndOfDisplayLine:function(e){e.execCommand(\"goLineRight\");var t=e.getCursor();return\"before\"==t.sticky&&t.ch--,t},textObjectManipulation:function(e,t,n,r){var o=n.selectedCharacter;\"b\"==o?o=\"(\":\"B\"==o&&(o=\"{\");var i,a=!n.textObjectInner;if({\"(\":\")\",\")\":\"(\",\"{\":\"}\",\"}\":\"{\",\"[\":\"]\",\"]\":\"[\",\"<\":\">\",\">\":\"<\"}[o])i=function(e,t,n,r){var o,i,a=t,s={\"(\":/[()]/,\")\":/[()]/,\"[\":/[[\\]]/,\"]\":/[[\\]]/,\"{\":/[{}]/,\"}\":/[{}]/,\"<\":/[<>]/,\">\":/[<>]/}[n],c={\"(\":\"(\",\")\":\"(\",\"[\":\"[\",\"]\":\"[\",\"{\":\"{\",\"}\":\"{\",\"<\":\"<\",\">\":\"<\"}[n],l=e.getLine(a.line).charAt(a.ch),u=l===c?1:0;if(o=e.scanForBracket(new y(a.line,a.ch+u),-1,void 0,{bracketRegex:s}),i=e.scanForBracket(new y(a.line,a.ch+u),1,void 0,{bracketRegex:s}),!o||!i)return{start:a,end:a};if(o=o.pos,i=i.pos,o.line==i.line&&o.ch>i.ch||o.line>i.line){var h=o;o=i,i=h}r?i.ch+=1:o.ch+=1;return{start:o,end:i}}(e,t,o,a);else if({\"'\":!0,'\"':!0,\"`\":!0}[o])i=function(e,t,n,r){var o,i,a,s,c=we(t),l=e.getLine(c.line),u=l.split(\"\"),h=u.indexOf(n);c.ch<h?c.ch=h:h<c.ch&&u[c.ch]==n&&(i=c.ch,--c.ch);if(u[c.ch]!=n||i)for(a=c.ch;a>-1&&!o;a--)u[a]==n&&(o=a+1);else o=c.ch+1;if(o&&!i)for(a=o,s=u.length;a<s&&!i;a++)u[a]==n&&(i=a);if(!o||!i)return{start:c,end:c};r&&(--o,++i);return{start:new y(c.line,o),end:new y(c.line,i)}}(e,t,o,a);else if(\"W\"===o)i=_e(e,a,!0,!0);else if(\"w\"===o)i=_e(e,a,!0,!1);else if(\"p\"===o)if(i=Je(e,t,n.repeat,0,a),n.linewise=!0,r.visualMode)r.visualLine||(r.visualLine=!0);else{var s=r.inputState.operatorArgs;s&&(s.linewise=!0),i.end.line--}else if(\"t\"===o)i=function(e,t,n){var r=t;if(!m.findMatchingTag||!m.findEnclosingTag)return{start:r,end:r};var o=m.findMatchingTag(e,t)||m.findEnclosingTag(e,t);if(!o||!o.open||!o.close)return{start:r,end:r};if(n)return{start:o.open.from,end:o.close.to};return{start:o.open.to,end:o.close.from}}(e,t,a);else{if(\"s\"!==o)return null;var c=e.getLine(t.line);t.ch>0&&z(c[t.ch])&&(t.ch-=1);var l=qe(e,t,n.repeat,1,a),u=qe(e,t,n.repeat,-1,a);U(e.getLine(u.line)[u.ch])&&U(e.getLine(l.line)[l.ch-1])&&(u={line:u.line,ch:u.ch+1}),i={start:u,end:l}}return e.state.vim.visualMode?function(e,t,n){var r,o=e.state.vim.sel,i=o.head,a=o.anchor;Se(n,t)&&(r=n,n=t,t=r);Se(i,a)?(i=Me(t,i),a=Ae(a,n)):(a=Me(t,a),-1==(i=ye(i=Ae(i,n),0,-1)).ch&&i.line!=e.firstLine()&&(i=new y(i.line-1,Le(e,i.line-1))));return[a,i]}(e,i.start,i.end):[i.start,i.end]},repeatLastCharacterSearch:function(e,t,n){var r=Z.lastCharacterSearch,o=n.repeat,i=n.forward===r.forward,a=(r.increment?1:0)*(i?-1:1);e.moveH(-a,\"char\"),n.inclusive=!!i;var s=We(e,o,i,r.selectedCharacter);return s?(s.ch+=a,s):(e.moveH(a,\"char\"),t)}};function de(e,t){for(var n=[],r=0;r<t;r++)n.push(e);return n}var fe={change:function(e,t,n){var r,o,i=e.state.vim,a=n[0].anchor,s=n[0].head;if(i.visualMode)if(t.fullLine)s.ch=Number.MAX_VALUE,s.line--,e.setSelection(a,s),o=e.getSelection(),e.replaceSelection(\"\"),r=a;else{o=e.getSelection();var c=de(\"\",n.length);e.replaceSelections(c),r=Me(n[0].head,n[0].anchor)}else{o=e.getRange(a,s);var l=i.lastEditInputState||{};if(\"moveByWords\"==l.motion&&!U(o)){var u=/\\s+$/.exec(o);u&&l.motionArgs&&l.motionArgs.forward&&(s=ye(s,0,-u[0].length),o=o.slice(0,-u[0].length))}var h=new y(a.line-1,Number.MAX_VALUE),p=e.firstLine()==e.lastLine();s.line>e.lastLine()&&t.linewise&&!p?e.replaceRange(\"\",h,s):e.replaceRange(\"\",a,s),t.linewise&&(p||(e.setCursor(h),m.commands.newlineAndIndent(e)),a.ch=Number.MAX_VALUE),r=a}Z.registerController.pushText(t.registerName,\"change\",o,t.linewise,n.length>1),me.enterInsertMode(e,{head:r},e.state.vim)},delete:function(e,t,n){var r,o,i=e.state.vim;if(i.visualBlock){o=e.getSelection();var a=de(\"\",n.length);e.replaceSelections(a),r=Me(n[0].head,n[0].anchor)}else{var s=n[0].anchor,c=n[0].head;t.linewise&&c.line!=e.firstLine()&&s.line==e.lastLine()&&s.line==c.line-1&&(s.line==e.firstLine()?s.ch=0:s=new y(s.line-1,Le(e,s.line-1))),o=e.getRange(s,c),e.replaceRange(\"\",s,c),r=s,t.linewise&&(r=pe.moveToFirstNonWhiteSpaceCharacter(e,s))}return Z.registerController.pushText(t.registerName,\"delete\",o,t.linewise,i.visualBlock),ge(e,r)},indent:function(e,t,n){var r=e.state.vim;if(e.indentMore)for(var o=r.visualMode?t.repeat:1,i=0;i<o;i++)t.indentRight?e.indentMore():e.indentLess();else{var a=n[0].anchor.line,s=r.visualBlock?n[n.length-1].anchor.line:n[0].head.line;o=r.visualMode?t.repeat:1;t.linewise&&s--;for(var c=a;c<=s;c++)for(i=0;i<o;i++)e.indentLine(c,t.indentRight)}return pe.moveToFirstNonWhiteSpaceCharacter(e,n[0].anchor)},indentAuto:function(e,t,n){return n.length>1&&e.setSelection(n[0].anchor,n[n.length-1].head),e.execCommand(\"indentAuto\"),pe.moveToFirstNonWhiteSpaceCharacter(e,n[0].anchor)},changeCase:function(e,t,n,r,o){for(var i=e.getSelections(),a=[],s=t.toLower,c=0;c<i.length;c++){var l=i[c],u=\"\";if(!0===s)u=l.toLowerCase();else if(!1===s)u=l.toUpperCase();else for(var h=0;h<l.length;h++){var p=l.charAt(h);u+=W(p)?p.toLowerCase():p.toUpperCase()}a.push(u)}return e.replaceSelections(a),t.shouldMoveCursor?o:!e.state.vim.visualMode&&t.linewise&&n[0].anchor.line+1==n[0].head.line?pe.moveToFirstNonWhiteSpaceCharacter(e,r):t.linewise?r:Me(n[0].anchor,n[0].head)},yank:function(e,t,n,r){var o=e.state.vim,i=e.getSelection(),a=o.visualMode?Me(o.sel.anchor,o.sel.head,n[0].head,n[0].anchor):r;return Z.registerController.pushText(t.registerName,\"yank\",i,t.linewise,o.visualBlock),a}};var me={jumpListWalk:function(e,t,n){if(!n.visualMode){var r=t.repeat,o=t.forward,i=Z.jumpList.move(e,o?r:-r),a=i?i.find():void 0;a=a||e.getCursor(),e.setCursor(a),e.ace.curOp.command.scrollIntoView=\"center-animate\"}},scroll:function(e,t,n){if(!n.visualMode){var r=t.repeat||1,o=e.defaultTextHeight(),i=e.getScrollInfo().top,a=o*r,s=t.forward?i+a:i-a,c=we(e.getCursor()),l=e.charCoords(c,\"local\");if(t.forward)s>l.top?(c.line+=(s-l.top)/o,c.line=Math.ceil(c.line),e.setCursor(c),l=e.charCoords(c,\"local\"),e.scrollTo(null,l.top)):e.scrollTo(null,s);else{var u=s+e.getScrollInfo().clientHeight;u<l.bottom?(c.line-=(l.bottom-u)/o,c.line=Math.floor(c.line),e.setCursor(c),l=e.charCoords(c,\"local\"),e.scrollTo(null,l.bottom-e.getScrollInfo().clientHeight)):e.scrollTo(null,s)}}},scrollToCursor:function(e,t){var n=e.getCursor().line,r=e.charCoords(new y(n,0),\"local\"),o=e.getScrollInfo().clientHeight,i=r.top;switch(t.position){case\"center\":i=r.bottom-o/2;break;case\"bottom\":var a=new y(n,e.getLine(n).length-1);i=i-o+(e.charCoords(a,\"local\").bottom-i)}e.scrollTo(null,i)},replayMacro:function(e,t,n){var r=t.selectedCharacter,o=t.repeat,i=Z.macroModeState;for(\"@\"==r?r=i.latestRegister:i.latestRegister=r;o--;)Ct(e,n,i,r)},enterMacroRecordMode:function(e,t){var n=Z.macroModeState,r=t.selectedCharacter;Z.registerController.isValidRegister(r)&&n.enterMacroRecordMode(e,r)},toggleOverwrite:function(e){e.state.overwrite?(e.toggleOverwrite(!1),e.setOption(\"keyMap\",\"vim-insert\"),m.signal(e,\"vim-mode-change\",{mode:\"insert\"})):(e.toggleOverwrite(!0),e.setOption(\"keyMap\",\"vim-replace\"),m.signal(e,\"vim-mode-change\",{mode:\"replace\"}))},enterInsertMode:function(e,t,n){if(!e.getOption(\"readOnly\")){n.insertMode=!0,n.insertModeRepeat=t&&t.repeat||1;var r=t?t.insertAt:null,o=n.sel,i=t.head||e.getCursor(\"head\"),a=e.listSelections().length;if(\"eol\"==r)i=new y(i.line,Le(e,i.line));else if(\"bol\"==r)i=new y(i.line,0);else if(\"charAfter\"==r){i=k(e,i,ye(i,0,1)).end}else if(\"firstNonBlank\"==r){i=k(e,i,pe.moveToFirstNonWhiteSpaceCharacter(e,i)).end}else if(\"startOfSelectedArea\"==r){if(!n.visualMode)return;n.visualBlock?(i=new y(Math.min(o.head.line,o.anchor.line),Math.min(o.head.ch,o.anchor.ch)),a=Math.abs(o.head.line-o.anchor.line)+1):i=o.head.line<o.anchor.line?o.head:new y(o.anchor.line,0)}else if(\"endOfSelectedArea\"==r){if(!n.visualMode)return;n.visualBlock?(i=new y(Math.min(o.head.line,o.anchor.line),Math.max(o.head.ch,o.anchor.ch)+1),a=Math.abs(o.head.line-o.anchor.line)+1):i=o.head.line>=o.anchor.line?ye(o.head,0,1):new y(o.anchor.line,0)}else if(\"inplace\"==r){if(n.visualMode)return}else\"lastEdit\"==r&&(i=dt(e)||i);e.setOption(\"disableInput\",!1),t&&t.replace?(e.toggleOverwrite(!0),e.setOption(\"keyMap\",\"vim-replace\"),m.signal(e,\"vim-mode-change\",{mode:\"replace\"})):(e.toggleOverwrite(!1),e.setOption(\"keyMap\",\"vim-insert\"),m.signal(e,\"vim-mode-change\",{mode:\"insert\"})),Z.macroModeState.isPlaying||(e.on(\"change\",kt),m.on(e.getInputField(),\"keydown\",Mt)),n.visualMode&&Pe(e),Re(e,i,a)}},toggleVisualMode:function(e,t,n){var r,o=t.repeat,i=e.getCursor();if(n.visualMode)n.visualLine^t.linewise||n.visualBlock^t.blockwise?(n.visualLine=!!t.linewise,n.visualBlock=!!t.blockwise,m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:n.visualLine?\"linewise\":n.visualBlock?\"blockwise\":\"\"}),Ie(e)):Pe(e);else{n.visualMode=!0,n.visualLine=!!t.linewise,n.visualBlock=!!t.blockwise;var a=k(e,i,r=ge(e,new y(i.line,i.ch+o-1)));n.sel={anchor:a.start,head:a.end},m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:n.visualLine?\"linewise\":n.visualBlock?\"blockwise\":\"\"}),Ie(e),Ue(e,n,\"<\",Me(i,r)),Ue(e,n,\">\",Ae(i,r))}},reselectLastSelection:function(e,t,n){var r=n.lastSelection;if(n.visualMode&&Be(e,n),r){var o=r.anchorMark.find(),i=r.headMark.find();if(!o||!i)return;n.sel={anchor:o,head:i},n.visualMode=!0,n.visualLine=r.visualLine,n.visualBlock=r.visualBlock,Ie(e),Ue(e,n,\"<\",Me(o,i)),Ue(e,n,\">\",Ae(o,i)),m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:n.visualLine?\"linewise\":n.visualBlock?\"blockwise\":\"\"})}},joinLines:function(e,t,n){var r,o;if(n.visualMode){if(r=e.getCursor(\"anchor\"),Se(o=e.getCursor(\"head\"),r)){var i=o;o=r,r=i}o.ch=Le(e,o.line)-1}else{var a=Math.max(t.repeat,2);r=e.getCursor(),o=ge(e,new y(r.line+a-1,1/0))}for(var s=0,c=r.line;c<o.line;c++){s=Le(e,r.line);var l=\"\",u=0;if(!t.keepSpaces){var h=e.getLine(r.line+1);-1==(u=h.search(/\\S/))?u=h.length:l=\" \"}e.replaceRange(l,new y(r.line,s),new y(r.line+1,u))}var p=ge(e,new y(r.line,s));n.visualMode&&Pe(e,!1),e.setCursor(p)},newLineAndEnterInsertMode:function(e,t,n){n.insertMode=!0;var r=we(e.getCursor());r.line!==e.firstLine()||t.after?(r.line=t.after?r.line:r.line-1,r.ch=Le(e,r.line),e.setCursor(r),(m.commands.newlineAndIndentContinueComment||m.commands.newlineAndIndent)(e)):(e.replaceRange(\"\\n\",new y(e.firstLine(),0)),e.setCursor(e.firstLine(),0));this.enterInsertMode(e,{repeat:t.repeat},n)},paste:function(e,t,n){var r=this,o=Z.registerController.getRegister(t.registerName);if(\"+\"===t.registerName)navigator.clipboard.readText().then((function(i){r.continuePaste(e,t,n,i,o)}));else{var i=o.toString();this.continuePaste(e,t,n,i,o)}},continuePaste:function(e,t,n,r,o){var i=we(e.getCursor());if(r){if(t.matchIndent){var a=e.getOption(\"tabSize\"),s=function(e){var t=e.split(\"\\t\").length-1,n=e.split(\" \").length-1;return t*a+1*n},c=e.getLine(e.getCursor().line),l=s(c.match(/^\\s*/)[0]),u=r.replace(/\\n$/,\"\"),h=r!==u,p=s(r.match(/^\\s*/)[0]);r=u.replace(/^\\s*/gm,(function(t){var n=l+(s(t)-p);if(n<0)return\"\";if(e.getOption(\"indentWithTabs\")){var r=Math.floor(n/a);return Array(r+1).join(\"\\t\")}return Array(n+1).join(\" \")}));r+=h?\"\\n\":\"\"}if(t.repeat>1)r=Array(t.repeat+1).join(r);var d,f,m=o.linewise,g=o.blockwise;if(g){r=r.split(\"\\n\"),m&&r.pop();for(var v=0;v<r.length;v++)r[v]=\"\"==r[v]?\" \":r[v];i.ch+=t.after?1:0,i.ch=Math.min(Le(e,i.line),i.ch)}else m?n.visualMode?r=n.visualLine?r.slice(0,-1):\"\\n\"+r.slice(0,r.length-1)+\"\\n\":t.after?(r=\"\\n\"+r.slice(0,r.length-1),i.ch=Le(e,i.line)):i.ch=0:i.ch+=t.after?1:0;if(n.visualMode){var C;n.lastPastedText=r;var k=function(e,t){var n=t.lastSelection,r=function(){var t=e.listSelections(),n=t[0],r=t[t.length-1];return[Se(n.anchor,n.head)?n.anchor:n.head,Se(r.anchor,r.head)?r.head:r.anchor]},o=function(){var t=e.getCursor(),r=e.getCursor(),o=n.visualBlock;if(o){var i=o.width,a=o.height;r=new y(t.line+a,t.ch+i);for(var s=[],c=t.line;c<r.line;c++){var l={anchor:new y(c,t.ch),head:new y(c,r.ch)};s.push(l)}e.setSelections(s)}else{var u=n.anchorMark.find(),h=n.headMark.find(),p=h.line-u.line,d=h.ch-u.ch;r={line:r.line+p,ch:p?r.ch:d+r.ch},n.visualLine&&(t=new y(t.line,0),r=new y(r.line,Le(e,r.line))),e.setSelection(t,r)}return[t,r]};return t.visualMode?r():o()}(e,n),w=k[0],x=k[1],S=e.getSelection(),M=e.listSelections(),A=new Array(M.length).join(\"1\").split(\"1\");n.lastSelection&&(C=n.lastSelection.headMark.find()),Z.registerController.unnamedRegister.setText(S),g?(e.replaceSelections(A),x=new y(w.line+r.length-1,w.ch),e.setCursor(w),Ee(e,x),e.replaceSelections(r),d=w):n.visualBlock?(e.replaceSelections(A),e.setCursor(w),e.replaceRange(r,w,w),d=w):(e.replaceRange(r,w,x),d=e.posFromIndex(e.indexFromPos(w)+r.length-1)),C&&(n.lastSelection.headMark=e.setBookmark(C)),m&&(d.ch=0)}else if(g){e.setCursor(i);for(v=0;v<r.length;v++){var b=i.line+v;b>e.lastLine()&&e.replaceRange(\"\\n\",new y(b,0)),Le(e,b)<i.ch&&Te(e,b,i.ch)}e.setCursor(i),Ee(e,new y(i.line+r.length-1,i.ch)),e.replaceSelections(r),d=i}else e.replaceRange(r,i),m&&t.after?d=new y(i.line+1,Ne(e.getLine(i.line+1))):m&&!t.after?d=new y(i.line,Ne(e.getLine(i.line))):!m&&t.after?(f=e.indexFromPos(i),d=e.posFromIndex(f+r.length-1)):(f=e.indexFromPos(i),d=e.posFromIndex(f+r.length));n.visualMode&&Pe(e,!1),e.setCursor(d)}},undo:function(e,t){e.operation((function(){ke(e,m.commands.undo,t.repeat)(),e.setCursor(ge(e,e.getCursor(\"start\")))}))},redo:function(e,t){ke(e,m.commands.redo,t.repeat)()},setRegister:function(e,t,n){n.inputState.registerName=t.selectedCharacter},setMark:function(e,t,n){Ue(e,n,t.selectedCharacter,e.getCursor())},replace:function(e,t,n){var r,o,i=t.selectedCharacter,a=e.getCursor(),s=e.listSelections();if(n.visualMode)a=e.getCursor(\"start\"),o=e.getCursor(\"end\");else{var c=e.getLine(a.line);(r=a.ch+t.repeat)>c.length&&(r=c.length),o=new y(a.line,r)}var l=k(e,a,o);if(a=l.start,o=l.end,\"\\n\"==i)n.visualMode||e.replaceRange(\"\",a,o),(m.commands.newlineAndIndentContinueComment||m.commands.newlineAndIndent)(e);else{var u=e.getRange(a,o);if(u=(u=u.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,i)).replace(/[^\\n]/g,i),n.visualBlock){var h=new Array(e.getOption(\"tabSize\")+1).join(\" \");u=(u=(u=e.getSelection()).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,i)).replace(/\\t/g,h).replace(/[^\\n]/g,i).split(\"\\n\"),e.replaceSelections(u)}else e.replaceRange(u,a,o);n.visualMode?(a=Se(s[0].anchor,s[0].head)?s[0].anchor:s[0].head,e.setCursor(a),Pe(e,!1)):e.setCursor(ye(o,0,-1))}},incrementNumberToken:function(e,t){for(var n,r,o,i,a=e.getCursor(),s=e.getLine(a.line),c=/(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;null!==(n=c.exec(s))&&(o=(r=n.index)+n[0].length,!(a.ch<o)););if((t.backtrack||!(o<=a.ch))&&n){var l=n[2]||n[4],u=n[3]||n[5],h=t.increase?1:-1,p={\"0b\":2,0:8,\"\":10,\"0x\":16}[l.toLowerCase()];i=(parseInt(n[1]+u,p)+h*t.repeat).toString(p);var d=l?new Array(u.length-i.length+1+n[1].length).join(\"0\"):\"\";i=\"-\"===i.charAt(0)?\"-\"+l+d+i.substr(1):l+d+i;var f=new y(a.line,r),m=new y(a.line,o);e.replaceRange(i,f,m),e.setCursor(new y(a.line,r+i.length-1))}},repeatLastEdit:function(e,t,n){if(n.lastEditInputState){var r=t.repeat;r&&t.repeatIsExplicit?n.lastEditInputState.repeatOverride=r:r=n.lastEditInputState.repeatOverride||r,At(e,n,r,!1)}},indent:function(e,t){e.indentLine(e.getCursor().line,t.indentRight)},exitInsertMode:vt};function ge(e,t,n){var r=e.state.vim,o=r.insertMode||r.visualMode,i=Math.min(Math.max(e.firstLine(),t.line),e.lastLine()),a=e.getLine(i),s=a.length-1+!!o,c=Math.min(Math.max(0,t.ch),s),l=a.charCodeAt(c);if(56320<l&&l<57343){var u=1;n&&n.line==i&&n.ch>c&&(u=-1),(c+=u)>s&&(c-=2)}return new y(i,c)}function ve(e){var t={};for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function ye(e,t,n){return\"object\"===typeof t&&(n=t.ch,t=t.line),new y(e.line+t,e.ch+n)}function Ce(e,t){if(\"<character>\"==t.slice(-11)){var n=t.length-11,r=e.slice(0,n),o=t.slice(0,n);return r==o&&e.length>n?\"full\":0==o.indexOf(r)&&\"partial\"}return e==t?\"full\":0==t.indexOf(e)&&\"partial\"}function ke(e,t,n){return function(){for(var r=0;r<n;r++)t(e)}}function we(e){return new y(e.line,e.ch)}function xe(e,t){return e.ch==t.ch&&e.line==t.line}function Se(e,t){return e.line<t.line||e.line==t.line&&e.ch<t.ch}function Me(e,t){return arguments.length>2&&(t=Me.apply(void 0,Array.prototype.slice.call(arguments,1))),Se(e,t)?e:t}function Ae(e,t){return arguments.length>2&&(t=Ae.apply(void 0,Array.prototype.slice.call(arguments,1))),Se(e,t)?t:e}function be(e,t,n){var r=Se(e,t),o=Se(t,n);return r&&o}function Le(e,t){return e.getLine(t).length}function Oe(e){return e.trim?e.trim():e.replace(/^\\s+|\\s+$/g,\"\")}function Te(e,t,n){var r=Le(e,t),o=new Array(n-r+1).join(\" \");e.setCursor(new y(t,r)),e.replaceRange(o,e.getCursor())}function Ee(e,t){var n=[],r=e.listSelections(),o=we(e.clipPos(t)),i=!xe(t,o),a=function(e,t,n){for(var r=0;r<e.length;r++){var o=\"head\"!=n&&xe(e[r].anchor,t),i=\"anchor\"!=n&&xe(e[r].head,t);if(o||i)return r}return-1}(r,e.getCursor(\"head\")),s=xe(r[a].head,r[a].anchor),c=r.length-1,l=c-a>a?c:0,u=r[l].anchor,h=Math.min(u.line,o.line),p=Math.max(u.line,o.line),d=u.ch,f=o.ch,m=r[l].head.ch-d,g=f-d;m>0&&g<=0?(d++,i||f--):m<0&&g>=0?(d--,s||f++):m<0&&-1==g&&(d--,f++);for(var v=h;v<=p;v++){var C={anchor:new y(v,d),head:new y(v,f)};n.push(C)}return e.setSelections(n),t.ch=f,u.ch=d,u}function Re(e,t,n){for(var r=[],o=0;o<n;o++){var i=ye(t,o,0);r.push({anchor:i,head:i})}e.setSelections(r,0)}function Be(e,t){var n=t.sel.anchor,r=t.sel.head;t.lastPastedText&&(r=e.posFromIndex(e.indexFromPos(n)+t.lastPastedText.length),t.lastPastedText=null),t.lastSelection={anchorMark:e.setBookmark(n),headMark:e.setBookmark(r),anchor:we(n),head:we(r),visualMode:t.visualMode,visualLine:t.visualLine,visualBlock:t.visualBlock}}function Ie(e,t,n){var r=e.state.vim,o=Ke(e,t=t||r.sel,n=n||r.visualLine?\"line\":r.visualBlock?\"block\":\"char\");e.setSelections(o.ranges,o.primary)}function Ke(e,t,n,r){var o=we(t.head),i=we(t.anchor);if(\"char\"==n){var a=r||Se(t.head,t.anchor)?0:1,s=Se(t.head,t.anchor)?1:0;return o=ye(t.head,0,a),{ranges:[{anchor:i=ye(t.anchor,0,s),head:o}],primary:0}}if(\"line\"==n){if(Se(t.head,t.anchor))o.ch=0,i.ch=Le(e,i.line);else{i.ch=0;var c=e.lastLine();o.line>c&&(o.line=c),o.ch=Le(e,o.line)}return{ranges:[{anchor:i,head:o}],primary:0}}if(\"block\"==n){var l=Math.min(i.line,o.line),u=i.ch,h=Math.max(i.line,o.line),p=o.ch;u<p?p+=1:u+=1;for(var d=h-l+1,f=o.line==l?0:d-1,m=[],g=0;g<d;g++)m.push({anchor:new y(l+g,u),head:new y(l+g,p)});return{ranges:m,primary:f}}}function Pe(e,t){var n=e.state.vim;!1!==t&&e.setCursor(ge(e,n.sel.head)),Be(e,n),n.visualMode=!1,n.visualLine=!1,n.visualBlock=!1,n.insertMode||m.signal(e,\"vim-mode-change\",{mode:\"normal\"})}function Ne(e){if(!e)return 0;var t=e.search(/\\S/);return-1==t?e.length:t}function _e(e,t,n,r,o){for(var i=function(e){var t=e.getCursor(\"head\");return 1==e.getSelection().length&&(t=Me(t,e.getCursor(\"anchor\"))),t}(e),a=e.getLine(i.line),s=i.ch,c=o?I[0]:K[0];!c(a.charAt(s));)if(++s>=a.length)return null;r?c=K[0]:(c=I[0])(a.charAt(s))||(c=I[1]);for(var l=s,u=s;c(a.charAt(l))&&l<a.length;)l++;for(;c(a.charAt(u))&&u>=0;)u--;if(u++,t){for(var h=l;/\\s/.test(a.charAt(l))&&l<a.length;)l++;if(h==l){for(var p=u;/\\s/.test(a.charAt(u-1))&&u>0;)u--;u||(u=p)}}return{start:new y(i.line,u),end:new y(i.line,l)}}function He(e,t,n){xe(t,n)||Z.jumpList.add(e,t,n)}function $e(e,t){Z.lastCharacterSearch.increment=e,Z.lastCharacterSearch.forward=t.forward,Z.lastCharacterSearch.selectedCharacter=t.selectedCharacter}var De={\"(\":\"bracket\",\")\":\"bracket\",\"{\":\"bracket\",\"}\":\"bracket\",\"[\":\"section\",\"]\":\"section\",\"*\":\"comment\",\"/\":\"comment\",m:\"method\",M:\"method\",\"#\":\"preprocess\"},Ve={bracket:{isComplete:function(e){if(e.nextCh===e.symb){if(e.depth++,e.depth>=1)return!0}else e.nextCh===e.reverseSymb&&e.depth--;return!1}},section:{init:function(e){e.curMoveThrough=!0,e.symb=(e.forward?\"]\":\"[\")===e.symb?\"{\":\"}\"},isComplete:function(e){return 0===e.index&&e.nextCh===e.symb}},comment:{isComplete:function(e){var t=\"*\"===e.lastCh&&\"/\"===e.nextCh;return e.lastCh=e.nextCh,t}},method:{init:function(e){e.symb=\"m\"===e.symb?\"{\":\"}\",e.reverseSymb=\"{\"===e.symb?\"}\":\"{\"},isComplete:function(e){return e.nextCh===e.symb}},preprocess:{init:function(e){e.index=0},isComplete:function(e){if(\"#\"===e.nextCh){var t=e.lineText.match(/^#(\\w+)/)[1];if(\"endif\"===t){if(e.forward&&0===e.depth)return!0;e.depth++}else if(\"if\"===t){if(!e.forward&&0===e.depth)return!0;e.depth--}if(\"else\"===t&&0===e.depth)return!0}return!1}}};function Fe(e,t,n,r,o){var i=t.line,a=t.ch,s=e.getLine(i),c=n?1:-1,l=r?K:I;if(o&&\"\"==s){if(i+=c,s=e.getLine(i),!F(e,i))return null;a=n?0:s.length}for(;;){if(o&&\"\"==s)return{from:0,to:0,line:i};for(var u=c>0?s.length:-1,h=u,p=u;a!=u;){for(var d=!1,f=0;f<l.length&&!d;++f)if(l[f](s.charAt(a))){for(h=a;a!=u&&l[f](s.charAt(a));)a+=c;if(d=h!=(p=a),h==t.ch&&i==t.line&&p==h+c)continue;return{from:Math.min(h,p+1),to:Math.max(h,p),line:i}}d||(a+=c)}if(!F(e,i+=c))return null;s=e.getLine(i),a=c>0?0:s.length}}function je(e,t,n,r,o){var i=new y(t.line+n.repeat-1,1/0),a=e.clipPos(i);return a.ch--,o||(r.lastHPos=1/0,r.lastHSPos=e.charCoords(a,\"div\").left),i}function We(e,t,n,r){for(var o,i=e.getCursor(),a=i.ch,s=0;s<t;s++){if(-1==(o=ze(a,e.getLine(i.line),r,n,!0)))return null;a=o}return new y(e.getCursor().line,o)}function Ue(e,t,n,r){J(n,D)&&(t.marks[n]&&t.marks[n].clear(),t.marks[n]=e.setBookmark(r))}function ze(e,t,n,r,o){var i;return r?-1==(i=t.indexOf(n,e+1))||o||(i-=1):-1==(i=t.lastIndexOf(n,e-1))||o||(i+=1),i}function Je(e,t,n,r,o){var i,a=t.line,s=e.firstLine(),c=e.lastLine(),l=a;function u(t){return!/\\S/.test(e.getLine(t))}function h(e,t,n){return n?u(e)!=u(e+t):!u(e)&&u(e+t)}function p(t){r=r>0?1:-1;var n=e.ace.session.getFoldLine(t);n&&t+r>n.start.row&&t+r<n.end.row&&(r=(r>0?n.end.row:n.start.row)-t)}if(r){for(;s<=l&&l<=c&&n>0;)p(l),h(l,r)&&n--,l+=r;return new y(l,0)}var d=e.state.vim;if(d.visualLine&&h(a,1,!0)){var f=d.sel.anchor;h(f.line,-1,!0)&&(o&&f.line==a||(a+=1))}var m=u(a);for(l=a;l<=c&&n;l++)h(l,1,!0)&&(o&&u(l)==m||n--);for(i=new y(l,0),l>c&&!m?m=!0:o=!1,l=a;l>s&&(o&&u(l)!=m&&l!=a||!h(l,-1,!0));l--);return{start:new y(l,0),end:i}}function qe(e,t,n,r,o){function i(e){e.pos+e.dir<0||e.pos+e.dir>=e.line.length?e.line=null:e.pos+=e.dir}function a(e,t,n,r){var a={line:e.getLine(t),ln:t,pos:n,dir:r};if(\"\"===a.line)return{ln:a.ln,pos:a.pos};var s=a.pos;for(i(a);null!==a.line;){if(s=a.pos,z(a.line[a.pos])){if(o){for(i(a);null!==a.line&&U(a.line[a.pos]);)s=a.pos,i(a);return{ln:a.ln,pos:s+1}}return{ln:a.ln,pos:a.pos+1}}i(a)}return{ln:a.ln,pos:s+1}}function s(e,t,n,r){var a=e.getLine(t),s={line:a,ln:t,pos:n,dir:r};if(\"\"===s.line)return{ln:s.ln,pos:s.pos};var c=s.pos;for(i(s);null!==s.line;){if(U(s.line[s.pos])||z(s.line[s.pos])){if(z(s.line[s.pos]))return o&&U(s.line[s.pos+1])?{ln:s.ln,pos:s.pos+1}:{ln:s.ln,pos:c}}else c=s.pos;i(s)}return s.line=a,o&&U(s.line[s.pos])?{ln:s.ln,pos:s.pos}:{ln:s.ln,pos:c}}for(var c={ln:t.line,pos:t.ch};n>0;)c=r<0?s(e,c.ln,c.pos,r):a(e,c.ln,c.pos,r),n--;return new y(c.ln,c.pos)}function Qe(){}function Ge(e){var t=e.state.vim;return t.searchState_||(t.searchState_=new Qe)}function Xe(e,t){var n=Ze(e,t)||[];if(!n.length)return[];var r=[];if(0===n[0]){for(var o=0;o<n.length;o++)\"number\"==typeof n[o]&&r.push(e.substring(n[o]+1,n[o+1]));return r}}function Ze(e,t){t||(t=\"/\");for(var n=!1,r=[],o=0;o<e.length;o++){var i=e.charAt(o);n||i!=t||r.push(o),n=!n&&\"\\\\\"==i}return r}Q(\"pcre\",!0,\"boolean\"),Qe.prototype={getQuery:function(){return Z.query},setQuery:function(e){Z.query=e},getOverlay:function(){return this.searchOverlay},setOverlay:function(e){this.searchOverlay=e},isReversed:function(){return Z.isReversed},setReversed:function(e){Z.isReversed=e},getScrollbarAnnotate:function(){return this.annotate},setScrollbarAnnotate:function(e){this.annotate=e}};var Ye={\"\\\\n\":\"\\n\",\"\\\\r\":\"\\r\",\"\\\\t\":\"\\t\"};var et={\"\\\\/\":\"/\",\"\\\\\\\\\":\"\\\\\",\"\\\\n\":\"\\n\",\"\\\\r\":\"\\r\",\"\\\\t\":\"\\t\",\"\\\\&\":\"&\"};function tt(e,t,n){if(Z.registerController.getRegister(\"/\").setText(e),e instanceof RegExp)return e;var r,o,i=Ze(e,\"/\");i.length?(r=e.substring(0,i[0]),o=-1!=e.substring(i[0]).indexOf(\"i\")):r=e;return r?(X(\"pcre\")||(r=function(e){for(var t=!1,n=[],r=-1;r<e.length;r++){var o=e.charAt(r)||\"\",i=e.charAt(r+1)||\"\",a=i&&-1!=\"|(){\".indexOf(i);t?(\"\\\\\"===o&&a||n.push(o),t=!1):\"\\\\\"===o?(t=!0,i&&-1!=\"}\".indexOf(i)&&(a=!0),a&&\"\\\\\"!==i||n.push(o)):(n.push(o),a&&\"\\\\\"!==i&&n.push(\"\\\\\"))}return n.join(\"\")}(r)),n&&(t=/^[^A-Z]*$/.test(r)),new RegExp(r,t||o?\"im\":\"m\")):null}function nt(e){\"string\"===typeof e&&(e=document.createElement(e));for(var t,n=1;n<arguments.length;n++)if(t=arguments[n])if(\"object\"!==typeof t&&(t=document.createTextNode(t)),t.nodeType)e.appendChild(t);else for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(\"$\"===r[0]?e.style[r.slice(1)]=t[r]:e.setAttribute(r,t[r]));return e}function rt(e,t){var n=nt(\"div\",{$color:\"red\",$whiteSpace:\"pre\",class:\"cm-vim-message\"},t);e.openNotification?e.openNotification(n,{bottom:!0,duration:5e3}):alert(n.innerText)}function ot(e,t){var n,r,o=(n=t.prefix,r=t.desc,nt(document.createDocumentFragment(),nt(\"span\",{$fontFamily:\"monospace\",$whiteSpace:\"pre\"},n,nt(\"input\",{type:\"text\",autocorrect:\"off\",autocapitalize:\"off\",spellcheck:\"false\"})),r&&nt(\"span\",{$color:\"#888\"},r)));if(e.openDialog)e.openDialog(o,t.onClose,{onKeyDown:t.onKeyDown,onKeyUp:t.onKeyUp,bottom:!0,selectValueOnOpen:!1,value:t.value});else{var i=\"\";\"string\"!=typeof t.prefix&&t.prefix&&(i+=t.prefix.textContent),t.desc&&(i+=\" \"+t.desc),t.onClose(prompt(i,\"\"))}}function it(e,t,n,r){if(t){var o=Ge(e),i=tt(t,!!n,!!r);if(i)return st(e,i),function(e,t){if(e instanceof RegExp&&t instanceof RegExp){for(var n=[\"global\",\"multiline\",\"ignoreCase\",\"source\"],r=0;r<n.length;r++){var o=n[r];if(e[o]!==t[o])return!1}return!0}return!1}(i,o.getQuery())||o.setQuery(i),i}}var at=0;function st(e,t){clearTimeout(at),at=setTimeout((function(){if(e.state.vim){var n=Ge(e),r=n.getOverlay();r&&t==r.query||(r&&e.removeOverlay(r),r=function(e){if(\"^\"==e.source.charAt(0))var t=!0;return{token:function(n){if(!t||n.sol()){var r=n.match(e,!1);if(r)return 0==r[0].length?(n.next(),\"searching\"):n.sol()||(n.backUp(1),e.exec(n.next()+r[0]))?(n.match(e),\"searching\"):(n.next(),null);for(;!n.eol()&&(n.next(),!n.match(e,!1)););}else n.skipToEnd()},query:e}}(t),e.addOverlay(r),e.showMatchesOnScrollbar&&(n.getScrollbarAnnotate()&&n.getScrollbarAnnotate().clear(),n.setScrollbarAnnotate(e.showMatchesOnScrollbar(t))),n.setOverlay(r))}}),50)}function ct(e,t,n,r){return void 0===r&&(r=1),e.operation((function(){for(var o=e.getCursor(),i=e.getSearchCursor(n,o),a=0;a<r;a++){var s=i.find(t);if(0==a&&s&&xe(i.from(),o)){var c=t?i.from():i.to();(s=i.find(t))&&!s[0]&&xe(i.from(),c)&&e.getLine(c.line).length==c.ch&&(s=i.find(t))}if(!s&&!(i=e.getSearchCursor(n,t?new y(e.lastLine()):new y(e.firstLine(),0))).find(t))return}return i.from()}))}function lt(e){var t=Ge(e);e.removeOverlay(Ge(e).getOverlay()),t.setOverlay(null),t.getScrollbarAnnotate()&&(t.getScrollbarAnnotate().clear(),t.setScrollbarAnnotate(null))}function ut(e,t,n){return\"number\"!=typeof e&&(e=e.line),t instanceof Array?J(e,t):\"number\"==typeof n?e>=t&&e<=n:e==t}function ht(e){var t=e.ace.renderer;return{top:t.getFirstFullyVisibleRow(),bottom:t.getLastFullyVisibleRow()}}function pt(e,t,n){if(\"'\"==n||\"`\"==n)return Z.jumpList.find(e,-1)||new y(0,0);if(\".\"==n)return dt(e);var r=t.marks[n];return r&&r.find()}function dt(e){var t=e.ace.session.$undoManager;if(t&&t.$lastDelta)return v(t.$lastDelta.end)}var ft=function(){this.buildCommandMap_()};ft.prototype={processCommand:function(e,t,n){var r=this;e.operation((function(){e.curOp.isVimOp=!0,r._processCommand(e,t,n)}))},_processCommand:function(e,t,n){var r=e.state.vim,o=Z.registerController.getRegister(\":\"),i=o.toString();r.visualMode&&Pe(e);var a=new m.StringStream(t);o.setText(t);var s,c,l=n||{};l.input=t;try{this.parseInput_(e,a,l)}catch(h){throw rt(e,h.toString()),h}if(l.commandName){if(s=this.matchCommand_(l.commandName)){if(c=s.name,s.excludeFromCommandHistory&&o.setText(i),this.parseCommandArgs_(a,l,s),\"exToKey\"==s.type){for(var u=0;u<s.toKeys.length;u++)ie.handleKey(e,s.toKeys[u],\"mapping\");return}if(\"exToEx\"==s.type)return void this.processCommand(e,s.toInput)}}else void 0!==l.line&&(c=\"move\");if(c)try{mt[c](e,l),s&&s.possiblyAsync||!l.callback||l.callback()}catch(h){throw rt(e,h.toString()),h}else rt(e,'Not an editor command \":'+t+'\"')},parseInput_:function(e,t,n){t.eatWhile(\":\"),t.eat(\"%\")?(n.line=e.firstLine(),n.lineEnd=e.lastLine()):(n.line=this.parseLineSpec_(e,t),void 0!==n.line&&t.eat(\",\")&&(n.lineEnd=this.parseLineSpec_(e,t)));var r=t.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);return n.commandName=r?r[1]:t.match(/.*/)[0],n},parseLineSpec_:function(e,t){var n=t.match(/^(\\d+)/);if(n)return parseInt(n[1],10)-1;switch(t.next()){case\".\":return this.parseLineSpecOffset_(t,e.getCursor().line);case\"$\":return this.parseLineSpecOffset_(t,e.lastLine());case\"'\":var r=t.next(),o=pt(e,e.state.vim,r);if(!o)throw new Error(\"Mark not set\");return this.parseLineSpecOffset_(t,o.line);case\"-\":case\"+\":return t.backUp(1),this.parseLineSpecOffset_(t,e.getCursor().line);default:return void t.backUp(1)}},parseLineSpecOffset_:function(e,t){var n=e.match(/^([+-])?(\\d+)/);if(n){var r=parseInt(n[2],10);\"-\"==n[1]?t-=r:t+=r}return t},parseCommandArgs_:function(e,t,n){if(!e.eol()){t.argString=e.match(/.*/)[0];var r=n.argDelimiter||/\\s+/,o=Oe(t.argString).split(r);o.length&&o[0]&&(t.args=o)}},matchCommand_:function(e){for(var t=e.length;t>0;t--){var n=e.substring(0,t);if(this.commandMap_[n]){var r=this.commandMap_[n];if(0===r.name.indexOf(e))return r}}return null},buildCommandMap_:function(){this.commandMap_={};for(var e=0;e<S.length;e++){var t=S[e],n=t.shortName||t.name;this.commandMap_[n]=t}},map:function(e,t,n){if(\":\"!=e&&\":\"==e.charAt(0)){if(n)throw Error(\"Mode not supported for ex mappings\");var r=e.substring(1);\":\"!=t&&\":\"==t.charAt(0)?this.commandMap_[r]={name:r,type:\"exToEx\",toInput:t.substring(1),user:!0}:this.commandMap_[r]={name:r,type:\"exToKey\",toKeys:t,user:!0}}else if(\":\"!=t&&\":\"==t.charAt(0)){var o={keys:e,type:\"keyToEx\",exArgs:{input:t.substring(1)}};n&&(o.context=n),w.unshift(o)}else{o={keys:e,type:\"keyToKey\",toKeys:t};n&&(o.context=n),w.unshift(o)}},unmap:function(e,t){if(\":\"!=e&&\":\"==e.charAt(0)){if(t)throw Error(\"Mode not supported for ex mappings\");var n=e.substring(1);if(this.commandMap_[n]&&this.commandMap_[n].user)return delete this.commandMap_[n],!0}else for(var r=e,o=0;o<w.length;o++)if(r==w[o].keys&&w[o].context===t)return w.splice(o,1),!0}};var mt={colorscheme:function(e,t){!t.args||t.args.length<1?rt(e,e.getOption(\"theme\")):e.setOption(\"theme\",t.args[0])},map:function(e,t,n){var r=t.args;!r||r.length<2?e&&rt(e,\"Invalid mapping: \"+t.input):gt.map(r[0],r[1],n)},imap:function(e,t){this.map(e,t,\"insert\")},nmap:function(e,t){this.map(e,t,\"normal\")},vmap:function(e,t){this.map(e,t,\"visual\")},unmap:function(e,t,n){var r=t.args;(!r||r.length<1||!gt.unmap(r[0],n))&&e&&rt(e,\"No such mapping: \"+t.input)},move:function(e,t){he.processCommand(e,e.state.vim,{type:\"motion\",motion:\"moveToLineOrEdgeOfDocument\",motionArgs:{forward:!1,explicitRepeat:!0,linewise:!0},repeatOverride:t.line+1})},set:function(e,t){var n=t.args,r=t.setCfg||{};if(!n||n.length<1)e&&rt(e,\"Invalid mapping: \"+t.input);else{var o=n[0].split(\"=\"),i=o[0],a=o[1],s=!1;if(\"?\"==i.charAt(i.length-1)){if(a)throw Error(\"Trailing characters: \"+t.argString);i=i.substring(0,i.length-1),s=!0}void 0===a&&\"no\"==i.substring(0,2)&&(i=i.substring(2),a=!1);var c=q[i]&&\"boolean\"==q[i].type;if(c&&void 0==a&&(a=!0),!c&&void 0===a||s){var l=X(i,e,r);l instanceof Error?rt(e,l.message):rt(e,!0===l||!1===l?\" \"+(l?\"\":\"no\")+i:\"  \"+i+\"=\"+l)}else{var u=G(i,a,e,r);u instanceof Error&&rt(e,u.message)}}},setlocal:function(e,t){t.setCfg={scope:\"local\"},this.set(e,t)},setglobal:function(e,t){t.setCfg={scope:\"global\"},this.set(e,t)},registers:function(e,t){var n=t.args,r=Z.registerController.registers,o=\"----------Registers----------\\n\\n\";if(n){n=n.join(\"\");for(var i=0;i<n.length;i++){if(a=n.charAt(i),Z.registerController.isValidRegister(a))o+='\"'+a+\"    \"+(r[a]||new ce).toString()+\"\\n\"}}else for(var a in r){var s=r[a].toString();s.length&&(o+='\"'+a+\"    \"+s+\"\\n\")}rt(e,o)},sort:function(e,t){var n,r,o,i,a;var s=function(){if(t.argString){var e=new m.StringStream(t.argString);if(e.eat(\"!\")&&(n=!0),e.eol())return;if(!e.eatSpace())return\"Invalid arguments\";var s=e.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);if(!s&&!e.eol())return\"Invalid arguments\";if(s[1]){r=-1!=s[1].indexOf(\"i\"),o=-1!=s[1].indexOf(\"u\");var c=-1!=s[1].indexOf(\"d\")||-1!=s[1].indexOf(\"n\")&&1,l=-1!=s[1].indexOf(\"x\")&&1,u=-1!=s[1].indexOf(\"o\")&&1;if(c+l+u>1)return\"Invalid arguments\";i=(c?\"decimal\":l&&\"hex\")||u&&\"octal\"}s[2]&&(a=new RegExp(s[2].substr(1,s[2].length-2),r?\"i\":\"\"))}}();if(s)rt(e,s+\": \"+t.argString);else{var c=t.line||e.firstLine(),l=t.lineEnd||t.line||e.lastLine();if(c!=l){var u=new y(c,0),h=new y(l,Le(e,l)),p=e.getRange(u,h).split(\"\\n\"),d=a||(\"decimal\"==i?/(-?)([\\d]+)/:\"hex\"==i?/(-?)(?:0x)?([0-9a-f]+)/i:\"octal\"==i?/([0-7]+)/:null),f=\"decimal\"==i?10:\"hex\"==i?16:\"octal\"==i?8:null,g=[],v=[];if(i||a)for(var C=0;C<p.length;C++){var k=a?p[C].match(a):null;k&&\"\"!=k[0]?g.push(k):!a&&d.exec(p[C])?g.push(p[C]):v.push(p[C])}else v=p;if(g.sort(a?function(e,t){var o;return n&&(o=e,e=t,t=o),r&&(e[0]=e[0].toLowerCase(),t[0]=t[0].toLowerCase()),e[0]<t[0]?-1:1}:S),a)for(C=0;C<g.length;C++)g[C]=g[C].input;else i||v.sort(S);if(p=n?g.concat(v):v.concat(g),o){var w,x=p;p=[];for(C=0;C<x.length;C++)x[C]!=w&&p.push(x[C]),w=x[C]}e.replaceRange(p.join(\"\\n\"),u,h)}}function S(e,t){var o;n&&(o=e,e=t,t=o);r&&(e=e.toLowerCase(),t=t.toLowerCase());var a=i&&d.exec(e),s=i&&d.exec(t);return a?(a=parseInt((a[1]+a[2]).toLowerCase(),f))-(s=parseInt((s[1]+s[2]).toLowerCase(),f)):e<t?-1:1}},vglobal:function(e,t){this.global(e,t)},global:function(e,t){var n=t.argString;if(n){var r,o=\"v\"===t.commandName[0],i=void 0!==t.line?t.line:e.firstLine(),a=t.lineEnd||t.line||e.lastLine(),s=function(e){return Xe(e,\"/\")}(n),c=n;if(s.length&&(c=s[0],r=s.slice(1,s.length).join(\"/\")),c)try{it(e,c,!0,!0)}catch(f){return void rt(e,\"Invalid regex: \"+c)}for(var l=Ge(e).getQuery(),u=[],h=i;h<=a;h++){var p=e.getLineHandle(h);l.test(p.text)!==o&&u.push(r?p:p.text)}if(r){var d=0;!function t(){if(d<u.length){var n=u[d++],o=e.getLineNumber(n);if(null==o)return void t();var i=o+1+r;gt.processCommand(e,i,{callback:t})}}()}else rt(e,u.join(\"\\n\"))}else rt(e,\"Regular Expression missing from global\")},substitute:function(e,t){if(!e.getSearchCursor)throw new Error(\"Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.\");var n,r,o,i,a=t.argString,s=a?Xe(a,a[0]):[],c=\"\",l=!1,u=!1;if(s.length)n=s[0],X(\"pcre\")&&\"\"!==n&&(n=new RegExp(n).source),void 0!==(c=s[1])&&(c=X(\"pcre\")?function(e){for(var t=new m.StringStream(e),n=[];!t.eol();){for(;t.peek()&&\"\\\\\"!=t.peek();)n.push(t.next());var r=!1;for(var o in et)if(t.match(o,!0)){r=!0,n.push(et[o]);break}r||n.push(t.next())}return n.join(\"\")}(c.replace(/([^\\\\])&/g,\"$1$$&\")):function(e){for(var t,n=!1,r=[],o=-1;o<e.length;o++){var i=e.charAt(o)||\"\",a=e.charAt(o+1)||\"\";Ye[i+a]?(r.push(Ye[i+a]),o++):n?(r.push(i),n=!1):\"\\\\\"===i?(n=!0,t=a,B.test(t)||\"$\"===a?r.push(\"$\"):\"/\"!==a&&\"\\\\\"!==a&&r.push(\"\\\\\")):(\"$\"===i&&r.push(\"$\"),r.push(i),\"/\"===a&&r.push(\"\\\\\"))}return r.join(\"\")}(c),Z.lastSubstituteReplacePart=c),r=s[2]?s[2].split(\" \"):[];else if(a&&a.length)return void rt(e,\"Substitutions should be of the form :s/pattern/replace/\");if(r&&(o=r[0],i=parseInt(r[1]),o&&(-1!=o.indexOf(\"c\")&&(l=!0),-1!=o.indexOf(\"g\")&&(u=!0),n=X(\"pcre\")?n+\"/\"+o:n.replace(/\\//g,\"\\\\/\")+\"/\"+o)),n)try{it(e,n,!0,!0)}catch(v){return void rt(e,\"Invalid regex: \"+n)}if(void 0!==(c=c||Z.lastSubstituteReplacePart)){var h=Ge(e).getQuery(),p=void 0!==t.line?t.line:e.getCursor().line,d=t.lineEnd||p;p==e.firstLine()&&d==e.lastLine()&&(d=1/0),i&&(d=(p=d)+i-1);var f=ge(e,new y(p,0)),g=e.getSearchCursor(h,f);!function(e,t,n,r,o,i,a,s,c){e.state.vim.exMode=!0;var l,u,h,p=!1;function d(){e.operation((function(){for(;!p;)f(),v();y()}))}function f(){var t=e.getRange(i.from(),i.to()).replace(a,s),n=i.to().line;i.replace(t),u=i.to().line,o+=u-n,h=u<n}function g(){var e=l&&we(i.to()),t=i.findNext();return t&&!t[0]&&e&&xe(i.from(),e)&&(t=i.findNext()),t}function v(){for(;g()&&ut(i.from(),r,o);)if(n||i.from().line!=u||h)return e.scrollIntoView(i.from(),30),e.setSelection(i.from(),i.to()),l=i.from(),void(p=!1);p=!0}function y(t){if(t&&t(),e.focus(),l){e.setCursor(l);var n=e.state.vim;n.exMode=!1,n.lastHPos=n.lastHSPos=l.ch}c&&c()}function C(t,n,r){switch(m.e_stop(t),m.keyName(t)){case\"Y\":f(),v();break;case\"N\":v();break;case\"A\":var o=c;c=void 0,e.operation(d),c=o;break;case\"L\":f();case\"Q\":case\"Esc\":case\"Ctrl-C\":case\"Ctrl-[\":y(r)}return p&&y(r),!0}if(v(),p)return void rt(e,\"No matches for \"+a.source);if(!t)return d(),void(c&&c());ot(e,{prefix:nt(\"span\",\"replace with \",nt(\"strong\",s),\" (y/n/a/q/l)\"),onKeyDown:C})}(e,l,u,p,d,g,h,c,t.callback)}else rt(e,\"No previous substitute regular expression\")},redo:m.commands.redo,undo:m.commands.undo,write:function(e){m.commands.save?m.commands.save(e):e.save&&e.save()},nohlsearch:function(e){lt(e)},yank:function(e){var t=we(e.getCursor()).line,n=e.getLine(t);Z.registerController.pushText(\"0\",\"yank\",n,!0,!0)},delmarks:function(e,t){if(t.argString&&Oe(t.argString))for(var n=e.state.vim,r=new m.StringStream(Oe(t.argString));!r.eol();){r.eatSpace();var o=r.pos;if(!r.match(/[a-zA-Z]/,!1))return void rt(e,\"Invalid argument: \"+t.argString.substring(o));var i=r.next();if(r.match(\"-\",!0)){if(!r.match(/[a-zA-Z]/,!1))return void rt(e,\"Invalid argument: \"+t.argString.substring(o));var a=i,s=r.next();if(!(j(a)&&j(s)||W(a)&&W(s)))return void rt(e,\"Invalid argument: \"+a+\"-\");var c=a.charCodeAt(0),l=s.charCodeAt(0);if(c>=l)return void rt(e,\"Invalid argument: \"+t.argString.substring(o));for(var u=0;u<=l-c;u++){var h=String.fromCharCode(c+u);delete n.marks[h]}}else delete n.marks[i]}else rt(e,\"Argument required\")}},gt=new ft;function vt(e){var t=e.state.vim,n=Z.macroModeState,r=Z.registerController.getRegister(\".\"),o=n.isPlaying,i=n.lastInsertModeChanges;o||(e.off(\"change\",kt),m.off(e.getInputField(),\"keydown\",Mt)),!o&&t.insertModeRepeat>1&&(At(e,t,t.insertModeRepeat-1,!0),t.lastEditInputState.repeatOverride=t.insertModeRepeat),delete t.insertModeRepeat,t.insertMode=!1,e.setCursor(e.getCursor().line,e.getCursor().ch-1),e.setOption(\"keyMap\",\"vim\"),e.setOption(\"disableInput\",!0),e.toggleOverwrite(!1),r.setText(i.changes.join(\"\")),m.signal(e,\"vim-mode-change\",{mode:\"normal\"}),n.isRecording&&function(e){if(e.isPlaying)return;var t=e.latestRegister,n=Z.registerController.getRegister(t);n&&n.pushInsertModeChanges&&n.pushInsertModeChanges(e.lastInsertModeChanges)}(n)}function yt(e){w.unshift(e)}function Ct(e,t,n,r){var o=Z.registerController.getRegister(r);if(\":\"==r)return o.keyBuffer[0]&&gt.processCommand(e,o.keyBuffer[0]),void(n.isPlaying=!1);var i=o.keyBuffer,a=0;n.isPlaying=!0,n.replaySearchQueries=o.searchQueries.slice(0);for(var s=0;s<i.length;s++)for(var c,l,u=i[s];u;)if(l=(c=/<\\w+-.+?>|<\\w+>|./.exec(u))[0],u=u.substring(c.index+l.length),ie.handleKey(e,l,\"macro\"),t.insertMode){var h=o.insertModeChanges[a++].changes;Z.macroModeState.lastInsertModeChanges.changes=h,bt(e,h,1),vt(e)}n.isPlaying=!1}function kt(e,t){var n=Z.macroModeState,r=n.lastInsertModeChanges;if(!n.isPlaying)for(;t;){if(r.expectCursorActivityForChange=!0,r.ignoreCount>1)r.ignoreCount--;else if(\"+input\"==t.origin||\"paste\"==t.origin||void 0===t.origin){var o=e.listSelections().length;o>1&&(r.ignoreCount=o);var i=t.text.join(\"\\n\");r.maybeReset&&(r.changes=[],r.maybeReset=!1),i&&(e.state.overwrite&&!/\\n/.test(i)?r.changes.push([i]):r.changes.push(i))}t=t.next}}function wt(e){var t=e.state.vim;if(t.insertMode){var n=Z.macroModeState;if(n.isPlaying)return;var r=n.lastInsertModeChanges;r.expectCursorActivityForChange?r.expectCursorActivityForChange=!1:r.maybeReset=!0}else e.curOp.isVimOp||xt(e,t)}function xt(e,t,n){var r=e.getCursor(\"anchor\"),o=e.getCursor(\"head\");if(t.visualMode&&!e.somethingSelected()?Pe(e,!1):t.visualMode||t.insertMode||!e.somethingSelected()||(t.visualMode=!0,t.visualLine=!1,m.signal(e,\"vim-mode-change\",{mode:\"visual\"})),t.visualMode){var i=Se(o,r)?0:-1,a=Se(o,r)?-1:0;o=ye(o,0,i),r=ye(r,0,a),t.sel={anchor:r,head:o},Ue(e,t,\"<\",Me(o,r)),Ue(e,t,\">\",Ae(o,r))}else t.insertMode||n||(t.lastHPos=e.getCursor().ch)}function St(e){this.keyName=e}function Mt(e){var t=Z.macroModeState.lastInsertModeChanges,n=m.keyName(e);n&&(-1==n.indexOf(\"Delete\")&&-1==n.indexOf(\"Backspace\")||m.lookupKey(n,\"vim-insert\",(function(){return t.maybeReset&&(t.changes=[],t.maybeReset=!1),t.changes.push(new St(n)),!0})))}function At(e,t,n,r){var o=Z.macroModeState;o.isPlaying=!0;var i=!!t.lastEditActionCommand,a=t.inputState;function s(){i?he.processAction(e,t,t.lastEditActionCommand):he.evalInput(e,t)}function c(n){if(o.lastInsertModeChanges.changes.length>0){n=t.lastEditActionCommand?n:1;var r=o.lastInsertModeChanges;bt(e,r.changes,n)}}if(t.inputState=t.lastEditInputState,i&&t.lastEditActionCommand.interlaceInsertRepeat)for(var l=0;l<n;l++)s(),c(1);else r||s(),c(n);t.inputState=a,t.insertMode&&!r&&vt(e),o.isPlaying=!1}function bt(e,t,n){function r(t){return\"string\"==typeof t?m.commands[t](e):t(e),!0}var o=e.getCursor(\"head\"),i=Z.macroModeState.lastInsertModeChanges.visualBlock;i&&(Re(e,o,i+1),n=e.listSelections().length,e.setCursor(o));for(var a=0;a<n;a++){i&&e.setCursor(ye(o,a,0));for(var s=0;s<t.length;s++){var c=t[s];if(c instanceof St)m.lookupKey(c.keyName,\"vim-insert\",r);else if(\"string\"==typeof c)e.replaceSelection(c);else{var l=e.getCursor(),u=ye(l,0,c[0].length);e.replaceRange(c[0],l,u),e.setCursor(u)}}}i&&e.setCursor(ye(o,0,1))}m.keyMap.vim={attach:L,detach:b,call:O},Q(\"insertModeEscKeysTimeout\",200,\"number\"),m.keyMap[\"vim-insert\"]={fallthrough:[\"default\"],attach:L,detach:b,call:O},m.keyMap[\"vim-replace\"]={Backspace:\"goCharLeft\",fallthrough:[\"vim-insert\"],attach:L,detach:b,call:O},oe(),m.Vim=ie;var Lt={return:\"CR\",backspace:\"BS\",delete:\"Del\",esc:\"Esc\",left:\"Left\",right:\"Right\",up:\"Up\",down:\"Down\",space:\"Space\",insert:\"Ins\",home:\"Home\",end:\"End\",pageup:\"PageUp\",pagedown:\"PageDown\",enter:\"CR\"};var Ot=ie.handleKey.bind(ie);function Tt(e){var t=new e.constructor;return Object.keys(e).forEach((function(n){var r=e[n];Array.isArray(r)?r=r.slice():r&&\"object\"==typeof r&&r.constructor!=Object&&(r=Tt(r)),t[n]=r})),e.sel&&(t.sel={head:e.sel.head&&we(e.sel.head),anchor:e.sel.anchor&&we(e.sel.anchor)}),t}function Et(e,t,n){var r=!1,o=ie.maybeInitVimState_(e),i=o.visualBlock||o.wasInVisualBlock,a=e.ace.inMultiSelectMode;if(o.wasInVisualBlock&&!a?o.wasInVisualBlock=!1:a&&o.visualBlock&&(o.wasInVisualBlock=!0),\"<Esc>\"!=t||o.insertMode||o.visualMode||!a)if(i||!a||e.ace.inVirtualSelectionMode)r=ie.handleKey(e,t,n);else{var s=Tt(o);e.operation((function(){e.ace.forEachSelection((function(){var o=e.ace.selection;e.state.vim.lastHPos=null==o.$desiredColumn?o.lead.column:o.$desiredColumn;var i=e.getCursor(\"head\"),a=e.getCursor(\"anchor\"),c=Se(i,a)?0:-1,l=Se(i,a)?-1:0;i=ye(i,0,c),a=ye(a,0,l),e.state.vim.sel.head=i,e.state.vim.sel.anchor=a,r=Ot(e,t,n),o.$desiredColumn=-1==e.state.vim.lastHPos?null:e.state.vim.lastHPos,e.virtualSelectionMode()&&(e.state.vim=Tt(s))})),e.curOp.cursorActivity&&!r&&(e.curOp.cursorActivity=!1)}),!0)}else e.ace.exitMultiSelectMode();return!r||o.visualMode||o.insert||o.visualMode==e.somethingSelected()||xt(e,o,!0),r}ie.handleKey=function(e,t,n){return e.operation((function(){return Ot(e,t,n)}),!0)},t.CodeMirror=m;var Rt=ie.maybeInitVimState_;function Bt(e,t){t.off(\"beforeEndOperation\",Bt);var n=t.state.cm.vimCmd;n&&t.execCommand(n.exec?n:n.name,n.args),t.curOp=t.prevOp}t.handler={$id:\"ace/keyboard/vim\",drawCursor:function(e,t,n,o,a){var s=this.state.vim||{},c=n.characterWidth,l=n.lineHeight,u=t.top,h=t.left;s.insertMode||!(o.cursor?r.comparePoints(o.cursor,o.start)<=0:a.selection.isBackwards()||a.selection.isEmpty())&&h>c&&(h-=c);!s.insertMode&&s.status&&(u+=l/=2),i.translate(e,h,u),i.setStyle(e.style,\"width\",c+\"px\"),i.setStyle(e.style,\"height\",l+\"px\")},$getDirectionForHighlight:function(e){var t=e.state.cm;if(!Rt(t).insertMode)return e.session.selection.isBackwards()||e.session.selection.isEmpty()},handleKeyboard:function(e,t,n,r,o){var i=e.editor,a=i.state.cm,s=Rt(a);if(-1!=r){if(s.insertMode||(-1==t?(n.charCodeAt(0)>255&&e.inputKey&&(n=e.inputKey)&&4==e.inputHash&&(n=n.toUpperCase()),e.inputChar=n):4==t||0==t?e.inputKey==n&&e.inputHash==t&&e.inputChar?(n=e.inputChar,t=-1):(e.inputChar=null,e.inputKey=n,e.inputHash=t):e.inputChar=e.inputKey=null),a.state.overwrite&&s.insertMode&&\"backspace\"==n&&0==t)return{command:\"gotoleft\"};if(\"c\"==n&&1==t&&!u.isMac&&i.getCopyText())return i.once(\"copy\",(function(){s.insertMode?i.selection.clearSelection():a.operation((function(){Pe(a)}))})),{command:\"null\",passEvent:!0};if(\"esc\"==n&&!s.insertMode&&!s.visualMode&&!a.ace.inMultiSelectMode){var c=Ge(a).getOverlay();c&&a.removeOverlay(c)}if(-1==t||1&t||0===t&&n.length>1){var l=s.insertMode,h=function(e,t,n){t.length>1&&\"n\"==t[0]&&(t=t.replace(\"numpad\",\"\")),t=Lt[t]||t;var r=\"\";return n.ctrlKey&&(r+=\"C-\"),n.altKey&&(r+=\"A-\"),(r||t.length>1)&&n.shiftKey&&(r+=\"S-\"),(r+=t).length>1&&(r=\"<\"+r+\">\"),r}(0,n,o||{});null==s.status&&(s.status=\"\");var p=Et(a,h,\"user\");if(s=Rt(a),p&&null!=s.status?s.status+=h:null==s.status&&(s.status=\"\"),a._signal(\"changeStatus\"),!p&&(-1!=t||l))return;return{command:\"null\",passEvent:!p}}}},attach:function(e){e.state||(e.state={});var t=new m(e);function n(){var n=Rt(t).insertMode;t.ace.renderer.setStyle(\"normal-mode\",!n),e.textInput.setCommandMode(!n),e.renderer.$keepTextAreaAtCursor=n,e.renderer.$blockCursor=!n}e.state.cm=t,e.$vimModeHandler=this,m.keyMap.vim.attach(t),Rt(t).status=null,t.on(\"vim-command-done\",(function(){t.virtualSelectionMode()||(Rt(t).status=null,t.ace._signal(\"changeStatus\"),t.ace.session.markUndoGroup())})),t.on(\"changeStatus\",(function(){t.ace.renderer.updateCursor(),t.ace._signal(\"changeStatus\")})),t.on(\"vim-mode-change\",(function(){t.virtualSelectionMode()||(n(),t._signal(\"changeStatus\"))})),n(),e.renderer.$cursorLayer.drawCursor=this.drawCursor.bind(t)},detach:function(e){var t=e.state.cm;m.keyMap.vim.detach(t),t.destroy(),e.state.cm=null,e.$vimModeHandler=null,e.renderer.$cursorLayer.drawCursor=null,e.renderer.setStyle(\"normal-mode\",!1),e.textInput.setCommandMode(!1),e.renderer.$keepTextAreaAtCursor=!0},getStatusText:function(e){var t=e.state.cm,n=Rt(t);if(n.insertMode)return\"INSERT\";var r=\"\";return n.visualMode&&(r+=\"VISUAL\",n.visualLine&&(r+=\" LINE\"),n.visualBlock&&(r+=\" BLOCK\")),n.status&&(r+=(r?\" \":\"\")+n.status),r}},ie.defineOption({name:\"wrap\",set:function(e,t){t&&t.ace.setOption(\"wrap\",e)},type:\"boolean\"},!1),ie.defineEx(\"write\",\"w\",(function(){console.log(\":write is not implemented\")})),w.push({keys:\"zc\",type:\"action\",action:\"fold\",actionArgs:{open:!1}},{keys:\"zC\",type:\"action\",action:\"fold\",actionArgs:{open:!1,all:!0}},{keys:\"zo\",type:\"action\",action:\"fold\",actionArgs:{open:!0}},{keys:\"zO\",type:\"action\",action:\"fold\",actionArgs:{open:!0,all:!0}},{keys:\"za\",type:\"action\",action:\"fold\",actionArgs:{toggle:!0}},{keys:\"zA\",type:\"action\",action:\"fold\",actionArgs:{toggle:!0,all:!0}},{keys:\"zf\",type:\"action\",action:\"fold\",actionArgs:{open:!0,all:!0}},{keys:\"zd\",type:\"action\",action:\"fold\",actionArgs:{open:!0,all:!0}},{keys:\"<C-A-k>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorAbove\"}},{keys:\"<C-A-j>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorBelow\"}},{keys:\"<C-A-S-k>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorAboveSkipCurrent\"}},{keys:\"<C-A-S-j>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorBelowSkipCurrent\"}},{keys:\"<C-A-h>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectMoreBefore\"}},{keys:\"<C-A-l>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectMoreAfter\"}},{keys:\"<C-A-S-h>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectNextBefore\"}},{keys:\"<C-A-S-l>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectNextAfter\"}}),w.push({keys:\"gq\",type:\"operator\",operator:\"hardWrap\"}),ie.defineOperator(\"hardWrap\",(function(e,t,n,r,o){var i=n[0].anchor.line,a=n[0].head.line;return t.linewise&&a--,f(e.ace,{startRow:i,endRow:a}),y(a,0)})),Q(\"textwidth\",void 0,\"number\",[\"tw\"],(function(e,t){if(void 0!==t){if(void 0===e)return t.ace.getOption(\"printMarginColumn\");var n=Math.round(e);n>1&&t.ace.setOption(\"printMarginColumn\",n)}})),me.aceCommand=function(e,t,n){e.vimCmd=t,e.ace.inVirtualSelectionMode?e.ace.on(\"beforeEndOperation\",Bt):Bt(null,e.ace)},me.fold=function(e,t,n){e.ace.execCommand([\"toggleFoldWidget\",\"toggleFoldWidget\",\"foldOther\",\"unfoldall\"][(t.all?2:0)+(t.open?1:0)])},t.handler.defaultKeymap=w,t.handler.actions=me,t.Vim=ie})),ace.require([\"ace/keyboard/vim\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"50c2574eba3c27efdab147e2d120b613.js","input":"ace.define(\"ace/ext/hardwrap\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/editor\", \"ace/config\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  function hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n      var line = session.getLine(row);\n      if (line.length > max) {\n        var space = findSpace(line, max, 5);\n        if (space) {\n          var indentation = /^\\s*/.exec(line)[0];\n          session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n        }\n        endRow++;\n      } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n        var nextLine = session.getLine(row + 1);\n        if (nextLine && /\\S/.test(nextLine)) {\n          var trimmedLine = line.replace(/\\s+$/, \"\");\n          var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n          var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n          var space = findSpace(mergedLine, max, 5);\n          if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n            var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n            session.replace(replaceRange, \" \");\n            row--;\n            endRow--;\n          } else if (trimmedLine.length < line.length) {\n            session.remove(new Range(row, trimmedLine.length, row, line.length));\n          }\n        }\n      }\n      row++;\n    }\n    function findSpace(line, max, min) {\n      if (line.length < max) return;\n      var before = line.slice(0, max);\n      var after = line.slice(max);\n      var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n      var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n      var start = 0;\n      var end = 0;\n      if (spaceBefore && !spaceBefore[2]) {\n        start = max - spaceBefore[1].length;\n        end = max;\n      }\n      if (spaceAfter && !spaceAfter[2]) {\n        if (!start) start = max;\n        end = max + spaceAfter[1].length;\n      }\n      if (start) {\n        return {\n          start: start,\n          end: end\n        };\n      }\n      if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n        return {\n          start: spaceBefore.index,\n          end: spaceBefore.index + spaceBefore[2].length\n        };\n      }\n      if (spaceAfter && spaceAfter[2]) {\n        start = max + spaceAfter[2].length;\n        return {\n          start: start,\n          end: start + spaceAfter[3].length\n        };\n      }\n    }\n  }\n  function wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n      var editor = e.editor;\n      var cursor = editor.selection.cursor;\n      if (cursor.column <= editor.renderer.$printMarginColumn) return;\n      var lastDelta = editor.session.$undoManager.$lastDelta;\n      hardWrap(editor, {\n        startRow: cursor.row,\n        endRow: cursor.row,\n        allowMerge: false\n      });\n      if (lastDelta != editor.session.$undoManager.$lastDelta) editor.session.markUndoGroup();\n    }\n  }\n  var Editor = require(\"../editor\").Editor;\n  require(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n      set: function set(val) {\n        if (val) {\n          this.commands.on(\"afterExec\", wrapAfterInput);\n        } else {\n          this.commands.off(\"afterExec\", wrapAfterInput);\n        }\n      },\n      value: false\n    }\n  });\n  exports.hardWrap = hardWrap;\n});\nace.define(\"ace/keyboard/vim\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/lib/event_emitter\", \"ace/lib/dom\", \"ace/lib/oop\", \"ace/lib/keys\", \"ace/lib/event\", \"ace/search\", \"ace/lib/useragent\", \"ace/search_highlight\", \"ace/commands/multi_select_commands\", \"ace/mode/text\", \"ace/ext/hardwrap\", \"ace/multi_select\"], function (require, exports, module) {\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n  'use strict';\n\n  function log() {\n    var d = \"\";\n    function format(p) {\n      if (typeof p != \"object\") return p + \"\";\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n      if (Array.isArray(p)) return \"[\" + p.map(function (x) {\n        return format(x);\n      }) + \"]\";\n      return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n    console.log(d);\n  }\n  var Range = require(\"../range\").Range;\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n  var domLib = require(\"../lib/dom\");\n  var oop = require(\"../lib/oop\");\n  var KEYS = require(\"../lib/keys\");\n  var event = require(\"../lib/event\");\n  var Search = require(\"../search\").Search;\n  var useragent = require(\"../lib/useragent\");\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n  var hardWrap = require(\"../ext/hardwrap\").hardWrap;\n  require(\"../multi_select\");\n  var CodeMirror = function CodeMirror(ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n  CodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  };\n  CodeMirror.defineOption = function (name, val, setter) {};\n  CodeMirror.commands = {\n    redo: function redo(cm) {\n      cm.ace.redo();\n    },\n    undo: function undo(cm) {\n      cm.ace.undo();\n    },\n    newlineAndIndent: function newlineAndIndent(cm) {\n      cm.ace.insert(\"\\n\");\n    },\n    goLineLeft: function goLineLeft(cm) {\n      cm.ace.selection.moveCursorLineStart();\n    },\n    goLineRight: function goLineRight(cm) {\n      cm.ace.selection.moveCursorLineEnd();\n    }\n  };\n  CodeMirror.keyMap = {};\n  CodeMirror.addClass = CodeMirror.rmClass = function () {};\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n  CodeMirror.keyName = function (e) {\n    var key = KEYS[e.keyCode] || e.key || \"\";\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n  CodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\") map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n  CodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n  };\n  CodeMirror.findEnclosingTag = function (cm, head) {};\n  CodeMirror.signal = function (o, name, e) {\n    return o._signal(name, e);\n  };\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n  CodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n  (function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n      this.ace.off('change', this.onChange);\n      this.ace.off('changeSelection', this.onSelectionChange);\n      this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n      this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n      return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n      var change = {\n        text: delta.action[0] == 'i' ? delta.lines : []\n      };\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.changeHandlers) curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n      this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n      this.curOp.cursorActivity = true;\n      if (this.ace.inMultiSelectMode) {\n        this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n      }\n    };\n    this.operation = function (fn, force) {\n      if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n        return fn();\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      if (!this.ace.curOp) {\n        var prevOp = this.ace.prevOp;\n        this.ace.startOperation({\n          command: {\n            name: \"vim\",\n            scrollIntoView: \"cursor\"\n          }\n        });\n      }\n      var curOp = this.curOp = this.curOp || {};\n      this.curOp.force = force;\n      var result = fn();\n      if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n        if (this.state.dialog) this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n        this.ace.endOperation();\n        if (!curOp.cursorActivity && !curOp.lastChange && prevOp) this.ace.prevOp = prevOp;\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      return result;\n    };\n    this.onBeforeEndOperation = function () {\n      var op = this.curOp;\n      if (op) {\n        if (op.change) {\n          this.signal(\"change\", op.change, op);\n        }\n        if (op && op.cursorActivity) {\n          this.signal(\"cursorActivity\", null, op);\n        }\n        this.curOp = null;\n      }\n    };\n    this.signal = function (eventName, e, handlers) {\n      var listeners = handlers ? handlers[eventName + \"Handlers\"] : (this._eventRegistry || {})[eventName];\n      if (!listeners) return;\n      listeners = listeners.slice();\n      for (var i = 0; i < listeners.length; i++) listeners[i](this, e);\n    };\n    this.firstLine = function () {\n      return 0;\n    };\n    this.lastLine = function () {\n      return this.ace.session.getLength() - 1;\n    };\n    this.lineCount = function () {\n      return this.ace.session.getLength();\n    };\n    this.setCursor = function (line, ch) {\n      if (typeof line === 'object') {\n        ch = line.ch;\n        line = line.line;\n      }\n      var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n      if (!this.ace.inVirtualSelectionMode) this.ace.exitMultiSelectMode();\n      this.ace.session.unfold({\n        row: line,\n        column: ch\n      });\n      this.ace.selection.moveTo(line, ch);\n      if (shouldScroll) {\n        this.ace.renderer.scrollCursorIntoView();\n        this.ace.endOperation();\n      }\n    };\n    this.getCursor = function (p) {\n      var sel = this.ace.selection;\n      var pos = p == 'anchor' ? sel.isEmpty() ? sel.lead : sel.anchor : p == 'head' || !p ? sel.lead : sel.getRange()[p];\n      return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n      var ranges = this.ace.multiSelect.rangeList.ranges;\n      if (!ranges.length || this.ace.inVirtualSelectionMode) return [{\n        anchor: this.getCursor('anchor'),\n        head: this.getCursor('head')\n      }];\n      return ranges.map(function (r) {\n        return {\n          anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n          head: this.clipPos(toCmPos(r.cursor))\n        };\n      }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n      var sel = this.ace.multiSelect;\n      var ranges = p.map(function (x) {\n        var anchor = toAcePos(x.anchor);\n        var head = toAcePos(x.head);\n        var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);\n        r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n        return r;\n      });\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.selection.fromOrientedRange(ranges[0]);\n        return;\n      }\n      if (!primIndex) {\n        ranges = ranges.reverse();\n      } else if (ranges[primIndex]) {\n        ranges.push(ranges.splice(primIndex, 1)[0]);\n      }\n      sel.toSingleRange(ranges[0].clone());\n      var session = this.ace.session;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n        sel.addRange(range);\n      }\n    };\n    this.setSelection = function (a, h, options) {\n      var sel = this.ace.selection;\n      sel.moveTo(a.line, a.ch);\n      sel.selectTo(h.line, h.ch);\n      if (options && options.origin == '*mouse') {\n        this.onBeforeEndOperation();\n      }\n    };\n    this.somethingSelected = function (p) {\n      return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n      var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n      return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n      this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n      return {\n        clear: function clear() {},\n        find: function find() {}\n      };\n    };\n    this.$updateMarkers = function (delta) {\n      var isInsert = delta.action == \"insert\";\n      var start = delta.start;\n      var end = delta.end;\n      var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n      var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n      if (isInsert) end = start;\n      for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = Range.comparePoints(point, start);\n        if (cmp < 0) {\n          continue; // delta starts after the range\n        }\n\n        if (cmp === 0) {\n          if (isInsert) {\n            if (point.bias == 1) {\n              cmp = 1;\n            } else {\n              point.bias = -1;\n              continue;\n            }\n          }\n        }\n        var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n        if (cmp2 > 0) {\n          point.row += rowShift;\n          point.column += point.row == end.row ? colShift : 0;\n          continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n          point.row = start.row;\n          point.column = start.column;\n          if (cmp2 === 0) point.bias = 1;\n        }\n      }\n    };\n    var Marker = function Marker(cm, id, row, column) {\n      this.cm = cm;\n      this.id = id;\n      this.row = row;\n      this.column = column;\n      cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () {\n      delete this.cm.marks[this.id];\n    };\n    Marker.prototype.find = function () {\n      return toCmPos(this);\n    };\n    this.setBookmark = function (cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n      if (!options || !options.insertLeft) bm.$insertRight = true;\n      this.marks[bm.id] = bm;\n      return bm;\n    };\n    this.moveH = function (increment, unit) {\n      if (unit == 'char') {\n        var sel = this.ace.selection;\n        sel.clearSelection();\n        sel.moveCursorBy(0, increment);\n      }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n      if (unit == 'page') {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        amount = amount * Math.floor(config.height / config.lineHeight);\n        unit = 'line';\n      }\n      if (unit == 'line') {\n        var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n        if (goalColumn != null) screenPos.column = goalColumn;\n        screenPos.row += amount;\n        screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n        var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n        return toCmPos(pos);\n      } else {\n        debugger;\n      }\n    };\n    this.charCoords = function (pos, mode) {\n      if (mode == 'div' || !mode) {\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        return {\n          left: sc.column,\n          top: sc.row\n        };\n      }\n      if (mode == 'local') {\n        var renderer = this.ace.renderer;\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        var lh = renderer.layerConfig.lineHeight;\n        var cw = renderer.layerConfig.characterWidth;\n        var top = lh * sc.row;\n        return {\n          left: sc.column * cw,\n          top: top,\n          bottom: top + lh\n        };\n      }\n    };\n    this.coordsChar = function (pos, mode) {\n      var renderer = this.ace.renderer;\n      if (mode == 'local') {\n        var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n        var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n        var ch = renderer.session.screenToDocumentPosition(row, col);\n        return toCmPos(ch);\n      } else if (mode == 'div') {\n        throw \"not implemented\";\n      }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n      var caseSensitive = false;\n      var isRegexp = false;\n      if (query instanceof RegExp && !query.global) {\n        caseSensitive = !query.ignoreCase;\n        query = query.source;\n        isRegexp = true;\n      }\n      if (query == \"\\\\n\") {\n        query = \"\\n\";\n        isRegexp = false;\n      }\n      var search = new Search();\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var acePos = {\n        row: pos.line,\n        column: pos.ch\n      };\n      var cm = this;\n      var last = null;\n      return {\n        findNext: function findNext() {\n          return this.find(false);\n        },\n        findPrevious: function findPrevious() {\n          return this.find(true);\n        },\n        find: function find(back) {\n          search.setOptions({\n            needle: query,\n            caseSensitive: caseSensitive,\n            wrap: false,\n            backwards: back,\n            regExp: isRegexp,\n            start: last || acePos\n          });\n          var range = search.find(cm.ace.session);\n          last = range;\n          return last && [!last.isEmpty()];\n        },\n        from: function from() {\n          return last && toCmPos(last.start);\n        },\n        to: function to() {\n          return last && toCmPos(last.end);\n        },\n        replace: function replace(text) {\n          if (last) {\n            last.end = cm.ace.session.doc.replace(last, text);\n          }\n        }\n      };\n    };\n    this.scrollTo = function (x, y) {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      var maxHeight = config.maxHeight;\n      maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n      if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n      if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () {\n      return 0;\n    };\n    this.scrollIntoView = function (pos, margin) {\n      if (pos) {\n        var renderer = this.ace.renderer;\n        var viewMargin = {\n          \"top\": 0,\n          \"bottom\": margin\n        };\n        renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);\n      }\n    };\n    this.getLine = function (row) {\n      return this.ace.session.getLine(row);\n    };\n    this.getRange = function (s, e) {\n      return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n      if (!e) e = s;\n      var range = new Range(s.line, s.ch, e.line, e.ch);\n      this.ace.session.$clipRangeToDocument(range);\n      return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection = this.replaceSelections = function (p) {\n      var sel = this.ace.selection;\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.session.replace(sel.getRange(), p[0] || \"\");\n        return;\n      }\n      sel.inVirtualSelectionMode = true;\n      var ranges = sel.rangeList.ranges;\n      if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n      for (var i = ranges.length; i--;) this.ace.session.replace(ranges[i], p[i] || \"\");\n      sel.inVirtualSelectionMode = false;\n    };\n    this.getSelection = function () {\n      return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n      return this.listSelections().map(function (x) {\n        return this.getRange(x.anchor, x.head);\n      }, this);\n    };\n    this.getInputField = function () {\n      return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n      return this.ace.container;\n    };\n    var optMap = {\n      indentWithTabs: \"useSoftTabs\",\n      indentUnit: \"tabSize\",\n      tabSize: \"tabSize\",\n      firstLineNumber: \"firstLineNumber\",\n      readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n      this.state[name] = val;\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          val = !val;\n          break;\n        case 'keyMap':\n          this.state.$keyMap = val;\n          return;\n          break;\n        default:\n          name = optMap[name];\n      }\n      if (name) this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n      var val;\n      var aceOpt = optMap[name];\n      if (aceOpt) val = this.ace.getOption(aceOpt);\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          return !val;\n        case 'keyMap':\n          return this.state.$keyMap || 'vim';\n      }\n      return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n      this.state.overwrite = on;\n      return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n      if (!this.$searchHighlight || !this.$searchHighlight.session) {\n        var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n        var marker = this.ace.session.addDynamicMarker(highlight);\n        highlight.id = marker.id;\n        highlight.session = this.ace.session;\n        highlight.destroy = function (o) {\n          highlight.session.off(\"change\", highlight.updateOnChange);\n          highlight.session.off(\"changeEditor\", highlight.destroy);\n          highlight.session.removeMarker(highlight.id);\n          highlight.session = null;\n        };\n        highlight.updateOnChange = function (delta) {\n          var row = delta.start.row;\n          if (row == delta.end.row) highlight.cache[row] = undefined;else highlight.cache.splice(row, highlight.cache.length);\n        };\n        highlight.session.on(\"changeEditor\", highlight.destroy);\n        highlight.session.on(\"change\", highlight.updateOnChange);\n      }\n      var re = new RegExp(o.query.source, \"gmi\");\n      this.$searchHighlight = o.highlight = highlight;\n      this.$searchHighlight.setRegexp(re);\n      this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n      if (this.$searchHighlight && this.$searchHighlight.session) {\n        this.$searchHighlight.destroy();\n      }\n    };\n    this.getScrollInfo = function () {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      return {\n        left: renderer.scrollLeft,\n        top: renderer.scrollTop,\n        height: config.maxHeight,\n        width: config.width,\n        clientHeight: config.height,\n        clientWidth: config.width\n      };\n    };\n    this.getValue = function () {\n      return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n      return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n      var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n      return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n      var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n      return {\n        to: m && toCmPos(m)\n      };\n    };\n    this.findMatchingTag = function (pos) {\n      var m = this.ace.session.getMatchingTags(toAcePos(pos));\n      if (!m) return;\n      return {\n        open: {\n          from: toCmPos(m.openTag.start),\n          to: toCmPos(m.openTag.end)\n        },\n        close: {\n          from: toCmPos(m.closeTag.start),\n          to: toCmPos(m.closeTag.end)\n        }\n      };\n    };\n    this.indentLine = function (line, method) {\n      if (method === true) this.ace.session.indentRows(line, line, \"\\t\");else if (method === false) this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n      return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n      return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n      return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n      return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n      return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n      var re = options.bracketRegex.source;\n      var tokenRe = /paren|text|operator|tag/;\n      if (dir == 1) {\n        var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n      } else {\n        var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {\n          row: pos.line,\n          column: pos.ch + 1\n        }, tokenRe);\n      }\n      return m && {\n        pos: toCmPos(m)\n      };\n    };\n    this.refresh = function () {\n      return this.ace.resize(true);\n    };\n    this.getMode = function () {\n      return {\n        name: this.getOption(\"mode\")\n      };\n    };\n    this.execCommand = function (name) {\n      if (CodeMirror.commands.hasOwnProperty(name)) return CodeMirror.commands[name](this);\n      if (name == \"indentAuto\") return this.ace.execCommand(\"autoindent\");\n      console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n      return handle.row;\n    };\n    this.getLineHandle = function (row) {\n      return {\n        text: this.ace.session.getLine(row),\n        row: row\n      };\n    };\n  }).call(CodeMirror.prototype);\n  function toAcePos(cmPos) {\n    return {\n      row: cmPos.line,\n      column: cmPos.ch\n    };\n  }\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n  var StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n  StringStream.prototype = {\n    eol: function eol() {\n      return this.pos >= this.string.length;\n    },\n    sol: function sol() {\n      return this.pos == this.lineStart;\n    },\n    peek: function peek() {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function next() {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function eat(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function eatWhile(match) {\n      var start = this.pos;\n      while (this.eat(match)) {}\n      return this.pos > start;\n    },\n    eatSpace: function eatSpace() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function skipToEnd() {\n      this.pos = this.string.length;\n    },\n    skipTo: function skipTo(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function backUp(n) {\n      this.pos -= n;\n    },\n    column: function column() {\n      throw \"not implemented\";\n    },\n    indentation: function indentation() {\n      throw \"not implemented\";\n    },\n    match: function match(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function cased(str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function current() {\n      return this.string.slice(this.start, this.pos);\n    },\n    hideFirstChars: function hideFirstChars(n, inner) {\n      this.lineStart += n;\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    }\n  };\n  CodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n  };\n  domLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n  (function () {\n    function dialogDiv(cm, template, bottom) {\n      var wrap = cm.ace.container;\n      var dialog;\n      dialog = wrap.appendChild(document.createElement(\"div\"));\n      if (bottom) dialog.className = \"ace_dialog ace_dialog-bottom\";else dialog.className = \"ace_dialog ace_dialog-top\";\n      if (typeof template == \"string\") {\n        dialog.innerHTML = template;\n      } else {\n        // Assuming it's a detached DOM element.\n        dialog.appendChild(template);\n      }\n      return dialog;\n    }\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n      if (this.virtualSelectionMode()) return;\n      if (!options) options = {};\n      closeNotification(this, null);\n      var dialog = dialogDiv(this, template, options.bottom);\n      var closed = false,\n        me = this;\n      this.state.dialog = dialog;\n      function close(newVal) {\n        if (typeof newVal == 'string') {\n          inp.value = newVal;\n        } else {\n          if (closed) return;\n          if (newVal && newVal.type == \"blur\") {\n            if (document.activeElement === inp) return;\n          }\n          if (me.state.dialog == dialog) {\n            me.state.dialog = null;\n            me.focus();\n          }\n          closed = true;\n          dialog.remove();\n          if (options.onClose) options.onClose(dialog);\n          var cm = me;\n          if (cm.state.vim) {\n            cm.state.vim.status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n          }\n        }\n      }\n      var inp = dialog.getElementsByTagName(\"input\")[0],\n        button;\n      if (inp) {\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) inp.select();\n        }\n        if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n          options.onInput(e, inp.value, close);\n        });\n        if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n          options.onKeyUp(e, inp.value, close);\n        });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n          if (e.keyCode == 13) callback(inp.value);\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            CodeMirror.e_stop(e);\n            close();\n          }\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n        inp.focus();\n      } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function () {\n          close();\n          me.focus();\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n      return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n      if (this.virtualSelectionMode()) return;\n      closeNotification(this, close);\n      var dialog = dialogDiv(this, template, options && options.bottom);\n      var closed = false,\n        doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n      function close() {\n        if (closed) return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n      }\n      CodeMirror.on(dialog, 'click', function (e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration) doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  })();\n  var Pos = CodeMirror.Pos;\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head) return range.head;\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);\n    }\n    return range.head;\n  }\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n    return {\n      start: curStart,\n      end: curEnd\n    };\n  }\n  var defaultKeymap = [{\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n  function detachVimMap(cm, next) {\n    if (this == CodeMirror.keyMap.vim) {\n      cm.options.$customCursor = null;\n      CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n  function attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) {\n      if (cm.curOp) cm.curOp.selectionChanged = true;\n      cm.options.$customCursor = transformCursor;\n      CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  }\n  CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n  });\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n    if (this[key]) {\n      return this[key];\n    }\n    var vimKey = cmKeyToVimKey(key);\n    if (!vimKey) {\n      return false;\n    }\n    var cmd = vimApi.findKey(cm, vimKey);\n    if (typeof cmd == 'function') {\n      CodeMirror.signal(cm, 'vim-keypress', vimKey);\n    }\n    return cmd;\n  }\n  var modifiers = {\n    Shift: 'S',\n    Ctrl: 'C',\n    Alt: 'A',\n    Cmd: 'D',\n    Mod: 'A',\n    CapsLock: ''\n  };\n  var specialKeys = {\n    Enter: 'CR',\n    Backspace: 'BS',\n    Delete: 'Del',\n    Insert: 'Ins'\n  };\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n      return key.charAt(1);\n    }\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      return false;\n    } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n      return false;\n    }\n    var hasCharacter = false;\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n    if (!hasCharacter) {\n      return false;\n    }\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n    return '<' + pieces.join('-') + '>';\n  }\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n    bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n  function makeKeyRange(start, size) {\n    var keys = [];\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n    return keys;\n  }\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\n  var upperCaseChars;\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var options = {};\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n      type = 'string';\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  var createCircularJumpList = function createCircularJumpList() {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined,\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n  var createInsertModeChanges = function createInsertModeChanges(c) {\n    if (c) {\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      changes: [],\n      expectCursorActivityForChange: false\n    };\n  };\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function exitMacroRecordMode() {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function enterMacroRecordMode(cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {\n            class: 'cm-vim-message'\n          }, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {\n            bottom: true\n          });\n        }\n        this.isRecording = true;\n      }\n    }\n  };\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      cm.state.vim = {\n        inputState: new InputState(),\n        lastEditInputState: undefined,\n        lastEditActionCommand: undefined,\n        lastHPos: -1,\n        lastHSPos: -1,\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeRepeat: undefined,\n        visualMode: false,\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        options: {}\n      };\n    }\n    return cm.state.vim;\n  }\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      searchQuery: null,\n      searchIsReversed: false,\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      searchHistoryController: new HistoryController(),\n      exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function buildKeyMap() {},\n    getRegisterController: function getRegisterController() {\n      return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function getVimGlobalState_() {\n      return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function map(lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function unmap(lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function noremap(lhs, rhs, ctx) {\n      function toCtxArray(ctx) {\n        return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n      }\n      var ctxsToMap = toCtxArray(ctx);\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n        var mapping = defaultKeymap[i];\n        if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {\n          var newMapping = {};\n          for (var key in mapping) {\n            newMapping[key] = mapping[key];\n          }\n          newMapping.keys = lhs;\n          if (ctx && !newMapping.context) {\n            newMapping.context = ctx;\n          }\n          this._mapCommand(newMapping);\n          var mappedCtxs = toCtxArray(mapping.context);\n          ctxsToMap = ctxsToMap.filter(function (el) {\n            return mappedCtxs.indexOf(el) === -1;\n          });\n        }\n      }\n    },\n    mapclear: function mapclear(ctx) {\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function defineEx(name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function handleKey(cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function findKey(cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          } else {\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n      function doKeyToKey(keys) {\n        var match;\n        while (keys) {\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'mapping');\n        }\n      }\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        while (keys.length > 1 && match.type != 'full') {\n          var keys = vim.inputState.keyBuffer = keys.slice(1);\n          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          if (thisMatch.type != 'none') {\n            match = thisMatch;\n          }\n        }\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          return !keysAreChars;\n        }\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        clearInputState(cm);\n        return match.command;\n      }\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          return true;\n        } else if (match.type == 'clear') {\n          clearInputState(cm);\n          return true;\n        }\n        vim.inputState.keyBuffer = '';\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return undefined; //ace_patch\n      } else if (command === true) {\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          if ((command.operator || command.isEdit) && cm.getOption('readOnly')) return; // ace_patch\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function handleEx(cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n    return repeat;\n  };\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n  Register.prototype = {\n    setText: function setText(text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function pushText(text, linewise) {\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function pushInsertModeChanges(changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function pushSearchQuery(query) {\n      this.searchQueries.push(query);\n    },\n    clear: function clear() {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function toString() {\n      return this.keyBuffer.join('');\n    }\n  };\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n  }\n  RegisterController.prototype = {\n    pushText: function pushText(registerName, operator, text, linewise, blockwise) {\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+') {\n        navigator.clipboard.writeText(text);\n      }\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function getRegister(name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    },\n    isValidRegister: function isValidRegister(name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function shiftNumericRegisters_() {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n  HistoryController.prototype = {\n    nextMatch: function nextMatch(input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      if (i < 0) return input;\n    },\n    pushInput: function pushInput(input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function reset() {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function matchCommand(keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial'\n        };\n      }\n      var bestMatch;\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {\n          type: 'clear'\n        };\n        inputState.selectedCharacter = character;\n      }\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function processCommand(cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n        default:\n          break;\n      }\n    },\n    processMotion: function processMotion(cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function processOperator(cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function processOperatorMotion(cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function processAction(cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function processSearch(cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n      function onPromptClose(query) {\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function onPromptKeyUp(e, query, close) {\n        var keyName = CodeMirror.keyName(e),\n          up,\n          offset;\n        if (keyName == 'Up' || keyName == 'Down') {\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {}\n        if (parsedQuery) {\n          cm.scrollIntoView(_findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      function onPromptKeyDown(e, query, close) {\n        var keyName = CodeMirror.keyName(e);\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: '(JavaScript regexp)',\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);\n            isKeyword = false;\n          }\n          if (!word) {\n            return;\n          }\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    processEx: function processEx(cm, vim, command) {\n      function onPromptClose(input) {\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n      function onPromptKeyDown(e, input, close) {\n        var keyName = CodeMirror.keyName(e),\n          up,\n          offset;\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function evalInput(cm, vim) {\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          if (!operator && cm.ace.curOp != null) cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n          var jumpList = vimGlobalState.jumpList;\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          if (cm.ace.curOp) cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n        if (vim.visualMode) {\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function recordLastEdit(vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  var motions = {\n    moveToTopLine: function moveToTopLine(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function moveToMiddleLine(cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function moveToBottomLine(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function expandToLine(_cm, head, motionArgs) {\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function findNext(cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return _findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function findAndSelectNextInclusive(cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n      if (!next) {\n        return;\n      }\n      if (prevInputState.operator) {\n        return next;\n      }\n      var from = next[0];\n      var to = new Pos(next[1].line, next[1].ch - 1);\n      if (vim.visualMode) {\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n            return [anchor, from];\n          }\n        }\n      } else {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function goToMark(cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function moveToOtherHighlightedEnd(cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function jumpToMark(cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n          if (isWrongDirection) {\n            continue;\n          }\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n      if (motionArgs.linewise) {\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function moveByCharacters(_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function moveByLines(cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return _moveToEol(cm, head, motionArgs, vim, true);\n      }\n      var fold = cm.ace.session.getFoldLine(line);\n      if (fold) {\n        if (motionArgs.forward) {\n          if (line > fold.start.row) line = fold.end.row + 1;\n        } else {\n          line = fold.start.row;\n        }\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function moveByDisplayLines(cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function moveByPage(cm, head, motionArgs) {\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function moveByParagraph(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function moveBySentence(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function moveByScroll(cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function moveByWords(cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function moveTillCharacter(cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function moveToCharacter(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function moveToSymbol(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function moveToColumn(cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return _moveToColumn(cm, repeat);\n    },\n    moveToEol: function moveToEol(cm, head, motionArgs, vim) {\n      return _moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function moveToFirstNonWhiteSpaceCharacter(cm, head) {\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function moveToMatchedSymbol(cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n        var matched = cm.findMatchingBracket(new Pos(line, ch + 1), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function moveToStartOfLine(_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function moveToLineOrEdgeOfDocument(cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function moveToStartOfDisplayLine(cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function moveToEndOfDisplayLine(cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function textObjectManipulation(cm, head, motionArgs, vim) {\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter;\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp;\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W') {\n        tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);\n      } else if (character === 'w') {\n        tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n          start = {\n            line: start.line,\n            ch: start.ch + 1\n          };\n        }\n        tmp = {\n          start: start,\n          end: end\n        };\n      } else {\n        return null;\n      }\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n    repeatLastCharacterSearch: function repeatLastCharacterSearch(cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = _moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  var operators = {\n    change: function change(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n        head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange('', prevLineEnd, head);\n        } else {\n          cm.replaceRange('', anchor, head);\n        }\n        if (args.linewise) {\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n            CodeMirror.commands.newlineAndIndent(cm);\n          }\n          anchor.ch = Number.MAX_VALUE;\n        }\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    'delete': function _delete(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function indent(cm, args, ranges) {\n      var vim = cm.state.vim;\n      if (cm.indentMore) {\n        var repeat = vim.visualMode ? args.repeat : 1;\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        var repeat = vim.visualMode ? args.repeat : 1;\n        if (args.linewise) {\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function indentAuto(cm, _args, ranges) {\n      if (ranges.length > 1) {\n        // ace_patch\n        cm.setSelection(ranges[0].anchor, ranges[ranges.length - 1].head);\n      }\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function changeCase(cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function yank(cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n  var actions = {\n    jumpListWalk: function jumpListWalk(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n      cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n\n    scroll: function scroll(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function scrollToCursor(cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center':\n          y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function replayMacro(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function enterMacroRecordMode(cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function enterInsertMode(cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        cm.on('change', onChange);\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function toggleVisualMode(cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      if (!vim.visualMode) {\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function reselectLastSelection(cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function joinLines(cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function newLineAndEnterInsertMode(cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function paste(cm, actionArgs, vim) {\n      var _this = this;\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      if (actionArgs.registerName === '+') {\n        navigator.clipboard.readText().then(function (value) {\n          _this.continuePaste(cm, actionArgs, vim, value, register);\n        });\n      } else {\n        var text = register.toString();\n        this.continuePaste(cm, actionArgs, vim, text, register);\n      }\n    },\n    continuePaste: function continuePaste(cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        var whitespaceLength = function whitespaceLength(str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        text = text.split('\\n');\n        if (linewise) {\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      var idx;\n      if (vim.visualMode) {\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          cm.replaceSelections(emptyStrings);\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          if (linewise && actionArgs.after) {\n            curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function undo(cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function redo(cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function setRegister(_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function setMark(cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function replace(cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function incrementNumberToken(cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function repeatLastEdit(cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n      _repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n\n    indent: function indent(cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 < charCode && charCode < 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line) {\n        if (oldCur.ch > ch) {\n          direction = -1;\n        }\n      }\n      ch += direction;\n      if (ch > maxCh) ch -= 2;\n    }\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    var match,\n      partial = [],\n      full = [];\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n      if (match == 'partial') {\n        partial.push(command);\n      }\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  function cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n    cm.setSelections(sel, 0);\n  }\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function getCurrentSelectedAreaRange() {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function getLastSelectedAreaRange() {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n        fromCh = anchor.ch,\n        bottom = Math.max(anchor.line, head.line),\n        toCh = head.ch;\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n      ;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  }\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      lines.pop();\n      var line;\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    while (!test(line.charAt(idx))) {\n      idx++;\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n    if (inclusive) {\n      var wordEnd = end;\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n      if (wordEnd == end) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function isComplete(state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function init(state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function isComplete(state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function isComplete(state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    method: {\n      init: function init(state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function isComplete(state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function init(state) {\n        state.index = 0;\n      },\n      isComplete: function isComplete(state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0) return true;\n        }\n        return false;\n      }\n    }\n  };\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n  function _moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n  }\n  function _moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return null;\n      }\n      start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n  }\n  function _moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    function isEmpty(i) {\n      return !/\\S/.test(cm.getLine(i));\n    } // ace_patch\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n      dir = dir > 0 ? 1 : -1;\n      var foldLine = cm.ace.session.getFoldLine(i);\n      if (foldLine) {\n        if (i + dir > foldLine.start.row && i + dir < foldLine.end.row) dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n      }\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        skipFold(i);\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      } else {\n        curr.pos += curr.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos + 1\n            };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos + 1\n            };\n          }\n        }\n        nextChar(curr);\n      }\n      return {\n        ln: curr.ln,\n        pos: lastSentencePos + 1\n      };\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos\n            };\n          } else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return {\n                ln: curr.ln,\n                pos: curr.pos + 1\n              };\n            } else {\n              return {\n                ln: curr.ln,\n                pos: lastSentencePos\n              };\n            }\n          }\n        }\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      } else {\n        return {\n          ln: curr.ln,\n          pos: lastSentencePos\n        };\n      }\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n      start,\n      end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    start = start.pos;\n    end = end.pos;\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n      --cur.ch; // make sure to look backwards\n    }\n\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  defineOption('pcre', true, 'boolean');\n  function SearchState() {}\n  SearchState.prototype = {\n    getQuery: function getQuery() {\n      return vimGlobalState.query;\n    },\n    setQuery: function setQuery(query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function getOverlay() {\n      return this.searchOverlay;\n    },\n    setOverlay: function setOverlay(overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function isReversed() {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function setReversed(reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function getScrollbarAnnotate() {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function setScrollbarAnnotate(annotate) {\n      this.annotate = annotate;\n    }\n  };\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n    return slashes;\n  }\n  function translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t',\n    '\\\\&': '&'\n  };\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n  function parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n      return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      regexPart = query;\n    } else {\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n    return regexp;\n  }\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n  function showConfirm(cm, template) {\n    var pre = dom('div', {\n      $color: 'red',\n      $whiteSpace: 'pre',\n      class: 'cm-vim-message'\n    }, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  function makePrompt(prefix, desc) {\n    return dom(document.createDocumentFragment(), dom('span', {\n      $fontFamily: 'monospace',\n      $whiteSpace: 'pre'\n    }, prefix, dom('input', {\n      type: 'text',\n      autocorrect: 'off',\n      autocapitalize: 'off',\n      spellcheck: 'false'\n    })), desc && dom('span', {\n      $color: '#888'\n    }, desc));\n  }\n  function showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function token(stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  function _findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      var found = cursor.find(!prev);\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  function getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n      top: renderer.getFirstFullyVisibleRow(),\n      bottom: renderer.getLastFullyVisibleRow()\n    };\n  }\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n  function getLastEditPos(cm) {\n    var undoManager = cm.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta) return toCmPos(undoManager.$lastDelta.end);\n  }\n  var ExCommandDispatcher = function ExCommandDispatcher() {\n    this.buildCommandMap_();\n  };\n  ExCommandDispatcher.prototype = {\n    processCommand: function processCommand(cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function _processCommand(cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var inputStream = new CodeMirror.StringStream(input);\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            for (var i = 0; i < command.toKeys.length; i++) {\n              vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n            }\n            return;\n          } else if (command.type == 'exToEx') {\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function parseInput_(cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n      return result;\n    },\n    parseLineSpec_: function parseLineSpec_(cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function parseLineSpecOffset_(inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    },\n    parseCommandArgs_: function parseCommandArgs_(inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function matchCommand_(commandName) {\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    },\n    buildCommandMap_: function buildCommandMap_() {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function map(lhs, rhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToEx',\n            exArgs: {\n              input: rhs.substring(1)\n            }\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        } else {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToKey',\n            toKeys: rhs\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function unmap(lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function colorscheme(cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function map(cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function imap(cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function nmap(cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function vmap(cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    unmap: function unmap(cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    move: function move(cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function set(cm, params) {\n      var setArgs = params.args;\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        optionName = optionName.substring(2);\n        value = false;\n      }\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean && value == undefined) {\n        value = true;\n      }\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function setlocal(cm, params) {\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function setglobal(cm, params) {\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function registers(cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    sort: function sort(cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat('!')) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function vglobal(cm, params) {\n      this.global(cm, params);\n    },\n    global: function global(cm, params) {\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd;\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLineHandle(i);\n        var matched = query.test(line.text);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? line : line.text);\n        }\n      }\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function nextCommand() {\n        if (index < matchedLines.length) {\n          var line = matchedLines[index++];\n          var lineNum = cm.getLineNumber(line);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        }\n      };\n      nextCommand();\n    },\n    substitute: function substitute(cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n        replacePart = '',\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function write(cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        cm.save();\n      }\n    },\n    nohlsearch: function nohlsearch(cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function yank(cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function delmarks(cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n        var count = stream.pos;\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n        var sym = stream.next();\n        if (stream.match('-', true)) {\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var startMark = sym;\n          var finishMark = stream.next();\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    function onPromptKeyDown(e, _value, close) {\n      CodeMirror.e_stop(e);\n      var keyName = CodeMirror.keyName(e);\n      switch (keyName) {\n        case 'Y':\n          replace();\n          next();\n          break;\n        case 'N':\n          next();\n          break;\n        case 'A':\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'L':\n          replace();\n        case 'Q':\n        case 'Esc':\n        case 'Ctrl-C':\n        case 'Ctrl-[':\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n  CodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      _repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) command[key] = extra[key];\n    _mapCommand(command);\n  }\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  CodeMirror.keyMap['vim-insert'] = {\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  CodeMirror.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      while (text) {\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          }\n        }\n        changeObj = changeObj.next;\n      }\n    }\n  }\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  function handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n    if (vim.visualMode) {\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode && !keepHPos) {\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n    if (!keyName) {\n      return;\n    }\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n  }\n  function _repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    }\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n  resetVimGlobalState();\n  CodeMirror.Vim = vimApi;\n  var specialKey = {\n    'return': 'CR',\n    backspace: 'BS',\n    'delete': 'Del',\n    esc: 'Esc',\n    left: 'Left',\n    right: 'Right',\n    up: 'Up',\n    down: 'Down',\n    space: 'Space',\n    insert: 'Ins',\n    home: 'Home',\n    end: 'End',\n    pageup: 'PageUp',\n    pagedown: 'PageDown',\n    enter: 'CR'\n  };\n  function lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  var handleKey = vimApi.handleKey.bind(vimApi);\n  vimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n      return handleKey(cm, key, origin);\n    }, true);\n  };\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      cm.operation(function () {\n        cm.ace.forEachSelection(function () {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n        });\n        if (cm.curOp.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n      }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n  }\n  exports.CodeMirror = CodeMirror;\n  var getVim = vimApi.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function drawCursor(element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w) left -= w;\n      }\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n      domLib.translate(element, left, top);\n      domLib.setStyle(element.style, \"width\", w + \"px\");\n      domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function $getDirectionForHighlight(editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (!vim.insertMode) {\n        return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n      }\n    },\n    handleKeyboard: function handleKeyboard(data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4) key = key.toUpperCase();\n            }\n          }\n          data.inputChar = key;\n        } else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1;\n          } else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        } else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n      if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n        return {\n          command: \"gotoleft\"\n        };\n      }\n      if (key == \"c\" && hashId == 1) {\n        // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function () {\n            if (vim.insertMode) editor.selection.clearSelection();else cm.operation(function () {\n              exitVisualMode(cm);\n            });\n          });\n          return {\n            command: \"null\",\n            passEvent: true\n          };\n        }\n      }\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {});\n        if (vim.status == null) vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n        if (isHandled && vim.status != null) vim.status += name;else if (vim.status == null) vim.status = \"\";\n        cm._signal(\"changeStatus\");\n        if (!isHandled && (hashId != -1 || insertMode)) return;\n        return {\n          command: \"null\",\n          passEvent: !isHandled\n        };\n      }\n    },\n    attach: function attach(editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      CodeMirror.keyMap.vim.attach(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function () {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n        cm.ace._signal(\"changeStatus\");\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function () {\n        cm.ace.renderer.updateCursor();\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function () {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n        cm._signal(\"changeStatus\");\n      });\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function detach(editor) {\n      var cm = editor.state.cm;\n      CodeMirror.keyMap.vim.detach(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function getStatusText(editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode) return \"INSERT\";\n      var status = \"\";\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine) status += \" LINE\";\n        if (vim.visualBlock) status += \" BLOCK\";\n      }\n      if (vim.status) status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  vimApi.defineOption({\n    name: \"wrap\",\n    set: function set(value, cm) {\n      if (cm) {\n        cm.ace.setOption(\"wrap\", value);\n      }\n    },\n    type: \"boolean\"\n  }, false);\n  vimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n  });\n  defaultKeymap.push({\n    keys: 'zc',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false\n    }\n  }, {\n    keys: 'zC',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false,\n      all: true\n    }\n  }, {\n    keys: 'zo',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true\n    }\n  }, {\n    keys: 'zO',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'za',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true\n    }\n  }, {\n    keys: 'zA',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true,\n      all: true\n    }\n  }, {\n    keys: 'zf',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'zd',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: '<C-A-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAbove\"\n    }\n  }, {\n    keys: '<C-A-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelow\"\n    }\n  }, {\n    keys: '<C-A-S-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAboveSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-S-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelowSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreBefore\"\n    }\n  }, {\n    keys: '<C-A-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreAfter\"\n    }\n  }, {\n    keys: '<C-A-S-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextBefore\"\n    }\n  }, {\n    keys: '<C-A-S-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextAfter\"\n    }\n  });\n  defaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  });\n  vimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise) head--;\n    hardWrap(cm.ace, {\n      startRow: anchor,\n      endRow: head\n    });\n    return Pos(head, 0);\n  });\n  defineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (width === undefined) {\n      var value = cm.ace.getOption('printMarginColumn');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.ace.setOption('printMarginColumn', column);\n      }\n    }\n  });\n  actions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode) cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);else delayedExecAceCommand(null, cm.ace);\n  };\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n  }\n  actions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = vimApi;\n});\n(function () {\n  ace.require([\"ace/keyboard/vim\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}