{"code":"ace.define(\"ace/mode/c9search_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/mode/text_highlight_rules\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),i=e(\"../lib/lang\"),o=e(\"./text_highlight_rules\").TextHighlightRules;var a=function(){this.$rules={start:[{tokenNames:[\"c9searchresults.constant.numeric\",\"c9searchresults.text\",\"c9searchresults.text\",\"c9searchresults.keyword\"],regex:/(^\\s+[0-9]+)(:)(\\d*\\s?)([^\\r\\n]+)/,onMatch:function(e,t,n){var r=this.splitRegex.exec(e),i=this.tokenNames,o=[{type:i[0],value:r[1]},{type:i[1],value:r[2]}];r[3]&&(\" \"==r[3]?o[1]={type:i[1],value:r[2]+\" \"}:o.push({type:i[1],value:r[3]}));var a,s=n[1],c=r[4],u=0;if(s&&s.exec)for(s.lastIndex=0;a=s.exec(c);){var h=c.substring(u,a.index);if(u=s.lastIndex,h&&o.push({type:i[2],value:h}),a[0])o.push({type:i[3],value:a[0]});else if(!h)break}return u<c.length&&o.push({type:i[2],value:c.substr(u)}),o}},{regex:\"^Searching for [^\\\\r\\\\n]*$\",onMatch:function(e,t,n){var r,o,a=e.split(\"\\x01\");if(a.length<3)return\"text\";var s=0,c=[{value:a[s++]+\"'\",type:\"text\"},{value:o=a[s++],type:\"text\"},{value:\"'\"+a[s++],type:\"text\"}];for(\" in\"!==a[2]&&c.push({value:\"'\"+a[s++]+\"'\",type:\"text\"},{value:a[s++],type:\"text\"}),c.push({value:\" \"+a[s++]+\" \",type:\"text\"}),a[s+1]?(r=a[s+1],c.push({value:\"(\"+a[s+1]+\")\",type:\"text\"}),s+=1):s-=1;s++<a.length;)a[s]&&c.push({value:a[s],type:\"text\"});o&&(/regex/.test(r)||(o=i.escapeRegExp(o)),/whole/.test(r)&&(o=\"\\\\b\"+o+\"\\\\b\"));var u=o&&function(e,t){try{return new RegExp(e,t)}catch(n){}}(\"(\"+o+\")\",/ sensitive/.test(r)?\"g\":\"ig\");return u&&(n[0]=t,n[1]=u),c}},{regex:\"^(?=Found \\\\d+ matches)\",token:\"text\",next:\"numbers\"},{token:\"string\",regex:\"^\\\\S:?[^:]+\",next:\"numbers\"}],numbers:[{regex:\"\\\\d+\",token:\"constant.numeric\"},{regex:\"$\",token:\"text\",next:\"start\"}]},this.normalizeRules()};r.inherits(a,o),t.C9SearchHighlightRules=a})),ace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range,i=function(){};(function(){this.checkOutdent=function(e,t){return!!/^\\s+$/.test(e)&&/^\\s*\\}/.test(t)},this.autoOutdent=function(e,t){var n=e.getLine(t).match(/^(\\s*\\})/);if(!n)return 0;var i=n[1].length,o=e.findMatchingBracket({row:t,column:i});if(!o||o.row==t)return 0;var a=this.$getIndent(e.getLine(o.row));e.replace(new r(t,0,t,i-1),a)},this.$getIndent=function(e){return e.match(/^\\s*/)[0]}}).call(i.prototype),t.MatchingBraceOutdent=i})),ace.define(\"ace/mode/folding/c9search\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/range\",\"ace/mode/folding/fold_mode\"],(function(e,t,n){\"use strict\";var r=e(\"../../lib/oop\"),i=e(\"../../range\").Range,o=e(\"./fold_mode\").FoldMode,a=t.FoldMode=function(){};r.inherits(a,o),function(){this.foldingStartMarker=/^(\\S.*:|Searching for.*)$/,this.foldingStopMarker=/^(\\s+|Found.*)$/,this.getFoldWidgetRange=function(e,t,n){var r=e.doc.getAllLines(n),o=r[n],a=/^(Found.*|Searching for.*)$/,s=a.test(o)?a:/^(\\S.*:|\\s*)$/,c=n,u=n;if(this.foldingStartMarker.test(o)){for(var h=n+1,l=e.getLength();h<l&&!s.test(r[h]);h++);u=h}else if(this.foldingStopMarker.test(o)){for(h=n-1;h>=0&&(o=r[h],!s.test(o));h--);c=h}if(c!=u){var d=o.length;return s===a&&(d=o.search(/\\(Found[^)]+\\)$|$/)),new i(c,d,u,0)}}}.call(a.prototype)})),ace.define(\"ace/mode/c9search\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/c9search_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/mode/folding/c9search\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),i=e(\"./text\").Mode,o=e(\"./c9search_highlight_rules\").C9SearchHighlightRules,a=e(\"./matching_brace_outdent\").MatchingBraceOutdent,s=e(\"./folding/c9search\").FoldMode,c=function(){this.HighlightRules=o,this.$outdent=new a,this.foldingRules=new s};r.inherits(c,i),function(){this.getNextLineIndent=function(e,t,n){return this.$getIndent(t)},this.checkOutdent=function(e,t,n){return this.$outdent.checkOutdent(t,n)},this.autoOutdent=function(e,t,n){this.$outdent.autoOutdent(t,n)},this.$id=\"ace/mode/c9search\"}.call(c.prototype),t.Mode=c})),ace.require([\"ace/mode/c9search\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"a32acfcd6d04e5e4518733feb8bbc3eb.js","input":"ace.define(\"ace/mode/c9search_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/lib/lang\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var lang = require(\"../lib/lang\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  function safeCreateRegexp(source, flag) {\n    try {\n      return new RegExp(source, flag);\n    } catch (e) {}\n  }\n  var C9SearchHighlightRules = function C9SearchHighlightRules() {\n    this.$rules = {\n      \"start\": [{\n        tokenNames: [\"c9searchresults.constant.numeric\", \"c9searchresults.text\", \"c9searchresults.text\", \"c9searchresults.keyword\"],\n        regex: /(^\\s+[0-9]+)(:)(\\d*\\s?)([^\\r\\n]+)/,\n        onMatch: function onMatch(val, state, stack) {\n          var values = this.splitRegex.exec(val);\n          var types = this.tokenNames;\n          var tokens = [{\n            type: types[0],\n            value: values[1]\n          }, {\n            type: types[1],\n            value: values[2]\n          }];\n          if (values[3]) {\n            if (values[3] == \" \") tokens[1] = {\n              type: types[1],\n              value: values[2] + \" \"\n            };else tokens.push({\n              type: types[1],\n              value: values[3]\n            });\n          }\n          var regex = stack[1];\n          var str = values[4];\n          var m;\n          var last = 0;\n          if (regex && regex.exec) {\n            regex.lastIndex = 0;\n            while (m = regex.exec(str)) {\n              var skipped = str.substring(last, m.index);\n              last = regex.lastIndex;\n              if (skipped) tokens.push({\n                type: types[2],\n                value: skipped\n              });\n              if (m[0]) tokens.push({\n                type: types[3],\n                value: m[0]\n              });else if (!skipped) break;\n            }\n          }\n          if (last < str.length) tokens.push({\n            type: types[2],\n            value: str.substr(last)\n          });\n          return tokens;\n        }\n      }, {\n        regex: \"^Searching for [^\\\\r\\\\n]*$\",\n        onMatch: function onMatch(val, state, stack) {\n          var parts = val.split(\"\\x01\");\n          if (parts.length < 3) return \"text\";\n          var options, search;\n          var i = 0;\n          var tokens = [{\n            value: parts[i++] + \"'\",\n            type: \"text\"\n          }, {\n            value: search = parts[i++],\n            type: \"text\" // \"c9searchresults.keyword\"\n          }, {\n            value: \"'\" + parts[i++],\n            type: \"text\"\n          }];\n          if (parts[2] !== \" in\") {\n            tokens.push({\n              value: \"'\" + parts[i++] + \"'\",\n              type: \"text\"\n            }, {\n              value: parts[i++],\n              type: \"text\"\n            });\n          }\n          tokens.push({\n            value: \" \" + parts[i++] + \" \",\n            type: \"text\"\n          });\n          if (parts[i + 1]) {\n            options = parts[i + 1];\n            tokens.push({\n              value: \"(\" + parts[i + 1] + \")\",\n              type: \"text\"\n            });\n            i += 1;\n          } else {\n            i -= 1;\n          }\n          while (i++ < parts.length) {\n            parts[i] && tokens.push({\n              value: parts[i],\n              type: \"text\"\n            });\n          }\n          if (search) {\n            if (!/regex/.test(options)) search = lang.escapeRegExp(search);\n            if (/whole/.test(options)) search = \"\\\\b\" + search + \"\\\\b\";\n          }\n          var regex = search && safeCreateRegexp(\"(\" + search + \")\", / sensitive/.test(options) ? \"g\" : \"ig\");\n          if (regex) {\n            stack[0] = state;\n            stack[1] = regex;\n          }\n          return tokens;\n        }\n      }, {\n        regex: \"^(?=Found \\\\d+ matches)\",\n        token: \"text\",\n        next: \"numbers\"\n      }, {\n        token: \"string\",\n        regex: \"^\\\\S:?[^:]+\",\n        next: \"numbers\"\n      }],\n      numbers: [{\n        regex: \"\\\\d+\",\n        token: \"constant.numeric\"\n      }, {\n        regex: \"$\",\n        token: \"text\",\n        next: \"start\"\n      }]\n    };\n    this.normalizeRules();\n  };\n  oop.inherits(C9SearchHighlightRules, TextHighlightRules);\n  exports.C9SearchHighlightRules = C9SearchHighlightRules;\n});\nace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  var MatchingBraceOutdent = function MatchingBraceOutdent() {};\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/folding/c9search\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/range\", \"ace/mode/folding/fold_mode\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var Range = require(\"../../range\").Range;\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^(\\S.*:|Searching for.*)$/;\n    this.foldingStopMarker = /^(\\s+|Found.*)$/;\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var lines = session.doc.getAllLines(row);\n      var line = lines[row];\n      var level1 = /^(Found.*|Searching for.*)$/;\n      var level2 = /^(\\S.*:|\\s*)$/;\n      var re = level1.test(line) ? level1 : level2;\n      var startRow = row;\n      var endRow = row;\n      if (this.foldingStartMarker.test(line)) {\n        for (var i = row + 1, l = session.getLength(); i < l; i++) {\n          if (re.test(lines[i])) break;\n        }\n        endRow = i;\n      } else if (this.foldingStopMarker.test(line)) {\n        for (var i = row - 1; i >= 0; i--) {\n          line = lines[i];\n          if (re.test(line)) break;\n        }\n        startRow = i;\n      }\n      if (startRow != endRow) {\n        var col = line.length;\n        if (re === level1) col = line.search(/\\(Found[^)]+\\)$|$/);\n        return new Range(startRow, col, endRow, 0);\n      }\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/c9search\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/c9search_highlight_rules\", \"ace/mode/matching_brace_outdent\", \"ace/mode/folding/c9search\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var C9SearchHighlightRules = require(\"./c9search_highlight_rules\").C9SearchHighlightRules;\n  var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n  var C9StyleFoldMode = require(\"./folding/c9search\").FoldMode;\n  var Mode = function Mode() {\n    this.HighlightRules = C9SearchHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.foldingRules = new C9StyleFoldMode();\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n      return this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, doc, row) {\n      this.$outdent.autoOutdent(doc, row);\n    };\n    this.$id = \"ace/mode/c9search\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/c9search\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}