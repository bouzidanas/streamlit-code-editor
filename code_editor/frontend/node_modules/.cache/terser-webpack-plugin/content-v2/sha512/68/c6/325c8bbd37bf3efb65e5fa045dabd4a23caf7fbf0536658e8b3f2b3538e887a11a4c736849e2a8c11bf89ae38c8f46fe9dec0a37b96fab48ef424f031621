{"code":"ace.define(\"ace/mode/lua_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),o=e(\"./text_highlight_rules\").TextHighlightRules,i=function(){var e=this.createKeywordMapper({keyword:\"break|do|else|elseif|end|for|function|if|in|local|repeat|return|then|until|while|or|and|not\",\"support.function\":\"string|xpcall|package|tostring|print|os|unpack|require|getfenv|setmetatable|next|assert|tonumber|io|rawequal|collectgarbage|getmetatable|module|rawset|math|debug|pcall|table|newproxy|type|coroutine|_G|select|gcinfo|pairs|rawget|loadstring|ipairs|_VERSION|dofile|setfenv|load|error|loadfile|sub|upper|len|gfind|rep|find|match|char|dump|gmatch|reverse|byte|format|gsub|lower|preload|loadlib|loaded|loaders|cpath|config|path|seeall|exit|setlocale|date|getenv|difftime|remove|time|clock|tmpname|rename|execute|lines|write|close|flush|open|output|type|read|stderr|stdin|input|stdout|popen|tmpfile|log|max|acos|huge|ldexp|pi|cos|tanh|pow|deg|tan|cosh|sinh|random|randomseed|frexp|ceil|floor|rad|abs|sqrt|modf|asin|min|mod|fmod|log10|atan2|exp|sin|atan|getupvalue|debug|sethook|getmetatable|gethook|setmetatable|setlocal|traceback|setfenv|getinfo|setupvalue|getlocal|getregistry|getfenv|setn|insert|getn|foreachi|maxn|foreach|concat|sort|remove|resume|yield|status|wrap|create|running|__add|__sub|__mod|__unm|__concat|__lt|__index|__call|__gc|__metatable|__mul|__div|__pow|__len|__eq|__le|__newindex|__tostring|__mode|__tonumber\",\"keyword.deprecated\":\"setn|foreach|foreachi|gcinfo|log10|maxn\",\"constant.library\":\"string|package|os|io|math|debug|table|coroutine\",\"constant.language\":\"true|false|nil|_G|_VERSION\",\"variable.language\":\"self\"},\"identifier\"),t=\"(?:\\\\d+)\",n=\"(?:\"+(\"(?:(?:\"+t+\"?(?:\\\\.\\\\d+))|(?:\"+t+\"\\\\.))\")+\")\";this.$rules={start:[{stateName:\"bracketedComment\",onMatch:function(e,t,n){return n.unshift(this.next,e.length-2,t),\"comment\"},regex:/\\-\\-\\[=*\\[/,next:[{onMatch:function(e,t,n){return e.length==n[1]?(n.shift(),n.shift(),this.next=n.shift()):this.next=\"\",\"comment\"},regex:/\\]=*\\]/,next:\"start\"},{defaultToken:\"comment.body\"}]},{token:\"comment\",regex:\"\\\\-\\\\-.*$\"},{stateName:\"bracketedString\",onMatch:function(e,t,n){return n.unshift(this.next,e.length,t),\"string.start\"},regex:/\\[=*\\[/,next:[{onMatch:function(e,t,n){return e.length==n[1]?(n.shift(),n.shift(),this.next=n.shift()):this.next=\"\",\"string.end\"},regex:/\\]=*\\]/,next:\"start\"},{defaultToken:\"string\"}]},{token:\"string\",regex:'\"(?:[^\\\\\\\\]|\\\\\\\\.)*?\"'},{token:\"string\",regex:\"'(?:[^\\\\\\\\]|\\\\\\\\.)*?'\"},{token:\"constant.numeric\",regex:n},{token:\"constant.numeric\",regex:\"(?:(?:(?:[1-9]\\\\d*)|(?:0))|(?:0[xX][\\\\dA-Fa-f]+))\\\\b\"},{token:e,regex:\"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"},{token:\"keyword.operator\",regex:\"\\\\+|\\\\-|\\\\*|\\\\/|%|\\\\#|\\\\^|~|<|>|<=|=>|==|~=|=|\\\\:|\\\\.\\\\.\\\\.|\\\\.\\\\.\"},{token:\"paren.lparen\",regex:\"[\\\\[\\\\(\\\\{]\"},{token:\"paren.rparen\",regex:\"[\\\\]\\\\)\\\\}]\"},{token:\"text\",regex:\"\\\\s+|\\\\w+\"}]},this.normalizeRules()};r.inherits(i,o),t.LuaHighlightRules=i})),ace.define(\"ace/mode/folding/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"],(function(e,t,n){\"use strict\";var r=e(\"../../lib/oop\"),o=e(\"./fold_mode\").FoldMode,i=e(\"../../range\").Range,a=e(\"../../token_iterator\").TokenIterator,l=t.FoldMode=function(){};r.inherits(l,o),function(){this.foldingStartMarker=/\\b(function|then|do|repeat)\\b|{\\s*$|(\\[=*\\[)/,this.foldingStopMarker=/\\bend\\b|^\\s*}|\\]=*\\]/,this.getFoldWidget=function(e,t,n){var r=e.getLine(n),o=this.foldingStartMarker.test(r),i=this.foldingStopMarker.test(r);if(o&&!i){var a;if(\"then\"==(a=r.match(this.foldingStartMarker))[1]&&/\\belseif\\b/.test(r))return;if(a[1]){if(\"keyword\"===e.getTokenAt(n,a.index+1).type)return\"start\"}else{if(!a[2])return\"start\";if(\"bracketedComment\"==(l=e.bgTokenizer.getState(n)||\"\")[0]||\"bracketedString\"==l[0])return\"start\"}}if(\"markbeginend\"!=t||!i||o&&i)return\"\";if(\"end\"===(a=r.match(this.foldingStopMarker))[0]){if(\"keyword\"===e.getTokenAt(n,a.index+1).type)return\"end\"}else{if(\"]\"!==a[0][0])return\"end\";var l;if(\"bracketedComment\"==(l=e.bgTokenizer.getState(n-1)||\"\")[0]||\"bracketedString\"==l[0])return\"end\"}},this.getFoldWidgetRange=function(e,t,n){var r,o=e.doc.getLine(n);return(r=this.foldingStartMarker.exec(o))?r[1]?this.luaBlock(e,n,r.index+1):r[2]?e.getCommentFoldRange(n,r.index+1):this.openingBracketBlock(e,\"{\",n,r.index):(r=this.foldingStopMarker.exec(o))?\"end\"===r[0]&&\"keyword\"===e.getTokenAt(n,r.index+1).type?this.luaBlock(e,n,r.index+1):\"]\"===r[0][0]?e.getCommentFoldRange(n,r.index+1):this.closingBracketBlock(e,\"}\",n,r.index+r[0].length):void 0},this.luaBlock=function(e,t,n,r){var o=new a(e,t,n),l={function:1,do:1,then:1,elseif:-1,end:-1,repeat:1,until:-1},s=o.getCurrentToken();if(s&&\"keyword\"==s.type){var u=s.value,g=[u],d=l[u];if(d){var c=-1===d?o.getCurrentTokenColumn():e.getLine(t).length,h=t;for(o.step=-1===d?o.stepBackward:o.stepForward;s=o.step();)if(\"keyword\"===s.type){var f=d*l[s.value];if(f>0)g.unshift(s.value);else if(f<=0){if(g.shift(),!g.length&&\"elseif\"!=s.value)break;0===f&&g.unshift(s.value)}}if(!s)return null;if(r)return o.getCurrentTokenRange();t=o.getCurrentTokenRow();return-1===d?new i(t,e.getLine(t).length,h,c):new i(h,c,t,o.getCurrentTokenColumn())}}}}.call(l.prototype)})),ace.define(\"ace/mode/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/lua_highlight_rules\",\"ace/mode/folding/lua\",\"ace/range\",\"ace/worker/worker_client\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),o=e(\"./text\").Mode,i=e(\"./lua_highlight_rules\").LuaHighlightRules,a=e(\"./folding/lua\").FoldMode,l=e(\"../range\").Range,s=e(\"../worker/worker_client\").WorkerClient,u=function(){this.HighlightRules=i,this.foldingRules=new a,this.$behaviour=this.$defaultBehaviour};r.inherits(u,o),function(){this.lineCommentStart=\"--\",this.blockComment={start:\"--[[\",end:\"--]]\"};var e={function:1,then:1,do:1,else:1,elseif:1,repeat:1,end:-1,until:-1},t=[\"else\",\"elseif\",\"end\",\"until\"];this.getNextLineIndent=function(t,n,r){var o=this.$getIndent(n),i=0,a=this.getTokenizer().getLineTokens(n,t).tokens;return\"start\"==t&&(i=function(t){for(var n=0,r=0;r<t.length;r++){var o=t[r];\"keyword\"==o.type?o.value in e&&(n+=e[o.value]):\"paren.lparen\"==o.type?n+=o.value.length:\"paren.rparen\"==o.type&&(n-=o.value.length)}return n<0?-1:n>0?1:0}(a)),i>0?o+r:i<0&&o.substr(o.length-r.length)==r&&!this.checkOutdent(t,n,\"\\n\")?o.substr(0,o.length-r.length):o},this.checkOutdent=function(e,n,r){if(\"\\n\"!=r&&\"\\r\"!=r&&\"\\r\\n\"!=r)return!1;if(n.match(/^\\s*[\\)\\}\\]]$/))return!0;var o=this.getTokenizer().getLineTokens(n.trim(),e).tokens;return!(!o||!o.length)&&(\"keyword\"==o[0].type&&-1!=t.indexOf(o[0].value))},this.getMatching=function(t,n,r){if(void 0==n){var o=t.selection.lead;r=o.column,n=o.row}var i=t.getTokenAt(n,r);if(i&&i.value in e)return this.foldingRules.luaBlock(t,n,r,!0)},this.autoOutdent=function(e,t,n){var r=t.getLine(n).match(/^\\s*/)[0].length;if(r&&n){var o=this.getMatching(t,n,r+1);if(o&&o.start.row!=n){var i=this.$getIndent(t.getLine(o.start.row));i.length!=r&&(t.replace(new l(n,0,n,r),i),t.outdentRows(new l(n+1,0,n+1,0)))}}},this.createWorker=function(e){var t=new s([\"ace\"],\"ace/mode/lua_worker\",\"Worker\");return t.attachToDocument(e.getDocument()),t.on(\"annotate\",(function(t){e.setAnnotations(t.data)})),t.on(\"terminate\",(function(){e.clearAnnotations()})),t},this.$id=\"ace/mode/lua\",this.snippetFileId=\"ace/snippets/lua\"}.call(u.prototype),t.Mode=u})),ace.require([\"ace/mode/lua\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"014d84e08c5a2ee1b019d81a57f69b6d.js","input":"ace.define(\"ace/mode/lua_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var LuaHighlightRules = function () {\n    var keywords = \"break|do|else|elseif|end|for|function|if|in|local|repeat|\" + \"return|then|until|while|or|and|not\";\n    var builtinConstants = \"true|false|nil|_G|_VERSION\";\n    var functions = \"string|xpcall|package|tostring|print|os|unpack|require|\" + \"getfenv|setmetatable|next|assert|tonumber|io|rawequal|\" + \"collectgarbage|getmetatable|module|rawset|math|debug|\" + \"pcall|table|newproxy|type|coroutine|_G|select|gcinfo|\" + \"pairs|rawget|loadstring|ipairs|_VERSION|dofile|setfenv|\" + \"load|error|loadfile|\" + \"sub|upper|len|gfind|rep|find|match|char|dump|gmatch|\" + \"reverse|byte|format|gsub|lower|preload|loadlib|loaded|\" + \"loaders|cpath|config|path|seeall|exit|setlocale|date|\" + \"getenv|difftime|remove|time|clock|tmpname|rename|execute|\" + \"lines|write|close|flush|open|output|type|read|stderr|\" + \"stdin|input|stdout|popen|tmpfile|log|max|acos|huge|\" + \"ldexp|pi|cos|tanh|pow|deg|tan|cosh|sinh|random|randomseed|\" + \"frexp|ceil|floor|rad|abs|sqrt|modf|asin|min|mod|fmod|log10|\" + \"atan2|exp|sin|atan|getupvalue|debug|sethook|getmetatable|\" + \"gethook|setmetatable|setlocal|traceback|setfenv|getinfo|\" + \"setupvalue|getlocal|getregistry|getfenv|setn|insert|getn|\" + \"foreachi|maxn|foreach|concat|sort|remove|resume|yield|\" + \"status|wrap|create|running|\" + \"__add|__sub|__mod|__unm|__concat|__lt|__index|__call|__gc|__metatable|\" + \"__mul|__div|__pow|__len|__eq|__le|__newindex|__tostring|__mode|__tonumber\";\n    var stdLibaries = \"string|package|os|io|math|debug|table|coroutine\";\n    var deprecatedIn5152 = \"setn|foreach|foreachi|gcinfo|log10|maxn\";\n    var keywordMapper = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"support.function\": functions,\n      \"keyword.deprecated\": deprecatedIn5152,\n      \"constant.library\": stdLibaries,\n      \"constant.language\": builtinConstants,\n      \"variable.language\": \"self\"\n    }, \"identifier\");\n    var decimalInteger = \"(?:(?:[1-9]\\\\d*)|(?:0))\";\n    var hexInteger = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n    var integer = \"(?:\" + decimalInteger + \"|\" + hexInteger + \")\";\n    var fraction = \"(?:\\\\.\\\\d+)\";\n    var intPart = \"(?:\\\\d+)\";\n    var pointFloat = \"(?:(?:\" + intPart + \"?\" + fraction + \")|(?:\" + intPart + \"\\\\.))\";\n    var floatNumber = \"(?:\" + pointFloat + \")\";\n    this.$rules = {\n      \"start\": [{\n        stateName: \"bracketedComment\",\n        onMatch: function (value, currentState, stack) {\n          stack.unshift(this.next, value.length - 2, currentState);\n          return \"comment\";\n        },\n        regex: /\\-\\-\\[=*\\[/,\n        next: [{\n          onMatch: function (value, currentState, stack) {\n            if (value.length == stack[1]) {\n              stack.shift();\n              stack.shift();\n              this.next = stack.shift();\n            } else {\n              this.next = \"\";\n            }\n            return \"comment\";\n          },\n          regex: /\\]=*\\]/,\n          next: \"start\"\n        }, {\n          defaultToken: \"comment.body\"\n        }]\n      }, {\n        token: \"comment\",\n        regex: \"\\\\-\\\\-.*$\"\n      }, {\n        stateName: \"bracketedString\",\n        onMatch: function (value, currentState, stack) {\n          stack.unshift(this.next, value.length, currentState);\n          return \"string.start\";\n        },\n        regex: /\\[=*\\[/,\n        next: [{\n          onMatch: function (value, currentState, stack) {\n            if (value.length == stack[1]) {\n              stack.shift();\n              stack.shift();\n              this.next = stack.shift();\n            } else {\n              this.next = \"\";\n            }\n            return \"string.end\";\n          },\n          regex: /\\]=*\\]/,\n          next: \"start\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string\",\n        // \" string\n        regex: '\"(?:[^\\\\\\\\]|\\\\\\\\.)*?\"'\n      }, {\n        token: \"string\",\n        // ' string\n        regex: \"'(?:[^\\\\\\\\]|\\\\\\\\.)*?'\"\n      }, {\n        token: \"constant.numeric\",\n        // float\n        regex: floatNumber\n      }, {\n        token: \"constant.numeric\",\n        // integer\n        regex: integer + \"\\\\b\"\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n      }, {\n        token: \"keyword.operator\",\n        regex: \"\\\\+|\\\\-|\\\\*|\\\\/|%|\\\\#|\\\\^|~|<|>|<=|=>|==|~=|=|\\\\:|\\\\.\\\\.\\\\.|\\\\.\\\\.\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[\\\\[\\\\(\\\\{]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\]\\\\)\\\\}]\"\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+|\\\\w+\"\n      }]\n    };\n    this.normalizeRules();\n  };\n  oop.inherits(LuaHighlightRules, TextHighlightRules);\n  exports.LuaHighlightRules = LuaHighlightRules;\n});\nace.define(\"ace/mode/folding/lua\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var TokenIterator = require(\"../../token_iterator\").TokenIterator;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /\\b(function|then|do|repeat)\\b|{\\s*$|(\\[=*\\[)/;\n    this.foldingStopMarker = /\\bend\\b|^\\s*}|\\]=*\\]/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var isStart = this.foldingStartMarker.test(line);\n      var isEnd = this.foldingStopMarker.test(line);\n      if (isStart && !isEnd) {\n        var match = line.match(this.foldingStartMarker);\n        if (match[1] == \"then\" && /\\belseif\\b/.test(line)) return;\n        if (match[1]) {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"start\";\n        } else if (match[2]) {\n          var type = session.bgTokenizer.getState(row) || \"\";\n          if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\") return \"start\";\n        } else {\n          return \"start\";\n        }\n      }\n      if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd) return \"\";\n      var match = line.match(this.foldingStopMarker);\n      if (match[0] === \"end\") {\n        if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"end\";\n      } else if (match[0][0] === \"]\") {\n        var type = session.bgTokenizer.getState(row - 1) || \"\";\n        if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\") return \"end\";\n      } else return \"end\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n      if (match) {\n        if (match[1]) return this.luaBlock(session, row, match.index + 1);\n        if (match[2]) return session.getCommentFoldRange(row, match.index + 1);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n      var match = this.foldingStopMarker.exec(line);\n      if (match) {\n        if (match[0] === \"end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return this.luaBlock(session, row, match.index + 1);\n        }\n        if (match[0][0] === \"]\") return session.getCommentFoldRange(row, match.index + 1);\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n    this.luaBlock = function (session, row, column, tokenRange) {\n      var stream = new TokenIterator(session, row, column);\n      var indentKeywords = {\n        \"function\": 1,\n        \"do\": 1,\n        \"then\": 1,\n        \"elseif\": -1,\n        \"end\": -1,\n        \"repeat\": 1,\n        \"until\": -1\n      };\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"keyword\") return;\n      var val = token.value;\n      var stack = [val];\n      var dir = indentKeywords[val];\n      if (!dir) return;\n      var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n      var startRow = row;\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n      while (token = stream.step()) {\n        if (token.type !== \"keyword\") continue;\n        var level = dir * indentKeywords[token.value];\n        if (level > 0) {\n          stack.unshift(token.value);\n        } else if (level <= 0) {\n          stack.shift();\n          if (!stack.length && token.value != \"elseif\") break;\n          if (level === 0) stack.unshift(token.value);\n        }\n      }\n      if (!token) return null;\n      if (tokenRange) return stream.getCurrentTokenRange();\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) return new Range(row, session.getLine(row).length, startRow, startColumn);else return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/lua\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/lua_highlight_rules\", \"ace/mode/folding/lua\", \"ace/range\", \"ace/worker/worker_client\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var LuaHighlightRules = require(\"./lua_highlight_rules\").LuaHighlightRules;\n  var LuaFoldMode = require(\"./folding/lua\").FoldMode;\n  var Range = require(\"../range\").Range;\n  var WorkerClient = require(\"../worker/worker_client\").WorkerClient;\n  var Mode = function () {\n    this.HighlightRules = LuaHighlightRules;\n    this.foldingRules = new LuaFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"--\";\n    this.blockComment = {\n      start: \"--[[\",\n      end: \"--]]\"\n    };\n    var indentKeywords = {\n      \"function\": 1,\n      \"then\": 1,\n      \"do\": 1,\n      \"else\": 1,\n      \"elseif\": 1,\n      \"repeat\": 1,\n      \"end\": -1,\n      \"until\": -1\n    };\n    var outdentKeywords = [\"else\", \"elseif\", \"end\", \"until\"];\n    function getNetIndentLevel(tokens) {\n      var level = 0;\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (token.type == \"keyword\") {\n          if (token.value in indentKeywords) {\n            level += indentKeywords[token.value];\n          }\n        } else if (token.type == \"paren.lparen\") {\n          level += token.value.length;\n        } else if (token.type == \"paren.rparen\") {\n          level -= token.value.length;\n        }\n      }\n      if (level < 0) {\n        return -1;\n      } else if (level > 0) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      var level = 0;\n      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n      var tokens = tokenizedLine.tokens;\n      if (state == \"start\") {\n        level = getNetIndentLevel(tokens);\n      }\n      if (level > 0) {\n        return indent + tab;\n      } else if (level < 0 && indent.substr(indent.length - tab.length) == tab) {\n        if (!this.checkOutdent(state, line, \"\\n\")) {\n          return indent.substr(0, indent.length - tab.length);\n        }\n      }\n      return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n      if (input != \"\\n\" && input != \"\\r\" && input != \"\\r\\n\") return false;\n      if (line.match(/^\\s*[\\)\\}\\]]$/)) return true;\n      var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;\n      if (!tokens || !tokens.length) return false;\n      return tokens[0].type == \"keyword\" && outdentKeywords.indexOf(tokens[0].value) != -1;\n    };\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) {\n        var pos = session.selection.lead;\n        column = pos.column;\n        row = pos.row;\n      }\n      var startToken = session.getTokenAt(row, column);\n      if (startToken && startToken.value in indentKeywords) return this.foldingRules.luaBlock(session, row, column, true);\n    };\n    this.autoOutdent = function (state, session, row) {\n      var line = session.getLine(row);\n      var column = line.match(/^\\s*/)[0].length;\n      if (!column || !row) return;\n      var startRange = this.getMatching(session, row, column + 1);\n      if (!startRange || startRange.start.row == row) return;\n      var indent = this.$getIndent(session.getLine(startRange.start.row));\n      if (indent.length != column) {\n        session.replace(new Range(row, 0, row, column), indent);\n        session.outdentRows(new Range(row + 1, 0, row + 1, 0));\n      }\n    };\n    this.createWorker = function (session) {\n      var worker = new WorkerClient([\"ace\"], \"ace/mode/lua_worker\", \"Worker\");\n      worker.attachToDocument(session.getDocument());\n      worker.on(\"annotate\", function (e) {\n        session.setAnnotations(e.data);\n      });\n      worker.on(\"terminate\", function () {\n        session.clearAnnotations();\n      });\n      return worker;\n    };\n    this.$id = \"ace/mode/lua\";\n    this.snippetFileId = \"ace/snippets/lua\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/lua\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}