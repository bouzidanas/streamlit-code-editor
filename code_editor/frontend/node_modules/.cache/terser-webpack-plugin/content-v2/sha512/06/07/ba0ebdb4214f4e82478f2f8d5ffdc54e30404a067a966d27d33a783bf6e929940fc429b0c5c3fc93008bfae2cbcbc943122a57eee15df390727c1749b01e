{"code":"ace.define(\"ace/ext/hardwrap\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/editor\",\"ace/config\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range;function i(e,t){for(var n=t.column||e.getOption(\"printMarginColumn\"),i=0!=t.allowMerge,o=Math.min(t.startRow,t.endRow),a=Math.max(t.startRow,t.endRow),s=e.session;o<=a;){var l=s.getLine(o);if(l.length>n){if(h=g(l,n,5)){var c=/^\\s*/.exec(l)[0];s.replace(new r(o,h.start,o,h.end),\"\\n\"+c)}a++}else if(i&&/\\S/.test(l)&&o!=a){var u=s.getLine(o+1);if(u&&/\\S/.test(u)){var h,d=l.replace(/\\s+$/,\"\"),p=u.replace(/^\\s+/,\"\"),f=d+\" \"+p;if((h=g(f,n,5))&&h.start>d.length||f.length<n){var m=new r(o,d.length,o+1,u.length-p.length);s.replace(m,\" \"),o--,a--}else d.length<l.length&&s.remove(new r(o,d.length,o,l.length))}}o++}function g(e,t,n){if(!(e.length<t)){var r=e.slice(0,t),i=e.slice(t),o=/^(?:(\\s+)|(\\S+)(\\s+))/.exec(i),a=/(?:(\\s+)|(\\s+)(\\S+))$/.exec(r),s=0,l=0;return a&&!a[2]&&(s=t-a[1].length,l=t),o&&!o[2]&&(s||(s=t),l=t+o[1].length),s?{start:s,end:l}:a&&a[2]&&a.index>n?{start:a.index,end:a.index+a[2].length}:o&&o[2]?{start:s=t+o[2].length,end:s+o[3].length}:void 0}}}function o(e){if(\"insertstring\"==e.command.name&&/\\S/.test(e.args)){var t=e.editor,n=t.selection.cursor;if(n.column<=t.renderer.$printMarginColumn)return;var r=t.session.$undoManager.$lastDelta;i(t,{startRow:n.row,endRow:n.row,allowMerge:!1}),r!=t.session.$undoManager.$lastDelta&&t.session.markUndoGroup()}}var a=e(\"../editor\").Editor;e(\"../config\").defineOptions(a.prototype,\"editor\",{hardWrap:{set:function(e){e?this.commands.on(\"afterExec\",o):this.commands.off(\"afterExec\",o)},value:!1}}),t.hardWrap=i})),ace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/ext/hardwrap\",\"ace/multi_select\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range,i=e(\"../lib/event_emitter\").EventEmitter,o=e(\"../lib/dom\"),a=e(\"../lib/oop\"),s=e(\"../lib/keys\"),l=e(\"../lib/event\"),c=e(\"../search\").Search,u=e(\"../lib/useragent\"),h=e(\"../search_highlight\").SearchHighlight,d=e(\"../commands/multi_select_commands\"),p=e(\"../mode/text\").Mode.prototype.tokenRe,f=e(\"../ext/hardwrap\").hardWrap;e(\"../multi_select\");var m=function(e){this.ace=e,this.state={},this.marks={},this.options={},this.$uid=0,this.onChange=this.onChange.bind(this),this.onSelectionChange=this.onSelectionChange.bind(this),this.onBeforeEndOperation=this.onBeforeEndOperation.bind(this),this.ace.on(\"change\",this.onChange),this.ace.on(\"changeSelection\",this.onSelectionChange),this.ace.on(\"beforeEndOperation\",this.onBeforeEndOperation)};function g(e){return{row:e.line,column:e.ch}}function v(e){return new y(e.row,e.column)}m.Pos=function(e,t){if(!(this instanceof y))return new y(e,t);this.line=e,this.ch=t},m.defineOption=function(e,t,n){},m.commands={redo:function(e){e.ace.redo()},undo:function(e){e.ace.undo()},newlineAndIndent:function(e){e.ace.insert(\"\\n\")},goLineLeft:function(e){e.ace.selection.moveCursorLineStart()},goLineRight:function(e){e.ace.selection.moveCursorLineEnd()}},m.keyMap={},m.addClass=m.rmClass=function(){},m.e_stop=m.e_preventDefault=l.stopEvent,m.keyName=function(e){var t=s[e.keyCode]||e.key||\"\";return 1==t.length&&(t=t.toUpperCase()),t=l.getModifierString(e).replace(/(^|-)\\w/g,(function(e){return e.toUpperCase()}))+t},m.keyMap.default=function(e){return function(t){var n=t.ace.commands.commandKeyBinding[e.toLowerCase()];return n&&!1!==t.ace.execCommand(n)}},m.lookupKey=function e(t,n,r){n||(n=\"default\"),\"string\"==typeof n&&(n=m.keyMap[n]||m.keyMap.default);var i=\"function\"==typeof n?n(t):n[t];if(!1===i)return\"nothing\";if(\"...\"===i)return\"multi\";if(null!=i&&r(i))return\"handled\";if(n.fallthrough){if(!Array.isArray(n.fallthrough))return e(t,n.fallthrough,r);for(var o=0;o<n.fallthrough.length;o++){var a=e(t,n.fallthrough[o],r);if(a)return a}}},m.findMatchingTag=function(e,t){return e.findMatchingTag(t)},m.findEnclosingTag=function(e,t){},m.signal=function(e,t,n){return e._signal(t,n)},m.on=l.addListener,m.off=l.removeListener,m.isWordChar=function(e){return e<\"\\x7f\"?/^\\w$/.test(e):(p.lastIndex=0,p.test(e))},function(){a.implement(m.prototype,i),this.destroy=function(){this.ace.off(\"change\",this.onChange),this.ace.off(\"changeSelection\",this.onSelectionChange),this.ace.off(\"beforeEndOperation\",this.onBeforeEndOperation),this.removeOverlay()},this.virtualSelectionMode=function(){return this.ace.inVirtualSelectionMode&&this.ace.selection.index},this.onChange=function(e){this.$lineHandleChanges&&this.$lineHandleChanges.push(e);var t={text:\"i\"==e.action[0]?e.lines:[]},n=this.curOp=this.curOp||{};n.changeHandlers||(n.changeHandlers=this._eventRegistry.change&&this._eventRegistry.change.slice()),n.lastChange?n.lastChange.next=n.lastChange=t:n.lastChange=n.change=t,this.$updateMarkers(e)},this.onSelectionChange=function(){var e=this.curOp=this.curOp||{};e.cursorActivityHandlers||(e.cursorActivityHandlers=this._eventRegistry.cursorActivity&&this._eventRegistry.cursorActivity.slice()),this.curOp.cursorActivity=!0,this.ace.inMultiSelectMode&&this.ace.keyBinding.removeKeyboardHandler(d.keyboardHandler)},this.operation=function(e,t){if(!t&&this.curOp||t&&this.curOp&&this.curOp.force)return e();if(!t&&this.ace.curOp||this.curOp&&this.onBeforeEndOperation(),!this.ace.curOp){var n=this.ace.prevOp;this.ace.startOperation({command:{name:\"vim\",scrollIntoView:\"cursor\"}})}var r=this.curOp=this.curOp||{};this.curOp.force=t;var i=e();return this.ace.curOp&&\"vim\"==this.ace.curOp.command.name&&(this.state.dialog&&(this.ace.curOp.command.scrollIntoView=this.ace.curOp.vimDialogScroll),this.ace.endOperation(),r.cursorActivity||r.lastChange||!n||(this.ace.prevOp=n)),!t&&this.ace.curOp||this.curOp&&this.onBeforeEndOperation(),i},this.onBeforeEndOperation=function(){var e=this.curOp;e&&(e.change&&this.signal(\"change\",e.change,e),e&&e.cursorActivity&&this.signal(\"cursorActivity\",null,e),this.curOp=null)},this.signal=function(e,t,n){var r=n?n[e+\"Handlers\"]:(this._eventRegistry||{})[e];if(r){r=r.slice();for(var i=0;i<r.length;i++)r[i](this,t)}},this.firstLine=function(){return 0},this.lastLine=function(){return this.ace.session.getLength()-1},this.lineCount=function(){return this.ace.session.getLength()},this.setCursor=function(e,t){\"object\"===typeof e&&(t=e.ch,e=e.line);var n=!this.curOp&&!this.ace.inVirtualSelectionMode;this.ace.inVirtualSelectionMode||this.ace.exitMultiSelectMode(),this.ace.session.unfold({row:e,column:t}),this.ace.selection.moveTo(e,t),n&&(this.ace.renderer.scrollCursorIntoView(),this.ace.endOperation())},this.getCursor=function(e){var t=this.ace.selection;return v(\"anchor\"==e?t.isEmpty()?t.lead:t.anchor:\"head\"!=e&&e?t.getRange()[e]:t.lead)},this.listSelections=function(e){var t=this.ace.multiSelect.rangeList.ranges;return!t.length||this.ace.inVirtualSelectionMode?[{anchor:this.getCursor(\"anchor\"),head:this.getCursor(\"head\")}]:t.map((function(e){return{anchor:this.clipPos(v(e.cursor==e.end?e.start:e.end)),head:this.clipPos(v(e.cursor))}}),this)},this.setSelections=function(e,t){var n=this.ace.multiSelect,i=e.map((function(e){var t=g(e.anchor),n=g(e.head),i=r.comparePoints(t,n)<0?new r.fromPoints(t,n):new r.fromPoints(n,t);return i.cursor=r.comparePoints(i.start,n)?i.end:i.start,i}));if(this.ace.inVirtualSelectionMode)this.ace.selection.fromOrientedRange(i[0]);else{t?i[t]&&i.push(i.splice(t,1)[0]):i=i.reverse(),n.toSingleRange(i[0].clone());for(var o=this.ace.session,a=0;a<i.length;a++){var s=o.$clipRangeToDocument(i[a]);n.addRange(s)}}},this.setSelection=function(e,t,n){var r=this.ace.selection;r.moveTo(e.line,e.ch),r.selectTo(t.line,t.ch),n&&\"*mouse\"==n.origin&&this.onBeforeEndOperation()},this.somethingSelected=function(e){return!this.ace.selection.isEmpty()},this.clipPos=function(e){return v(this.ace.session.$clipPositionToDocument(e.line,e.ch))},this.foldCode=function(e){this.ace.session.$toggleFoldWidget(e.line,{})},this.markText=function(e){return{clear:function(){},find:function(){}}},this.$updateMarkers=function(e){var t=\"insert\"==e.action,n=e.start,i=e.end,o=(i.row-n.row)*(t?1:-1),a=(i.column-n.column)*(t?1:-1);for(var s in t&&(i=n),this.marks){var l=this.marks[s],c=r.comparePoints(l,n);if(!(c<0)){if(0===c&&t)if(l.$insertRight){if(1!=l.bias){l.bias=-1;continue}c=1}else c=1;var u=t?c:r.comparePoints(l,i);u>0?(l.row+=o,l.column+=l.row==i.row?a:0):!t&&u<=0&&(l.row=n.row,l.column=n.column,0===u&&(l.bias=1))}}};var e=function(e,t,n,r){this.cm=e,this.id=t,this.row=n,this.column=r,e.marks[this.id]=this};e.prototype.clear=function(){delete this.cm.marks[this.id]},e.prototype.find=function(){return v(this)},this.setBookmark=function(t,n){var r=new e(this,this.$uid++,t.line,t.ch);return n&&n.insertLeft||(r.$insertRight=!0),this.marks[r.id]=r,r},this.moveH=function(e,t){if(\"char\"==t){var n=this.ace.selection;n.clearSelection(),n.moveCursorBy(0,e)}},this.findPosV=function(e,t,n,r){if(\"page\"==n){var i=this.ace.renderer.layerConfig;t*=Math.floor(i.height/i.lineHeight),n=\"line\"}if(\"line\"==n){var o=this.ace.session.documentToScreenPosition(e.line,e.ch);return null!=r&&(o.column=r),o.row+=t,o.row=Math.min(Math.max(0,o.row),this.ace.session.getScreenLength()-1),v(this.ace.session.screenToDocumentPosition(o.row,o.column))}},this.charCoords=function(e,t){if(\"div\"==t||!t)return{left:(r=this.ace.session.documentToScreenPosition(e.line,e.ch)).column,top:r.row};if(\"local\"==t){var n=this.ace.renderer,r=this.ace.session.documentToScreenPosition(e.line,e.ch),i=n.layerConfig.lineHeight,o=n.layerConfig.characterWidth,a=i*r.row;return{left:r.column*o,top:a,bottom:a+i}}},this.coordsChar=function(e,t){var n=this.ace.renderer;if(\"local\"==t){var r=Math.max(0,Math.floor(e.top/n.lineHeight)),i=Math.max(0,Math.floor(e.left/n.characterWidth));return v(n.session.screenToDocumentPosition(r,i))}if(\"div\"==t)throw\"not implemented\"},this.getSearchCursor=function(e,t,n){var r=!1,i=!1;e instanceof RegExp&&!e.global&&(r=!e.ignoreCase,e=e.source,i=!0),\"\\\\n\"==e&&(e=\"\\n\",i=!1);var o=new c;void 0==t.ch&&(t.ch=Number.MAX_VALUE);var a={row:t.line,column:t.ch},s=this,l=null;return{findNext:function(){return this.find(!1)},findPrevious:function(){return this.find(!0)},find:function(t){o.setOptions({needle:e,caseSensitive:r,wrap:!1,backwards:t,regExp:i,start:l||a});var n=o.find(s.ace.session);return(l=n)&&[!l.isEmpty()]},from:function(){return l&&v(l.start)},to:function(){return l&&v(l.end)},replace:function(e){l&&(l.end=s.ace.session.doc.replace(l,e))}}},this.scrollTo=function(e,t){var n=this.ace.renderer,r=n.layerConfig,i=r.maxHeight;i-=(n.$size.scrollerHeight-n.lineHeight)*n.$scrollPastEnd,null!=t&&this.ace.session.setScrollTop(Math.max(0,Math.min(t,i))),null!=e&&this.ace.session.setScrollLeft(Math.max(0,Math.min(e,r.width)))},this.scrollInfo=function(){return 0},this.scrollIntoView=function(e,t){if(e){var n=this.ace.renderer,r={top:0,bottom:t};n.scrollCursorIntoView(g(e),2*n.lineHeight/n.$size.scrollerHeight,r)}},this.getLine=function(e){return this.ace.session.getLine(e)},this.getRange=function(e,t){return this.ace.session.getTextRange(new r(e.line,e.ch,t.line,t.ch))},this.replaceRange=function(e,t,n){n||(n=t);var i=new r(t.line,t.ch,n.line,n.ch);return this.ace.session.$clipRangeToDocument(i),this.ace.session.replace(i,e)},this.replaceSelection=this.replaceSelections=function(e){var t=Array.isArray(e)&&e,n=this.ace.selection;if(this.ace.inVirtualSelectionMode)this.ace.session.replace(n.getRange(),t?e[0]||\"\":e);else{n.inVirtualSelectionMode=!0;var r=n.rangeList.ranges;r.length||(r=[this.ace.multiSelect.getRange()]);for(var i=r.length;i--;)this.ace.session.replace(r[i],t?e[i]||\"\":e);n.inVirtualSelectionMode=!1}},this.getSelection=function(){return this.ace.getSelectedText()},this.getSelections=function(){return this.listSelections().map((function(e){return this.getRange(e.anchor,e.head)}),this)},this.getInputField=function(){return this.ace.textInput.getElement()},this.getWrapperElement=function(){return this.ace.container};var t={indentWithTabs:\"useSoftTabs\",indentUnit:\"tabSize\",tabSize:\"tabSize\",firstLineNumber:\"firstLineNumber\",readOnly:\"readOnly\"};this.setOption=function(e,n){switch(this.state[e]=n,e){case\"indentWithTabs\":e=t[e],n=!n;break;case\"keyMap\":return void(this.state.$keyMap=n);default:e=t[e]}e&&this.ace.setOption(e,n)},this.getOption=function(e){var n,r=t[e];switch(r&&(n=this.ace.getOption(r)),e){case\"indentWithTabs\":return e=t[e],!n;case\"keyMap\":return this.state.$keyMap||\"vim\"}return r?n:this.state[e]},this.toggleOverwrite=function(e){return this.state.overwrite=e,this.ace.setOverwrite(e)},this.addOverlay=function(e){if(!this.$searchHighlight||!this.$searchHighlight.session){var t=new h(null,\"ace_highlight-marker\",\"text\"),n=this.ace.session.addDynamicMarker(t);t.id=n.id,t.session=this.ace.session,t.destroy=function(e){t.session.off(\"change\",t.updateOnChange),t.session.off(\"changeEditor\",t.destroy),t.session.removeMarker(t.id),t.session=null},t.updateOnChange=function(e){var n=e.start.row;n==e.end.row?t.cache[n]=void 0:t.cache.splice(n,t.cache.length)},t.session.on(\"changeEditor\",t.destroy),t.session.on(\"change\",t.updateOnChange)}var r=new RegExp(e.query.source,\"gmi\");this.$searchHighlight=e.highlight=t,this.$searchHighlight.setRegexp(r),this.ace.renderer.updateBackMarkers()},this.removeOverlay=function(e){this.$searchHighlight&&this.$searchHighlight.session&&this.$searchHighlight.destroy()},this.getScrollInfo=function(){var e=this.ace.renderer,t=e.layerConfig;return{left:e.scrollLeft,top:e.scrollTop,height:t.maxHeight,width:t.width,clientHeight:t.height,clientWidth:t.width}},this.getValue=function(){return this.ace.getValue()},this.setValue=function(e){return this.ace.setValue(e,-1)},this.getTokenTypeAt=function(e){var t=this.ace.session.getTokenAt(e.line,e.ch);return t&&/comment|string/.test(t.type)?\"string\":\"\"},this.findMatchingBracket=function(e){var t=this.ace.session.findMatchingBracket(g(e));return{to:t&&v(t)}},this.findMatchingTag=function(e){var t=this.ace.session.getMatchingTags(g(e));if(t)return{open:{from:v(t.openTag.start),to:v(t.openTag.end)},close:{from:v(t.closeTag.start),to:v(t.closeTag.end)}}},this.indentLine=function(e,t){!0===t?this.ace.session.indentRows(e,e,\"\\t\"):!1===t&&this.ace.session.outdentRows(new r(e,0,e,0))},this.indexFromPos=function(e){return this.ace.session.doc.positionToIndex(g(e))},this.posFromIndex=function(e){return v(this.ace.session.doc.indexToPosition(e))},this.focus=function(e){return this.ace.textInput.focus()},this.blur=function(e){return this.ace.blur()},this.defaultTextHeight=function(e){return this.ace.renderer.layerConfig.lineHeight},this.scanForBracket=function(e,t,n,r){var i=r.bracketRegex.source,o=/paren|text|operator|tag/;if(1==t)var a=this.ace.session.$findClosingBracket(i.slice(1,2),g(e),o);else!(a=this.ace.session.$findOpeningBracket(i.slice(-2,-1),{row:e.line,column:e.ch+1},o))&&r.bracketRegex&&r.bracketRegex.test(this.getLine(e.line)[e.ch-1])&&(a={row:e.line,column:e.ch-1});return a&&{pos:v(a)}},this.refresh=function(){return this.ace.resize(!0)},this.getMode=function(){return{name:this.getOption(\"mode\")}},this.execCommand=function(e){return m.commands.hasOwnProperty(e)?m.commands[e](this):\"indentAuto\"==e?this.ace.execCommand(\"autoindent\"):void console.log(e+\" is not implemented\")},this.getLineNumber=function(e){var t=this.$lineHandleChanges;if(!t)return null;for(var n=e.row,r=0;r<t.length;r++){var i=t[r];if(i.start.row!=i.end.row)if(\"i\"==i.action[0])i.start.row<n&&(n+=i.end.row-i.start.row);else if(i.start.row<n){if(n<i.end.row||n==i.end.row&&i.start.column>0)return null;n-=i.end.row-i.start.row}}return n},this.getLineHandle=function(e){return this.$lineHandleChanges||(this.$lineHandleChanges=[]),{text:this.ace.session.getLine(e),row:e}},this.releaseLineHandles=function(){this.$lineHandleChanges=void 0},this.getLastEditEnd=function(){var e=this.ace.session.$undoManager;if(e&&e.$lastDelta)return v(e.$lastDelta.end)}}.call(m.prototype),(m.StringStream=function(e,t){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0}).prototype={eol:function(){return this.pos>=this.string.length},sol:function(){return this.pos==this.lineStart},peek:function(){return this.string.charAt(this.pos)||void 0},next:function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},eat:function(e){var t=this.string.charAt(this.pos);if(\"string\"==typeof e)var n=t==e;else n=t&&(e.test?e.test(t):e(t));if(n)return++this.pos,t},eatWhile:function(e){for(var t=this.pos;this.eat(e););return this.pos>t},eatSpace:function(){for(var e=this.pos;/[\\s\\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>e},skipToEnd:function(){this.pos=this.string.length},skipTo:function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},backUp:function(e){this.pos-=e},column:function(){throw\"not implemented\"},indentation:function(){throw\"not implemented\"},match:function(e,t,n){if(\"string\"!=typeof e){var r=this.string.slice(this.pos).match(e);return r&&r.index>0?null:(r&&!1!==t&&(this.pos+=r[0].length),r)}var i=function(e){return n?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},current:function(){return this.string.slice(this.start,this.pos)},hideFirstChars:function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}}},m.defineExtension=function(e,t){m.prototype[e]=t},o.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\",\"vimMode\",!1),function(){function e(e,t,n){var r;return(r=e.ace.container.appendChild(document.createElement(\"div\"))).className=n?\"ace_dialog ace_dialog-bottom\":\"ace_dialog ace_dialog-top\",\"string\"==typeof t?r.innerHTML=t:r.appendChild(t),r}function t(e,t){e.state.currentNotificationClose&&e.state.currentNotificationClose(),e.state.currentNotificationClose=t}m.defineExtension(\"openDialog\",(function(n,r,i){if(!this.virtualSelectionMode()){i||(i={}),t(this,null);var o=e(this,n,i.bottom),a=!1,s=this;this.state.dialog=o;var l,c=o.getElementsByTagName(\"input\")[0];return c?(i.value&&(c.value=i.value,!1!==i.selectValueOnOpen&&c.select()),i.onInput&&m.on(c,\"input\",(function(e){i.onInput(e,c.value,u)})),i.onKeyUp&&m.on(c,\"keyup\",(function(e){i.onKeyUp(e,c.value,u)})),m.on(c,\"keydown\",(function(e){i&&i.onKeyDown&&i.onKeyDown(e,c.value,u)||(13==e.keyCode&&r(c.value),(27==e.keyCode||!1!==i.closeOnEnter&&13==e.keyCode)&&(m.e_stop(e),u()))})),!1!==i.closeOnBlur&&m.on(c,\"blur\",u),c.focus()):(l=o.getElementsByTagName(\"button\")[0])&&(m.on(l,\"click\",(function(){u(),s.focus()})),!1!==i.closeOnBlur&&m.on(l,\"blur\",u),l.focus()),u}function u(e){if(\"string\"==typeof e)c.value=e;else{if(a)return;if(e&&\"blur\"==e.type&&document.activeElement===c)return;s.state.dialog==o&&(s.state.dialog=null,s.focus()),a=!0,o.remove(),i.onClose&&i.onClose(o);var t=s;t.state.vim&&(t.state.vim.status=null,t.ace._signal(\"changeStatus\"),t.ace.renderer.$loop.schedule(t.ace.renderer.CHANGE_CURSOR))}}})),m.defineExtension(\"openNotification\",(function(n,r){if(!this.virtualSelectionMode()){t(this,l);var i,o=e(this,n,r&&r.bottom),a=!1,s=r&&\"undefined\"!==typeof r.duration?r.duration:5e3;return m.on(o,\"click\",(function(e){m.e_preventDefault(e),l()})),s&&(i=setTimeout(l,s)),l}function l(){a||(a=!0,clearTimeout(i),o.remove())}}))}();var y=m.Pos;function C(e,t,n){if(t.line===n.line&&t.ch>=n.ch-1){var r=e.getLine(t.line).charCodeAt(t.ch);55296<=r&&r<=55551&&(n.ch+=1)}return{start:t,end:n}}var w=[{keys:\"<Left>\",type:\"keyToKey\",toKeys:\"h\"},{keys:\"<Right>\",type:\"keyToKey\",toKeys:\"l\"},{keys:\"<Up>\",type:\"keyToKey\",toKeys:\"k\"},{keys:\"<Down>\",type:\"keyToKey\",toKeys:\"j\"},{keys:\"g<Up>\",type:\"keyToKey\",toKeys:\"gk\"},{keys:\"g<Down>\",type:\"keyToKey\",toKeys:\"gj\"},{keys:\"<Space>\",type:\"keyToKey\",toKeys:\"l\"},{keys:\"<BS>\",type:\"keyToKey\",toKeys:\"h\"},{keys:\"<Del>\",type:\"keyToKey\",toKeys:\"x\"},{keys:\"<C-Space>\",type:\"keyToKey\",toKeys:\"W\"},{keys:\"<C-BS>\",type:\"keyToKey\",toKeys:\"B\"},{keys:\"<S-Space>\",type:\"keyToKey\",toKeys:\"w\"},{keys:\"<S-BS>\",type:\"keyToKey\",toKeys:\"b\"},{keys:\"<C-n>\",type:\"keyToKey\",toKeys:\"j\"},{keys:\"<C-p>\",type:\"keyToKey\",toKeys:\"k\"},{keys:\"<C-[>\",type:\"keyToKey\",toKeys:\"<Esc>\"},{keys:\"<C-c>\",type:\"keyToKey\",toKeys:\"<Esc>\"},{keys:\"<C-[>\",type:\"keyToKey\",toKeys:\"<Esc>\",context:\"insert\"},{keys:\"<C-c>\",type:\"keyToKey\",toKeys:\"<Esc>\",context:\"insert\"},{keys:\"<C-Esc>\",type:\"keyToKey\",toKeys:\"<Esc>\"},{keys:\"<C-Esc>\",type:\"keyToKey\",toKeys:\"<Esc>\",context:\"insert\"},{keys:\"s\",type:\"keyToKey\",toKeys:\"cl\",context:\"normal\"},{keys:\"s\",type:\"keyToKey\",toKeys:\"c\",context:\"visual\"},{keys:\"S\",type:\"keyToKey\",toKeys:\"cc\",context:\"normal\"},{keys:\"S\",type:\"keyToKey\",toKeys:\"VdO\",context:\"visual\"},{keys:\"<Home>\",type:\"keyToKey\",toKeys:\"0\"},{keys:\"<End>\",type:\"keyToKey\",toKeys:\"$\"},{keys:\"<PageUp>\",type:\"keyToKey\",toKeys:\"<C-b>\"},{keys:\"<PageDown>\",type:\"keyToKey\",toKeys:\"<C-f>\"},{keys:\"<CR>\",type:\"keyToKey\",toKeys:\"j^\",context:\"normal\"},{keys:\"<Ins>\",type:\"keyToKey\",toKeys:\"i\",context:\"normal\"},{keys:\"<Ins>\",type:\"action\",action:\"toggleOverwrite\",context:\"insert\"},{keys:\"H\",type:\"motion\",motion:\"moveToTopLine\",motionArgs:{linewise:!0,toJumplist:!0}},{keys:\"M\",type:\"motion\",motion:\"moveToMiddleLine\",motionArgs:{linewise:!0,toJumplist:!0}},{keys:\"L\",type:\"motion\",motion:\"moveToBottomLine\",motionArgs:{linewise:!0,toJumplist:!0}},{keys:\"h\",type:\"motion\",motion:\"moveByCharacters\",motionArgs:{forward:!1}},{keys:\"l\",type:\"motion\",motion:\"moveByCharacters\",motionArgs:{forward:!0}},{keys:\"j\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!0,linewise:!0}},{keys:\"k\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!1,linewise:!0}},{keys:\"gj\",type:\"motion\",motion:\"moveByDisplayLines\",motionArgs:{forward:!0}},{keys:\"gk\",type:\"motion\",motion:\"moveByDisplayLines\",motionArgs:{forward:!1}},{keys:\"w\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!1}},{keys:\"W\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!1,bigWord:!0}},{keys:\"e\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!0,inclusive:!0}},{keys:\"E\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!0,wordEnd:!0,bigWord:!0,inclusive:!0}},{keys:\"b\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!1}},{keys:\"B\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!1,bigWord:!0}},{keys:\"ge\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!0,inclusive:!0}},{keys:\"gE\",type:\"motion\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!0,bigWord:!0,inclusive:!0}},{keys:\"{\",type:\"motion\",motion:\"moveByParagraph\",motionArgs:{forward:!1,toJumplist:!0}},{keys:\"}\",type:\"motion\",motion:\"moveByParagraph\",motionArgs:{forward:!0,toJumplist:!0}},{keys:\"(\",type:\"motion\",motion:\"moveBySentence\",motionArgs:{forward:!1}},{keys:\")\",type:\"motion\",motion:\"moveBySentence\",motionArgs:{forward:!0}},{keys:\"<C-f>\",type:\"motion\",motion:\"moveByPage\",motionArgs:{forward:!0}},{keys:\"<C-b>\",type:\"motion\",motion:\"moveByPage\",motionArgs:{forward:!1}},{keys:\"<C-d>\",type:\"motion\",motion:\"moveByScroll\",motionArgs:{forward:!0,explicitRepeat:!0}},{keys:\"<C-u>\",type:\"motion\",motion:\"moveByScroll\",motionArgs:{forward:!1,explicitRepeat:!0}},{keys:\"gg\",type:\"motion\",motion:\"moveToLineOrEdgeOfDocument\",motionArgs:{forward:!1,explicitRepeat:!0,linewise:!0,toJumplist:!0}},{keys:\"G\",type:\"motion\",motion:\"moveToLineOrEdgeOfDocument\",motionArgs:{forward:!0,explicitRepeat:!0,linewise:!0,toJumplist:!0}},{keys:\"g$\",type:\"motion\",motion:\"moveToEndOfDisplayLine\"},{keys:\"g^\",type:\"motion\",motion:\"moveToStartOfDisplayLine\"},{keys:\"g0\",type:\"motion\",motion:\"moveToStartOfDisplayLine\"},{keys:\"0\",type:\"motion\",motion:\"moveToStartOfLine\"},{keys:\"^\",type:\"motion\",motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\"+\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!0,toFirstChar:!0}},{keys:\"-\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!1,toFirstChar:!0}},{keys:\"_\",type:\"motion\",motion:\"moveByLines\",motionArgs:{forward:!0,toFirstChar:!0,repeatOffset:-1}},{keys:\"$\",type:\"motion\",motion:\"moveToEol\",motionArgs:{inclusive:!0}},{keys:\"%\",type:\"motion\",motion:\"moveToMatchedSymbol\",motionArgs:{inclusive:!0,toJumplist:!0}},{keys:\"f<character>\",type:\"motion\",motion:\"moveToCharacter\",motionArgs:{forward:!0,inclusive:!0}},{keys:\"F<character>\",type:\"motion\",motion:\"moveToCharacter\",motionArgs:{forward:!1}},{keys:\"t<character>\",type:\"motion\",motion:\"moveTillCharacter\",motionArgs:{forward:!0,inclusive:!0}},{keys:\"T<character>\",type:\"motion\",motion:\"moveTillCharacter\",motionArgs:{forward:!1}},{keys:\";\",type:\"motion\",motion:\"repeatLastCharacterSearch\",motionArgs:{forward:!0}},{keys:\",\",type:\"motion\",motion:\"repeatLastCharacterSearch\",motionArgs:{forward:!1}},{keys:\"'<register>\",type:\"motion\",motion:\"goToMark\",motionArgs:{toJumplist:!0,linewise:!0}},{keys:\"`<register>\",type:\"motion\",motion:\"goToMark\",motionArgs:{toJumplist:!0}},{keys:\"]`\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!0}},{keys:\"[`\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!1}},{keys:\"]'\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!0,linewise:!0}},{keys:\"['\",type:\"motion\",motion:\"jumpToMark\",motionArgs:{forward:!1,linewise:!0}},{keys:\"]p\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!0,isEdit:!0,matchIndent:!0}},{keys:\"[p\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!1,isEdit:!0,matchIndent:!0}},{keys:\"]<character>\",type:\"motion\",motion:\"moveToSymbol\",motionArgs:{forward:!0,toJumplist:!0}},{keys:\"[<character>\",type:\"motion\",motion:\"moveToSymbol\",motionArgs:{forward:!1,toJumplist:!0}},{keys:\"|\",type:\"motion\",motion:\"moveToColumn\"},{keys:\"o\",type:\"motion\",motion:\"moveToOtherHighlightedEnd\",context:\"visual\"},{keys:\"O\",type:\"motion\",motion:\"moveToOtherHighlightedEnd\",motionArgs:{sameLine:!0},context:\"visual\"},{keys:\"d\",type:\"operator\",operator:\"delete\"},{keys:\"y\",type:\"operator\",operator:\"yank\"},{keys:\"c\",type:\"operator\",operator:\"change\"},{keys:\"=\",type:\"operator\",operator:\"indentAuto\"},{keys:\">\",type:\"operator\",operator:\"indent\",operatorArgs:{indentRight:!0}},{keys:\"<\",type:\"operator\",operator:\"indent\",operatorArgs:{indentRight:!1}},{keys:\"g~\",type:\"operator\",operator:\"changeCase\"},{keys:\"gu\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!0},isEdit:!0},{keys:\"gU\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!1},isEdit:!0},{keys:\"n\",type:\"motion\",motion:\"findNext\",motionArgs:{forward:!0,toJumplist:!0}},{keys:\"N\",type:\"motion\",motion:\"findNext\",motionArgs:{forward:!1,toJumplist:!0}},{keys:\"gn\",type:\"motion\",motion:\"findAndSelectNextInclusive\",motionArgs:{forward:!0}},{keys:\"gN\",type:\"motion\",motion:\"findAndSelectNextInclusive\",motionArgs:{forward:!1}},{keys:\"gq\",type:\"operator\",operator:\"hardWrap\"},{keys:\"gw\",type:\"operator\",operator:\"hardWrap\",operatorArgs:{keepCursor:!0}},{keys:\"x\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveByCharacters\",motionArgs:{forward:!0},operatorMotionArgs:{visualLine:!1}},{keys:\"X\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveByCharacters\",motionArgs:{forward:!1},operatorMotionArgs:{visualLine:!0}},{keys:\"D\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveToEol\",motionArgs:{inclusive:!0},context:\"normal\"},{keys:\"D\",type:\"operator\",operator:\"delete\",operatorArgs:{linewise:!0},context:\"visual\"},{keys:\"Y\",type:\"operatorMotion\",operator:\"yank\",motion:\"expandToLine\",motionArgs:{linewise:!0},context:\"normal\"},{keys:\"Y\",type:\"operator\",operator:\"yank\",operatorArgs:{linewise:!0},context:\"visual\"},{keys:\"C\",type:\"operatorMotion\",operator:\"change\",motion:\"moveToEol\",motionArgs:{inclusive:!0},context:\"normal\"},{keys:\"C\",type:\"operator\",operator:\"change\",operatorArgs:{linewise:!0},context:\"visual\"},{keys:\"~\",type:\"operatorMotion\",operator:\"changeCase\",motion:\"moveByCharacters\",motionArgs:{forward:!0},operatorArgs:{shouldMoveCursor:!0},context:\"normal\"},{keys:\"~\",type:\"operator\",operator:\"changeCase\",context:\"visual\"},{keys:\"<C-u>\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveToStartOfLine\",context:\"insert\"},{keys:\"<C-w>\",type:\"operatorMotion\",operator:\"delete\",motion:\"moveByWords\",motionArgs:{forward:!1,wordEnd:!1},context:\"insert\"},{keys:\"<C-w>\",type:\"idle\",context:\"normal\"},{keys:\"<C-i>\",type:\"action\",action:\"jumpListWalk\",actionArgs:{forward:!0}},{keys:\"<C-o>\",type:\"action\",action:\"jumpListWalk\",actionArgs:{forward:!1}},{keys:\"<C-e>\",type:\"action\",action:\"scroll\",actionArgs:{forward:!0,linewise:!0}},{keys:\"<C-y>\",type:\"action\",action:\"scroll\",actionArgs:{forward:!1,linewise:!0}},{keys:\"a\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"charAfter\"},context:\"normal\"},{keys:\"A\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"eol\"},context:\"normal\"},{keys:\"A\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"endOfSelectedArea\"},context:\"visual\"},{keys:\"i\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"inplace\"},context:\"normal\"},{keys:\"gi\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"lastEdit\"},context:\"normal\"},{keys:\"I\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"firstNonBlank\"},context:\"normal\"},{keys:\"gI\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"bol\"},context:\"normal\"},{keys:\"I\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{insertAt:\"startOfSelectedArea\"},context:\"visual\"},{keys:\"o\",type:\"action\",action:\"newLineAndEnterInsertMode\",isEdit:!0,interlaceInsertRepeat:!0,actionArgs:{after:!0},context:\"normal\"},{keys:\"O\",type:\"action\",action:\"newLineAndEnterInsertMode\",isEdit:!0,interlaceInsertRepeat:!0,actionArgs:{after:!1},context:\"normal\"},{keys:\"v\",type:\"action\",action:\"toggleVisualMode\"},{keys:\"V\",type:\"action\",action:\"toggleVisualMode\",actionArgs:{linewise:!0}},{keys:\"<C-v>\",type:\"action\",action:\"toggleVisualMode\",actionArgs:{blockwise:!0}},{keys:\"<C-q>\",type:\"action\",action:\"toggleVisualMode\",actionArgs:{blockwise:!0}},{keys:\"gv\",type:\"action\",action:\"reselectLastSelection\"},{keys:\"J\",type:\"action\",action:\"joinLines\",isEdit:!0},{keys:\"gJ\",type:\"action\",action:\"joinLines\",actionArgs:{keepSpaces:!0},isEdit:!0},{keys:\"p\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!0,isEdit:!0}},{keys:\"P\",type:\"action\",action:\"paste\",isEdit:!0,actionArgs:{after:!1,isEdit:!0}},{keys:\"r<character>\",type:\"action\",action:\"replace\",isEdit:!0},{keys:\"@<register>\",type:\"action\",action:\"replayMacro\"},{keys:\"q<register>\",type:\"action\",action:\"enterMacroRecordMode\"},{keys:\"R\",type:\"action\",action:\"enterInsertMode\",isEdit:!0,actionArgs:{replace:!0},context:\"normal\"},{keys:\"R\",type:\"operator\",operator:\"change\",operatorArgs:{linewise:!0,fullLine:!0},context:\"visual\",exitVisualBlock:!0},{keys:\"u\",type:\"action\",action:\"undo\",context:\"normal\"},{keys:\"u\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!0},context:\"visual\",isEdit:!0},{keys:\"U\",type:\"operator\",operator:\"changeCase\",operatorArgs:{toLower:!1},context:\"visual\",isEdit:!0},{keys:\"<C-r>\",type:\"action\",action:\"redo\"},{keys:\"m<register>\",type:\"action\",action:\"setMark\"},{keys:'\"<register>',type:\"action\",action:\"setRegister\"},{keys:\"<C-r><register>\",type:\"action\",action:\"insertRegister\",context:\"insert\",isEdit:!0},{keys:\"<C-o>\",type:\"action\",action:\"oneNormalCommand\",context:\"insert\"},{keys:\"zz\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"center\"}},{keys:\"z.\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"center\"},motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\"zt\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"top\"}},{keys:\"z<CR>\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"top\"},motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\"zb\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"bottom\"}},{keys:\"z-\",type:\"action\",action:\"scrollToCursor\",actionArgs:{position:\"bottom\"},motion:\"moveToFirstNonWhiteSpaceCharacter\"},{keys:\".\",type:\"action\",action:\"repeatLastEdit\"},{keys:\"<C-a>\",type:\"action\",action:\"incrementNumberToken\",isEdit:!0,actionArgs:{increase:!0,backtrack:!1}},{keys:\"<C-x>\",type:\"action\",action:\"incrementNumberToken\",isEdit:!0,actionArgs:{increase:!1,backtrack:!1}},{keys:\"<C-t>\",type:\"action\",action:\"indent\",actionArgs:{indentRight:!0},context:\"insert\"},{keys:\"<C-d>\",type:\"action\",action:\"indent\",actionArgs:{indentRight:!1},context:\"insert\"},{keys:\"a<register>\",type:\"motion\",motion:\"textObjectManipulation\"},{keys:\"i<register>\",type:\"motion\",motion:\"textObjectManipulation\",motionArgs:{textObjectInner:!0}},{keys:\"/\",type:\"search\",searchArgs:{forward:!0,querySrc:\"prompt\",toJumplist:!0}},{keys:\"?\",type:\"search\",searchArgs:{forward:!1,querySrc:\"prompt\",toJumplist:!0}},{keys:\"*\",type:\"search\",searchArgs:{forward:!0,querySrc:\"wordUnderCursor\",wholeWordOnly:!0,toJumplist:!0}},{keys:\"#\",type:\"search\",searchArgs:{forward:!1,querySrc:\"wordUnderCursor\",wholeWordOnly:!0,toJumplist:!0}},{keys:\"g*\",type:\"search\",searchArgs:{forward:!0,querySrc:\"wordUnderCursor\",toJumplist:!0}},{keys:\"g#\",type:\"search\",searchArgs:{forward:!1,querySrc:\"wordUnderCursor\",toJumplist:!0}},{keys:\":\",type:\"ex\"}],k=w.length,S=[{name:\"colorscheme\",shortName:\"colo\"},{name:\"map\"},{name:\"imap\",shortName:\"im\"},{name:\"nmap\",shortName:\"nm\"},{name:\"vmap\",shortName:\"vm\"},{name:\"omap\",shortName:\"om\"},{name:\"noremap\",shortName:\"no\"},{name:\"nnoremap\",shortName:\"nn\"},{name:\"vnoremap\",shortName:\"vn\"},{name:\"inoremap\",shortName:\"ino\"},{name:\"onoremap\",shortName:\"ono\"},{name:\"unmap\"},{name:\"mapclear\",shortName:\"mapc\"},{name:\"nmapclear\",shortName:\"nmapc\"},{name:\"vmapclear\",shortName:\"vmapc\"},{name:\"imapclear\",shortName:\"imapc\"},{name:\"omapclear\",shortName:\"omapc\"},{name:\"write\",shortName:\"w\"},{name:\"undo\",shortName:\"u\"},{name:\"redo\",shortName:\"red\"},{name:\"set\",shortName:\"se\"},{name:\"setlocal\",shortName:\"setl\"},{name:\"setglobal\",shortName:\"setg\"},{name:\"sort\",shortName:\"sor\"},{name:\"substitute\",shortName:\"s\",possiblyAsync:!0},{name:\"startinsert\",shortName:\"start\"},{name:\"nohlsearch\",shortName:\"noh\"},{name:\"yank\",shortName:\"y\"},{name:\"delmarks\",shortName:\"delm\"},{name:\"registers\",shortName:\"reg\",excludeFromCommandHistory:!0},{name:\"vglobal\",shortName:\"v\"},{name:\"delete\",shortName:\"d\"},{name:\"join\",shortName:\"j\"},{name:\"normal\",shortName:\"norm\"},{name:\"global\",shortName:\"g\"}],x=le(\"\");function M(e){e.setOption(\"disableInput\",!0),e.setOption(\"showCursorWhenSelecting\",!1),m.signal(e,\"vim-mode-change\",{mode:\"normal\"}),e.on(\"cursorActivity\",bt),J(e),m.on(e.getInputField(),\"paste\",b(e))}function A(e){e.setOption(\"disableInput\",!1),e.off(\"cursorActivity\",bt),m.off(e.getInputField(),\"paste\",b(e)),e.state.vim=null,ht&&clearTimeout(ht)}function b(e){var t=e.state.vim;return t.onPasteFn||(t.onPasteFn=function(){t.insertMode||(e.setCursor(Se(e.getCursor(),0,1)),Ce.enterInsertMode(e,{},t))}),t.onPasteFn}var L,T=/[\\d]/,E=[m.isWordChar,function(e){return e&&!m.isWordChar(e)&&!/\\s/.test(e)}],O=[function(e){return/\\S/.test(e)}],R=[\"<\",\">\"],B=[\"-\",'\"',\".\",\":\",\"_\",\"/\",\"+\"],I=/^\\w$/;try{L=new RegExp(\"^[\\\\p{Lu}]$\",\"u\")}catch($t){L=/^[A-Z]$/}function N(e,t){return t>=e.firstLine()&&t<=e.lastLine()}function K(e){return/^[a-z]$/.test(e)}function P(e){return L.test(e)}function H(e){return/^\\s*$/.test(e)}function _(e){return-1!=\".?!\".indexOf(e)}function $(e,t){for(var n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}var D={};function V(e,t,n,r,i){if(void 0===t&&!i)throw Error(\"defaultValue is required unless callback is provided\");if(n||(n=\"string\"),D[e]={type:n,defaultValue:t,callback:i},r)for(var o=0;o<r.length;o++)D[r[o]]=D[e];t&&W(e,t)}function W(e,t,n,r){var i=D[e],o=(r=r||{}).scope;if(!i)return new Error(\"Unknown option: \"+e);if(\"boolean\"==i.type){if(t&&!0!==t)return new Error(\"Invalid argument: \"+e+\"=\"+t);!1!==t&&(t=!0)}i.callback?(\"local\"!==o&&i.callback(t,void 0),\"global\"!==o&&n&&i.callback(t,n)):(\"local\"!==o&&(i.value=\"boolean\"==i.type?!!t:t),\"global\"!==o&&n&&(n.state.vim.options[e]={value:t}))}function j(e,t,n){var r=D[e],i=(n=n||{}).scope;if(!r)return new Error(\"Unknown option: \"+e);if(r.callback){var o=t&&r.callback(void 0,t);return\"global\"!==i&&void 0!==o?o:\"local\"!==i?r.callback():void 0}return((o=\"global\"!==i&&t&&t.state.vim.options[e])||\"local\"!==i&&r||{}).value}V(\"filetype\",void 0,\"string\",[\"ft\"],(function(e,t){if(void 0!==t){if(void 0===e)return\"null\"==(n=t.getOption(\"mode\"))?\"\":n;var n=\"\"==e?\"null\":e;t.setOption(\"mode\",n)}})),V(\"textwidth\",80,\"number\",[\"tw\"],(function(e,t){if(void 0!==t){if(void 0===e)return t.getOption(\"textwidth\");var n=Math.round(e);n>1&&t.setOption(\"textwidth\",n)}}));var F,U,z=function(){var e=100,t=-1,n=0,r=0,i=new Array(e);function o(o,a){(t+=a)>n?t=n:t<r&&(t=r);var s=i[(e+t)%e];if(s&&!s.find()){var l,c=a>0?1:-1,u=o.getCursor();do{if((s=i[(e+(t+=c))%e])&&(l=s.find())&&!be(u,l))break}while(t<n&&t>r)}return s}return{cachedCursor:void 0,add:function(o,a,s){var l=i[t%e];function c(n){var r=++t%e,a=i[r];a&&a.clear(),i[r]=o.setBookmark(n)}if(l){var u=l.find();u&&!be(u,a)&&c(a)}else c(a);c(s),n=t,(r=t-e+1)<0&&(r=0)},find:function(e,n){var r=t,i=o(e,n);return t=r,i&&i.find()},move:o}},Q=function(e){return e?{changes:e.changes,expectCursorActivityForChange:e.expectCursorActivityForChange}:{changes:[],expectCursorActivityForChange:!1}};function q(){this.latestRegister=void 0,this.isPlaying=!1,this.isRecording=!1,this.replaySearchQueries=[],this.onRecordingDone=void 0,this.lastInsertModeChanges=Q()}function J(e){return e.state.vim||(e.state.vim={inputState:new ce,lastEditInputState:void 0,lastEditActionCommand:void 0,lastHPos:-1,lastHSPos:-1,lastMotion:null,marks:{},insertMode:!1,insertModeReturn:!1,insertModeRepeat:void 0,visualMode:!1,visualLine:!1,visualBlock:!1,lastSelection:null,lastPastedText:null,sel:{},options:{},expectLiteralNext:!1}),e.state.vim}function G(){for(var e in F={searchQuery:null,searchIsReversed:!1,lastSubstituteReplacePart:void 0,jumpList:z(),macroModeState:new q,lastCharacterSearch:{increment:0,forward:!0,selectedCharacter:\"\"},registerController:new pe({}),searchHistoryController:new fe,exCommandHistoryController:new fe},D){var t=D[e];t.value=t.defaultValue}}q.prototype={exitMacroRecordMode:function(){var e=F.macroModeState;e.onRecordingDone&&e.onRecordingDone(),e.onRecordingDone=void 0,e.isRecording=!1},enterMacroRecordMode:function(e,t){var n=F.registerController.getRegister(t);if(n){if(n.clear(),this.latestRegister=t,e.openDialog){var r=st(\"span\",{class:\"cm-vim-message\"},\"recording @\"+t);this.onRecordingDone=e.openDialog(r,null,{bottom:!0})}this.isRecording=!0}}};var X,Z={enterVimMode:M,leaveVimMode:A,buildKeyMap:function(){},getRegisterController:function(){return F.registerController},resetVimGlobalState_:G,getVimGlobalState_:function(){return F},maybeInitVimState_:J,suppressErrorLogging:!1,InsertModeKey:Tt,map:function(e,t,n){kt.map(e,t,n)},unmap:function(e,t){return kt.unmap(e,t)},noremap:function(e,t,n){kt.map(e,t,n,!0)},mapclear:function(e){var t=w.length,n=k,r=w.slice(0,t-n);if(w=w.slice(t-n),e)for(var i=r.length-1;i>=0;i--){var o=r[i];if(e!==o.context)if(o.context)this._mapCommand(o);else{var a=[\"normal\",\"insert\",\"visual\"];for(var s in a)if(a[s]!==e){var l={};for(var c in o)l[c]=o[c];l.context=a[s],this._mapCommand(l)}}}},langmap:se,vimKeyFromEvent:ae,setOption:W,getOption:j,defineOption:V,defineEx:function(e,t,n){if(t){if(0!==e.indexOf(t))throw new Error('(Vim.defineEx) \"'+t+'\" is not a prefix of \"'+e+'\", command not registered')}else t=e;wt[e]=n,kt.commandMap_[t]={name:e,shortName:t,type:\"api\"}},handleKey:function(e,t,n){var r=this.findKey(e,t,n);if(\"function\"===typeof r)return r()},multiSelectHandleKey:Pt,findKey:function(e,t,n){var r,i=J(e);function o(){var r=F.macroModeState;if(r.isRecording){if(\"q\"==t)return r.exitMacroRecordMode(),ue(e),!0;\"mapping\"!=n&&function(e,t){if(e.isPlaying)return;var n=e.latestRegister,r=F.registerController.getRegister(n);r&&r.pushText(t)}(r,t)}}function a(){if(\"<Esc>\"==t){if(i.visualMode)$e(e);else{if(!i.insertMode)return;St(e)}return ue(e),!0}}return!1===(r=i.insertMode?function(){if(a())return!0;i.inputState.keyBuffer.push(t);var n=i.inputState.keyBuffer.join(\"\"),r=1==t.length,o=me.matchCommand(n,w,i.inputState,\"insert\"),s=i.inputState.changeQueue;if(\"none\"==o.type)return ue(e),!1;if(\"partial\"==o.type){if(o.expectLiteralNext&&(i.expectLiteralNext=!0),U&&window.clearTimeout(U),U=r&&window.setTimeout((function(){i.insertMode&&i.inputState.keyBuffer.length&&ue(e)}),j(\"insertModeEscKeysTimeout\")),r){var l=e.listSelections();s&&s.removed.length==l.length||(s=i.inputState.changeQueue=new he),s.inserted+=t;for(var c=0;c<l.length;c++){var u=Te(l[c].anchor,l[c].head),h=Ee(l[c].anchor,l[c].head),d=e.getRange(u,e.state.overwrite?Se(h,0,1):h);s.removed[c]=(s.removed[c]||\"\")+d}}return!r}if(i.expectLiteralNext=!1,U&&window.clearTimeout(U),o.command&&s){for(l=e.listSelections(),c=0;c<l.length;c++){var p=l[c].head;e.replaceRange(s.removed[c]||\"\",Se(p,0,-s.inserted.length),p,\"+input\")}F.macroModeState.lastInsertModeChanges.changes.pop()}return o.command||ue(e),o.command}():function(){if(o()||a())return!0;i.inputState.keyBuffer.push(t);var n=i.inputState.keyBuffer.join(\"\");if(/^[1-9]\\d*$/.test(n))return!0;var r=/^(\\d*)(.*)$/.exec(n);if(!r)return ue(e),!1;var s=i.visualMode?\"visual\":\"normal\",l=r[2]||r[1];i.inputState.operatorShortcut&&i.inputState.operatorShortcut.slice(-1)==l&&(l=i.inputState.operatorShortcut);var c=me.matchCommand(l,w,i.inputState,s);return\"none\"==c.type?(ue(e),!1):\"partial\"==c.type?(c.expectLiteralNext&&(i.expectLiteralNext=!0),!0):\"clear\"==c.type?(ue(e),!0):(i.expectLiteralNext=!1,i.inputState.keyBuffer.length=0,(r=/^(\\d*)(.*)$/.exec(n))[1]&&\"0\"!=r[1]&&i.inputState.pushRepeatDigit(r[1]),c.command)}())?i.insertMode||1!==t.length?void 0:function(){return!0}:!0===r?function(){return!0}:function(){if(!r.operator&&!r.isEdit||!e.getOption(\"readOnly\"))return e.operation((function(){e.curOp.isVimOp=!0;try{\"keyToKey\"==r.type?ne(e,r.toKeys,r):me.processCommand(e,i,r)}catch(t){throw e.state.vim=void 0,J(e),Z.suppressErrorLogging||console.log(t),t}return!0}))}},handleEx:function(e,t){kt.processCommand(e,t)},defineMotion:function(e,t){ge[e]=t},defineAction:function(e,t){Ce[e]=t},defineOperator:function(e,t){ye[e]=t},mapCommand:function(e,t,n,r,i){var o={keys:e,type:t};for(var a in o[t]=n,o[t+\"Args\"]=r,i)o[a]=i[a];xt(o)},_mapCommand:xt,defineRegister:function(e,t){var n=F.registerController.registers;if(!e||1!=e.length)throw Error(\"Register name must be 1 character\");n[e]=t,B.push(e)},exitVisualMode:$e,exitInsertMode:St},Y=[],ee=!1;function te(e){if(\"<\"==e[0]){var t=e.toLowerCase().slice(1,-1),n=t.split(\"-\");if(\"lt\"==(t=n.pop()||\"\"))e=\"<\";else if(\"space\"==t)e=\" \";else if(\"cr\"==t)e=\"\\n\";else if(oe[t]){var r=X.value,i={key:oe[t],target:{value:r,selectionEnd:r.length,selectionStart:r.length}};return X.onKeyDown&&X.onKeyDown(i,X.value,a),void(X&&X.onKeyUp&&X.onKeyUp(i,X.value,a))}}if(\"\\n\"==e){var o=X;X=null,o.onClose&&o.onClose(o.value)}else X.value=(X.value||\"\")+e;function a(e){\"string\"==typeof e?X.value=e:X=null}}function ne(e,t,n){var r=ee;if(n){if(-1!=Y.indexOf(n))return;Y.push(n),ee=0!=n.noremap}try{for(var i,o=J(e),a=/<(?:[CSMA]-)*\\w+>|./gi;i=a.exec(t);){var s=i[0],l=o.insertMode;if(X)te(s);else if(!Z.handleKey(e,s,\"mapping\")&&l&&o.insertMode){if(\"<\"==s[0]){var c=s.toLowerCase().slice(1,-1),u=c.split(\"-\");if(\"lt\"==(c=u.pop()||\"\"))s=\"<\";else if(\"space\"==c)s=\" \";else if(\"cr\"==c)s=\"\\n\";else{if(oe.hasOwnProperty(c)){Rt(e,s=oe[c]);continue}s=s[0],a.lastIndex=i.index+1}}e.replaceSelection(s)}}}finally{if(Y.pop(),ee=!!Y.length&&r,!Y.length&&X){var h=X;X=null,ct(e,h)}}}var re={Return:\"CR\",Backspace:\"BS\",Delete:\"Del\",Escape:\"Esc\",Insert:\"Ins\",ArrowLeft:\"Left\",ArrowRight:\"Right\",ArrowUp:\"Up\",ArrowDown:\"Down\",Enter:\"CR\",\" \":\"Space\"},ie={Shift:1,Alt:1,Command:1,Control:1,CapsLock:1,AltGraph:1,Dead:1,Unidentified:1},oe={};function ae(e,t){var n=e.key;if(!ie[n]){n.length>1&&\"n\"==n[0]&&(n=n.replace(\"Numpad\",\"\")),n=re[n]||n;var r=\"\";if(e.ctrlKey&&(r+=\"C-\"),e.altKey&&(r+=\"A-\"),e.metaKey&&(r+=\"M-\"),m.isMac&&e.altKey&&!e.metaKey&&!e.ctrlKey&&(r=r.slice(2)),(r||n.length>1)&&e.shiftKey&&(r+=\"S-\"),t&&!t.expectLiteralNext&&1==n.length)if(x.keymap&&n in x.keymap)0==x.remapCtrl&&r||(n=x.keymap[n]);else if(n.charCodeAt(0)>255){var i=e.code&&e.code.slice(-1)||\"\";e.shiftKey||(i=i.toLowerCase()),i&&(n=i)}return(r+=n).length>1&&(r=\"<\"+r+\">\"),r}}function se(e,t){x.string!==e&&(x=le(e)),x.remapCtrl=t}function le(e){var t={};if(!e)return{keymap:t,string:\"\"};function n(e){return e.split(/\\\\?(.)/).filter(Boolean)}return e.split(/((?:[^\\\\,]|\\\\.)+),/).map((function(e){if(e){var r=e.split(/((?:[^\\\\;]|\\\\.)+);/);if(3==r.length){var i=n(r[1]),o=n(r[2]);if(i.length!==o.length)return;for(var a=0;a<i.length;++a)t[i[a]]=o[a]}else if(1==r.length){var s=n(e);if(s.length%2!==0)return;for(a=0;a<s.length;a+=2)t[s[a]]=s[a+1]}}})),{keymap:t,string:e}}function ce(){this.prefixRepeat=[],this.motionRepeat=[],this.operator=null,this.operatorArgs=null,this.motion=null,this.motionArgs=null,this.keyBuffer=[],this.registerName=null,this.changeQueue=null}function ue(e,t){e.state.vim.inputState=new ce,e.state.vim.expectLiteralNext=!1,m.signal(e,\"vim-command-done\",t)}function he(){this.removed=[],this.inserted=\"\"}function de(e,t,n){this.clear(),this.keyBuffer=[e||\"\"],this.insertModeChanges=[],this.searchQueries=[],this.linewise=!!t,this.blockwise=!!n}function pe(e){this.registers=e,this.unnamedRegister=e['\"']=new de,e[\".\"]=new de,e[\":\"]=new de,e[\"/\"]=new de,e[\"+\"]=new de}function fe(){this.historyBuffer=[],this.iterator=0,this.initialPrefix=null}\"Left|Right|Up|Down|End|Home\".split(\"|\").concat(Object.keys(re)).forEach((function(e){oe[(re[e]||\"\").toLowerCase()]=oe[e.toLowerCase()]=e})),V(\"langmap\",void 0,\"string\",[\"lmap\"],(function(e,t){if(void 0===e)return x.string;se(e)})),ce.prototype.pushRepeatDigit=function(e){this.operator?this.motionRepeat=this.motionRepeat.concat(e):this.prefixRepeat=this.prefixRepeat.concat(e)},ce.prototype.getRepeat=function(){var e=0;return(this.prefixRepeat.length>0||this.motionRepeat.length>0)&&(e=1,this.prefixRepeat.length>0&&(e*=parseInt(this.prefixRepeat.join(\"\"),10)),this.motionRepeat.length>0&&(e*=parseInt(this.motionRepeat.join(\"\"),10))),e},de.prototype={setText:function(e,t,n){this.keyBuffer=[e||\"\"],this.linewise=!!t,this.blockwise=!!n},pushText:function(e,t){t&&(this.linewise||this.keyBuffer.push(\"\\n\"),this.linewise=!0),this.keyBuffer.push(e)},pushInsertModeChanges:function(e){this.insertModeChanges.push(Q(e))},pushSearchQuery:function(e){this.searchQueries.push(e)},clear:function(){this.keyBuffer=[],this.insertModeChanges=[],this.searchQueries=[],this.linewise=!1},toString:function(){return this.keyBuffer.join(\"\")}},pe.prototype={pushText:function(e,t,n,r,i){if(\"_\"!==e){r&&\"\\n\"!==n.charAt(n.length-1)&&(n+=\"\\n\");var o=this.isValidRegister(e)?this.getRegister(e):null;if(o){P(e)?o.pushText(n,r):o.setText(n,r,i),\"+\"===e&&\"undefined\"!==typeof navigator&&\"undefined\"!==typeof navigator.clipboard&&\"function\"===typeof navigator.clipboard.readText&&navigator.clipboard.writeText(n),this.unnamedRegister.setText(o.toString(),r)}else{switch(t){case\"yank\":this.registers[0]=new de(n,r,i);break;case\"delete\":case\"change\":-1==n.indexOf(\"\\n\")?this.registers[\"-\"]=new de(n,r):(this.shiftNumericRegisters_(),this.registers[1]=new de(n,r))}this.unnamedRegister.setText(n,r,i)}}},getRegister:function(e){return this.isValidRegister(e)?(e=e.toLowerCase(),this.registers[e]||(this.registers[e]=new de),this.registers[e]):this.unnamedRegister},isValidRegister:function(e){return e&&($(e,B)||I.test(e))},shiftNumericRegisters_:function(){for(var e=9;e>=2;e--)this.registers[e]=this.getRegister(\"\"+(e-1))}},fe.prototype={nextMatch:function(e,t){var n=this.historyBuffer,r=t?-1:1;null===this.initialPrefix&&(this.initialPrefix=e);for(var i=this.iterator+r;t?i>=0:i<n.length;i+=r)for(var o=n[i],a=0;a<=o.length;a++)if(this.initialPrefix==o.substring(0,a))return this.iterator=i,o;return i>=n.length?(this.iterator=n.length,this.initialPrefix):i<0?e:void 0},pushInput:function(e){var t=this.historyBuffer.indexOf(e);t>-1&&this.historyBuffer.splice(t,1),e.length&&this.historyBuffer.push(e)},reset:function(){this.initialPrefix=null,this.iterator=this.historyBuffer.length}};var me={matchCommand:function(e,t,n,r){var i,o=function(e,t,n,r){r.operator&&(n=\"operatorPending\");for(var i,o=[],a=[],s=ee?t.length-k:0;s<t.length;s++){var l=t[s];\"insert\"==n&&\"insert\"!=l.context||l.context&&l.context!=n||r.operator&&\"action\"==l.type||!(i=xe(e,l.keys))||(\"partial\"==i&&o.push(l),\"full\"==i&&a.push(l))}return{partial:o.length&&o,full:a.length&&a}}(e,t,r,n);if(!o.full&&!o.partial)return{type:\"none\"};if(!o.full&&o.partial)return{type:\"partial\",expectLiteralNext:1==o.partial.length&&\"<character>\"==o.partial[0].keys.slice(-11)};for(var a=0;a<o.full.length;a++){var s=o.full[a];i||(i=s)}if(\"<character>\"==i.keys.slice(-11)||\"<register>\"==i.keys.slice(-10)){var l=function(e){var t=/^.*(<[^>]+>)$/.exec(e),n=t?t[1]:e.slice(-1);if(n.length>1)switch(n){case\"<CR>\":n=\"\\n\";break;case\"<Space>\":n=\" \";break;default:n=\"\"}return n}(e);if(!l||l.length>1)return{type:\"clear\"};n.selectedCharacter=l}return{type:\"full\",command:i}},processCommand:function(e,t,n){switch(t.inputState.repeatOverride=n.repeatOverride,n.type){case\"motion\":this.processMotion(e,t,n);break;case\"operator\":this.processOperator(e,t,n);break;case\"operatorMotion\":this.processOperatorMotion(e,t,n);break;case\"action\":this.processAction(e,t,n);break;case\"search\":this.processSearch(e,t,n);break;case\"ex\":case\"keyToEx\":this.processEx(e,t,n)}},processMotion:function(e,t,n){t.inputState.motion=n.motion,t.inputState.motionArgs=ke(n.motionArgs),this.evalInput(e,t)},processOperator:function(e,t,n){var r=t.inputState;if(r.operator){if(r.operator==n.operator)return r.motion=\"expandToLine\",r.motionArgs={linewise:!0},void this.evalInput(e,t);ue(e)}r.operator=n.operator,r.operatorArgs=ke(n.operatorArgs),n.keys.length>1&&(r.operatorShortcut=n.keys),n.exitVisualBlock&&(t.visualBlock=!1,He(e)),t.visualMode&&this.evalInput(e,t)},processOperatorMotion:function(e,t,n){var r=t.visualMode,i=ke(n.operatorMotionArgs);i&&r&&i.visualLine&&(t.visualLine=!0),this.processOperator(e,t,n),r||this.processMotion(e,t,n)},processAction:function(e,t,n){var r=t.inputState,i=r.getRepeat(),o=!!i,a=ke(n.actionArgs)||{};r.selectedCharacter&&(a.selectedCharacter=r.selectedCharacter),n.operator&&this.processOperator(e,t,n),n.motion&&this.processMotion(e,t,n),(n.motion||n.operator)&&this.evalInput(e,t),a.repeat=i||1,a.repeatIsExplicit=o,a.registerName=r.registerName,ue(e),t.lastMotion=null,n.isEdit&&this.recordLastEdit(t,r,n),Ce[n.action](e,a,t)},processSearch:function(e,t,n){if(e.getSearchCursor){var r=n.searchArgs.forward,i=n.searchArgs.wholeWordOnly;tt(e).setReversed(!r);var o=r?\"/\":\"?\",a=tt(e).getQuery(),s=e.getScrollInfo();switch(n.searchArgs.querySrc){case\"prompt\":var l=F.macroModeState;if(l.isPlaying)d(h=l.replaySearchQueries.shift(),!0,!1);else ct(e,{onClose:function(e){d(e,!0,!0);var t=F.macroModeState;t.isRecording&&function(e,t){if(!e.isPlaying){var n=e.latestRegister,r=F.registerController.getRegister(n);r&&r.pushSearchQuery&&r.pushSearchQuery(t)}}(t,e)},prefix:o,desc:\"(JavaScript regexp)\",onKeyUp:function(t,n,i){var o,a,l,c=ae(t);\"<Up>\"==c||\"<Down>\"==c?(o=\"<Up>\"==c,a=t.target?t.target.selectionEnd:0,i(n=F.searchHistoryController.nextMatch(n,o)||\"\"),a&&t.target&&(t.target.selectionEnd=t.target.selectionStart=Math.min(a,t.target.value.length))):c&&\"<Left>\"!=c&&\"<Right>\"!=c&&F.searchHistoryController.reset();try{l=ut(e,n,!0,!0)}catch(t){}l?e.scrollIntoView(pt(e,!r,l),30):(ft(e),e.scrollTo(s.left,s.top))},onKeyDown:function(t,n,r){var i=ae(t);\"<Esc>\"==i||\"<C-c>\"==i||\"<C-[>\"==i||\"<BS>\"==i&&\"\"==n?(F.searchHistoryController.pushInput(n),F.searchHistoryController.reset(),ut(e,a),ft(e),e.scrollTo(s.left,s.top),m.e_stop(t),ue(e),r(),e.focus()):\"<Up>\"==i||\"<Down>\"==i?m.e_stop(t):\"<C-u>\"==i&&(m.e_stop(t),r(\"\"))}});break;case\"wordUnderCursor\":var c=Ve(e,{noSymbol:!0}),u=!0;if(c||(c=Ve(e,{noSymbol:!1}),u=!1),!c)return lt(e,\"No word under cursor\"),void ue(e);var h=e.getLine(c.start.line).substring(c.start.ch,c.end.ch);h=u&&i?\"\\\\b\"+h+\"\\\\b\":h.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g,\"\\\\$1\"),F.jumpList.cachedCursor=e.getCursor(),e.setCursor(c.start),d(h,!0,!1)}}function d(r,i,o){F.searchHistoryController.pushInput(r),F.searchHistoryController.reset();try{ut(e,r,i,o)}catch(a){return lt(e,\"Invalid regex: \"+r),void ue(e)}me.processMotion(e,t,{type:\"motion\",motion:\"findNext\",motionArgs:{forward:!0,toJumplist:n.searchArgs.toJumplist}})}},processEx:function(e,t,n){function r(t){F.exCommandHistoryController.pushInput(t),F.exCommandHistoryController.reset(),kt.processCommand(e,t),e.state.vim&&ue(e)}function i(t,n,r){var i,o,a=ae(t);(\"<Esc>\"==a||\"<C-c>\"==a||\"<C-[>\"==a||\"<BS>\"==a&&\"\"==n)&&(F.exCommandHistoryController.pushInput(n),F.exCommandHistoryController.reset(),m.e_stop(t),ue(e),r(),e.focus()),\"<Up>\"==a||\"<Down>\"==a?(m.e_stop(t),i=\"<Up>\"==a,o=t.target?t.target.selectionEnd:0,r(n=F.exCommandHistoryController.nextMatch(n,i)||\"\"),o&&t.target&&(t.target.selectionEnd=t.target.selectionStart=Math.min(o,t.target.value.length))):\"<C-u>\"==a?(m.e_stop(t),r(\"\")):a&&\"<Left>\"!=a&&\"<Right>\"!=a&&F.exCommandHistoryController.reset()}\"keyToEx\"==n.type?kt.processCommand(e,n.exArgs.input):t.visualMode?ct(e,{onClose:r,prefix:\":\",value:\"'<,'>\",onKeyDown:i,selectValueOnOpen:!1}):ct(e,{onClose:r,prefix:\":\",onKeyDown:i})},evalInput:function(e,t){var n,r,i,o=t.inputState,a=o.motion,s=o.motionArgs||{},l=o.operator,c=o.operatorArgs||{},u=o.registerName,h=t.sel,d=Ae(t.visualMode?we(e,h.head):e.getCursor(\"head\")),p=Ae(t.visualMode?we(e,h.anchor):e.getCursor(\"anchor\")),f=Ae(d),m=Ae(p);if(l&&this.recordLastEdit(t,o),(i=void 0!==o.repeatOverride?o.repeatOverride:o.getRepeat())>0&&s.explicitRepeat?s.repeatIsExplicit=!0:(s.noRepeat||!s.explicitRepeat&&0===i)&&(i=1,s.repeatIsExplicit=!1),o.selectedCharacter&&(s.selectedCharacter=c.selectedCharacter=o.selectedCharacter),s.repeat=i,ue(e),a){var g=ge[a](e,d,s,t,o);if(t.lastMotion=ge[a],!g)return;if(s.toJumplist){l||null==e.ace.curOp||(e.ace.curOp.command.scrollIntoView=\"center-animate\");var v=F.jumpList,w=v.cachedCursor;w?(We(e,w,g),delete v.cachedCursor):We(e,d,g)}g instanceof Array?(r=g[0],n=g[1]):n=g,n||(n=Ae(d)),t.visualMode?(t.visualBlock&&n.ch===1/0||(n=we(e,n,f)),r&&(r=we(e,r)),r=r||m,h.anchor=r,h.head=n,He(e),Je(e,t,\"<\",Le(r,n)?r:n),Je(e,t,\">\",Le(r,n)?n:r)):l||(e.ace.curOp&&(e.ace.curOp.vimDialogScroll=\"center-animate\"),n=we(e,n,f),e.setCursor(n.line,n.ch))}if(l){if(c.lastSel){r=m;var k=c.lastSel,S=Math.abs(k.head.line-k.anchor.line),x=Math.abs(k.head.ch-k.anchor.ch);n=k.visualLine?new y(m.line+S,m.ch):k.visualBlock?new y(m.line+S,m.ch+x):k.head.line==k.anchor.line?new y(m.line,m.ch+x):new y(m.line+S,m.ch),t.visualMode=!0,t.visualLine=k.visualLine,t.visualBlock=k.visualBlock,h=t.sel={anchor:r,head:n},He(e)}else t.visualMode&&(c.lastSel={anchor:Ae(h.anchor),head:Ae(h.head),visualBlock:t.visualBlock,visualLine:t.visualLine});var M,A,b,L,T;if(t.visualMode){if(M=Te(h.head,h.anchor),A=Ee(h.head,h.anchor),b=t.visualLine||c.linewise,L=t.visualBlock?\"block\":b?\"line\":\"char\",T=_e(e,{anchor:(B=C(e,M,A)).start,head:B.end},L),b){var E=T.ranges;if(\"block\"==L)for(var O=0;O<E.length;O++)E[O].head.ch=Re(e,E[O].head.line);else\"line\"==L&&(E[0].head=new y(E[0].head.line+1,0))}}else{if(M=Ae(r||m),Le(A=Ae(n||f),M)){var R=M;M=A,A=R}(b=s.linewise||c.linewise)?function(e,t,n){t.ch=0,n.ch=0,n.line++}(0,M,A):s.forward&&function(e,t,n){var r=e.getRange(t,n);if(/\\n\\s*$/.test(r)){var i=r.split(\"\\n\");i.pop();for(var o=i.pop();i.length>0&&o&&H(o);o=i.pop())n.line--,n.ch=0;o?(n.line--,n.ch=Re(e,n.line)):n.ch=0}}(e,M,A),L=\"char\";var B,I=!s.inclusive||b;T=_e(e,{anchor:(B=C(e,M,A)).start,head:B.end},L,I)}e.setSelections(T.ranges,T.primary),t.lastMotion=null,c.repeat=i,c.registerName=u,c.linewise=b;var N=ye[l](e,c,T.ranges,m,n);t.visualMode&&$e(e,null!=N),N&&e.setCursor(N)}},recordLastEdit:function(e,t,n){var r=F.macroModeState;r.isPlaying||(e.lastEditInputState=t,e.lastEditActionCommand=n,r.lastInsertModeChanges.changes=[],r.lastInsertModeChanges.expectCursorActivityForChange=!1,r.lastInsertModeChanges.visualBlock=e.visualBlock?e.sel.head.line-e.sel.anchor.line:0)}},ge={moveToTopLine:function(e,t,n){var r=gt(e).top+n.repeat-1;return new y(r,De(e.getLine(r)))},moveToMiddleLine:function(e){var t=gt(e),n=Math.floor(.5*(t.top+t.bottom));return new y(n,De(e.getLine(n)))},moveToBottomLine:function(e,t,n){var r=gt(e).bottom-n.repeat+1;return new y(r,De(e.getLine(r)))},expandToLine:function(e,t,n){return new y(t.line+n.repeat-1,1/0)},findNext:function(e,t,n){var r=tt(e),i=r.getQuery();if(i){var o=!n.forward;return o=r.isReversed()?!o:o,dt(e,i),pt(e,o,i,n.repeat)}},findAndSelectNextInclusive:function(e,t,n,r,i){var o=tt(e),a=o.getQuery();if(a){var s=!n.forward,l=function(e,t,n,r,i){void 0===r&&(r=1);return e.operation((function(){var o=e.getCursor(),a=e.getSearchCursor(n,o),s=a.find(!t);!i.visualMode&&s&&be(a.from(),o)&&a.find(!t);for(var l=0;l<r;l++)if(!(s=a.find(t))&&!(a=e.getSearchCursor(n,t?new y(e.lastLine()):new y(e.firstLine(),0))).find(t))return;return[a.from(),a.to()]}))}(e,s=o.isReversed()?!s:s,a,n.repeat,r);if(l){if(i.operator)return l;var c=l[0],u=new y(l[1].line,l[1].ch-1);if(r.visualMode){(r.visualLine||r.visualBlock)&&(r.visualLine=!1,r.visualBlock=!1,m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:\"\"}));var h=r.sel.anchor;if(h)return o.isReversed()?n.forward?[h,c]:[h,u]:n.forward?[h,u]:[h,c]}else r.visualMode=!0,r.visualLine=!1,r.visualBlock=!1,m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:\"\"});return s?[u,c]:[c,u]}}},goToMark:function(e,t,n,r){var i=vt(e,r,n.selectedCharacter);return i?n.linewise?{line:i.line,ch:De(e.getLine(i.line))}:i:null},moveToOtherHighlightedEnd:function(e,t,n,r){if(r.visualBlock&&n.sameLine){var i=r.sel;return[we(e,new y(i.anchor.line,i.head.ch)),we(e,new y(i.head.line,i.anchor.ch))]}return[r.sel.head,r.sel.anchor]},jumpToMark:function(e,t,n,r){for(var i=t,o=0;o<n.repeat;o++){var a=i;for(var s in r.marks)if(K(s)){var l=r.marks[s].find();if(!(n.forward?Le(l,a):Le(a,l))&&(!n.linewise||l.line!=a.line)){var c=be(a,i),u=n.forward?Oe(a,l,i):Oe(i,l,a);(c||u)&&(i=l)}}}return n.linewise&&(i=new y(i.line,De(e.getLine(i.line)))),i},moveByCharacters:function(e,t,n){var r=t,i=n.repeat,o=n.forward?r.ch+i:r.ch-i;return new y(r.line,o)},moveByLines:function(e,t,n,r){var i=t,o=i.ch;switch(r.lastMotion){case this.moveByLines:case this.moveByDisplayLines:case this.moveByScroll:case this.moveToColumn:case this.moveToEol:o=r.lastHPos;break;default:r.lastHPos=o}var a=n.repeat+(n.repeatOffset||0),s=n.forward?i.line+a:i.line-a,l=e.firstLine(),c=e.lastLine();if(s<l&&i.line==l)return this.moveToStartOfLine(e,t,n,r);if(s>c&&i.line==c)return Qe(e,t,n,r,!0);var u=e.ace.session.getFoldLine(s);return u&&(n.forward?s>u.start.row&&(s=u.end.row+1):s=u.start.row),n.toFirstChar&&(o=De(e.getLine(s)),r.lastHPos=o),r.lastHSPos=e.charCoords(new y(s,o),\"div\").left,new y(s,o)},moveByDisplayLines:function(e,t,n,r){var i=t;switch(r.lastMotion){case this.moveByDisplayLines:case this.moveByScroll:case this.moveByLines:case this.moveToColumn:case this.moveToEol:break;default:r.lastHSPos=e.charCoords(i,\"div\").left}var o=n.repeat;if((s=e.findPosV(i,n.forward?o:-o,\"line\",r.lastHSPos)).hitSide)if(n.forward)var a={top:e.charCoords(s,\"div\").top+8,left:r.lastHSPos},s=e.coordsChar(a,\"div\");else{var l=e.charCoords(new y(e.firstLine(),0),\"div\");l.left=r.lastHSPos,s=e.coordsChar(l,\"div\")}return r.lastHPos=s.ch,s},moveByPage:function(e,t,n){var r=t,i=n.repeat;return e.findPosV(r,n.forward?i:-i,\"page\")},moveByParagraph:function(e,t,n){var r=n.forward?1:-1;return Xe(e,t,n.repeat,r)},moveBySentence:function(e,t,n){var r=n.forward?1:-1;return function(e,t,n,r){function i(e,t){if(t.pos+t.dir<0||t.pos+t.dir>=t.line.length){if(t.ln+=t.dir,!N(e,t.ln))return t.line=null,t.ln=null,void(t.pos=null);t.line=e.getLine(t.ln),t.pos=t.dir>0?0:t.line.length-1}else t.pos+=t.dir}function o(e,t,n,r){var o=\"\"===(c=e.getLine(t)),a={line:c,ln:t,pos:n,dir:r},s={ln:a.ln,pos:a.pos},l=\"\"===a.line;for(i(e,a);null!==a.line;){if(s.ln=a.ln,s.pos=a.pos,\"\"===a.line&&!l)return{ln:a.ln,pos:a.pos};if(o&&\"\"!==a.line&&!H(a.line[a.pos]))return{ln:a.ln,pos:a.pos};!_(a.line[a.pos])||o||a.pos!==a.line.length-1&&!H(a.line[a.pos+1])||(o=!0),i(e,a)}var c=e.getLine(s.ln);s.pos=0;for(var u=c.length-1;u>=0;--u)if(!H(c[u])){s.pos=u;break}return s}function a(e,t,n,r){var o={line:l=e.getLine(t),ln:t,pos:n,dir:r},a={ln:o.ln,pos:null},s=\"\"===o.line;for(i(e,o);null!==o.line;){if(\"\"===o.line&&!s)return null!==a.pos?a:{ln:o.ln,pos:o.pos};if(_(o.line[o.pos])&&null!==a.pos&&(o.ln!==a.ln||o.pos+1!==a.pos))return a;\"\"===o.line||H(o.line[o.pos])||(s=!1,a={ln:o.ln,pos:o.pos}),i(e,o)}var l=e.getLine(a.ln);a.pos=0;for(var c=0;c<l.length;++c)if(!H(l[c])){a.pos=c;break}return a}var s={ln:t.line,pos:t.ch};for(;n>0;)s=r<0?a(e,s.ln,s.pos,r):o(e,s.ln,s.pos,r),n--;return new y(s.ln,s.pos)}(e,t,n.repeat,r)},moveByScroll:function(e,t,n,r){var i,o=e.getScrollInfo(),a=n.repeat;a||(a=o.clientHeight/(2*e.defaultTextHeight()));var s=e.charCoords(t,\"local\");if(n.repeat=a,!(i=ge.moveByDisplayLines(e,t,n,r)))return null;var l=e.charCoords(i,\"local\");return e.scrollTo(null,o.top+l.top-s.top),i},moveByWords:function(e,t,n){return function(e,t,n,r,i,o){var a=Ae(t),s=[];(r&&!i||!r&&i)&&n++;for(var l=!(r&&i),c=0;c<n;c++){var u=ze(e,t,r,o,l);if(!u){var h=Re(e,e.lastLine());s.push(r?{line:e.lastLine(),from:h,to:h}:{line:0,from:0,to:0});break}s.push(u),t=new y(u.line,r?u.to-1:u.from)}var d=s.length!=n,p=s[0],f=s.pop();return r&&!i?(d||p.from==a.ch&&p.line==a.line||(f=s.pop()),new y(f.line,f.from)):r&&i?new y(f.line,f.to-1):!r&&i?(d||p.to==a.ch&&p.line==a.line||(f=s.pop()),new y(f.line,f.to)):new y(f.line,f.from)}(e,t,n.repeat,!!n.forward,!!n.wordEnd,!!n.bigWord)},moveTillCharacter:function(e,t,n){var r=qe(e,n.repeat,n.forward,n.selectedCharacter,t),i=n.forward?-1:1;return je(i,n),r?(r.ch+=i,r):null},moveToCharacter:function(e,t,n){var r=n.repeat;return je(0,n),qe(e,r,n.forward,n.selectedCharacter,t)||t},moveToSymbol:function(e,t,n){return function(e,t,n,r){var i=Ae(e.getCursor()),o=n?1:-1,a=n?e.lineCount():-1,s=i.ch,l=i.line,c=e.getLine(l),u={lineText:c,nextCh:c.charAt(s),lastCh:null,index:s,symb:r,reverseSymb:(n?{\")\":\"(\",\"}\":\"{\"}:{\"(\":\")\",\"{\":\"}\"})[r],forward:n,depth:0,curMoveThrough:!1},h=Fe[r];if(!h)return i;var d=Ue[h].init,p=Ue[h].isComplete;d&&d(u);for(;l!==a&&t;){if(u.index+=o,u.nextCh=u.lineText.charAt(u.index),!u.nextCh){if(l+=o,u.lineText=e.getLine(l)||\"\",o>0)u.index=0;else{var f=u.lineText.length;u.index=f>0?f-1:0}u.nextCh=u.lineText.charAt(u.index)}p(u)&&(i.line=l,i.ch=u.index,t--)}if(u.nextCh||u.curMoveThrough)return new y(l,u.index);return i}(e,n.repeat,n.forward,n.selectedCharacter)||t},moveToColumn:function(e,t,n,r){var i=n.repeat;return r.lastHPos=i-1,r.lastHSPos=e.charCoords(t,\"div\").left,function(e,t){var n=e.getCursor().line;return we(e,new y(n,t-1))}(e,i)},moveToEol:function(e,t,n,r){return Qe(e,t,n,r,!1)},moveToFirstNonWhiteSpaceCharacter:function(e,t){var n=t;return new y(n.line,De(e.getLine(n.line)))},moveToMatchedSymbol:function(e,t){for(var n,r=t,i=r.line,o=r.ch,a=e.getLine(i);o<a.length;o++)if((n=a.charAt(o))&&-1!=\"()[]{}\".indexOf(n)){var s=e.getTokenTypeAt(new y(i,o+1));if(\"string\"!==s&&\"comment\"!==s)break}if(o<a.length){var l=/[<>]/.test(a[o])?/[(){}[\\]<>]/:/[(){}[\\]]/;return e.findMatchingBracket(new y(i,o+1),{bracketRegex:l}).to}return r},moveToStartOfLine:function(e,t){return new y(t.line,0)},moveToLineOrEdgeOfDocument:function(e,t,n){var r=n.forward?e.lastLine():e.firstLine();return n.repeatIsExplicit&&(r=n.repeat-e.getOption(\"firstLineNumber\")),new y(r,De(e.getLine(r)))},moveToStartOfDisplayLine:function(e){return e.execCommand(\"goLineLeft\"),e.getCursor()},moveToEndOfDisplayLine:function(e){e.execCommand(\"goLineRight\");var t=e.getCursor();return\"before\"==t.sticky&&t.ch--,t},textObjectManipulation:function(e,t,n,r){var i=n.selectedCharacter;\"b\"==i?i=\"(\":\"B\"==i&&(i=\"{\");var o,a,s=!n.textObjectInner;if({\"(\":\")\",\")\":\"(\",\"{\":\"}\",\"}\":\"{\",\"[\":\"]\",\"]\":\"[\",\"<\":\">\",\">\":\"<\"}[i]){if(a=!0,!(o=Ye(e,t,i,s))){var l=e.getSearchCursor(new RegExp(\"\\\\\"+i,\"g\"),t);l.find()&&(o=Ye(e,l.from(),i,s))}}else if({\"'\":!0,'\"':!0,\"`\":!0}[i])a=!0,o=function(e,t,n,r){var i,o,a,s,l=Ae(t),c=e.getLine(l.line),u=c.split(\"\"),h=u.indexOf(n);if(l.ch<h)l.ch=h;else if(h<l.ch&&u[l.ch]==n){var d=/string/.test(e.getTokenTypeAt(Se(t,0,1))),p=/string/.test(e.getTokenTypeAt(t));d&&!p||(o=l.ch,--l.ch)}if(u[l.ch]!=n||o)for(a=l.ch;a>-1&&!i;a--)u[a]==n&&(i=a+1);else i=l.ch+1;if(i&&!o)for(a=i,s=u.length;a<s&&!o;a++)u[a]==n&&(o=a);if(!i||!o)return{start:l,end:l};r&&(--i,++o);return{start:new y(l.line,i),end:new y(l.line,o)}}(e,t,i,s);else if(\"W\"===i||\"w\"===i)for(var c=n.repeat||1;c-- >0;){var u=Ve(e,{inclusive:s,innerWord:!s,bigWord:\"W\"===i,noSymbol:\"W\"===i,multiline:!0},o&&o.end);u&&(o||(o=u),o.end=u.end)}else if(\"p\"===i)if(o=Xe(e,t,n.repeat,0,s),n.linewise=!0,r.visualMode)r.visualLine||(r.visualLine=!0);else{var h=r.inputState.operatorArgs;h&&(h.linewise=!0),o.end.line--}else if(\"t\"===i)o=function(e,t,n){var r=t;if(!m.findMatchingTag||!m.findEnclosingTag)return{start:r,end:r};var i=m.findMatchingTag(e,t)||m.findEnclosingTag(e,t);if(!i||!i.open||!i.close)return{start:r,end:r};if(n)return{start:i.open.from,end:i.close.to};return{start:i.open.to,end:i.close.from}}(e,t,s);else if(\"s\"===i){var d=e.getLine(t.line);t.ch>0&&_(d[t.ch])&&(t.ch-=1);var p=Ze(e,t,n.repeat,1,s),f=Ze(e,t,n.repeat,-1,s);H(e.getLine(f.line)[f.ch])&&H(e.getLine(p.line)[p.ch-1])&&(f={line:f.line,ch:f.ch+1}),o={start:f,end:p}}return o?e.state.vim.visualMode?function(e,t,n,r){var i,o=e.state.vim.sel,a=r?t:o.head,s=r?t:o.anchor;Le(n,t)&&(i=n,n=t,t=i);Le(a,s)?(a=Te(t,a),s=Ee(s,n)):(s=Te(t,s),-1==(a=Se(a=Ee(a,n),0,-1)).ch&&a.line!=e.firstLine()&&(a=new y(a.line-1,Re(e,a.line-1))));return[s,a]}(e,o.start,o.end,a):[o.start,o.end]:null},repeatLastCharacterSearch:function(e,t,n){var r=F.lastCharacterSearch,i=n.repeat,o=n.forward===r.forward,a=(r.increment?1:0)*(o?-1:1);e.moveH(-a,\"char\"),n.inclusive=!!o;var s=qe(e,i,o,r.selectedCharacter);return s?(s.ch+=a,s):(e.moveH(a,\"char\"),t)}};function ve(e,t){for(var n=[],r=0;r<t;r++)n.push(e);return n}var ye={change:function(e,t,n){var r,i,o=e.state.vim,a=n[0].anchor,s=n[0].head;if(o.visualMode)if(t.fullLine)s.ch=Number.MAX_VALUE,s.line--,e.setSelection(a,s),i=e.getSelection(),e.replaceSelection(\"\"),r=a;else{i=e.getSelection();var l=ve(\"\",n.length);e.replaceSelections(l),r=Te(n[0].head,n[0].anchor)}else{i=e.getRange(a,s);var c=o.lastEditInputState||{};if(\"moveByWords\"==c.motion&&!H(i)){var u=/\\s+$/.exec(i);u&&c.motionArgs&&c.motionArgs.forward&&(s=Se(s,0,-u[0].length),i=i.slice(0,-u[0].length))}t.linewise&&(a=new y(a.line,De(e.getLine(a.line))),s.line>a.line&&(s=new y(s.line-1,Number.MAX_VALUE))),e.replaceRange(\"\",a,s),r=a}F.registerController.pushText(t.registerName,\"change\",i,t.linewise,n.length>1),Ce.enterInsertMode(e,{head:r},e.state.vim)},delete:function(e,t,n){var r,i,o=e.state.vim;if(o.visualBlock){i=e.getSelection();var a=ve(\"\",n.length);e.replaceSelections(a),r=Te(n[0].head,n[0].anchor)}else{var s=n[0].anchor,l=n[0].head;t.linewise&&l.line!=e.firstLine()&&s.line==e.lastLine()&&s.line==l.line-1&&(s.line==e.firstLine()?s.ch=0:s=new y(s.line-1,Re(e,s.line-1))),i=e.getRange(s,l),e.replaceRange(\"\",s,l),r=s,t.linewise&&(r=ge.moveToFirstNonWhiteSpaceCharacter(e,s))}return F.registerController.pushText(t.registerName,\"delete\",i,t.linewise,o.visualBlock),we(e,r)},indent:function(e,t,n){var r=e.state.vim;if(e.indentMore)for(var i=r.visualMode?t.repeat:1,o=0;o<i;o++)t.indentRight?e.indentMore():e.indentLess();else{var a=n[0].anchor.line,s=r.visualBlock?n[n.length-1].anchor.line:n[0].head.line;i=r.visualMode?t.repeat:1;t.linewise&&s--;for(var l=a;l<=s;l++)for(o=0;o<i;o++)e.indentLine(l,t.indentRight)}return ge.moveToFirstNonWhiteSpaceCharacter(e,n[0].anchor)},indentAuto:function(e,t,n){return e.execCommand(\"indentAuto\"),ge.moveToFirstNonWhiteSpaceCharacter(e,n[0].anchor)},hardWrap:function(e,t,n,r,i){if(e.hardWrap){var o=n[0].anchor.line,a=n[0].head.line;t.linewise&&a--;var s=e.hardWrap({from:o,to:a});return s>o&&t.linewise&&s--,t.keepCursor?r:new y(s,0)}},changeCase:function(e,t,n,r,i){for(var o=e.getSelections(),a=[],s=t.toLower,l=0;l<o.length;l++){var c=o[l],u=\"\";if(!0===s)u=c.toLowerCase();else if(!1===s)u=c.toUpperCase();else for(var h=0;h<c.length;h++){var d=c.charAt(h);u+=P(d)?d.toLowerCase():d.toUpperCase()}a.push(u)}return e.replaceSelections(a),t.shouldMoveCursor?i:!e.state.vim.visualMode&&t.linewise&&n[0].anchor.line+1==n[0].head.line?ge.moveToFirstNonWhiteSpaceCharacter(e,r):t.linewise?r:Te(n[0].anchor,n[0].head)},yank:function(e,t,n,r){var i=e.state.vim,o=e.getSelection(),a=i.visualMode?Te(i.sel.anchor,i.sel.head,n[0].head,n[0].anchor):r;return F.registerController.pushText(t.registerName,\"yank\",o,t.linewise,i.visualBlock),a}};var Ce={jumpListWalk:function(e,t,n){if(!n.visualMode){var r=t.repeat,i=t.forward,o=F.jumpList.move(e,i?r:-r),a=o?o.find():void 0;a=a||e.getCursor(),e.setCursor(a),e.ace.curOp.command.scrollIntoView=\"center-animate\"}},scroll:function(e,t,n){if(!n.visualMode){var r=t.repeat||1,i=e.defaultTextHeight(),o=e.getScrollInfo().top,a=i*r,s=t.forward?o+a:o-a,l=Ae(e.getCursor()),c=e.charCoords(l,\"local\");if(t.forward)s>c.top?(l.line+=(s-c.top)/i,l.line=Math.ceil(l.line),e.setCursor(l),c=e.charCoords(l,\"local\"),e.scrollTo(null,c.top)):e.scrollTo(null,s);else{var u=s+e.getScrollInfo().clientHeight;u<c.bottom?(l.line-=(c.bottom-u)/i,l.line=Math.floor(l.line),e.setCursor(l),c=e.charCoords(l,\"local\"),e.scrollTo(null,c.bottom-e.getScrollInfo().clientHeight)):e.scrollTo(null,s)}}},scrollToCursor:function(e,t){var n=e.getCursor().line,r=e.charCoords(new y(n,0),\"local\"),i=e.getScrollInfo().clientHeight,o=r.top;switch(t.position){case\"center\":o=r.bottom-i/2;break;case\"bottom\":var a=new y(n,e.getLine(n).length-1);o=o-i+(e.charCoords(a,\"local\").bottom-o)}e.scrollTo(null,o)},replayMacro:function(e,t,n){var r=t.selectedCharacter,i=t.repeat,o=F.macroModeState;for(\"@\"==r?r=o.latestRegister:o.latestRegister=r;i--;)Mt(e,n,o,r)},enterMacroRecordMode:function(e,t){var n=F.macroModeState,r=t.selectedCharacter;F.registerController.isValidRegister(r)&&n.enterMacroRecordMode(e,r)},toggleOverwrite:function(e){e.state.overwrite?(e.toggleOverwrite(!1),e.setOption(\"keyMap\",\"vim-insert\"),m.signal(e,\"vim-mode-change\",{mode:\"insert\"})):(e.toggleOverwrite(!0),e.setOption(\"keyMap\",\"vim-replace\"),m.signal(e,\"vim-mode-change\",{mode:\"replace\"}))},enterInsertMode:function(e,t,n){if(!e.getOption(\"readOnly\")){n.insertMode=!0,n.insertModeRepeat=t&&t.repeat||1;var r=t?t.insertAt:null,i=n.sel,o=t.head||e.getCursor(\"head\"),a=e.listSelections().length;if(\"eol\"==r)o=new y(o.line,Re(e,o.line));else if(\"bol\"==r)o=new y(o.line,0);else if(\"charAfter\"==r){o=C(e,o,Se(o,0,1)).end}else if(\"firstNonBlank\"==r){o=C(e,o,ge.moveToFirstNonWhiteSpaceCharacter(e,o)).end}else if(\"startOfSelectedArea\"==r){if(!n.visualMode)return;n.visualBlock?(o=new y(Math.min(i.head.line,i.anchor.line),Math.min(i.head.ch,i.anchor.ch)),a=Math.abs(i.head.line-i.anchor.line)+1):o=i.head.line<i.anchor.line?i.head:new y(i.anchor.line,0)}else if(\"endOfSelectedArea\"==r){if(!n.visualMode)return;n.visualBlock?(o=new y(Math.min(i.head.line,i.anchor.line),Math.max(i.head.ch,i.anchor.ch)+1),a=Math.abs(i.head.line-i.anchor.line)+1):o=i.head.line>=i.anchor.line?Se(i.head,0,1):new y(i.anchor.line,0)}else if(\"inplace\"==r){if(n.visualMode)return}else\"lastEdit\"==r&&(o=yt(e)||o);e.setOption(\"disableInput\",!1),t&&t.replace?(e.toggleOverwrite(!0),e.setOption(\"keyMap\",\"vim-replace\"),m.signal(e,\"vim-mode-change\",{mode:\"replace\"})):(e.toggleOverwrite(!1),e.setOption(\"keyMap\",\"vim-insert\"),m.signal(e,\"vim-mode-change\",{mode:\"insert\"})),F.macroModeState.isPlaying||(e.on(\"change\",At),n.insertEnd&&n.insertEnd.clear(),n.insertEnd=e.setBookmark(o,{insertLeft:!0}),m.on(e.getInputField(),\"keydown\",Et)),n.visualMode&&$e(e),Ke(e,o,a)}},toggleVisualMode:function(e,t,n){var r,i=t.repeat,o=e.getCursor();if(n.visualMode)n.visualLine^t.linewise||n.visualBlock^t.blockwise?(n.visualLine=!!t.linewise,n.visualBlock=!!t.blockwise,m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:n.visualLine?\"linewise\":n.visualBlock?\"blockwise\":\"\"}),He(e)):$e(e);else{n.visualMode=!0,n.visualLine=!!t.linewise,n.visualBlock=!!t.blockwise;var a=C(e,o,r=we(e,new y(o.line,o.ch+i-1)));n.sel={anchor:a.start,head:a.end},m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:n.visualLine?\"linewise\":n.visualBlock?\"blockwise\":\"\"}),He(e),Je(e,n,\"<\",Te(o,r)),Je(e,n,\">\",Ee(o,r))}},reselectLastSelection:function(e,t,n){var r=n.lastSelection;if(n.visualMode&&Pe(e,n),r){var i=r.anchorMark.find(),o=r.headMark.find();if(!i||!o)return;n.sel={anchor:i,head:o},n.visualMode=!0,n.visualLine=r.visualLine,n.visualBlock=r.visualBlock,He(e),Je(e,n,\"<\",Te(i,o)),Je(e,n,\">\",Ee(i,o)),m.signal(e,\"vim-mode-change\",{mode:\"visual\",subMode:n.visualLine?\"linewise\":n.visualBlock?\"blockwise\":\"\"})}},joinLines:function(e,t,n){var r,i;if(n.visualMode){if(r=e.getCursor(\"anchor\"),Le(i=e.getCursor(\"head\"),r)){var o=i;i=r,r=o}i.ch=Re(e,i.line)-1}else{var a=Math.max(t.repeat,2);r=e.getCursor(),i=we(e,new y(r.line+a-1,1/0))}for(var s=0,l=r.line;l<i.line;l++){s=Re(e,r.line);var c=\"\",u=0;if(!t.keepSpaces){var h=e.getLine(r.line+1);-1==(u=h.search(/\\S/))?u=h.length:c=\" \"}e.replaceRange(c,new y(r.line,s),new y(r.line+1,u))}var d=we(e,new y(r.line,s));n.visualMode&&$e(e,!1),e.setCursor(d)},newLineAndEnterInsertMode:function(e,t,n){n.insertMode=!0;var r=Ae(e.getCursor());r.line!==e.firstLine()||t.after?(r.line=t.after?r.line:r.line-1,r.ch=Re(e,r.line),e.setCursor(r),(m.commands.newlineAndIndentContinueComment||m.commands.newlineAndIndent)(e)):(e.replaceRange(\"\\n\",new y(e.firstLine(),0)),e.setCursor(e.firstLine(),0));this.enterInsertMode(e,{repeat:t.repeat},n)},paste:function(e,t,n){var r=this,i=F.registerController.getRegister(t.registerName),o=function(){var o=i.toString();r.continuePaste(e,t,n,o,i)};\"+\"===t.registerName&&\"undefined\"!==typeof navigator&&\"undefined\"!==typeof navigator.clipboard&&\"function\"===typeof navigator.clipboard.readText?navigator.clipboard.readText().then((function(o){r.continuePaste(e,t,n,o,i)}),(function(){o()})):o()},continuePaste:function(e,t,n,r,i){var o=Ae(e.getCursor());if(r){if(t.matchIndent){var a=e.getOption(\"tabSize\"),s=function(e){var t=e.split(\"\\t\").length-1,n=e.split(\" \").length-1;return t*a+1*n},l=e.getLine(e.getCursor().line),c=s(l.match(/^\\s*/)[0]),u=r.replace(/\\n$/,\"\"),h=r!==u,d=s(r.match(/^\\s*/)[0]);r=u.replace(/^\\s*/gm,(function(t){var n=c+(s(t)-d);if(n<0)return\"\";if(e.getOption(\"indentWithTabs\")){var r=Math.floor(n/a);return Array(r+1).join(\"\\t\")}return Array(n+1).join(\" \")}));r+=h?\"\\n\":\"\"}if(t.repeat>1)r=Array(t.repeat+1).join(r);var p,f=i.linewise,m=i.blockwise;if(m){r=r.split(\"\\n\"),f&&r.pop();for(var g=0;g<r.length;g++)r[g]=\"\"==r[g]?\" \":r[g];o.ch+=t.after?1:0,o.ch=Math.min(Re(e,o.line),o.ch)}else f?n.visualMode?r=n.visualLine?r.slice(0,-1):\"\\n\"+r.slice(0,r.length-1)+\"\\n\":t.after?(r=\"\\n\"+r.slice(0,r.length-1),o.ch=Re(e,o.line)):o.ch=0:o.ch+=t.after?1:0;if(n.visualMode){var v;n.lastPastedText=r;var C=function(e,t){var n=t.lastSelection,r=function(){var t=e.listSelections(),n=t[0],r=t[t.length-1];return[Le(n.anchor,n.head)?n.anchor:n.head,Le(r.anchor,r.head)?r.head:r.anchor]},i=function(){var t=e.getCursor(),r=e.getCursor(),i=n.visualBlock;if(i){var o=i.width,a=i.height;r=new y(t.line+a,t.ch+o);for(var s=[],l=t.line;l<r.line;l++){var c={anchor:new y(l,t.ch),head:new y(l,r.ch)};s.push(c)}e.setSelections(s)}else{var u=n.anchorMark.find(),h=n.headMark.find(),d=h.line-u.line,p=h.ch-u.ch;r={line:r.line+d,ch:d?r.ch:p+r.ch},n.visualLine&&(t=new y(t.line,0),r=new y(r.line,Re(e,r.line))),e.setSelection(t,r)}return[t,r]};return t.visualMode?r():i()}(e,n),w=C[0],k=C[1],S=e.getSelection(),x=e.listSelections(),M=new Array(x.length).join(\"1\").split(\"1\");n.lastSelection&&(v=n.lastSelection.headMark.find()),F.registerController.unnamedRegister.setText(S),m?(e.replaceSelections(M),k=new y(w.line+r.length-1,w.ch),e.setCursor(w),Ne(e,k),e.replaceSelections(r),p=w):n.visualBlock?(e.replaceSelections(M),e.setCursor(w),e.replaceRange(r,w,w),p=w):(e.replaceRange(r,w,k),p=e.posFromIndex(e.indexFromPos(w)+r.length-1)),v&&(n.lastSelection.headMark=e.setBookmark(v)),f&&(p.ch=0)}else if(m){e.setCursor(o);for(g=0;g<r.length;g++){(A=o.line+g)>e.lastLine()&&e.replaceRange(\"\\n\",new y(A,0)),Re(e,A)<o.ch&&Ie(e,A,o.ch)}e.setCursor(o),Ne(e,new y(o.line+r.length-1,o.ch)),e.replaceSelections(r),p=o}else if(e.replaceRange(r,o),f){var A=t.after?o.line+1:o.line;p=new y(A,De(e.getLine(A)))}else p=Ae(o),/\\n/.test(r)||(p.ch+=r.length-(t.after?1:0));n.visualMode&&$e(e,!1),e.setCursor(p)}},undo:function(e,t){e.operation((function(){Me(e,m.commands.undo,t.repeat)(),e.setCursor(we(e,e.getCursor(\"start\")))}))},redo:function(e,t){Me(e,m.commands.redo,t.repeat)()},setRegister:function(e,t,n){n.inputState.registerName=t.selectedCharacter},insertRegister:function(e,t,n){var r=t.selectedCharacter,i=F.registerController.getRegister(r),o=i&&i.toString();o&&e.replaceSelection(o)},oneNormalCommand:function(e,t,n){St(e,!0),n.insertModeReturn=!0,m.on(e,\"vim-command-done\",(function t(){n.visualMode||(n.insertModeReturn&&(n.insertModeReturn=!1,n.insertMode||Ce.enterInsertMode(e,{},n)),m.off(e,\"vim-command-done\",t))}))},setMark:function(e,t,n){Je(e,n,t.selectedCharacter,e.getCursor())},replace:function(e,t,n){var r,i,o=t.selectedCharacter,a=e.getCursor(),s=e.listSelections();if(n.visualMode)a=e.getCursor(\"start\"),i=e.getCursor(\"end\");else{var l=e.getLine(a.line);(r=a.ch+t.repeat)>l.length&&(r=l.length),i=new y(a.line,r)}var c=C(e,a,i);if(a=c.start,i=c.end,\"\\n\"==o)n.visualMode||e.replaceRange(\"\",a,i),(m.commands.newlineAndIndentContinueComment||m.commands.newlineAndIndent)(e);else{var u=e.getRange(a,i);if(u=(u=u.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,o)).replace(/[^\\n]/g,o),n.visualBlock){var h=new Array(e.getOption(\"tabSize\")+1).join(\" \");u=(u=(u=e.getSelection()).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,o)).replace(/\\t/g,h).replace(/[^\\n]/g,o).split(\"\\n\"),e.replaceSelections(u)}else e.replaceRange(u,a,i);n.visualMode?(a=Le(s[0].anchor,s[0].head)?s[0].anchor:s[0].head,e.setCursor(a),$e(e,!1)):e.setCursor(Se(i,0,-1))}},incrementNumberToken:function(e,t){for(var n,r,i,o,a=e.getCursor(),s=e.getLine(a.line),l=/(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;null!==(n=l.exec(s))&&(i=(r=n.index)+n[0].length,!(a.ch<i)););if((t.backtrack||!(i<=a.ch))&&n){var c=n[2]||n[4],u=n[3]||n[5],h=t.increase?1:-1,d={\"0b\":2,0:8,\"\":10,\"0x\":16}[c.toLowerCase()];o=(parseInt(n[1]+u,d)+h*t.repeat).toString(d);var p=c?new Array(u.length-o.length+1+n[1].length).join(\"0\"):\"\";o=\"-\"===o.charAt(0)?\"-\"+c+p+o.substr(1):c+p+o;var f=new y(a.line,r),m=new y(a.line,i);e.replaceRange(o,f,m),e.setCursor(new y(a.line,r+o.length-1))}},repeatLastEdit:function(e,t,n){if(n.lastEditInputState){var r=t.repeat;r&&t.repeatIsExplicit?n.lastEditInputState.repeatOverride=r:r=n.lastEditInputState.repeatOverride||r,Ot(e,n,r,!1)}},indent:function(e,t){e.indentLine(e.getCursor().line,t.indentRight)},exitInsertMode:St};function we(e,t,n){var r=e.state.vim,i=r.insertMode||r.visualMode,o=Math.min(Math.max(e.firstLine(),t.line),e.lastLine()),a=e.getLine(o),s=a.length-1+Number(!!i),l=Math.min(Math.max(0,t.ch),s),c=a.charCodeAt(l);if(56320<=c&&c<=57343){var u=1;n&&n.line==o&&n.ch>l&&(u=-1),(l+=u)>s&&(l-=2)}return new y(o,l)}function ke(e){var t={};for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function Se(e,t,n){return\"object\"===typeof t&&(n=t.ch,t=t.line),new y(e.line+t,e.ch+n)}function xe(e,t){var n=\"<character>\"==t.slice(-11),r=\"<register>\"==t.slice(-10);if(n||r){var i=t.length-(n?11:10),o=e.slice(0,i),a=t.slice(0,i);return o==a&&e.length>i?\"full\":0==a.indexOf(o)&&\"partial\"}return e==t?\"full\":0==t.indexOf(e)&&\"partial\"}function Me(e,t,n){return function(){for(var r=0;r<n;r++)t(e)}}function Ae(e){return new y(e.line,e.ch)}function be(e,t){return e.ch==t.ch&&e.line==t.line}function Le(e,t){return e.line<t.line||e.line==t.line&&e.ch<t.ch}function Te(e,t){return arguments.length>2&&(t=Te.apply(void 0,Array.prototype.slice.call(arguments,1))),Le(e,t)?e:t}function Ee(e,t){return arguments.length>2&&(t=Ee.apply(void 0,Array.prototype.slice.call(arguments,1))),Le(e,t)?t:e}function Oe(e,t,n){var r=Le(e,t),i=Le(t,n);return r&&i}function Re(e,t){return e.getLine(t).length}function Be(e){return e.trim?e.trim():e.replace(/^\\s+|\\s+$/g,\"\")}function Ie(e,t,n){var r=Re(e,t),i=new Array(n-r+1).join(\" \");e.setCursor(new y(t,r)),e.replaceRange(i,e.getCursor())}function Ne(e,t){var n=[],r=e.listSelections(),i=Ae(e.clipPos(t)),o=!be(t,i),a=function(e,t,n){for(var r=0;r<e.length;r++){var i=\"head\"!=n&&be(e[r].anchor,t),o=\"anchor\"!=n&&be(e[r].head,t);if(i||o)return r}return-1}(r,e.getCursor(\"head\")),s=be(r[a].head,r[a].anchor),l=r.length-1,c=l-a>a?l:0,u=r[c].anchor,h=Math.min(u.line,i.line),d=Math.max(u.line,i.line),p=u.ch,f=i.ch,m=r[c].head.ch-p,g=f-p;m>0&&g<=0?(p++,o||f--):m<0&&g>=0?(p--,s||f++):m<0&&-1==g&&(p--,f++);for(var v=h;v<=d;v++){var C={anchor:new y(v,p),head:new y(v,f)};n.push(C)}return e.setSelections(n),t.ch=f,u.ch=p,u}function Ke(e,t,n){for(var r=[],i=0;i<n;i++){var o=Se(t,i,0);r.push({anchor:o,head:o})}e.setSelections(r,0)}function Pe(e,t){var n=t.sel.anchor,r=t.sel.head;t.lastPastedText&&(r=e.posFromIndex(e.indexFromPos(n)+t.lastPastedText.length),t.lastPastedText=null),t.lastSelection={anchorMark:e.setBookmark(n),headMark:e.setBookmark(r),anchor:Ae(n),head:Ae(r),visualMode:t.visualMode,visualLine:t.visualLine,visualBlock:t.visualBlock}}function He(e,t,n){var r=e.state.vim,i=_e(e,t=t||r.sel,n=n||r.visualLine?\"line\":r.visualBlock?\"block\":\"char\");e.setSelections(i.ranges,i.primary)}function _e(e,t,n,r){var i=Ae(t.head),o=Ae(t.anchor);if(\"char\"==n){var a=r||Le(t.head,t.anchor)?0:1,s=Le(t.head,t.anchor)?1:0;return i=Se(t.head,0,a),{ranges:[{anchor:o=Se(t.anchor,0,s),head:i}],primary:0}}if(\"line\"==n){if(Le(t.head,t.anchor))i.ch=0,o.ch=Re(e,o.line);else{o.ch=0;var l=e.lastLine();i.line>l&&(i.line=l),i.ch=Re(e,i.line)}return{ranges:[{anchor:o,head:i}],primary:0}}if(\"block\"==n){var c=Math.min(o.line,i.line),u=o.ch,h=Math.max(o.line,i.line),d=i.ch;u<d?d+=1:u+=1;for(var p=h-c+1,f=i.line==c?0:p-1,m=[],g=0;g<p;g++)m.push({anchor:new y(c+g,u),head:new y(c+g,d)});return{ranges:m,primary:f}}}function $e(e,t){var n=e.state.vim;!1!==t&&e.setCursor(we(e,n.sel.head)),Pe(e,n),n.visualMode=!1,n.visualLine=!1,n.visualBlock=!1,n.insertMode||m.signal(e,\"vim-mode-change\",{mode:\"normal\"})}function De(e){if(!e)return 0;var t=e.search(/\\S/);return-1==t?e.length:t}function Ve(e,t,n){var r,i=t.inclusive,o=t.innerWord,a=t.bigWord,s=t.noSymbol,l=t.multiline,c=n||function(e){var t=e.getCursor(\"head\");return 1==e.getSelection().length&&(t=Te(t,e.getCursor(\"anchor\"))),t}(e),u=e.getLine(c.line),h=u,d=c.line,p=d,f=c.ch,m=s?E[0]:O[0];if(o&&/\\s/.test(u.charAt(f)))m=function(e){return/\\s/.test(e)};else{for(;!m(u.charAt(f));)if(++f>=u.length){if(!l)return null;f--,r=ze(e,c,!0,a,!0);break}a?m=O[0]:(m=E[0])(u.charAt(f))||(m=E[1])}for(var g=f,v=f;m(u.charAt(v))&&v>=0;)v--;if(v++,r)g=r.to,p=r.line,(h=e.getLine(p))||0!=g||g++;else for(;m(u.charAt(g))&&g<u.length;)g++;if(i){var C=g,w=c.ch<=v&&/\\s/.test(u.charAt(c.ch));if(!w)for(;/\\s/.test(h.charAt(g))&&g<h.length;)g++;if(C==g||w){for(var k=v;/\\s/.test(u.charAt(v-1))&&v>0;)v--;v||w||(v=k)}}return{start:new y(d,v),end:new y(p,g)}}function We(e,t,n){be(t,n)||F.jumpList.add(e,t,n)}function je(e,t){F.lastCharacterSearch.increment=e,F.lastCharacterSearch.forward=t.forward,F.lastCharacterSearch.selectedCharacter=t.selectedCharacter}var Fe={\"(\":\"bracket\",\")\":\"bracket\",\"{\":\"bracket\",\"}\":\"bracket\",\"[\":\"section\",\"]\":\"section\",\"*\":\"comment\",\"/\":\"comment\",m:\"method\",M:\"method\",\"#\":\"preprocess\"},Ue={bracket:{isComplete:function(e){if(e.nextCh===e.symb){if(e.depth++,e.depth>=1)return!0}else e.nextCh===e.reverseSymb&&e.depth--;return!1}},section:{init:function(e){e.curMoveThrough=!0,e.symb=(e.forward?\"]\":\"[\")===e.symb?\"{\":\"}\"},isComplete:function(e){return 0===e.index&&e.nextCh===e.symb}},comment:{isComplete:function(e){var t=\"*\"===e.lastCh&&\"/\"===e.nextCh;return e.lastCh=e.nextCh,t}},method:{init:function(e){e.symb=\"m\"===e.symb?\"{\":\"}\",e.reverseSymb=\"{\"===e.symb?\"}\":\"{\"},isComplete:function(e){return e.nextCh===e.symb}},preprocess:{init:function(e){e.index=0},isComplete:function(e){if(\"#\"===e.nextCh){var t=e.lineText.match(/^#(\\w+)/)[1];if(\"endif\"===t){if(e.forward&&0===e.depth)return!0;e.depth++}else if(\"if\"===t){if(!e.forward&&0===e.depth)return!0;e.depth--}if(\"else\"===t&&0===e.depth)return!0}return!1}}};function ze(e,t,n,r,i){var o=t.line,a=t.ch,s=e.getLine(o),l=n?1:-1,c=r?O:E;if(i&&\"\"==s){if(o+=l,s=e.getLine(o),!N(e,o))return null;a=n?0:s.length}for(;;){if(i&&\"\"==s)return{from:0,to:0,line:o};for(var u=l>0?s.length:-1,h=u,d=u;a!=u;){for(var p=!1,f=0;f<c.length&&!p;++f)if(c[f](s.charAt(a))){for(h=a;a!=u&&c[f](s.charAt(a));)a+=l;if(p=h!=(d=a),h==t.ch&&o==t.line&&d==h+l)continue;return{from:Math.min(h,d+1),to:Math.max(h,d),line:o}}p||(a+=l)}if(!N(e,o+=l))return null;s=e.getLine(o),a=l>0?0:s.length}}function Qe(e,t,n,r,i){var o=new y(t.line+n.repeat-1,1/0),a=e.clipPos(o);return a.ch--,i||(r.lastHPos=1/0,r.lastHSPos=e.charCoords(a,\"div\").left),o}function qe(e,t,n,r,i){for(var o,a=i||e.getCursor(),s=a.ch,l=0;l<t;l++){if(-1==(o=Ge(s,e.getLine(a.line),r,n,!0)))return null;s=o}return new y(e.getCursor().line,o)}function Je(e,t,n,r){($(n,R)||I.test(n))&&(t.marks[n]&&t.marks[n].clear(),t.marks[n]=e.setBookmark(r))}function Ge(e,t,n,r,i){var o;return r?-1==(o=t.indexOf(n,e+1))||i||(o-=1):-1==(o=t.lastIndexOf(n,e-1))||i||(o+=1),o}function Xe(e,t,n,r,i){var o,a=t.line,s=e.firstLine(),l=e.lastLine(),c=a;function u(t){return!/\\S/.test(e.getLine(t))}function h(e,t,n){return n?u(e)!=u(e+t):!u(e)&&u(e+t)}function d(t){r=r>0?1:-1;var n=e.ace.session.getFoldLine(t);n&&t+r>n.start.row&&t+r<n.end.row&&(r=(r>0?n.end.row:n.start.row)-t)}if(r){for(;s<=c&&c<=l&&n>0;)d(c),h(c,r)&&n--,c+=r;return new y(c,0)}var p=e.state.vim;if(p.visualLine&&h(a,1,!0)){var f=p.sel.anchor;h(f.line,-1,!0)&&(i&&f.line==a||(a+=1))}var m=u(a);for(c=a;c<=l&&n;c++)h(c,1,!0)&&(i&&u(c)==m||n--);for(o=new y(c,0),c>l&&!m?m=!0:i=!1,c=a;c>s&&(i&&u(c)!=m&&c!=a||!h(c,-1,!0));c--);return{start:new y(c,0),end:o}}function Ze(e,t,n,r,i){function o(e){e.pos+e.dir<0||e.pos+e.dir>=e.line.length?e.line=null:e.pos+=e.dir}function a(e,t,n,r){var a={line:e.getLine(t),ln:t,pos:n,dir:r};if(\"\"===a.line)return{ln:a.ln,pos:a.pos};var s=a.pos;for(o(a);null!==a.line;){if(s=a.pos,_(a.line[a.pos])){if(i){for(o(a);null!==a.line&&H(a.line[a.pos]);)s=a.pos,o(a);return{ln:a.ln,pos:s+1}}return{ln:a.ln,pos:a.pos+1}}o(a)}return{ln:a.ln,pos:s+1}}function s(e,t,n,r){var a=e.getLine(t),s={line:a,ln:t,pos:n,dir:r};if(\"\"===s.line)return{ln:s.ln,pos:s.pos};var l=s.pos;for(o(s);null!==s.line;){if(H(s.line[s.pos])||_(s.line[s.pos])){if(_(s.line[s.pos]))return i&&H(s.line[s.pos+1])?{ln:s.ln,pos:s.pos+1}:{ln:s.ln,pos:l}}else l=s.pos;o(s)}return s.line=a,i&&H(s.line[s.pos])?{ln:s.ln,pos:s.pos}:{ln:s.ln,pos:l}}for(var l={ln:t.line,pos:t.ch};n>0;)l=r<0?s(e,l.ln,l.pos,r):a(e,l.ln,l.pos,r),n--;return new y(l.ln,l.pos)}function Ye(e,t,n,r){var i,o,a=t,s={\"(\":/[()]/,\")\":/[()]/,\"[\":/[[\\]]/,\"]\":/[[\\]]/,\"{\":/[{}]/,\"}\":/[{}]/,\"<\":/[<>]/,\">\":/[<>]/}[n],l={\"(\":\"(\",\")\":\"(\",\"[\":\"[\",\"]\":\"[\",\"{\":\"{\",\"}\":\"{\",\"<\":\"<\",\">\":\"<\"}[n],c=e.getLine(a.line).charAt(a.ch)===l?1:0;if(i=e.scanForBracket(new y(a.line,a.ch+c),-1,void 0,{bracketRegex:s}),o=e.scanForBracket(new y(a.line,a.ch+c),1,void 0,{bracketRegex:s}),!i||!o)return null;if(i=i.pos,o=o.pos,i.line==o.line&&i.ch>o.ch||i.line>o.line){var u=i;i=o,o=u}return r?o.ch+=1:i.ch+=1,{start:i,end:o}}function et(){}function tt(e){var t=e.state.vim;return t.searchState_||(t.searchState_=new et)}function nt(e,t){var n=rt(e,t)||[];if(!n.length)return[];var r=[];if(0===n[0]){for(var i=0;i<n.length;i++)\"number\"==typeof n[i]&&r.push(e.substring(n[i]+1,n[i+1]));return r}}function rt(e,t){t||(t=\"/\");for(var n=!1,r=[],i=0;i<e.length;i++){var o=e.charAt(i);n||o!=t||r.push(i),n=!n&&\"\\\\\"==o}return r}V(\"pcre\",!0,\"boolean\"),et.prototype={getQuery:function(){return F.query},setQuery:function(e){F.query=e},getOverlay:function(){return this.searchOverlay},setOverlay:function(e){this.searchOverlay=e},isReversed:function(){return F.isReversed},setReversed:function(e){F.isReversed=e},getScrollbarAnnotate:function(){return this.annotate},setScrollbarAnnotate:function(e){this.annotate=e}};var it={\"\\\\n\":\"\\n\",\"\\\\r\":\"\\r\",\"\\\\t\":\"\\t\"};var ot={\"\\\\/\":\"/\",\"\\\\\\\\\":\"\\\\\",\"\\\\n\":\"\\n\",\"\\\\r\":\"\\r\",\"\\\\t\":\"\\t\",\"\\\\&\":\"&\"};function at(e,t,n){if(F.registerController.getRegister(\"/\").setText(e),e instanceof RegExp)return e;var r,i,o=rt(e,\"/\");o.length?(r=e.substring(0,o[0]),i=-1!=e.substring(o[0]).indexOf(\"i\")):r=e;return r?(j(\"pcre\")||(r=function(e){for(var t=!1,n=[],r=-1;r<e.length;r++){var i=e.charAt(r)||\"\",o=e.charAt(r+1)||\"\",a=o&&-1!=\"|(){\".indexOf(o);t?(\"\\\\\"===i&&a||n.push(i),t=!1):\"\\\\\"===i?(t=!0,o&&-1!=\"}\".indexOf(o)&&(a=!0),a&&\"\\\\\"!==o||n.push(i)):(n.push(i),a&&\"\\\\\"!==o&&n.push(\"\\\\\"))}return n.join(\"\")}(r)),n&&(t=/^[^A-Z]*$/.test(r)),new RegExp(r,t||i?\"im\":\"m\")):null}function st(e){\"string\"===typeof e&&(e=document.createElement(e));for(var t,n=1;n<arguments.length;n++)if(t=arguments[n])if(\"object\"!==typeof t&&(t=document.createTextNode(t)),t.nodeType)e.appendChild(t);else for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(\"$\"===r[0]?e.style[r.slice(1)]=t[r]:e.setAttribute(r,t[r]));return e}function lt(e,t){var n=st(\"div\",{$color:\"red\",$whiteSpace:\"pre\",class:\"cm-vim-message\"},t);e.openNotification?e.openNotification(n,{bottom:!0,duration:5e3}):alert(n.innerText)}function ct(e,t){if(Y.length)return t.value||(t.value=\"\"),void(X=t);var n,r,i=(n=t.prefix,r=t.desc,st(\"div\",{$display:\"flex\"},st(\"span\",{$fontFamily:\"monospace\",$whiteSpace:\"pre\",$flex:1},n,st(\"input\",{type:\"text\",autocorrect:\"off\",autocapitalize:\"off\",spellcheck:\"false\",$width:\"100%\"})),r&&st(\"span\",{$color:\"#888\"},r)));if(e.openDialog)e.openDialog(i,t.onClose,{onKeyDown:t.onKeyDown,onKeyUp:t.onKeyUp,bottom:!0,selectValueOnOpen:!1,value:t.value});else{var o=\"\";\"string\"!=typeof t.prefix&&t.prefix&&(o+=t.prefix.textContent),t.desc&&(o+=\" \"+t.desc),t.onClose(prompt(o,\"\"))}}function ut(e,t,n,r){if(t){var i=tt(e),o=at(t,!!n,!!r);if(o)return dt(e,o),function(e,t){if(e instanceof RegExp&&t instanceof RegExp){for(var n=[\"global\",\"multiline\",\"ignoreCase\",\"source\"],r=0;r<n.length;r++){var i=n[r];if(e[i]!==t[i])return!1}return!0}return!1}(o,i.getQuery())||i.setQuery(o),o}}var ht=0;function dt(e,t){clearTimeout(ht),tt(e).highlightTimeout=ht,ht=setTimeout((function(){if(e.state.vim){var n=tt(e);n.highlightTimeout=null;var r=n.getOverlay();r&&t==r.query||(r&&e.removeOverlay(r),r=function(e){if(\"^\"==e.source.charAt(0))var t=!0;return{token:function(n){if(!t||n.sol()){var r=n.match(e,!1);if(r)return 0==r[0].length?(n.next(),\"searching\"):n.sol()||(n.backUp(1),e.exec(n.next()+r[0]))?(n.match(e),\"searching\"):(n.next(),null);for(;!n.eol()&&(n.next(),!n.match(e,!1)););}else n.skipToEnd()},query:e}}(t),e.addOverlay(r),e.showMatchesOnScrollbar&&(n.getScrollbarAnnotate()&&n.getScrollbarAnnotate().clear(),n.setScrollbarAnnotate(e.showMatchesOnScrollbar(t))),n.setOverlay(r))}}),50)}function pt(e,t,n,r){return void 0===r&&(r=1),e.operation((function(){for(var i=e.getCursor(),o=e.getSearchCursor(n,i),a=0;a<r;a++){var s=o.find(t);if(0==a&&s&&be(o.from(),i)){var l=t?o.from():o.to();(s=o.find(t))&&!s[0]&&be(o.from(),l)&&e.getLine(l.line).length==l.ch&&(s=o.find(t))}if(!s&&!(o=e.getSearchCursor(n,t?new y(e.lastLine()):new y(e.firstLine(),0))).find(t))return}return o.from()}))}function ft(e){var t=tt(e);t.highlightTimeout&&(clearTimeout(t.highlightTimeout),t.highlightTimeout=null),e.removeOverlay(tt(e).getOverlay()),t.setOverlay(null),t.getScrollbarAnnotate()&&(t.getScrollbarAnnotate().clear(),t.setScrollbarAnnotate(null))}function mt(e,t,n){return\"number\"!=typeof e&&(e=e.line),t instanceof Array?$(e,t):\"number\"==typeof n?e>=t&&e<=n:e==t}function gt(e){var t=e.ace.renderer;return{top:t.getFirstFullyVisibleRow(),bottom:t.getLastFullyVisibleRow()}}function vt(e,t,n){if(\"'\"==n||\"`\"==n)return F.jumpList.find(e,-1)||new y(0,0);if(\".\"==n)return yt(e);var r=t.marks[n];return r&&r.find()}function yt(e){if(e.getLastEditEnd)return e.getLastEditEnd();for(var t=e.doc.history.done,n=t.length;n--;)if(t[n].changes)return Ae(t[n].changes[0].to)}var Ct=function(){this.buildCommandMap_()};Ct.prototype={processCommand:function(e,t,n){var r=this;e.operation((function(){e.curOp.isVimOp=!0,r._processCommand(e,t,n)}))},_processCommand:function(e,t,n){var r=e.state.vim,i=F.registerController.getRegister(\":\"),o=i.toString(),a=new m.StringStream(t);i.setText(t);var s,l,c=n||{};c.input=t;try{this.parseInput_(e,a,c)}catch(u){throw lt(e,u.toString()),u}if(r.visualMode&&$e(e),c.commandName){if(s=this.matchCommand_(c.commandName)){if(l=s.name,s.excludeFromCommandHistory&&i.setText(o),this.parseCommandArgs_(a,c,s),\"exToKey\"==s.type)return void ne(e,s.toKeys,s);if(\"exToEx\"==s.type)return void this.processCommand(e,s.toInput)}}else void 0!==c.line&&(l=\"move\");if(l)try{wt[l](e,c),s&&s.possiblyAsync||!c.callback||c.callback()}catch(u){throw lt(e,u.toString()),u}else lt(e,'Not an editor command \":'+t+'\"')},parseInput_:function(e,t,n){if(t.eatWhile(\":\"),t.eat(\"%\")?(n.line=e.firstLine(),n.lineEnd=e.lastLine()):(n.line=this.parseLineSpec_(e,t),void 0!==n.line&&t.eat(\",\")&&(n.lineEnd=this.parseLineSpec_(e,t))),void 0==n.line)if(e.state.vim.visualMode){var r=vt(e,e.state.vim,\"<\");n.selectionLine=r&&r.line,r=vt(e,e.state.vim,\">\"),n.selectionLineEnd=r&&r.line}else n.selectionLine=e.getCursor().line;else n.selectionLine=n.line,n.selectionLineEnd=n.lineEnd;var i=t.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);return n.commandName=i?i[1]:t.match(/.*/)[0],n},parseLineSpec_:function(e,t){var n=t.match(/^(\\d+)/);if(n)return parseInt(n[1],10)-1;switch(t.next()){case\".\":return this.parseLineSpecOffset_(t,e.getCursor().line);case\"$\":return this.parseLineSpecOffset_(t,e.lastLine());case\"'\":var r=t.next(),i=vt(e,e.state.vim,r);if(!i)throw new Error(\"Mark not set\");return this.parseLineSpecOffset_(t,i.line);case\"-\":case\"+\":return t.backUp(1),this.parseLineSpecOffset_(t,e.getCursor().line);default:return void t.backUp(1)}},parseLineSpecOffset_:function(e,t){var n=e.match(/^([+-])?(\\d+)/);if(n){var r=parseInt(n[2],10);\"-\"==n[1]?t-=r:t+=r}return t},parseCommandArgs_:function(e,t,n){if(!e.eol()){t.argString=e.match(/.*/)[0];var r=n.argDelimiter||/\\s+/,i=Be(t.argString).split(r);i.length&&i[0]&&(t.args=i)}},matchCommand_:function(e){for(var t=e.length;t>0;t--){var n=e.substring(0,t);if(this.commandMap_[n]){var r=this.commandMap_[n];if(0===r.name.indexOf(e))return r}}return null},buildCommandMap_:function(){this.commandMap_={};for(var e=0;e<S.length;e++){var t=S[e],n=t.shortName||t.name;this.commandMap_[n]=t}},map:function(e,t,n,r){if(\":\"!=e&&\":\"==e.charAt(0)){if(n)throw Error(\"Mode not supported for ex mappings\");var i=e.substring(1);\":\"!=t&&\":\"==t.charAt(0)?this.commandMap_[i]={name:i,type:\"exToEx\",toInput:t.substring(1),user:!0}:this.commandMap_[i]={name:i,type:\"exToKey\",toKeys:t,user:!0}}else{var o={keys:e,type:\"keyToKey\",toKeys:t,noremap:!!r};n&&(o.context=n),w.unshift(o)}},unmap:function(e,t){if(\":\"!=e&&\":\"==e.charAt(0)){if(t)throw Error(\"Mode not supported for ex mappings\");var n=e.substring(1);if(this.commandMap_[n]&&this.commandMap_[n].user)return delete this.commandMap_[n],!0}else for(var r=e,i=0;i<w.length;i++)if(r==w[i].keys&&w[i].context===t)return w.splice(i,1),!0}};var wt={colorscheme:function(e,t){!t.args||t.args.length<1?lt(e,e.getOption(\"theme\")):e.setOption(\"theme\",t.args[0])},map:function(e,t,n,r){var i=t.args;!i||i.length<2?e&&lt(e,\"Invalid mapping: \"+t.input):kt.map(i[0],i[1],n,r)},imap:function(e,t){this.map(e,t,\"insert\")},nmap:function(e,t){this.map(e,t,\"normal\")},vmap:function(e,t){this.map(e,t,\"visual\")},omap:function(e,t){this.map(e,t,\"operatorPending\")},noremap:function(e,t){this.map(e,t,void 0,!0)},inoremap:function(e,t){this.map(e,t,\"insert\",!0)},nnoremap:function(e,t){this.map(e,t,\"normal\",!0)},vnoremap:function(e,t){this.map(e,t,\"visual\",!0)},onoremap:function(e,t){this.map(e,t,\"operatorPending\",!0)},unmap:function(e,t,n){var r=t.args;(!r||r.length<1||!kt.unmap(r[0],n))&&e&&lt(e,\"No such mapping: \"+t.input)},mapclear:function(e,t){Z.mapclear()},imapclear:function(e,t){Z.mapclear(\"insert\")},nmapclear:function(e,t){Z.mapclear(\"normal\")},vmapclear:function(e,t){Z.mapclear(\"visual\")},omapclear:function(e,t){Z.mapclear(\"operatorPending\")},move:function(e,t){me.processCommand(e,e.state.vim,{type:\"motion\",motion:\"moveToLineOrEdgeOfDocument\",motionArgs:{forward:!1,explicitRepeat:!0,linewise:!0},repeatOverride:t.line+1})},set:function(e,t){var n=t.args,r=t.setCfg||{};if(!n||n.length<1)e&&lt(e,\"Invalid mapping: \"+t.input);else{var i=n[0].split(\"=\"),o=i[0],a=i[1],s=!1,l=!1;if(\"?\"==o.charAt(o.length-1)){if(a)throw Error(\"Trailing characters: \"+t.argString);o=o.substring(0,o.length-1),s=!0}else\"!\"==o.charAt(o.length-1)&&(o=o.substring(0,o.length-1),l=!0);void 0===a&&\"no\"==o.substring(0,2)&&(o=o.substring(2),a=!1);var c=D[o]&&\"boolean\"==D[o].type;if(c&&(l?a=!j(o,e,r):void 0==a&&(a=!0)),!c&&void 0===a||s){var u=j(o,e,r);u instanceof Error?lt(e,u.message):lt(e,!0===u||!1===u?\" \"+(u?\"\":\"no\")+o:\"  \"+o+\"=\"+u)}else{var h=W(o,a,e,r);h instanceof Error&&lt(e,h.message)}}},setlocal:function(e,t){t.setCfg={scope:\"local\"},this.set(e,t)},setglobal:function(e,t){t.setCfg={scope:\"global\"},this.set(e,t)},registers:function(e,t){var n=t.args,r=F.registerController.registers,i=\"----------Registers----------\\n\\n\";if(n){n=n.join(\"\");for(var o=0;o<n.length;o++){if(a=n.charAt(o),F.registerController.isValidRegister(a))i+='\"'+a+\"    \"+(r[a]||new de).toString()+\"\\n\"}}else for(var a in r){var s=r[a].toString();s.length&&(i+='\"'+a+\"    \"+s+\"\\n\")}lt(e,i)},sort:function(e,t){var n,r,i,o,a;var s=function(){if(t.argString){var e=new m.StringStream(t.argString);if(e.eat(\"!\")&&(n=!0),e.eol())return;if(!e.eatSpace())return\"Invalid arguments\";var s=e.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);if(!s&&!e.eol())return\"Invalid arguments\";if(s[1]){r=-1!=s[1].indexOf(\"i\"),i=-1!=s[1].indexOf(\"u\");var l=-1!=s[1].indexOf(\"d\")||-1!=s[1].indexOf(\"n\")&&1,c=-1!=s[1].indexOf(\"x\")&&1,u=-1!=s[1].indexOf(\"o\")&&1;if(l+c+u>1)return\"Invalid arguments\";o=(l?\"decimal\":c&&\"hex\")||u&&\"octal\"}s[2]&&(a=new RegExp(s[2].substr(1,s[2].length-2),r?\"i\":\"\"))}}();if(s)lt(e,s+\": \"+t.argString);else{var l=t.line||e.firstLine(),c=t.lineEnd||t.line||e.lastLine();if(l!=c){var u=new y(l,0),h=new y(c,Re(e,c)),d=e.getRange(u,h).split(\"\\n\"),p=a||(\"decimal\"==o?/(-?)([\\d]+)/:\"hex\"==o?/(-?)(?:0x)?([0-9a-f]+)/i:\"octal\"==o?/([0-7]+)/:null),f=\"decimal\"==o?10:\"hex\"==o?16:\"octal\"==o?8:null,g=[],v=[];if(o||a)for(var C=0;C<d.length;C++){var w=a?d[C].match(a):null;w&&\"\"!=w[0]?g.push(w):!a&&p.exec(d[C])?g.push(d[C]):v.push(d[C])}else v=d;if(g.sort(a?function(e,t){var i;return n&&(i=e,e=t,t=i),r&&(e[0]=e[0].toLowerCase(),t[0]=t[0].toLowerCase()),e[0]<t[0]?-1:1}:x),a)for(C=0;C<g.length;C++)g[C]=g[C].input;else o||v.sort(x);if(d=n?g.concat(v):v.concat(g),i){var k,S=d;d=[];for(C=0;C<S.length;C++)S[C]!=k&&d.push(S[C]),k=S[C]}e.replaceRange(d.join(\"\\n\"),u,h)}}function x(e,t){var i;n&&(i=e,e=t,t=i);r&&(e=e.toLowerCase(),t=t.toLowerCase());var a=o&&p.exec(e),s=o&&p.exec(t);return a?(a=parseInt((a[1]+a[2]).toLowerCase(),f))-(s=parseInt((s[1]+s[2]).toLowerCase(),f)):e<t?-1:1}},vglobal:function(e,t){this.global(e,t)},normal:function(e,t){var n=t.argString;if(n&&\"!\"==n[0]&&(n=n.slice(1),ee=!0),n=n.trimStart()){var r=t.line;if(\"number\"==typeof r)for(var i=isNaN(t.lineEnd)?r:t.lineEnd,o=r;o<=i;o++)e.setCursor(o,0),ne(e,t.argString.trimStart()),e.state.vim.insertMode&&St(e,!0);else ne(e,t.argString.trimStart()),e.state.vim.insertMode&&St(e,!0)}else lt(e,\"Argument is required.\")},global:function(e,t){var n=t.argString;if(n){var r=\"v\"===t.commandName[0];\"!\"===n[0]&&\"g\"===t.commandName[0]&&(r=!0,n=n.slice(1));var i,o=void 0!==t.line?t.line:e.firstLine(),a=t.lineEnd||t.line||e.lastLine(),s=function(e){return nt(e,\"/\")}(n),l=n;if(s.length&&(l=s[0],i=s.slice(1,s.length).join(\"/\")),l)try{ut(e,l,!0,!0)}catch(m){return void lt(e,\"Invalid regex: \"+l)}for(var c=tt(e).getQuery(),u=[],h=o;h<=a;h++){var d=e.getLine(h);c.test(d)!==r&&u.push(i?e.getLineHandle(h):d)}if(i){var p=0,f=function(){if(p<u.length){var t=u[p++],n=e.getLineNumber(t);if(null==n)return void f();var r=n+1+i;kt.processCommand(e,r,{callback:f})}else e.releaseLineHandles&&e.releaseLineHandles()};f()}else lt(e,u.join(\"\\n\"))}else lt(e,\"Regular Expression missing from global\")},substitute:function(e,t){if(!e.getSearchCursor)throw new Error(\"Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.\");var n,r,i,o,a=t.argString,s=a?nt(a,a[0]):[],l=\"\",c=!1,u=!1;if(s.length)n=s[0],j(\"pcre\")&&\"\"!==n&&(n=new RegExp(n).source),void 0!==(l=s[1])&&(l=j(\"pcre\")?function(e){for(var t=new m.StringStream(e),n=[];!t.eol();){for(;t.peek()&&\"\\\\\"!=t.peek();)n.push(t.next());var r=!1;for(var i in ot)if(t.match(i,!0)){r=!0,n.push(ot[i]);break}r||n.push(t.next())}return n.join(\"\")}(l.replace(/([^\\\\])&/g,\"$1$$&\")):function(e){for(var t,n=!1,r=[],i=-1;i<e.length;i++){var o=e.charAt(i)||\"\",a=e.charAt(i+1)||\"\";it[o+a]?(r.push(it[o+a]),i++):n?(r.push(o),n=!1):\"\\\\\"===o?(n=!0,t=a,T.test(t)||\"$\"===a?r.push(\"$\"):\"/\"!==a&&\"\\\\\"!==a&&r.push(\"\\\\\")):(\"$\"===o&&r.push(\"$\"),r.push(o),\"/\"===a&&r.push(\"\\\\\"))}return r.join(\"\")}(l),F.lastSubstituteReplacePart=l),r=s[2]?s[2].split(\" \"):[];else if(a&&a.length)return void lt(e,\"Substitutions should be of the form :s/pattern/replace/\");if(r&&(i=r[0],o=parseInt(r[1]),i&&(-1!=i.indexOf(\"c\")&&(c=!0),-1!=i.indexOf(\"g\")&&(u=!0),n=j(\"pcre\")?n+\"/\"+i:n.replace(/\\//g,\"\\\\/\")+\"/\"+i)),n)try{ut(e,n,!0,!0)}catch(v){return void lt(e,\"Invalid regex: \"+n)}if(void 0!==(l=l||F.lastSubstituteReplacePart)){var h=tt(e).getQuery(),d=void 0!==t.line?t.line:e.getCursor().line,p=t.lineEnd||d;d==e.firstLine()&&p==e.lastLine()&&(p=1/0),o&&(p=(d=p)+o-1);var f=we(e,new y(d,0)),g=e.getSearchCursor(h,f);!function(e,t,n,r,i,o,a,s,l){e.state.vim.exMode=!0;var c,u,h,d=!1;function p(){e.operation((function(){for(;!d;)f(),v();y()}))}function f(){var t=e.getRange(o.from(),o.to()).replace(a,s),n=o.to().line;o.replace(t),u=o.to().line,i+=u-n,h=u<n}function g(){var e=c&&Ae(o.to()),t=o.findNext();return t&&!t[0]&&e&&be(o.from(),e)&&(t=o.findNext()),t}function v(){for(;g()&&mt(o.from(),r,i);)if(n||o.from().line!=u||h)return e.scrollIntoView(o.from(),30),e.setSelection(o.from(),o.to()),c=o.from(),void(d=!1);d=!0}function y(t){if(t&&t(),e.focus(),c){e.setCursor(c);var n=e.state.vim;n.exMode=!1,n.lastHPos=n.lastHSPos=c.ch}l&&l()}function C(t,n,r){switch(m.e_stop(t),ae(t)){case\"y\":f(),v();break;case\"n\":v();break;case\"a\":var i=l;l=void 0,e.operation(p),l=i;break;case\"l\":f();case\"q\":case\"<Esc>\":case\"<C-c>\":case\"<C-[>\":y(r)}return d&&y(r),!0}if(v(),d)return void lt(e,\"No matches for \"+a.source);if(!t)return p(),void(l&&l());ct(e,{prefix:st(\"span\",\"replace with \",st(\"strong\",s),\" (y/n/a/q/l)\"),onKeyDown:C})}(e,c,u,d,p,g,h,l,t.callback)}else lt(e,\"No previous substitute regular expression\")},startinsert:function(e,t){ne(e,\"!\"==t.argString?\"A\":\"i\",{})},redo:m.commands.redo,undo:m.commands.undo,write:function(e){m.commands.save?m.commands.save(e):e.save&&e.save()},nohlsearch:function(e){ft(e)},yank:function(e){var t=Ae(e.getCursor()).line,n=e.getLine(t);F.registerController.pushText(\"0\",\"yank\",n,!0,!0)},delete:function(e,t){var n=t.selectionLine,r=isNaN(t.selectionLineEnd)?n:t.selectionLineEnd;ye.delete(e,{linewise:!0},[{anchor:new y(n,0),head:new y(r+1,0)}])},join:function(e,t){var n=t.selectionLine,r=isNaN(t.selectionLineEnd)?n:t.selectionLineEnd;e.setCursor(new y(n,0)),Ce.joinLines(e,{repeat:r-n},e.state.vim)},delmarks:function(e,t){if(t.argString&&Be(t.argString))for(var n=e.state.vim,r=new m.StringStream(Be(t.argString));!r.eol();){r.eatSpace();var i=r.pos;if(!r.match(/[a-zA-Z]/,!1))return void lt(e,\"Invalid argument: \"+t.argString.substring(i));var o=r.next();if(r.match(\"-\",!0)){if(!r.match(/[a-zA-Z]/,!1))return void lt(e,\"Invalid argument: \"+t.argString.substring(i));var a=o,s=r.next();if(!(K(a)&&K(s)||P(a)&&P(s)))return void lt(e,\"Invalid argument: \"+a+\"-\");var l=a.charCodeAt(0),c=s.charCodeAt(0);if(l>=c)return void lt(e,\"Invalid argument: \"+t.argString.substring(i));for(var u=0;u<=c-l;u++){var h=String.fromCharCode(l+u);delete n.marks[h]}}else delete n.marks[o]}else lt(e,\"Argument required\")}},kt=new Ct;function St(e,t){var n=e.state.vim,r=F.macroModeState,i=F.registerController.getRegister(\".\"),o=r.isPlaying,a=r.lastInsertModeChanges;o||(e.off(\"change\",At),n.insertEnd&&n.insertEnd.clear(),n.insertEnd=null,m.off(e.getInputField(),\"keydown\",Et)),!o&&n.insertModeRepeat>1&&(Ot(e,n,n.insertModeRepeat-1,!0),n.lastEditInputState.repeatOverride=n.insertModeRepeat),delete n.insertModeRepeat,n.insertMode=!1,t||e.setCursor(e.getCursor().line,e.getCursor().ch-1),e.setOption(\"keyMap\",\"vim\"),e.setOption(\"disableInput\",!0),e.toggleOverwrite(!1),i.setText(a.changes.join(\"\")),m.signal(e,\"vim-mode-change\",{mode:\"normal\"}),r.isRecording&&function(e){if(e.isPlaying)return;var t=e.latestRegister,n=F.registerController.getRegister(t);n&&n.pushInsertModeChanges&&n.pushInsertModeChanges(e.lastInsertModeChanges)}(r)}function xt(e){w.unshift(e)}function Mt(e,t,n,r){var i=F.registerController.getRegister(r);if(\":\"==r)return i.keyBuffer[0]&&kt.processCommand(e,i.keyBuffer[0]),void(n.isPlaying=!1);var o=i.keyBuffer,a=0;n.isPlaying=!0,n.replaySearchQueries=i.searchQueries.slice(0);for(var s=0;s<o.length;s++)for(var l,c,u=o[s];u;)if(c=(l=/<\\w+-.+?>|<\\w+>|./.exec(u))[0],u=u.substring(l.index+c.length),Z.handleKey(e,c,\"macro\"),t.insertMode){var h=i.insertModeChanges[a++].changes;F.macroModeState.lastInsertModeChanges.changes=h,Bt(e,h,1),St(e)}n.isPlaying=!1}function At(e,t){var n=F.macroModeState,r=n.lastInsertModeChanges;if(!n.isPlaying)for(var i=e.state.vim;t;){if(r.expectCursorActivityForChange=!0,r.ignoreCount>1)r.ignoreCount--;else if(\"+input\"==t.origin||\"paste\"==t.origin||void 0===t.origin){var o=e.listSelections().length;o>1&&(r.ignoreCount=o);var a=t.text.join(\"\\n\");if(r.maybeReset&&(r.changes=[],r.maybeReset=!1),a)if(e.state.overwrite&&!/\\n/.test(a))r.changes.push([a]);else{if(a.length>1){var s=i&&i.insertEnd&&i.insertEnd.find(),l=e.getCursor();if(s&&s.line==l.line){var c=s.ch-l.ch;c>0&&c<a.length&&(r.changes.push([a,c]),a=\"\")}}a&&r.changes.push(a)}}t=t.next}}function bt(e){var t=e.state.vim;if(t.insertMode){var n=F.macroModeState;if(n.isPlaying)return;var r=n.lastInsertModeChanges;r.expectCursorActivityForChange?r.expectCursorActivityForChange=!1:(r.maybeReset=!0,t.insertEnd&&t.insertEnd.clear(),t.insertEnd=e.setBookmark(e.getCursor(),{insertLeft:!0}))}else e.curOp.isVimOp||Lt(e,t)}function Lt(e,t,n){var r=e.getCursor(\"anchor\"),i=e.getCursor(\"head\");if(t.visualMode&&!e.somethingSelected()?$e(e,!1):t.visualMode||t.insertMode||!e.somethingSelected()||(t.visualMode=!0,t.visualLine=!1,m.signal(e,\"vim-mode-change\",{mode:\"visual\"})),t.visualMode){var o=Le(i,r)?0:-1,a=Le(i,r)?-1:0;i=Se(i,0,o),r=Se(r,0,a),t.sel={anchor:r,head:i},Je(e,t,\"<\",Te(i,r)),Je(e,t,\">\",Ee(i,r))}else t.insertMode||n||(t.lastHPos=e.getCursor().ch)}function Tt(e,t){this.keyName=e,this.key=t.key,this.ctrlKey=t.ctrlKey,this.altKey=t.altKey,this.metaKey=t.metaKey,this.shiftKey=t.shiftKey}function Et(e){var t=F.macroModeState.lastInsertModeChanges,n=m.keyName?m.keyName(e):e.key;n&&(-1==n.indexOf(\"Delete\")&&-1==n.indexOf(\"Backspace\")||(t.maybeReset&&(t.changes=[],t.maybeReset=!1),t.changes.push(new Tt(n,e))))}function Ot(e,t,n,r){var i=F.macroModeState;i.isPlaying=!0;var o=!!t.lastEditActionCommand,a=t.inputState;function s(){o?me.processAction(e,t,t.lastEditActionCommand):me.evalInput(e,t)}function l(n){if(i.lastInsertModeChanges.changes.length>0){n=t.lastEditActionCommand?n:1;var r=i.lastInsertModeChanges;Bt(e,r.changes,n)}}if(t.inputState=t.lastEditInputState,o&&t.lastEditActionCommand.interlaceInsertRepeat)for(var c=0;c<n;c++)s(),l(1);else r||s(),l(n);t.inputState=a,t.insertMode&&!r&&St(e),i.isPlaying=!1}function Rt(e,t){m.lookupKey(t,\"vim-insert\",(function(t){return\"string\"==typeof t?m.commands[t](e):t(e),!0}))}function Bt(e,t,n){var r=e.getCursor(\"head\"),i=F.macroModeState.lastInsertModeChanges.visualBlock;i&&(Ke(e,r,i+1),n=e.listSelections().length,e.setCursor(r));for(var o=0;o<n;o++){i&&e.setCursor(Se(r,o,0));for(var a=0;a<t.length;a++){var s=t[a];if(s instanceof Tt)Rt(e,s.keyName);else if(\"string\"==typeof s)e.replaceSelection(s);else{var l=e.getCursor(),c=Se(l,0,s[0].length-(s[1]||0));e.replaceRange(s[0],l,s[1]?l:c),e.setCursor(c)}}}i&&e.setCursor(Se(r,0,1))}V(\"insertModeEscKeysTimeout\",200,\"number\"),m.Vim=Z;var It={return:\"CR\",backspace:\"BS\",delete:\"Del\",esc:\"Esc\",left:\"Left\",right:\"Right\",up:\"Up\",down:\"Down\",space:\"Space\",insert:\"Ins\",home:\"Home\",end:\"End\",pageup:\"PageUp\",pagedown:\"PageDown\",enter:\"CR\"};var Nt=Z.handleKey.bind(Z);function Kt(e){var t=new e.constructor;return Object.keys(e).forEach((function(n){if(\"insertEnd\"!=n){var r=e[n];Array.isArray(r)?r=r.slice():r&&\"object\"==typeof r&&r.constructor!=Object&&(r=Kt(r)),t[n]=r}})),e.sel&&(t.sel={head:e.sel.head&&Ae(e.sel.head),anchor:e.sel.anchor&&Ae(e.sel.anchor)}),t}function Pt(e,t,n){var r=!1,i=Z.maybeInitVimState_(e),o=i.visualBlock||i.wasInVisualBlock,a=e.ace.inMultiSelectMode;if(i.wasInVisualBlock&&!a?i.wasInVisualBlock=!1:a&&i.visualBlock&&(i.wasInVisualBlock=!0),\"<Esc>\"!=t||i.insertMode||i.visualMode||!a)if(o||!a||e.ace.inVirtualSelectionMode)r=Z.handleKey(e,t,n);else{var s=Kt(i),l=i.inputState.changeQueueList||[];e.operation((function(){e.curOp.isVimOp=!0;var o=0;e.ace.forEachSelection((function(){var i=e.ace.selection;e.state.vim.lastHPos=null==i.$desiredColumn?i.lead.column:i.$desiredColumn,e.state.vim.inputState.changeQueue=l[o];var a=e.getCursor(\"head\"),c=e.getCursor(\"anchor\"),u=Le(a,c)?0:-1,h=Le(a,c)?-1:0;a=Se(a,0,u),c=Se(c,0,h),e.state.vim.sel.head=a,e.state.vim.sel.anchor=c,r=Nt(e,t,n),i.$desiredColumn=-1==e.state.vim.lastHPos?null:e.state.vim.lastHPos,e.ace.inVirtualSelectionMode&&(l[o]=e.state.vim.inputState.changeQueue),e.virtualSelectionMode()&&(e.state.vim=Kt(s)),o++})),e.curOp.cursorActivity&&!r&&(e.curOp.cursorActivity=!1),i.status=e.state.vim.status,e.state.vim=i,i.inputState.changeQueueList=l,i.inputState.changeQueue=null}),!0)}else e.ace.exitMultiSelectMode();return!r||i.visualMode||i.insert||i.visualMode==e.somethingSelected()||Lt(e,i,!0),r}Z.handleKey=function(e,t,n){return e.operation((function(){return Nt(e,t,n)}),!0)},G(),t.CodeMirror=m;var Ht=Z.maybeInitVimState_;function _t(e,t){t.off(\"beforeEndOperation\",_t);var n=t.state.cm.vimCmd;n&&t.execCommand(n.exec?n:n.name,n.args),t.curOp=t.prevOp}t.handler={$id:\"ace/keyboard/vim\",drawCursor:function(e,t,n,i,a){var s=this.state.vim||{},l=n.characterWidth,c=n.lineHeight,u=t.top,h=t.left;s.insertMode||!(i.cursor?r.comparePoints(i.cursor,i.start)<=0:a.selection.isBackwards()||a.selection.isEmpty())&&h>l&&(h-=l);!s.insertMode&&s.status&&(u+=c/=2),o.translate(e,h,u),o.setStyle(e.style,\"width\",l+\"px\"),o.setStyle(e.style,\"height\",c+\"px\")},$getDirectionForHighlight:function(e){var t=e.state.cm;if(!Ht(t).insertMode)return e.session.selection.isBackwards()||e.session.selection.isEmpty()},handleKeyboard:function(e,t,n,r,i){var o=e.editor,a=o.state.cm,s=Ht(a);if(-1!=r){if(s.insertMode||(-1==t?(n.charCodeAt(0)>255&&e.inputKey&&(n=e.inputKey)&&4==e.inputHash&&(n=n.toUpperCase()),e.inputChar=n):4==t||0==t?e.inputKey==n&&e.inputHash==t&&e.inputChar?(n=e.inputChar,t=-1):(e.inputChar=null,e.inputKey=n,e.inputHash=t):e.inputChar=e.inputKey=null),a.state.overwrite&&s.insertMode&&\"backspace\"==n&&0==t)return{command:\"gotoleft\"};if(\"c\"==n&&1==t&&!u.isMac&&o.getCopyText())return o.once(\"copy\",(function(){s.insertMode?o.selection.clearSelection():a.operation((function(){$e(a)}))})),{command:\"null\",passEvent:!0};if(\"esc\"==n&&!s.insertMode&&!s.visualMode&&!a.ace.inMultiSelectMode){var l=tt(a).getOverlay();l&&a.removeOverlay(l)}if(-1==t||1&t||0===t&&n.length>1){var c=s.insertMode,h=function(e,t,n,r){t.length>1&&\"n\"==t[0]&&(t=t.replace(\"numpad\",\"\")),t=It[t]||t;var i=\"\";if(n.ctrlKey&&(i+=\"C-\"),n.altKey&&(i+=\"A-\"),(i||t.length>1)&&n.shiftKey&&(i+=\"S-\"),r&&!r.expectLiteralNext&&1==t.length)if(x.keymap&&t in x.keymap)!1===x.remapCtrl&&i||(t=x.keymap[t]);else if(t.charCodeAt(0)>255){var o=n.code&&n.code.slice(-1)||\"\";n.shiftKey||(o=o.toLowerCase()),o&&(t=o)}return(i+=t).length>1&&(i=\"<\"+i+\">\"),i}(0,n,i||{},s);null==s.status&&(s.status=\"\");var d=Pt(a,h,\"user\");if(s=Ht(a),d&&null!=s.status?s.status+=h:null==s.status&&(s.status=\"\"),a._signal(\"changeStatus\"),!d&&(-1!=t||c))return;return{command:\"null\",passEvent:!d}}}},attach:function(e){e.state||(e.state={});var t=new m(e);function n(){var n=Ht(t).insertMode;t.ace.renderer.setStyle(\"normal-mode\",!n),e.textInput.setCommandMode(!n),e.renderer.$keepTextAreaAtCursor=n,e.renderer.$blockCursor=!n}e.state.cm=t,e.$vimModeHandler=this,M(t),Ht(t).status=null,t.on(\"vim-command-done\",(function(){t.virtualSelectionMode()||(Ht(t).status=null,t.ace._signal(\"changeStatus\"),t.ace.session.markUndoGroup())})),t.on(\"changeStatus\",(function(){t.ace.renderer.updateCursor(),t.ace._signal(\"changeStatus\")})),t.on(\"vim-mode-change\",(function(){t.virtualSelectionMode()||(n(),t._signal(\"changeStatus\"))})),n(),e.renderer.$cursorLayer.drawCursor=this.drawCursor.bind(t)},detach:function(e){var t=e.state.cm;A(t),t.destroy(),e.state.cm=null,e.$vimModeHandler=null,e.renderer.$cursorLayer.drawCursor=null,e.renderer.setStyle(\"normal-mode\",!1),e.textInput.setCommandMode(!1),e.renderer.$keepTextAreaAtCursor=!0},getStatusText:function(e){var t=e.state.cm,n=Ht(t);if(n.insertMode)return\"INSERT\";var r=\"\";return n.visualMode&&(r+=\"VISUAL\",n.visualLine&&(r+=\" LINE\"),n.visualBlock&&(r+=\" BLOCK\")),n.status&&(r+=(r?\" \":\"\")+n.status),r}},Z.defineOption({name:\"wrap\",set:function(e,t){t&&t.ace.setOption(\"wrap\",e)},type:\"boolean\"},!1),Z.defineEx(\"write\",\"w\",(function(){console.log(\":write is not implemented\")})),w.push({keys:\"zc\",type:\"action\",action:\"fold\",actionArgs:{open:!1}},{keys:\"zC\",type:\"action\",action:\"fold\",actionArgs:{open:!1,all:!0}},{keys:\"zo\",type:\"action\",action:\"fold\",actionArgs:{open:!0}},{keys:\"zO\",type:\"action\",action:\"fold\",actionArgs:{open:!0,all:!0}},{keys:\"za\",type:\"action\",action:\"fold\",actionArgs:{toggle:!0}},{keys:\"zA\",type:\"action\",action:\"fold\",actionArgs:{toggle:!0,all:!0}},{keys:\"zf\",type:\"action\",action:\"fold\",actionArgs:{open:!0,all:!0}},{keys:\"zd\",type:\"action\",action:\"fold\",actionArgs:{open:!0,all:!0}},{keys:\"<C-A-k>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorAbove\"}},{keys:\"<C-A-j>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorBelow\"}},{keys:\"<C-A-S-k>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorAboveSkipCurrent\"}},{keys:\"<C-A-S-j>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"addCursorBelowSkipCurrent\"}},{keys:\"<C-A-h>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectMoreBefore\"}},{keys:\"<C-A-l>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectMoreAfter\"}},{keys:\"<C-A-S-h>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectNextBefore\"}},{keys:\"<C-A-S-l>\",type:\"action\",action:\"aceCommand\",actionArgs:{name:\"selectNextAfter\"}}),w.push({keys:\"gq\",type:\"operator\",operator:\"hardWrap\"}),Z.defineOperator(\"hardWrap\",(function(e,t,n,r,i){var o=n[0].anchor.line,a=n[0].head.line;return t.linewise&&a--,f(e.ace,{startRow:o,endRow:a}),y(a,0)})),V(\"textwidth\",void 0,\"number\",[\"tw\"],(function(e,t){if(void 0!==t){if(void 0===e)return t.ace.getOption(\"printMarginColumn\");var n=Math.round(e);n>1&&t.ace.setOption(\"printMarginColumn\",n)}})),Ce.aceCommand=function(e,t,n){e.vimCmd=t,e.ace.inVirtualSelectionMode?e.ace.on(\"beforeEndOperation\",_t):_t(null,e.ace)},Ce.fold=function(e,t,n){e.ace.execCommand([\"toggleFoldWidget\",\"toggleFoldWidget\",\"foldOther\",\"unfoldall\"][(t.all?2:0)+(t.open?1:0)])},k=w.length,t.handler.defaultKeymap=w,t.handler.actions=Ce,t.Vim=Z})),ace.require([\"ace/keyboard/vim\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"92bb6c5f38fa012584acee2d656d8678.js","input":"ace.define(\"ace/ext/hardwrap\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/editor\", \"ace/config\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  function hardWrap(editor, options) {\n    var max = options.column || editor.getOption(\"printMarginColumn\");\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.startRow, options.endRow);\n    var endRow = Math.max(options.startRow, options.endRow);\n    var session = editor.session;\n    while (row <= endRow) {\n      var line = session.getLine(row);\n      if (line.length > max) {\n        var space = findSpace(line, max, 5);\n        if (space) {\n          var indentation = /^\\s*/.exec(line)[0];\n          session.replace(new Range(row, space.start, row, space.end), \"\\n\" + indentation);\n        }\n        endRow++;\n      } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n        var nextLine = session.getLine(row + 1);\n        if (nextLine && /\\S/.test(nextLine)) {\n          var trimmedLine = line.replace(/\\s+$/, \"\");\n          var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n          var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n          var space = findSpace(mergedLine, max, 5);\n          if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n            var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);\n            session.replace(replaceRange, \" \");\n            row--;\n            endRow--;\n          } else if (trimmedLine.length < line.length) {\n            session.remove(new Range(row, trimmedLine.length, row, line.length));\n          }\n        }\n      }\n      row++;\n    }\n    function findSpace(line, max, min) {\n      if (line.length < max) return;\n      var before = line.slice(0, max);\n      var after = line.slice(max);\n      var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n      var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n      var start = 0;\n      var end = 0;\n      if (spaceBefore && !spaceBefore[2]) {\n        start = max - spaceBefore[1].length;\n        end = max;\n      }\n      if (spaceAfter && !spaceAfter[2]) {\n        if (!start) start = max;\n        end = max + spaceAfter[1].length;\n      }\n      if (start) {\n        return {\n          start: start,\n          end: end\n        };\n      }\n      if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n        return {\n          start: spaceBefore.index,\n          end: spaceBefore.index + spaceBefore[2].length\n        };\n      }\n      if (spaceAfter && spaceAfter[2]) {\n        start = max + spaceAfter[2].length;\n        return {\n          start: start,\n          end: start + spaceAfter[3].length\n        };\n      }\n    }\n  }\n  function wrapAfterInput(e) {\n    if (e.command.name == \"insertstring\" && /\\S/.test(e.args)) {\n      var editor = e.editor;\n      var cursor = editor.selection.cursor;\n      if (cursor.column <= editor.renderer.$printMarginColumn) return;\n      var lastDelta = editor.session.$undoManager.$lastDelta;\n      hardWrap(editor, {\n        startRow: cursor.row,\n        endRow: cursor.row,\n        allowMerge: false\n      });\n      if (lastDelta != editor.session.$undoManager.$lastDelta) editor.session.markUndoGroup();\n    }\n  }\n  var Editor = require(\"../editor\").Editor;\n  require(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    hardWrap: {\n      set: function (val) {\n        if (val) {\n          this.commands.on(\"afterExec\", wrapAfterInput);\n        } else {\n          this.commands.off(\"afterExec\", wrapAfterInput);\n        }\n      },\n      value: false\n    }\n  });\n  exports.hardWrap = hardWrap;\n});\nace.define(\"ace/keyboard/vim\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/lib/event_emitter\", \"ace/lib/dom\", \"ace/lib/oop\", \"ace/lib/keys\", \"ace/lib/event\", \"ace/search\", \"ace/lib/useragent\", \"ace/search_highlight\", \"ace/commands/multi_select_commands\", \"ace/mode/text\", \"ace/ext/hardwrap\", \"ace/multi_select\"], function (require, exports, module) {\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n  'use strict';\n\n  function log() {\n    var d = \"\";\n    function format(p) {\n      if (typeof p != \"object\") return p + \"\";\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n      if (Array.isArray(p)) return \"[\" + p.map(function (x) {\n        return format(x);\n      }) + \"]\";\n      return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n    console.log(d);\n  }\n  var Range = require(\"../range\").Range;\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n  var domLib = require(\"../lib/dom\");\n  var oop = require(\"../lib/oop\");\n  var KEYS = require(\"../lib/keys\");\n  var event = require(\"../lib/event\");\n  var Search = require(\"../search\").Search;\n  var useragent = require(\"../lib/useragent\");\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n  var hardWrap = require(\"../ext/hardwrap\").hardWrap;\n  require(\"../multi_select\");\n  var CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.options = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n  CodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  };\n  CodeMirror.defineOption = function (name, val, setter) {};\n  CodeMirror.commands = {\n    redo: function (cm) {\n      cm.ace.redo();\n    },\n    undo: function (cm) {\n      cm.ace.undo();\n    },\n    newlineAndIndent: function (cm) {\n      cm.ace.insert(\"\\n\");\n    },\n    goLineLeft: function (cm) {\n      cm.ace.selection.moveCursorLineStart();\n    },\n    goLineRight: function (cm) {\n      cm.ace.selection.moveCursorLineEnd();\n    }\n  };\n  CodeMirror.keyMap = {};\n  CodeMirror.addClass = CodeMirror.rmClass = function () {};\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n  CodeMirror.keyName = function (e) {\n    var key = KEYS[e.keyCode] || e.key || \"\";\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n  CodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\") map = CodeMirror.keyMap[map] || CodeMirror.keyMap['default'];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n  CodeMirror.findMatchingTag = function (cm, head) {\n    return cm.findMatchingTag(head);\n  };\n  CodeMirror.findEnclosingTag = function (cm, head) {};\n  CodeMirror.signal = function (o, name, e) {\n    return o._signal(name, e);\n  };\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n  CodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n  (function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n    this.destroy = function () {\n      this.ace.off('change', this.onChange);\n      this.ace.off('changeSelection', this.onSelectionChange);\n      this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n      this.removeOverlay();\n    };\n    this.virtualSelectionMode = function () {\n      return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n    this.onChange = function (delta) {\n      if (this.$lineHandleChanges) {\n        this.$lineHandleChanges.push(delta);\n      }\n      var change = {\n        text: delta.action[0] == 'i' ? delta.lines : []\n      };\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.changeHandlers) curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n      this.$updateMarkers(delta);\n    };\n    this.onSelectionChange = function () {\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n      this.curOp.cursorActivity = true;\n      if (this.ace.inMultiSelectMode) {\n        this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n      }\n    };\n    this.operation = function (fn, force) {\n      if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n        return fn();\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      if (!this.ace.curOp) {\n        var prevOp = this.ace.prevOp;\n        this.ace.startOperation({\n          command: {\n            name: \"vim\",\n            scrollIntoView: \"cursor\"\n          }\n        });\n      }\n      var curOp = this.curOp = this.curOp || {};\n      this.curOp.force = force;\n      var result = fn();\n      if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n        if (this.state.dialog) this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;\n        this.ace.endOperation();\n        if (!curOp.cursorActivity && !curOp.lastChange && prevOp) this.ace.prevOp = prevOp;\n      }\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n      return result;\n    };\n    this.onBeforeEndOperation = function () {\n      var op = this.curOp;\n      if (op) {\n        if (op.change) {\n          this.signal(\"change\", op.change, op);\n        }\n        if (op && op.cursorActivity) {\n          this.signal(\"cursorActivity\", null, op);\n        }\n        this.curOp = null;\n      }\n    };\n    this.signal = function (eventName, e, handlers) {\n      var listeners = handlers ? handlers[eventName + \"Handlers\"] : (this._eventRegistry || {})[eventName];\n      if (!listeners) return;\n      listeners = listeners.slice();\n      for (var i = 0; i < listeners.length; i++) listeners[i](this, e);\n    };\n    this.firstLine = function () {\n      return 0;\n    };\n    this.lastLine = function () {\n      return this.ace.session.getLength() - 1;\n    };\n    this.lineCount = function () {\n      return this.ace.session.getLength();\n    };\n    this.setCursor = function (line, ch) {\n      if (typeof line === 'object') {\n        ch = line.ch;\n        line = line.line;\n      }\n      var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;\n      if (!this.ace.inVirtualSelectionMode) this.ace.exitMultiSelectMode();\n      this.ace.session.unfold({\n        row: line,\n        column: ch\n      });\n      this.ace.selection.moveTo(line, ch);\n      if (shouldScroll) {\n        this.ace.renderer.scrollCursorIntoView();\n        this.ace.endOperation();\n      }\n    };\n    this.getCursor = function (p) {\n      var sel = this.ace.selection;\n      var pos = p == 'anchor' ? sel.isEmpty() ? sel.lead : sel.anchor : p == 'head' || !p ? sel.lead : sel.getRange()[p];\n      return toCmPos(pos);\n    };\n    this.listSelections = function (p) {\n      var ranges = this.ace.multiSelect.rangeList.ranges;\n      if (!ranges.length || this.ace.inVirtualSelectionMode) return [{\n        anchor: this.getCursor('anchor'),\n        head: this.getCursor('head')\n      }];\n      return ranges.map(function (r) {\n        return {\n          anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n          head: this.clipPos(toCmPos(r.cursor))\n        };\n      }, this);\n    };\n    this.setSelections = function (p, primIndex) {\n      var sel = this.ace.multiSelect;\n      var ranges = p.map(function (x) {\n        var anchor = toAcePos(x.anchor);\n        var head = toAcePos(x.head);\n        var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);\n        r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n        return r;\n      });\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.selection.fromOrientedRange(ranges[0]);\n        return;\n      }\n      if (!primIndex) {\n        ranges = ranges.reverse();\n      } else if (ranges[primIndex]) {\n        ranges.push(ranges.splice(primIndex, 1)[0]);\n      }\n      sel.toSingleRange(ranges[0].clone());\n      var session = this.ace.session;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n        sel.addRange(range);\n      }\n    };\n    this.setSelection = function (a, h, options) {\n      var sel = this.ace.selection;\n      sel.moveTo(a.line, a.ch);\n      sel.selectTo(h.line, h.ch);\n      if (options && options.origin == '*mouse') {\n        this.onBeforeEndOperation();\n      }\n    };\n    this.somethingSelected = function (p) {\n      return !this.ace.selection.isEmpty();\n    };\n    this.clipPos = function (p) {\n      var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n      return toCmPos(pos);\n    };\n    this.foldCode = function (pos) {\n      this.ace.session.$toggleFoldWidget(pos.line, {});\n    };\n    this.markText = function (cursor) {\n      return {\n        clear: function () {},\n        find: function () {}\n      };\n    };\n    this.$updateMarkers = function (delta) {\n      var isInsert = delta.action == \"insert\";\n      var start = delta.start;\n      var end = delta.end;\n      var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n      var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n      if (isInsert) end = start;\n      for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = Range.comparePoints(point, start);\n        if (cmp < 0) {\n          continue; // delta starts after the range\n        }\n        if (cmp === 0) {\n          if (isInsert) {\n            if (!point.$insertRight) {\n              cmp = 1;\n            } else if (point.bias == 1) {\n              cmp = 1;\n            } else {\n              point.bias = -1;\n              continue;\n            }\n          }\n        }\n        var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n        if (cmp2 > 0) {\n          point.row += rowShift;\n          point.column += point.row == end.row ? colShift : 0;\n          continue;\n        }\n        if (!isInsert && cmp2 <= 0) {\n          point.row = start.row;\n          point.column = start.column;\n          if (cmp2 === 0) point.bias = 1;\n        }\n      }\n    };\n    var Marker = function (cm, id, row, column) {\n      this.cm = cm;\n      this.id = id;\n      this.row = row;\n      this.column = column;\n      cm.marks[this.id] = this;\n    };\n    Marker.prototype.clear = function () {\n      delete this.cm.marks[this.id];\n    };\n    Marker.prototype.find = function () {\n      return toCmPos(this);\n    };\n    this.setBookmark = function (cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n      if (!options || !options.insertLeft) bm.$insertRight = true;\n      this.marks[bm.id] = bm;\n      return bm;\n    };\n    this.moveH = function (increment, unit) {\n      if (unit == 'char') {\n        var sel = this.ace.selection;\n        sel.clearSelection();\n        sel.moveCursorBy(0, increment);\n      }\n    };\n    this.findPosV = function (start, amount, unit, goalColumn) {\n      if (unit == 'page') {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        amount = amount * Math.floor(config.height / config.lineHeight);\n        unit = 'line';\n      }\n      if (unit == 'line') {\n        var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n        if (goalColumn != null) screenPos.column = goalColumn;\n        screenPos.row += amount;\n        screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n        var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n        return toCmPos(pos);\n      } else {\n        debugger;\n      }\n    };\n    this.charCoords = function (pos, mode) {\n      if (mode == 'div' || !mode) {\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        return {\n          left: sc.column,\n          top: sc.row\n        };\n      }\n      if (mode == 'local') {\n        var renderer = this.ace.renderer;\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        var lh = renderer.layerConfig.lineHeight;\n        var cw = renderer.layerConfig.characterWidth;\n        var top = lh * sc.row;\n        return {\n          left: sc.column * cw,\n          top: top,\n          bottom: top + lh\n        };\n      }\n    };\n    this.coordsChar = function (pos, mode) {\n      var renderer = this.ace.renderer;\n      if (mode == 'local') {\n        var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n        var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n        var ch = renderer.session.screenToDocumentPosition(row, col);\n        return toCmPos(ch);\n      } else if (mode == 'div') {\n        throw \"not implemented\";\n      }\n    };\n    this.getSearchCursor = function (query, pos, caseFold) {\n      var caseSensitive = false;\n      var isRegexp = false;\n      if (query instanceof RegExp && !query.global) {\n        caseSensitive = !query.ignoreCase;\n        query = query.source;\n        isRegexp = true;\n      }\n      if (query == \"\\\\n\") {\n        query = \"\\n\";\n        isRegexp = false;\n      }\n      var search = new Search();\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var acePos = {\n        row: pos.line,\n        column: pos.ch\n      };\n      var cm = this;\n      var last = null;\n      return {\n        findNext: function () {\n          return this.find(false);\n        },\n        findPrevious: function () {\n          return this.find(true);\n        },\n        find: function (back) {\n          search.setOptions({\n            needle: query,\n            caseSensitive: caseSensitive,\n            wrap: false,\n            backwards: back,\n            regExp: isRegexp,\n            start: last || acePos\n          });\n          var range = search.find(cm.ace.session);\n          last = range;\n          return last && [!last.isEmpty()];\n        },\n        from: function () {\n          return last && toCmPos(last.start);\n        },\n        to: function () {\n          return last && toCmPos(last.end);\n        },\n        replace: function (text) {\n          if (last) {\n            last.end = cm.ace.session.doc.replace(last, text);\n          }\n        }\n      };\n    };\n    this.scrollTo = function (x, y) {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      var maxHeight = config.maxHeight;\n      maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n      if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n      if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n    this.scrollInfo = function () {\n      return 0;\n    };\n    this.scrollIntoView = function (pos, margin) {\n      if (pos) {\n        var renderer = this.ace.renderer;\n        var viewMargin = {\n          \"top\": 0,\n          \"bottom\": margin\n        };\n        renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);\n      }\n    };\n    this.getLine = function (row) {\n      return this.ace.session.getLine(row);\n    };\n    this.getRange = function (s, e) {\n      return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n    this.replaceRange = function (text, s, e) {\n      if (!e) e = s;\n      var range = new Range(s.line, s.ch, e.line, e.ch);\n      this.ace.session.$clipRangeToDocument(range);\n      return this.ace.session.replace(range, text);\n    };\n    this.replaceSelection = this.replaceSelections = function (p) {\n      var strings = Array.isArray(p) && p;\n      var sel = this.ace.selection;\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.session.replace(sel.getRange(), strings ? p[0] || \"\" : p);\n        return;\n      }\n      sel.inVirtualSelectionMode = true;\n      var ranges = sel.rangeList.ranges;\n      if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n      for (var i = ranges.length; i--;) this.ace.session.replace(ranges[i], strings ? p[i] || \"\" : p);\n      sel.inVirtualSelectionMode = false;\n    };\n    this.getSelection = function () {\n      return this.ace.getSelectedText();\n    };\n    this.getSelections = function () {\n      return this.listSelections().map(function (x) {\n        return this.getRange(x.anchor, x.head);\n      }, this);\n    };\n    this.getInputField = function () {\n      return this.ace.textInput.getElement();\n    };\n    this.getWrapperElement = function () {\n      return this.ace.container;\n    };\n    var optMap = {\n      indentWithTabs: \"useSoftTabs\",\n      indentUnit: \"tabSize\",\n      tabSize: \"tabSize\",\n      firstLineNumber: \"firstLineNumber\",\n      readOnly: \"readOnly\"\n    };\n    this.setOption = function (name, val) {\n      this.state[name] = val;\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          val = !val;\n          break;\n        case 'keyMap':\n          this.state.$keyMap = val;\n          return;\n          break;\n        default:\n          name = optMap[name];\n      }\n      if (name) this.ace.setOption(name, val);\n    };\n    this.getOption = function (name) {\n      var val;\n      var aceOpt = optMap[name];\n      if (aceOpt) val = this.ace.getOption(aceOpt);\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          return !val;\n        case 'keyMap':\n          return this.state.$keyMap || 'vim';\n      }\n      return aceOpt ? val : this.state[name];\n    };\n    this.toggleOverwrite = function (on) {\n      this.state.overwrite = on;\n      return this.ace.setOverwrite(on);\n    };\n    this.addOverlay = function (o) {\n      if (!this.$searchHighlight || !this.$searchHighlight.session) {\n        var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n        var marker = this.ace.session.addDynamicMarker(highlight);\n        highlight.id = marker.id;\n        highlight.session = this.ace.session;\n        highlight.destroy = function (o) {\n          highlight.session.off(\"change\", highlight.updateOnChange);\n          highlight.session.off(\"changeEditor\", highlight.destroy);\n          highlight.session.removeMarker(highlight.id);\n          highlight.session = null;\n        };\n        highlight.updateOnChange = function (delta) {\n          var row = delta.start.row;\n          if (row == delta.end.row) highlight.cache[row] = undefined;else highlight.cache.splice(row, highlight.cache.length);\n        };\n        highlight.session.on(\"changeEditor\", highlight.destroy);\n        highlight.session.on(\"change\", highlight.updateOnChange);\n      }\n      var re = new RegExp(o.query.source, \"gmi\");\n      this.$searchHighlight = o.highlight = highlight;\n      this.$searchHighlight.setRegexp(re);\n      this.ace.renderer.updateBackMarkers();\n    };\n    this.removeOverlay = function (o) {\n      if (this.$searchHighlight && this.$searchHighlight.session) {\n        this.$searchHighlight.destroy();\n      }\n    };\n    this.getScrollInfo = function () {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      return {\n        left: renderer.scrollLeft,\n        top: renderer.scrollTop,\n        height: config.maxHeight,\n        width: config.width,\n        clientHeight: config.height,\n        clientWidth: config.width\n      };\n    };\n    this.getValue = function () {\n      return this.ace.getValue();\n    };\n    this.setValue = function (v) {\n      return this.ace.setValue(v, -1);\n    };\n    this.getTokenTypeAt = function (pos) {\n      var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n      return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n    this.findMatchingBracket = function (pos) {\n      var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n      return {\n        to: m && toCmPos(m)\n      };\n    };\n    this.findMatchingTag = function (pos) {\n      var m = this.ace.session.getMatchingTags(toAcePos(pos));\n      if (!m) return;\n      return {\n        open: {\n          from: toCmPos(m.openTag.start),\n          to: toCmPos(m.openTag.end)\n        },\n        close: {\n          from: toCmPos(m.closeTag.start),\n          to: toCmPos(m.closeTag.end)\n        }\n      };\n    };\n    this.indentLine = function (line, method) {\n      if (method === true) this.ace.session.indentRows(line, line, \"\\t\");else if (method === false) this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n    this.indexFromPos = function (pos) {\n      return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n    this.posFromIndex = function (index) {\n      return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n    this.focus = function (index) {\n      return this.ace.textInput.focus();\n    };\n    this.blur = function (index) {\n      return this.ace.blur();\n    };\n    this.defaultTextHeight = function (index) {\n      return this.ace.renderer.layerConfig.lineHeight;\n    };\n    this.scanForBracket = function (pos, dir, _, options) {\n      var re = options.bracketRegex.source;\n      var tokenRe = /paren|text|operator|tag/;\n      if (dir == 1) {\n        var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n      } else {\n        var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {\n          row: pos.line,\n          column: pos.ch + 1\n        }, tokenRe);\n        if (!m && options.bracketRegex && options.bracketRegex.test(this.getLine(pos.line)[pos.ch - 1])) {\n          m = {\n            row: pos.line,\n            column: pos.ch - 1\n          };\n        }\n      }\n      return m && {\n        pos: toCmPos(m)\n      };\n    };\n    this.refresh = function () {\n      return this.ace.resize(true);\n    };\n    this.getMode = function () {\n      return {\n        name: this.getOption(\"mode\")\n      };\n    };\n    this.execCommand = function (name) {\n      if (CodeMirror.commands.hasOwnProperty(name)) return CodeMirror.commands[name](this);\n      if (name == \"indentAuto\") return this.ace.execCommand(\"autoindent\");\n      console.log(name + \" is not implemented\");\n    };\n    this.getLineNumber = function (handle) {\n      var deltas = this.$lineHandleChanges;\n      if (!deltas) return null;\n      var row = handle.row;\n      for (var i = 0; i < deltas.length; i++) {\n        var delta = deltas[i];\n        if (delta.start.row != delta.end.row) {\n          if (delta.action[0] == \"i\") {\n            if (delta.start.row < row) row += delta.end.row - delta.start.row;\n          } else {\n            if (delta.start.row < row) {\n              if (row < delta.end.row || row == delta.end.row && delta.start.column > 0) {\n                return null;\n              }\n              row -= delta.end.row - delta.start.row;\n            }\n          }\n        }\n      }\n      return row;\n    };\n    this.getLineHandle = function (row) {\n      if (!this.$lineHandleChanges) this.$lineHandleChanges = [];\n      return {\n        text: this.ace.session.getLine(row),\n        row: row\n      };\n    };\n    this.releaseLineHandles = function () {\n      this.$lineHandleChanges = undefined;\n    };\n    this.getLastEditEnd = function () {\n      var undoManager = this.ace.session.$undoManager;\n      if (undoManager && undoManager.$lastDelta) return toCmPos(undoManager.$lastDelta.end);\n    };\n  }).call(CodeMirror.prototype);\n  function toAcePos(cmPos) {\n    return {\n      row: cmPos.line,\n      column: cmPos.ch\n    };\n  }\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n  var StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n  StringStream.prototype = {\n    eol: function () {\n      return this.pos >= this.string.length;\n    },\n    sol: function () {\n      return this.pos == this.lineStart;\n    },\n    peek: function () {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function () {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function (match) {\n      var start = this.pos;\n      while (this.eat(match)) {}\n      return this.pos > start;\n    },\n    eatSpace: function () {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function () {\n      this.pos = this.string.length;\n    },\n    skipTo: function (ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function (n) {\n      this.pos -= n;\n    },\n    column: function () {\n      throw \"not implemented\";\n    },\n    indentation: function () {\n      throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function (str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function () {\n      return this.string.slice(this.start, this.pos);\n    },\n    hideFirstChars: function (n, inner) {\n      this.lineStart += n;\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    }\n  };\n  CodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n  };\n  domLib.importCssString(\".normal-mode .ace_cursor{\\n    border: none;\\n    background-color: rgba(255,0,0,0.5);\\n}\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\n  background-color: transparent;\\n  border: 1px solid red;\\n  opacity: 0.7\\n}\\n.ace_dialog {\\n  position: absolute;\\n  left: 0; right: 0;\\n  background: inherit;\\n  z-index: 15;\\n  padding: .1em .8em;\\n  overflow: hidden;\\n  color: inherit;\\n}\\n.ace_dialog-top {\\n  border-bottom: 1px solid #444;\\n  top: 0;\\n}\\n.ace_dialog-bottom {\\n  border-top: 1px solid #444;\\n  bottom: 0;\\n}\\n.ace_dialog input {\\n  border: none;\\n  outline: none;\\n  background: transparent;\\n  width: 20em;\\n  color: inherit;\\n  font-family: monospace;\\n}\", \"vimMode\", false);\n  (function () {\n    function dialogDiv(cm, template, bottom) {\n      var wrap = cm.ace.container;\n      var dialog;\n      dialog = wrap.appendChild(document.createElement(\"div\"));\n      if (bottom) dialog.className = \"ace_dialog ace_dialog-bottom\";else dialog.className = \"ace_dialog ace_dialog-top\";\n      if (typeof template == \"string\") {\n        dialog.innerHTML = template;\n      } else {\n        // Assuming it's a detached DOM element.\n        dialog.appendChild(template);\n      }\n      return dialog;\n    }\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n      if (this.virtualSelectionMode()) return;\n      if (!options) options = {};\n      closeNotification(this, null);\n      var dialog = dialogDiv(this, template, options.bottom);\n      var closed = false,\n        me = this;\n      this.state.dialog = dialog;\n      function close(newVal) {\n        if (typeof newVal == 'string') {\n          inp.value = newVal;\n        } else {\n          if (closed) return;\n          if (newVal && newVal.type == \"blur\") {\n            if (document.activeElement === inp) return;\n          }\n          if (me.state.dialog == dialog) {\n            me.state.dialog = null;\n            me.focus();\n          }\n          closed = true;\n          dialog.remove();\n          if (options.onClose) options.onClose(dialog);\n          var cm = me;\n          if (cm.state.vim) {\n            cm.state.vim.status = null;\n            cm.ace._signal(\"changeStatus\");\n            cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n          }\n        }\n      }\n      var inp = dialog.getElementsByTagName(\"input\")[0],\n        button;\n      if (inp) {\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) inp.select();\n        }\n        if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n          options.onInput(e, inp.value, close);\n        });\n        if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n          options.onKeyUp(e, inp.value, close);\n        });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n          if (e.keyCode == 13) callback(inp.value);\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            CodeMirror.e_stop(e);\n            close();\n          }\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n        inp.focus();\n      } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function () {\n          close();\n          me.focus();\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n      return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n      if (this.virtualSelectionMode()) return;\n      closeNotification(this, close);\n      var dialog = dialogDiv(this, template, options && options.bottom);\n      var closed = false,\n        doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n      function close() {\n        if (closed) return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n      }\n      CodeMirror.on(dialog, 'click', function (e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration) doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  })();\n  var Pos = CodeMirror.Pos;\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n    return {\n      start: curStart,\n      end: curEnd\n    };\n  }\n  var defaultKeymap = [{\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  },\n  // ipad keyboard sends C-Esc instead of C-[\n  {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<register>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<register>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  }, {\n    keys: 'gw',\n    type: 'operator',\n    operator: 'hardWrap',\n    operatorArgs: {\n      keepCursor: true\n    }\n  }, {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<register>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<register>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<register>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<register>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: '<C-r><register>',\n    type: 'action',\n    action: 'insertRegister',\n    context: 'insert',\n    isEdit: true\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'oneNormalCommand',\n    context: 'insert'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, {\n    keys: 'a<register>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<register>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'omap',\n    shortName: 'om'\n  }, {\n    name: 'noremap',\n    shortName: 'no'\n  }, {\n    name: 'nnoremap',\n    shortName: 'nn'\n  }, {\n    name: 'vnoremap',\n    shortName: 'vn'\n  }, {\n    name: 'inoremap',\n    shortName: 'ino'\n  }, {\n    name: 'onoremap',\n    shortName: 'ono'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'mapclear',\n    shortName: 'mapc'\n  }, {\n    name: 'nmapclear',\n    shortName: 'nmapc'\n  }, {\n    name: 'vmapclear',\n    shortName: 'vmapc'\n  }, {\n    name: 'imapclear',\n    shortName: 'imapc'\n  }, {\n    name: 'omapclear',\n    shortName: 'omapc'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'startinsert',\n    shortName: 'start'\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'delete',\n    shortName: 'd'\n  }, {\n    name: 'join',\n    shortName: 'j'\n  }, {\n    name: 'normal',\n    shortName: 'norm'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  var langmap = parseLangmap('');\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n    bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n  var validMarks = ['<', '>'];\n  var validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\n  var latinCharRegex = /^\\w$/;\n  var upperCaseChars;\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var options = {};\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n      type = 'string';\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  defineOption('textwidth', 80, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (width === undefined) {\n      var value = cm.getOption('textwidth');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.setOption('textwidth', column);\n      }\n    }\n  });\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined,\n      //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      changes: [],\n      expectCursorActivityForChange: false\n    };\n  };\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {\n            class: 'cm-vim-message'\n          }, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {\n            bottom: true\n          });\n        }\n        this.isRecording = true;\n      }\n    }\n  };\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      cm.state.vim = {\n        inputState: new InputState(),\n        lastEditInputState: undefined,\n        lastEditActionCommand: undefined,\n        lastHPos: -1,\n        lastHSPos: -1,\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeReturn: false,\n        insertModeRepeat: undefined,\n        visualMode: false,\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        options: {},\n        expectLiteralNext: false\n      };\n    }\n    return cm.state.vim;\n  }\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      searchQuery: null,\n      searchIsReversed: false,\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      searchHistoryController: new HistoryController(),\n      exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {},\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    mapclear: function (ctx) {\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    findKey: function (cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          } else {\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        var changeQueue = vim.inputState.changeQueue;\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = keysAreChars && window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer.length) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            if (!changeQueue || changeQueue.removed.length != selections.length) changeQueue = vim.inputState.changeQueue = new ChangeQueue();\n            changeQueue.inserted += key;\n            for (var i = 0; i < selections.length; i++) {\n              var from = cursorMin(selections[i].anchor, selections[i].head);\n              var to = cursorMax(selections[i].anchor, selections[i].head);\n              var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n              changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n            }\n          }\n          return !keysAreChars;\n        }\n        vim.expectLiteralNext = false;\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (match.command && changeQueue) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(changeQueue.removed[i] || \"\", offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        if (!match.command) clearInputState(cm);\n        return match.command;\n      }\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          return true;\n        } else if (match.type == 'clear') {\n          clearInputState(cm);\n          return true;\n        }\n        vim.expectLiteralNext = false;\n        vim.inputState.keyBuffer.length = 0;\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return !vim.insertMode && key.length === 1 ? function () {\n          return true;\n        } : undefined;\n      } else if (command === true) {\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          if ((command.operator || command.isEdit) && cm.getOption('readOnly')) return; // ace_patch\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(cm, command.toKeys, command);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n  var keyToKeyStack = [];\n  var noremap = false;\n  var virtualPrompt;\n  function sendKeyToPrompt(key) {\n    if (key[0] == \"<\") {\n      var lowerKey = key.toLowerCase().slice(1, -1);\n      var parts = lowerKey.split('-');\n      lowerKey = parts.pop() || '';\n      if (lowerKey == 'lt') key = '<';else if (lowerKey == 'space') key = ' ';else if (lowerKey == 'cr') key = '\\n';else if (vimToCmKeyMap[lowerKey]) {\n        var value = virtualPrompt.value;\n        var event = {\n          key: vimToCmKeyMap[lowerKey],\n          target: {\n            value: value,\n            selectionEnd: value.length,\n            selectionStart: value.length\n          }\n        };\n        if (virtualPrompt.onKeyDown) {\n          virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n        }\n        if (virtualPrompt && virtualPrompt.onKeyUp) {\n          virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n        }\n        return;\n      }\n    }\n    if (key == '\\n') {\n      var prompt = virtualPrompt;\n      virtualPrompt = null;\n      prompt.onClose && prompt.onClose(prompt.value);\n    } else {\n      virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n    function close(value) {\n      if (typeof value == 'string') {\n        virtualPrompt.value = value;\n      } else {\n        virtualPrompt = null;\n      }\n    }\n  }\n  function doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    if (fromKey) {\n      if (keyToKeyStack.indexOf(fromKey) != -1) return;\n      keyToKeyStack.push(fromKey);\n      noremap = fromKey.noremap != false;\n    }\n    try {\n      var vim = maybeInitVimState(cm);\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n      var match;\n      while (match = keyRe.exec(keys)) {\n        var key = match[0];\n        var wasInsert = vim.insertMode;\n        if (virtualPrompt) {\n          sendKeyToPrompt(key);\n          continue;\n        }\n        var result = vimApi.handleKey(cm, key, 'mapping');\n        if (!result && wasInsert && vim.insertMode) {\n          if (key[0] == \"<\") {\n            var lowerKey = key.toLowerCase().slice(1, -1);\n            var parts = lowerKey.split('-');\n            lowerKey = parts.pop() || '';\n            if (lowerKey == 'lt') key = '<';else if (lowerKey == 'space') key = ' ';else if (lowerKey == 'cr') key = '\\n';else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n              key = vimToCmKeyMap[lowerKey];\n              sendCmKey(cm, key);\n              continue;\n            } else {\n              key = key[0];\n              keyRe.lastIndex = match.index + 1;\n            }\n          }\n          cm.replaceSelection(key);\n        }\n      }\n    } finally {\n      keyToKeyStack.pop();\n      noremap = keyToKeyStack.length ? noremapBefore : false;\n      if (!keyToKeyStack.length && virtualPrompt) {\n        var promptOptions = virtualPrompt;\n        virtualPrompt = null;\n        showPrompt(cm, promptOptions);\n      }\n    }\n  }\n  var specialKey = {\n    Return: 'CR',\n    Backspace: 'BS',\n    'Delete': 'Del',\n    Escape: 'Esc',\n    Insert: 'Ins',\n    ArrowLeft: 'Left',\n    ArrowRight: 'Right',\n    ArrowUp: 'Up',\n    ArrowDown: 'Down',\n    Enter: 'CR',\n    ' ': 'Space'\n  };\n  var ignoredKeys = {\n    Shift: 1,\n    Alt: 1,\n    Command: 1,\n    Control: 1,\n    CapsLock: 1,\n    AltGraph: 1,\n    Dead: 1,\n    Unidentified: 1\n  };\n  var vimToCmKeyMap = {};\n  'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function (x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()] = vimToCmKeyMap[x.toLowerCase()] = x;\n  });\n  function vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key]) return;\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if (e.metaKey) {\n      name += 'M-';\n    }\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n      name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl != false || !name) key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code && e.code.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  ;\n  function updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n      langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n  }\n  function parseLangmap(langmapString) {\n    var keymap = {};\n    if (!langmapString) return {\n      keymap: keymap,\n      string: ''\n    };\n    function getEscaped(list) {\n      return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(function (part) {\n      if (!part) return;\n      var semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n      if (semicolon.length == 3) {\n        var from = getEscaped(semicolon[1]);\n        var to = getEscaped(semicolon[2]);\n        if (from.length !== to.length) return; // skip over malformed part\n        for (var i = 0; i < from.length; ++i) keymap[from[i]] = to[i];\n      } else if (semicolon.length == 1) {\n        var pairs = getEscaped(part);\n        if (pairs.length % 2 !== 0) return; // skip over malformed part\n        for (var i = 0; i < pairs.length; i += 2) keymap[pairs[i]] = pairs[i + 1];\n      }\n    });\n    return {\n      keymap: keymap,\n      string: langmapString\n    };\n  }\n  defineOption('langmap', undefined, 'string', ['lmap'], function (name, cm) {\n    if (name === undefined) {\n      return langmap.string;\n    } else {\n      updateLangmap(name);\n    }\n  });\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n    this.changeQueue = null; // For restoring text used by insert mode keybindings\n  }\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n    return repeat;\n  };\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n  function ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n  }\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n  Register.prototype = {\n    setText: function (text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n      this.searchQueries.push(query);\n    },\n    clear: function () {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function () {\n      return this.keyBuffer.join('');\n    }\n  };\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n    registers['+'] = new Register();\n  }\n  RegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+' && typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined' && typeof navigator.clipboard.readText === 'function') {\n        navigator.clipboard.writeText(text);\n      }\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    },\n    isValidRegister: function (name) {\n      return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    },\n    shiftNumericRegisters_: function () {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n  HistoryController.prototype = {\n    nextMatch: function (input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      if (i < 0) return input;\n    },\n    pushInput: function (input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function () {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial',\n          expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n        };\n      }\n      var bestMatch;\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {\n          type: 'clear'\n        };\n        inputState.selectedCharacter = character;\n      }\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n        default:\n          break;\n      }\n    },\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n      function onPromptClose(query) {\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function onPromptKeyUp(e, query, close) {\n        var keyName = vimKeyFromEvent(e),\n          up,\n          offset;\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {}\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      function onPromptKeyDown(e, query, close) {\n        var keyName = vimKeyFromEvent(e);\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' || keyName == '<BS>' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == '<C-u>') {\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: '(JavaScript regexp)',\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, {\n            noSymbol: true\n          });\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, {\n              noSymbol: false\n            });\n            isKeyword = false;\n          }\n          if (!word) {\n            showConfirm(cm, 'No word under cursor');\n            clearInputState(cm);\n            return;\n          }\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    processEx: function (cm, vim, command) {\n      function onPromptClose(input) {\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n      function onPromptKeyDown(e, input, close) {\n        var keyName = vimKeyFromEvent(e),\n          up,\n          offset;\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' || keyName == '<BS>' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == '<C-u>') {\n          CodeMirror.e_stop(e);\n          close('');\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function (cm, vim) {\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          if (!operator && cm.ace.curOp != null) cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n          var jumpList = vimGlobalState.jumpList;\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          if (cm.ace.curOp) cm.ace.curOp.vimDialogScroll = \"center-animate\"; // ace_patch\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n        if (vim.visualMode) {\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n      if (!next) {\n        return;\n      }\n      if (prevInputState.operator) {\n        return next;\n      }\n      var from = next[0];\n      var to = new Pos(next[1].line, next[1].ch - 1);\n      if (vim.visualMode) {\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n            return [anchor, from];\n          }\n        }\n      } else {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n          if (isWrongDirection) {\n            continue;\n          }\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n      if (motionArgs.linewise) {\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      var fold = cm.ace.session.getFoldLine(line);\n      if (fold) {\n        if (motionArgs.forward) {\n          if (line > fold.start.row) line = fold.end.row + 1;\n        } else {\n          line = fold.start.row;\n        }\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n        var matched = cm.findMatchingBracket(new Pos(line, ch + 1), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter;\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp, move;\n      if (mirroredPairs[character]) {\n        move = true;\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n        if (!tmp) {\n          var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n          if (sc.find()) {\n            tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n          }\n        }\n      } else if (selfPaired[character]) {\n        move = true;\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W' || character === 'w') {\n        var repeat = motionArgs.repeat || 1;\n        while (repeat-- > 0) {\n          var repeated = expandWordUnderCursor(cm, {\n            inclusive: inclusive,\n            innerWord: !inclusive,\n            bigWord: character === 'W',\n            noSymbol: character === 'W',\n            multiline: true\n          }, tmp && tmp.end);\n          if (repeated) {\n            if (!tmp) tmp = repeated;\n            tmp.end = repeated.end;\n          }\n        }\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n          start = {\n            line: start.line,\n            ch: start.ch + 1\n          };\n        }\n        tmp = {\n          start: start,\n          end: end\n        };\n      }\n      if (!tmp) {\n        return null;\n      }\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end, move);\n      }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n        head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        if (args.linewise) {\n          anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n          if (head.line > anchor.line) {\n            head = new Pos(head.line - 1, Number.MAX_VALUE);\n          }\n        }\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n      if (cm.indentMore) {\n        var repeat = vim.visualMode ? args.repeat : 1;\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        var repeat = vim.visualMode ? args.repeat : 1;\n        if (args.linewise) {\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n      if (!cm.hardWrap) return;\n      var from = ranges[0].anchor.line;\n      var to = ranges[0].head.line;\n      if (operatorArgs.linewise) to--;\n      var endRow = cm.hardWrap({\n        from: from,\n        to: to\n      });\n      if (endRow > from && operatorArgs.linewise) endRow--;\n      return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n      cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center':\n          y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        cm.on('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(head, {\n          insertLeft: true\n        });\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      if (!vim.visualMode) {\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var _this = this;\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      var fallback = function () {\n        var text = register.toString();\n        _this.continuePaste(cm, actionArgs, vim, text, register);\n      };\n      if (actionArgs.registerName === '+' && typeof navigator !== 'undefined' && typeof navigator.clipboard !== 'undefined' && typeof navigator.clipboard.readText === 'function') {\n        navigator.clipboard.readText().then(function (value) {\n          _this.continuePaste(cm, actionArgs, vim, value, register);\n        }, function () {\n          fallback();\n        });\n      } else {\n        fallback();\n      }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        var whitespaceLength = function (str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        text = text.split('\\n');\n        if (linewise) {\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      if (vim.visualMode) {\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          cm.replaceSelections(emptyStrings);\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          if (linewise) {\n            var line = actionArgs.after ? cur.line + 1 : cur.line;\n            curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n          } else {\n            curPosFinal = copyCursor(cur);\n            if (!/\\n/.test(text)) {\n              curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n            }\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      var text = register && register.toString();\n      if (text) {\n        cm.replaceSelection(text);\n      }\n    },\n    oneNormalCommand: function (cm, actionArgs, vim) {\n      exitInsertMode(cm, true);\n      vim.insertModeReturn = true;\n      CodeMirror.on(cm, 'vim-command-done', function handler() {\n        if (vim.visualMode) return;\n        if (vim.insertModeReturn) {\n          vim.insertModeReturn = false;\n          if (!vim.insertMode) {\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        }\n        CodeMirror.off(cm, 'vim-command-done', handler);\n      });\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n        direction = -1;\n      }\n      ch += direction;\n      if (ch > maxCh) ch -= 2;\n    }\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    if (inputState.operator) context = \"operatorPending\";\n    var match,\n      partial = [],\n      full = [];\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n      if (match == 'partial') {\n        partial.push(command);\n      }\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  function commandMatch(pressed, mapped) {\n    var isLastCharacter = mapped.slice(-11) == '<character>';\n    var isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n      var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  function cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n    cm.setSelections(sel, 0);\n  }\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n  function expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start : sel.head;\n    var anchor = move ? start : sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n        fromCh = anchor.ch,\n        bottom = Math.max(anchor.line, head.line),\n        toCh = head.ch;\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n      ;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  }\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      lines.pop();\n      var line;\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n  function expandWordUnderCursor(cm, _a, cursor) {\n    var inclusive = _a.inclusive,\n      innerWord = _a.innerWord,\n      bigWord = _a.bigWord,\n      noSymbol = _a.noSymbol,\n      multiline = _a.multiline;\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n    var wordOnNextLine;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n      test = function (ch) {\n        return /\\s/.test(ch);\n      };\n    } else {\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n          if (!multiline) return null;\n          idx--;\n          wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n          break;\n        }\n      }\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n    }\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n    if (wordOnNextLine) {\n      end = wordOnNextLine.to;\n      endLineNumber = wordOnNextLine.line;\n      endLine = cm.getLine(endLineNumber);\n      if (!endLine && end == 0) end++;\n    } else {\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n    }\n    if (inclusive) {\n      var wordEnd = end;\n      var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n      if (!startsWithSpace) {\n        while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) {\n          end++;\n        }\n      }\n      if (wordEnd == end || startsWithSpace) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start && !startsWithSpace) {\n          start = wordStart;\n        }\n      }\n    }\n    return {\n      start: new Pos(startLineNumber, start),\n      end: new Pos(endLineNumber, end)\n    };\n  }\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    method: {\n      init: function (state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0) return true;\n        }\n        return false;\n      }\n    }\n  };\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n  }\n  function moveToCharacter(cm, repeat, forward, character, head) {\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return null;\n      }\n      start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n  }\n  function moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    function isEmpty(i) {\n      return !/\\S/.test(cm.getLine(i));\n    } // ace_patch\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    function skipFold(i) {\n      dir = dir > 0 ? 1 : -1;\n      var foldLine = cm.ace.session.getFoldLine(i);\n      if (foldLine) {\n        if (i + dir > foldLine.start.row && i + dir < foldLine.end.row) dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n      }\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        skipFold(i);\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return new Pos(i, 0);\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      } else {\n        curr.pos += curr.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos + 1\n            };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos + 1\n            };\n          }\n        }\n        nextChar(curr);\n      }\n      return {\n        ln: curr.ln,\n        pos: lastSentencePos + 1\n      };\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n      nextChar(curr);\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos\n            };\n          } else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return {\n                ln: curr.ln,\n                pos: curr.pos + 1\n              };\n            } else {\n              return {\n                ln: curr.ln,\n                pos: lastSentencePos\n              };\n            }\n          }\n        }\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      } else {\n        return {\n          ln: curr.ln,\n          pos: lastSentencePos\n        };\n      }\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n        nextChar(cm, curr);\n      }\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n      start,\n      end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    if (!start || !end) return null;\n    start = start.pos;\n    end = end.pos;\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n      var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n      var isStringStart = stringAfter && !stringBefore;\n      if (!isStringStart) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n    }\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n  defineOption('pcre', true, 'boolean');\n  function SearchState() {}\n  SearchState.prototype = {\n    getQuery: function () {\n      return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n      return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n      this.annotate = annotate;\n    }\n  };\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n    return slashes;\n  }\n  function translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t',\n    '\\\\&': '&'\n  };\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n  function parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    if (query instanceof RegExp) {\n      return query;\n    }\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      regexPart = query;\n    } else {\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n    return regexp;\n  }\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n  function showConfirm(cm, template) {\n    var pre = dom('div', {\n      $color: 'red',\n      $whiteSpace: 'pre',\n      class: 'cm-vim-message'\n    }, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  function makePrompt(prefix, desc) {\n    return dom('div', {\n      $display: 'flex'\n    }, dom('span', {\n      $fontFamily: 'monospace',\n      $whiteSpace: 'pre',\n      $flex: 1\n    }, prefix, dom('input', {\n      type: 'text',\n      autocorrect: 'off',\n      autocapitalize: 'off',\n      spellcheck: 'false',\n      $width: '100%'\n    })), desc && dom('span', {\n      $color: '#888'\n    }, desc));\n  }\n  function showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n      if (!options.value) options.value = '';\n      virtualPrompt = options;\n      return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      searchState.highlightTimeout = null;\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  function findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      var found = cursor.find(!prev);\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n      clearTimeout(state.highlightTimeout);\n      state.highlightTimeout = null;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  function getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n      top: renderer.getFirstFullyVisibleRow(),\n      bottom: renderer.getLastFullyVisibleRow()\n    };\n  }\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n  function getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n      return cm.getLastEditEnd();\n    }\n    var done = cm.doc.history.done;\n    for (var i = done.length; i--;) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n  var ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n  };\n  ExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function (cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      var inputStream = new CodeMirror.StringStream(input);\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            doKeyToKey(cm, command.toKeys, command);\n            return;\n          } else if (command.type == 'exToEx') {\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function (cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n      if (result.line == undefined) {\n        if (cm.state.vim.visualMode) {\n          var pos = getMarkPos(cm, cm.state.vim, '<');\n          result.selectionLine = pos && pos.line;\n          pos = getMarkPos(cm, cm.state.vim, '>');\n          result.selectionLineEnd = pos && pos.line;\n        } else {\n          result.selectionLine = cm.getCursor().line;\n        }\n      } else {\n        result.selectionLine = result.line;\n        result.selectionLineEnd = result.lineEnd;\n      }\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n      return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function (commandName) {\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    },\n    buildCommandMap_: function () {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function (lhs, rhs, ctx, noremap) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        var mapping = {\n          keys: lhs,\n          type: 'keyToKey',\n          toKeys: rhs,\n          noremap: !!noremap\n        };\n        if (ctx) {\n          mapping.context = ctx;\n        }\n        defaultKeymap.unshift(mapping);\n      }\n    },\n    unmap: function (lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx, defaultOnly) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    imap: function (cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function (cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function (cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    omap: function (cm, params) {\n      this.map(cm, params, 'operatorPending');\n    },\n    noremap: function (cm, params) {\n      this.map(cm, params, undefined, true);\n    },\n    inoremap: function (cm, params) {\n      this.map(cm, params, 'insert', true);\n    },\n    nnoremap: function (cm, params) {\n      this.map(cm, params, 'normal', true);\n    },\n    vnoremap: function (cm, params) {\n      this.map(cm, params, 'visual', true);\n    },\n    onoremap: function (cm, params) {\n      this.map(cm, params, 'operatorPending', true);\n    },\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    mapclear: function (cm, params) {\n      vimApi.mapclear();\n    },\n    imapclear: function (cm, params) {\n      vimApi.mapclear('insert');\n    },\n    nmapclear: function (cm, params) {\n      vimApi.mapclear('normal');\n    },\n    vmapclear: function (cm, params) {\n      vimApi.mapclear('visual');\n    },\n    omapclear: function (cm, params) {\n      vimApi.mapclear('operatorPending');\n    },\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function (cm, params) {\n      var setArgs = params.args;\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n      var forceToggle = false;\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      } else if (optionName.charAt(optionName.length - 1) == '!') {\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceToggle = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        optionName = optionName.substring(2);\n        value = false;\n      }\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean) {\n        if (forceToggle) {\n          value = !getOption(optionName, cm, setCfg);\n        } else if (value == undefined) {\n          value = true;\n        }\n      }\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function (cm, params) {\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat('!')) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n      this.global(cm, params);\n    },\n    normal: function (cm, params) {\n      var argString = params.argString;\n      if (argString && argString[0] == '!') {\n        argString = argString.slice(1);\n        noremap = true;\n      }\n      argString = argString.trimStart();\n      if (!argString) {\n        showConfirm(cm, 'Argument is required.');\n        return;\n      }\n      var line = params.line;\n      if (typeof line == 'number') {\n        var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n        for (var i = line; i <= lineEnd; i++) {\n          cm.setCursor(i, 0);\n          doKeyToKey(cm, params.argString.trimStart());\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      } else {\n        doKeyToKey(cm, params.argString.trimStart());\n        if (cm.state.vim.insertMode) {\n          exitInsertMode(cm, true);\n        }\n      }\n    },\n    global: function (cm, params) {\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      if (argString[0] === '!' && params.commandName[0] === 'g') {\n        inverted = true;\n        argString = argString.slice(1);\n      }\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd;\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLine(i);\n        var matched = query.test(line);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n        }\n      }\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var lineHandle = matchedLines[index++];\n          var lineNum = cm.getLineNumber(lineHandle);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        } else if (cm.releaseLineHandles) {\n          cm.releaseLineHandles();\n        }\n      };\n      nextCommand();\n    },\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n        replacePart = '',\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    startinsert: function (cm, params) {\n      doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        cm.save();\n      }\n    },\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delete: function (cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      operators.delete(cm, {\n        linewise: true\n      }, [{\n        anchor: new Pos(line, 0),\n        head: new Pos(lineEnd + 1, 0)\n      }]);\n    },\n    join: function (cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      cm.setCursor(new Pos(line, 0));\n      actions.joinLines(cm, {\n        repeat: lineEnd - line\n      }, cm.state.vim);\n    },\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n        var count = stream.pos;\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n        var sym = stream.next();\n        if (stream.match('-', true)) {\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var startMark = sym;\n          var finishMark = stream.next();\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    function onPromptKeyDown(e, _value, close) {\n      CodeMirror.e_stop(e);\n      var keyName = vimKeyFromEvent(e);\n      switch (keyName) {\n        case 'y':\n          replace();\n          next();\n          break;\n        case 'n':\n          next();\n          break;\n        case 'a':\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'l':\n          replace();\n        case 'q':\n        case '<Esc>':\n        case '<C-c>':\n        case '<C-[>':\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n  function exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      if (vim.insertEnd) vim.insertEnd.clear();\n      vim.insertEnd = null;\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) command[key] = extra[key];\n    _mapCommand(command);\n  }\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      while (text) {\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      var vim = cm.state.vim;\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              if (text.length > 1) {\n                var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                var cursor = cm.getCursor();\n                if (insertEnd && insertEnd.line == cursor.line) {\n                  var offset = insertEnd.ch - cursor.ch;\n                  if (offset > 0 && offset < text.length) {\n                    lastChange.changes.push([text, offset]);\n                    text = '';\n                  }\n                }\n              }\n              if (text) lastChange.changes.push(text);\n            }\n          }\n        }\n        changeObj = changeObj.next;\n      }\n    }\n  }\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        lastChange.maybeReset = true;\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(cm.getCursor(), {\n          insertLeft: true\n        });\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  function handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n    if (vim.visualMode) {\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode && !keepHPos) {\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n  function InsertModeKey(keyName, e) {\n    this.keyName = keyName;\n    this.key = e.key;\n    this.ctrlKey = e.ctrlKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    this.shiftKey = e.shiftKey;\n  }\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n    if (!keyName) {\n      return;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n  }\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  function sendCmKey(cm, key) {\n    CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    });\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          sendCmKey(cm, change.keyName, change);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n          cm.replaceRange(change[0], start, change[1] ? start : end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n  CodeMirror.Vim = vimApi;\n  var specialKeyAce = {\n    'return': 'CR',\n    backspace: 'BS',\n    'delete': 'Del',\n    esc: 'Esc',\n    left: 'Left',\n    right: 'Right',\n    up: 'Up',\n    down: 'Down',\n    space: 'Space',\n    insert: 'Ins',\n    home: 'Home',\n    end: 'End',\n    pageup: 'PageUp',\n    pagedown: 'PageDown',\n    enter: 'CR'\n  };\n  function lookupKey(hashId, key, e, vim) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKeyAce[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl !== false || !name) key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code && e.code.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  var handleKey = vimApi.handleKey.bind(vimApi);\n  vimApi.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n      return handleKey(cm, key, origin);\n    }, true);\n  };\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      if (key == \"insertEnd\") return;\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      var changeQueueList = vim.inputState.changeQueueList || [];\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        var index = 0;\n        cm.ace.forEachSelection(function () {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          cm.state.vim.inputState.changeQueue = changeQueueList[index];\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n          if (cm.ace.inVirtualSelectionMode) {\n            changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n          }\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n          index++;\n        });\n        if (cm.curOp.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n        vim.status = cm.state.vim.status;\n        cm.state.vim = vim;\n        vim.inputState.changeQueueList = changeQueueList;\n        vim.inputState.changeQueue = null;\n      }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n  }\n  resetVimGlobalState();\n  exports.CodeMirror = CodeMirror;\n  var getVim = vimApi.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w) left -= w;\n      }\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n      domLib.translate(element, left, top);\n      domLib.setStyle(element.style, \"width\", w + \"px\");\n      domLib.setStyle(element.style, \"height\", h + \"px\");\n    },\n    $getDirectionForHighlight: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (!vim.insertMode) {\n        return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();\n      }\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4) key = key.toUpperCase();\n            }\n          }\n          data.inputChar = key;\n        } else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1;\n          } else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        } else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n      if (cm.state.overwrite && vim.insertMode && key == \"backspace\" && hashId == 0) {\n        return {\n          command: \"gotoleft\"\n        };\n      }\n      if (key == \"c\" && hashId == 1) {\n        // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function () {\n            if (vim.insertMode) editor.selection.clearSelection();else cm.operation(function () {\n              exitVisualMode(cm);\n            });\n          });\n          return {\n            command: \"null\",\n            passEvent: true\n          };\n        }\n      }\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {}, vim);\n        if (vim.status == null) vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n        if (isHandled && vim.status != null) vim.status += name;else if (vim.status == null) vim.status = \"\";\n        cm._signal(\"changeStatus\");\n        if (!isHandled && (hashId != -1 || insertMode)) return;\n        return {\n          command: \"null\",\n          passEvent: !isHandled\n        };\n      }\n    },\n    attach: function (editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      enterVimMode(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function () {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n        cm.ace._signal(\"changeStatus\");\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function () {\n        cm.ace.renderer.updateCursor();\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function () {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n        cm._signal(\"changeStatus\");\n      });\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n      var cm = editor.state.cm;\n      leaveVimMode(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode) return \"INSERT\";\n      var status = \"\";\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine) status += \" LINE\";\n        if (vim.visualBlock) status += \" BLOCK\";\n      }\n      if (vim.status) status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  vimApi.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n      if (cm) {\n        cm.ace.setOption(\"wrap\", value);\n      }\n    },\n    type: \"boolean\"\n  }, false);\n  vimApi.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n  });\n  defaultKeymap.push({\n    keys: 'zc',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false\n    }\n  }, {\n    keys: 'zC',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false,\n      all: true\n    }\n  }, {\n    keys: 'zo',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true\n    }\n  }, {\n    keys: 'zO',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'za',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true\n    }\n  }, {\n    keys: 'zA',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true,\n      all: true\n    }\n  }, {\n    keys: 'zf',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'zd',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: '<C-A-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAbove\"\n    }\n  }, {\n    keys: '<C-A-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelow\"\n    }\n  }, {\n    keys: '<C-A-S-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAboveSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-S-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelowSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreBefore\"\n    }\n  }, {\n    keys: '<C-A-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreAfter\"\n    }\n  }, {\n    keys: '<C-A-S-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextBefore\"\n    }\n  }, {\n    keys: '<C-A-S-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextAfter\"\n    }\n  });\n  defaultKeymap.push({\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  });\n  vimApi.defineOperator(\"hardWrap\", function (cm, operatorArgs, ranges, oldAnchor, newHead) {\n    var anchor = ranges[0].anchor.line;\n    var head = ranges[0].head.line;\n    if (operatorArgs.linewise) head--;\n    hardWrap(cm.ace, {\n      startRow: anchor,\n      endRow: head\n    });\n    return Pos(head, 0);\n  });\n  defineOption('textwidth', undefined, 'number', ['tw'], function (width, cm) {\n    if (cm === undefined) {\n      return;\n    }\n    if (width === undefined) {\n      var value = cm.ace.getOption('printMarginColumn');\n      return value;\n    } else {\n      var column = Math.round(width);\n      if (column > 1) {\n        cm.ace.setOption('printMarginColumn', column);\n      }\n    }\n  });\n  actions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode) cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);else delayedExecAceCommand(null, cm.ace);\n  };\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n  }\n  actions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n  defaultKeymapLength = defaultKeymap.length; // ace_patch\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = vimApi;\n});\n(function () {\n  ace.require([\"ace/keyboard/vim\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}