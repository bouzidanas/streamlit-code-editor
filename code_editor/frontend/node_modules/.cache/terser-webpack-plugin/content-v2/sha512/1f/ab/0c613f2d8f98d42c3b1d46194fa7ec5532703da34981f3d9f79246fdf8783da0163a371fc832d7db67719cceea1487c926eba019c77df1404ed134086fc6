{"code":"ace.define(\"ace/mode/clojure_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),s=e(\"./text_highlight_rules\").TextHighlightRules,a=function(){var e=this.createKeywordMapper({keyword:\"throw try var def do fn if let loop monitor-enter monitor-exit new quote recur set!\",\"constant.language\":\"true false nil\",\"support.function\":\"* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* *compile-path* *e *err* *file* *flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* *source-path* *use-context-classloader* *warn-on-reflection* + - -> ->> .. / < <= = == > &gt; >= &gt;= accessor aclone add-classpath add-watch agent agent-errors aget alength alias all-ns alter alter-meta! alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 bases bean bigdec bigint binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* butlast byte byte-array bytes cast char char-array char-escape-string char-name-string char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement concat cond condp conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec decimal? declare definline defmacro defmethod defmulti defn defn- defonce defstruct delay delay? deliver deref derive descendants destructure disj disj! dissoc dissoc! distinct distinct? doall doc dorun doseq dosync dotimes doto double double-array doubles drop drop-last drop-while empty empty? ensure enumeration-seq eval even? every? false? ffirst file-seq filter find find-doc find-ns find-var first float float-array float? floats flush fn fn? fnext for force format future future-call future-cancel future-cancelled? future-done? future? gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator hash hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc init-proxy instance? int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array make-hierarchy map map? mapcat max max-key memfn memoize merge merge-with meta method-sig methods min min-key mod name namespace neg? newline next nfirst nil? nnext not not-any? not-empty not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? or parents partial partition pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers primitives-classnames print print-ctor print-doc print-dup print-method print-namespace-doc print-simple print-special-doc print-str printf println println-str prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot rand rand-int range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern re-seq read read-line read-string reduce ref ref-history-count ref-max-history ref-min-history ref-set refer refer-clojure release-pending-sends rem remove remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq rsubseq second select-keys send send-off seq seq? seque sequence sequential? set set-validator! set? short short-array shorts shutdown-agents slurp some sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-form-anchor special-symbol? split-at split-with str stream? string? struct struct-map subs subseq subvec supers swap! symbol symbol? sync syntax-symbol-anchor take take-last take-nth take-while test the-ns time to-array to-array-2d trampoline transient tree-seq true? type unchecked-add unchecked-dec unchecked-divide unchecked-inc unchecked-multiply unchecked-negate unchecked-remainder unchecked-subtract underive unquote unquote-splicing update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector? when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context with-local-vars with-meta with-open with-out-str with-precision xml-seq zero? zipmap\"},\"identifier\",!1,\" \");this.$rules={start:[{token:\"comment\",regex:\";.*$\"},{token:\"keyword\",regex:\"[\\\\(|\\\\)]\"},{token:\"keyword\",regex:\"[\\\\'\\\\(]\"},{token:\"keyword\",regex:\"[\\\\[|\\\\]]\"},{token:\"keyword\",regex:\"[\\\\{|\\\\}|\\\\#\\\\{|\\\\#\\\\}]\"},{token:\"keyword\",regex:\"[\\\\&]\"},{token:\"keyword\",regex:\"[\\\\#\\\\^\\\\{]\"},{token:\"keyword\",regex:\"[\\\\%]\"},{token:\"keyword\",regex:\"[@]\"},{token:\"constant.numeric\",regex:\"0[xX][0-9a-fA-F]+\\\\b\"},{token:\"constant.numeric\",regex:\"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"},{token:\"constant.language\",regex:\"[!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+||=|!=|<=|>=|<>|<|>|!|&&]\"},{token:e,regex:\"[a-zA-Z_$][a-zA-Z0-9_$\\\\-]*\\\\b\"},{token:\"string\",regex:'\"',next:\"string\"},{token:\"constant\",regex:/:[^()\\[\\]{}'\"\\^%`,;\\s]+/},{token:\"string.regexp\",regex:'/#\"(?:\\\\.|(?:\\\\\")|[^\"\"\\n])*\"/g'}],string:[{token:\"constant.language.escape\",regex:\"\\\\\\\\.|\\\\\\\\$\"},{token:\"string\",regex:'[^\"\\\\\\\\]+'},{token:\"string\",regex:'\"',next:\"start\"}]}};r.inherits(a,s),t.ClojureHighlightRules=a})),ace.define(\"ace/mode/matching_parens_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range,s=function(){};(function(){this.checkOutdent=function(e,t){return!!/^\\s+$/.test(e)&&/^\\s*\\)/.test(t)},this.autoOutdent=function(e,t){var n=e.getLine(t).match(/^(\\s*\\))/);if(!n)return 0;var s=n[1].length,a=e.findMatchingBracket({row:t,column:s});if(!a||a.row==t)return 0;var o=this.$getIndent(e.getLine(a.row));e.replace(new r(t,0,t,s-1),o)},this.$getIndent=function(e){var t=e.match(/^(\\s+)/);return t?t[1]:\"\"}}).call(s.prototype),t.MatchingParensOutdent=s})),ace.define(\"ace/mode/clojure\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/clojure_highlight_rules\",\"ace/mode/matching_parens_outdent\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),s=e(\"./text\").Mode,a=e(\"./clojure_highlight_rules\").ClojureHighlightRules,o=e(\"./matching_parens_outdent\").MatchingParensOutdent,i=function(){this.HighlightRules=a,this.$outdent=new o,this.$behaviour=this.$defaultBehaviour};r.inherits(i,s),function(){this.lineCommentStart=\";\",this.minorIndentFunctions=[\"defn\",\"defn-\",\"defmacro\",\"def\",\"deftest\",\"testing\"],this.$toIndent=function(e){return e.split(\"\").map((function(e){return/\\s/.exec(e)?e:\" \"})).join(\"\")},this.$calculateIndent=function(e,t){for(var n,r,s=this.$getIndent(e),a=0,o=e.length-1;o>=0&&(\"(\"===(r=e[o])?(a--,n=!0):\"(\"===r||\"[\"===r||\"{\"===r?(a--,n=!1):\")\"!==r&&\"]\"!==r&&\"}\"!==r||a++,!(a<0));o--);if(!(a<0&&n))return a<0&&!n?this.$toIndent(e.substring(0,o+1)):a>0?s=s.substring(0,s.length-t.length):s;for(var i=o+=1,c=\"\";;){if(\" \"===(r=e[o])||\"\\t\"===r)return-1!==this.minorIndentFunctions.indexOf(c)?this.$toIndent(e.substring(0,i-1)+t):this.$toIndent(e.substring(0,o+1));if(void 0===r)return this.$toIndent(e.substring(0,i-1)+t);c+=e[o],o++}},this.getNextLineIndent=function(e,t,n){return this.$calculateIndent(t,n)},this.checkOutdent=function(e,t,n){return this.$outdent.checkOutdent(t,n)},this.autoOutdent=function(e,t,n){this.$outdent.autoOutdent(t,n)},this.$id=\"ace/mode/clojure\",this.snippetFileId=\"ace/snippets/clojure\"}.call(i.prototype),t.Mode=i})),ace.require([\"ace/mode/clojure\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"f6bb72adbd9c04c120ec80cfe244cea0.js","input":"ace.define(\"ace/mode/clojure_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var ClojureHighlightRules = function ClojureHighlightRules() {\n    var builtinFunctions = '* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* ' + '*command-line-args* *compile-files* *compile-path* *e *err* *file* ' + '*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* ' + '*print-dup* *print-length* *print-level* *print-meta* *print-readably* ' + '*read-eval* *source-path* *use-context-classloader* ' + '*warn-on-reflection* + - -> ->> .. / < <= = ' + '== > &gt; >= &gt;= accessor aclone ' + 'add-classpath add-watch agent agent-errors aget alength alias all-ns ' + 'alter alter-meta! alter-var-root amap ancestors and apply areduce ' + 'array-map aset aset-boolean aset-byte aset-char aset-double aset-float ' + 'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? ' + 'atom await await-for await1 bases bean bigdec bigint binding bit-and ' + 'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left ' + 'bit-shift-right bit-test bit-xor boolean boolean-array booleans ' + 'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array ' + 'char-escape-string char-name-string char? chars chunk chunk-append ' + 'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? ' + 'class class? clear-agent-errors clojure-version coll? comment commute ' + 'comp comparator compare compare-and-set! compile complement concat cond ' + 'condp conj conj! cons constantly construct-proxy contains? count ' + 'counted? create-ns create-struct cycle dec decimal? declare definline ' + 'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? ' + 'deliver deref derive descendants destructure disj disj! dissoc dissoc! ' + 'distinct distinct? doall doc dorun doseq dosync dotimes doto double ' + 'double-array doubles drop drop-last drop-while empty empty? ensure ' + 'enumeration-seq eval even? every? false? ffirst file-seq filter find ' + 'find-doc find-ns find-var first float float-array float? floats flush ' + 'fn fn? fnext for force format future future-call future-cancel ' + 'future-cancelled? future-done? future? gen-class gen-interface gensym ' + 'get get-in get-method get-proxy-class get-thread-bindings get-validator ' + 'hash hash-map hash-set identical? identity if-let if-not ifn? import ' + 'in-ns inc init-proxy instance? int int-array integer? interleave intern ' + 'interpose into into-array ints io! isa? iterate iterator-seq juxt key ' + 'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list ' + 'list* list? load load-file load-reader load-string loaded-libs locking ' + 'long long-array longs loop macroexpand macroexpand-1 make-array ' + 'make-hierarchy map map? mapcat max max-key memfn memoize merge ' + 'merge-with meta method-sig methods min min-key mod name namespace neg? ' + 'newline next nfirst nil? nnext not not-any? not-empty not-every? not= ' + 'ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ' + 'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? ' + 'or parents partial partition pcalls peek persistent! pmap pop pop! ' + 'pop-thread-bindings pos? pr pr-str prefer-method prefers ' + 'primitives-classnames print print-ctor print-doc print-dup print-method ' + 'print-namespace-doc print-simple print-special-doc print-str printf ' + 'println println-str prn prn-str promise proxy proxy-call-with-super ' + 'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot ' + 'rand rand-int range ratio? rational? rationalize re-find re-groups ' + 're-matcher re-matches re-pattern re-seq read read-line read-string ' + 'reduce ref ref-history-count ref-max-history ref-min-history ref-set ' + 'refer refer-clojure release-pending-sends rem remove remove-method ' + 'remove-ns remove-watch repeat repeatedly replace replicate require ' + 'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq ' + 'rsubseq second select-keys send send-off seq seq? seque sequence ' + 'sequential? set set-validator! set? short short-array shorts ' + 'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by ' + 'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? ' + 'split-at split-with str stream? string? struct struct-map subs subseq ' + 'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take ' + 'take-last take-nth take-while test the-ns time to-array to-array-2d ' + 'trampoline transient tree-seq true? type unchecked-add unchecked-dec ' + 'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate ' + 'unchecked-remainder unchecked-subtract underive unquote ' + 'unquote-splicing update-in update-proxy use val vals var-get var-set ' + 'var? vary-meta vec vector vector? when when-first when-let when-not ' + 'while with-bindings with-bindings* with-in-str with-loading-context ' + 'with-local-vars with-meta with-open with-out-str with-precision xml-seq ' + 'zero? zipmap';\n    var keywords = 'throw try var ' + 'def do fn if let loop monitor-enter monitor-exit new quote recur set!';\n    var buildinConstants = \"true false nil\";\n    var keywordMapper = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"constant.language\": buildinConstants,\n      \"support.function\": builtinFunctions\n    }, \"identifier\", false, \" \");\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \";.*$\"\n      }, {\n        token: \"keyword\",\n        regex: \"[\\\\(|\\\\)]\"\n      }, {\n        token: \"keyword\",\n        regex: \"[\\\\'\\\\(]\"\n      }, {\n        token: \"keyword\",\n        regex: \"[\\\\[|\\\\]]\"\n      }, {\n        token: \"keyword\",\n        regex: \"[\\\\{|\\\\}|\\\\#\\\\{|\\\\#\\\\}]\"\n      }, {\n        token: \"keyword\",\n        regex: '[\\\\&]'\n      }, {\n        token: \"keyword\",\n        regex: '[\\\\#\\\\^\\\\{]'\n      }, {\n        token: \"keyword\",\n        regex: '[\\\\%]'\n      }, {\n        token: \"keyword\",\n        regex: '[@]'\n      }, {\n        token: \"constant.numeric\",\n        regex: \"0[xX][0-9a-fA-F]+\\\\b\"\n      }, {\n        token: \"constant.numeric\",\n        regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n      }, {\n        token: \"constant.language\",\n        regex: '[!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+||=|!=|<=|>=|<>|<|>|!|&&]'\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$\\\\-]*\\\\b\"\n      }, {\n        token: \"string\",\n        regex: '\"',\n        next: \"string\"\n      }, {\n        token: \"constant\",\n        regex: /:[^()\\[\\]{}'\"\\^%`,;\\s]+/\n      }, {\n        token: \"string.regexp\",\n        regex: '/#\"(?:\\\\.|(?:\\\\\")|[^\"\"\\n])*\"/g'\n      }],\n      \"string\": [{\n        token: \"constant.language.escape\",\n        regex: \"\\\\\\\\.|\\\\\\\\$\"\n      }, {\n        token: \"string\",\n        regex: '[^\"\\\\\\\\]+'\n      }, {\n        token: \"string\",\n        regex: '\"',\n        next: \"start\"\n      }]\n    };\n  };\n  oop.inherits(ClojureHighlightRules, TextHighlightRules);\n  exports.ClojureHighlightRules = ClojureHighlightRules;\n});\nace.define(\"ace/mode/matching_parens_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  var MatchingParensOutdent = function MatchingParensOutdent() {};\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\)/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\))/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n      var match = line.match(/^(\\s+)/);\n      if (match) {\n        return match[1];\n      }\n      return \"\";\n    };\n  }).call(MatchingParensOutdent.prototype);\n  exports.MatchingParensOutdent = MatchingParensOutdent;\n});\nace.define(\"ace/mode/clojure\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/clojure_highlight_rules\", \"ace/mode/matching_parens_outdent\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var ClojureHighlightRules = require(\"./clojure_highlight_rules\").ClojureHighlightRules;\n  var MatchingParensOutdent = require(\"./matching_parens_outdent\").MatchingParensOutdent;\n  var Mode = function Mode() {\n    this.HighlightRules = ClojureHighlightRules;\n    this.$outdent = new MatchingParensOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \";\";\n    this.minorIndentFunctions = [\"defn\", \"defn-\", \"defmacro\", \"def\", \"deftest\", \"testing\"];\n    this.$toIndent = function (str) {\n      return str.split('').map(function (ch) {\n        if (/\\s/.exec(ch)) {\n          return ch;\n        } else {\n          return ' ';\n        }\n      }).join('');\n    };\n    this.$calculateIndent = function (line, tab) {\n      var baseIndent = this.$getIndent(line);\n      var delta = 0;\n      var isParen, ch;\n      for (var i = line.length - 1; i >= 0; i--) {\n        ch = line[i];\n        if (ch === '(') {\n          delta--;\n          isParen = true;\n        } else if (ch === '(' || ch === '[' || ch === '{') {\n          delta--;\n          isParen = false;\n        } else if (ch === ')' || ch === ']' || ch === '}') {\n          delta++;\n        }\n        if (delta < 0) {\n          break;\n        }\n      }\n      if (delta < 0 && isParen) {\n        i += 1;\n        var iBefore = i;\n        var fn = '';\n        while (true) {\n          ch = line[i];\n          if (ch === ' ' || ch === '\\t') {\n            if (this.minorIndentFunctions.indexOf(fn) !== -1) {\n              return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n            } else {\n              return this.$toIndent(line.substring(0, i + 1));\n            }\n          } else if (ch === undefined) {\n            return this.$toIndent(line.substring(0, iBefore - 1) + tab);\n          }\n          fn += line[i];\n          i++;\n        }\n      } else if (delta < 0 && !isParen) {\n        return this.$toIndent(line.substring(0, i + 1));\n      } else if (delta > 0) {\n        baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\n        return baseIndent;\n      } else {\n        return baseIndent;\n      }\n    };\n    this.getNextLineIndent = function (state, line, tab) {\n      return this.$calculateIndent(line, tab);\n    };\n    this.checkOutdent = function (state, line, input) {\n      return this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, doc, row) {\n      this.$outdent.autoOutdent(doc, row);\n    };\n    this.$id = \"ace/mode/clojure\";\n    this.snippetFileId = \"ace/snippets/clojure\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/clojure\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}