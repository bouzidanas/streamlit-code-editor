{"code":"ace.define(\"ace/mode/latex_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,t,r){\"use strict\";var a=e(\"../lib/oop\"),n=e(\"./text_highlight_rules\").TextHighlightRules,o=function(){this.$rules={start:[{token:\"comment\",regex:\"%.*$\"},{token:[\"keyword\",\"lparen\",\"variable.parameter\",\"rparen\",\"lparen\",\"storage.type\",\"rparen\"],regex:\"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"},{token:[\"keyword\",\"lparen\",\"variable.parameter\",\"rparen\"],regex:\"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"},{token:[\"storage.type\",\"lparen\",\"variable.parameter\",\"rparen\"],regex:\"(\\\\\\\\begin)({)(verbatim)(})\",next:\"verbatim\"},{token:[\"storage.type\",\"lparen\",\"variable.parameter\",\"rparen\"],regex:\"(\\\\\\\\begin)({)(lstlisting)(})\",next:\"lstlisting\"},{token:[\"storage.type\",\"lparen\",\"variable.parameter\",\"rparen\"],regex:\"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"},{token:\"storage.type\",regex:/\\\\verb\\b\\*?/,next:[{token:[\"keyword.operator\",\"string\",\"keyword.operator\"],regex:\"(.)(.*?)(\\\\1|$)|\",next:\"start\"}]},{token:\"storage.type\",regex:\"\\\\\\\\[a-zA-Z]+\"},{token:\"lparen\",regex:\"[[({]\"},{token:\"rparen\",regex:\"[\\\\])}]\"},{token:\"constant.character.escape\",regex:\"\\\\\\\\[^a-zA-Z]?\"},{token:\"string\",regex:\"\\\\${1,2}\",next:\"equation\"}],equation:[{token:\"comment\",regex:\"%.*$\"},{token:\"string\",regex:\"\\\\${1,2}\",next:\"start\"},{token:\"constant.character.escape\",regex:\"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"},{token:\"error\",regex:\"^\\\\s*$\",next:\"start\"},{defaultToken:\"string\"}],verbatim:[{token:[\"storage.type\",\"lparen\",\"variable.parameter\",\"rparen\"],regex:\"(\\\\\\\\end)({)(verbatim)(})\",next:\"start\"},{defaultToken:\"text\"}],lstlisting:[{token:[\"storage.type\",\"lparen\",\"variable.parameter\",\"rparen\"],regex:\"(\\\\\\\\end)({)(lstlisting)(})\",next:\"start\"},{defaultToken:\"text\"}]},this.normalizeRules()};a.inherits(o,n),t.LatexHighlightRules=o})),ace.define(\"ace/mode/folding/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"],(function(e,t,r){\"use strict\";var a=e(\"../../lib/oop\"),n=e(\"./fold_mode\").FoldMode,o=e(\"../../range\").Range,i=e(\"../../token_iterator\").TokenIterator,l={\"\\\\subparagraph\":1,\"\\\\paragraph\":2,\"\\\\subsubsubsection\":3,\"\\\\subsubsection\":4,\"\\\\subsection\":5,\"\\\\section\":6,\"\\\\chapter\":7,\"\\\\part\":8,\"\\\\begin\":9,\"\\\\end\":10},s=t.FoldMode=function(){};a.inherits(s,n),function(){this.foldingStartMarker=/^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/,this.foldingStopMarker=/^\\s*\\\\(end)\\b|^\\s*}/,this.getFoldWidgetRange=function(e,t,r){var a,n=e.doc.getLine(r);return(a=this.foldingStartMarker.exec(n))?a[1]?this.latexBlock(e,r,a[0].length-1):a[2]?this.latexSection(e,r,a[0].length-1):this.openingBracketBlock(e,\"{\",r,a.index):(a=this.foldingStopMarker.exec(n))?a[1]?this.latexBlock(e,r,a[0].length-1):this.closingBracketBlock(e,\"}\",r,a.index+a[0].length):void 0},this.latexBlock=function(e,t,r,a){var n={\"\\\\begin\":1,\"\\\\end\":-1},l=new i(e,t,r),s=l.getCurrentToken();if(s&&(\"storage.type\"==s.type||\"constant.character.escape\"==s.type)){var g=n[s.value],c=function(){var e=l.stepForward(),t=e&&\"lparen\"==e.type?l.stepForward().value:\"\";return-1===g&&(l.stepBackward(),t&&l.stepBackward()),t},p=[c()],u=-1===g?l.getCurrentTokenColumn():e.getLine(t).length,d=t;for(l.step=-1===g?l.stepBackward:l.stepForward;s=l.step();)if(s&&(\"storage.type\"==s.type||\"constant.character.escape\"==s.type)){var h=n[s.value];if(h){var x=c();if(h===g)p.unshift(x);else if(p.shift()!==x||!p.length)break}}if(!p.length){if(1==g&&(l.stepBackward(),l.stepBackward()),a)return l.getCurrentTokenRange();t=l.getCurrentTokenRow();return-1===g?new o(t,e.getLine(t).length,d,u):new o(d,u,t,l.getCurrentTokenColumn())}}},this.latexSection=function(e,t,r){var a=new i(e,t,r),n=a.getCurrentToken();if(n&&\"storage.type\"==n.type){for(var s=l[n.value]||0,g=0,c=t;n=a.stepForward();)if(\"storage.type\"===n.type){var p=l[n.value]||0;if(p>=9){if(g||(c=a.getCurrentTokenRow()-1),(g+=9==p?1:-1)<0)break}else if(p>=s)break}for(g||(c=a.getCurrentTokenRow()-1);c>t&&!/\\S/.test(e.getLine(c));)c--;return new o(t,e.getLine(t).length,c,e.getLine(c).length)}}}.call(s.prototype)})),ace.define(\"ace/mode/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/latex_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/latex\"],(function(e,t,r){\"use strict\";var a=e(\"../lib/oop\"),n=e(\"./text\").Mode,o=e(\"./latex_highlight_rules\").LatexHighlightRules,i=e(\"./behaviour/cstyle\").CstyleBehaviour,l=e(\"./folding/latex\").FoldMode,s=function(){this.HighlightRules=o,this.foldingRules=new l,this.$behaviour=new i({braces:!0})};a.inherits(s,n),function(){this.type=\"text\",this.lineCommentStart=\"%\",this.$id=\"ace/mode/latex\",this.getMatching=function(e,t,r){void 0==t&&(t=e.selection.lead),\"object\"==typeof t&&(r=t.column,t=t.row);var a=e.getTokenAt(t,r);if(a)return\"\\\\begin\"==a.value||\"\\\\end\"==a.value?this.foldingRules.latexBlock(e,t,r,!0):void 0}}.call(s.prototype),t.Mode=s})),ace.require([\"ace/mode/latex\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"e3174c57f1802c7288315180a8886f78.js","input":"ace.define(\"ace/mode/latex_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var LatexHighlightRules = function () {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\begin)({)(verbatim)(})\",\n        next: \"verbatim\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\begin)({)(lstlisting)(})\",\n        next: \"lstlisting\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"\n      }, {\n        token: \"storage.type\",\n        regex: /\\\\verb\\b\\*?/,\n        next: [{\n          token: [\"keyword.operator\", \"string\", \"keyword.operator\"],\n          regex: \"(.)(.*?)(\\\\1|$)|\",\n          next: \"start\"\n        }]\n      }, {\n        token: \"storage.type\",\n        regex: \"\\\\\\\\[a-zA-Z]+\"\n      }, {\n        token: \"lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\[^a-zA-Z]?\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"equation\"\n      }],\n      \"equation\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"start\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n      }, {\n        token: \"error\",\n        regex: \"^\\\\s*$\",\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"verbatim\": [{\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\end)({)(verbatim)(})\",\n        next: \"start\"\n      }, {\n        defaultToken: \"text\"\n      }],\n      \"lstlisting\": [{\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\end)({)(lstlisting)(})\",\n        next: \"start\"\n      }, {\n        defaultToken: \"text\"\n      }]\n    };\n    this.normalizeRules();\n  };\n  oop.inherits(LatexHighlightRules, TextHighlightRules);\n  exports.LatexHighlightRules = LatexHighlightRules;\n});\nace.define(\"ace/mode/folding/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var TokenIterator = require(\"../../token_iterator\").TokenIterator;\n  var keywordLevels = {\n    \"\\\\subparagraph\": 1,\n    \"\\\\paragraph\": 2,\n    \"\\\\subsubsubsection\": 3,\n    \"\\\\subsubsection\": 4,\n    \"\\\\subsection\": 5,\n    \"\\\\section\": 6,\n    \"\\\\chapter\": 7,\n    \"\\\\part\": 8,\n    \"\\\\begin\": 9,\n    \"\\\\end\": 10\n  };\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        if (match[2]) return this.latexSection(session, row, match[0].length - 1);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n      var match = this.foldingStopMarker.exec(line);\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n    this.latexBlock = function (session, row, column, returnRange) {\n      var keywords = {\n        \"\\\\begin\": 1,\n        \"\\\\end\": -1\n      };\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) return;\n      var val = token.value;\n      var dir = keywords[val];\n      var getType = function () {\n        var token = stream.stepForward();\n        var type = token && token.type == \"lparen\" ? stream.stepForward().value : \"\";\n        if (dir === -1) {\n          stream.stepBackward();\n          if (type) stream.stepBackward();\n        }\n        return type;\n      };\n      var stack = [getType()];\n      var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n      var startRow = row;\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n      while (token = stream.step()) {\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) continue;\n        var level = keywords[token.value];\n        if (!level) continue;\n        var type = getType();\n        if (level === dir) stack.unshift(type);else if (stack.shift() !== type || !stack.length) break;\n      }\n      if (stack.length) return;\n      if (dir == 1) {\n        stream.stepBackward();\n        stream.stepBackward();\n      }\n      if (returnRange) return stream.getCurrentTokenRange();\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) return new Range(row, session.getLine(row).length, startRow, startColumn);else return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n    this.latexSection = function (session, row, column) {\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"storage.type\") return;\n      var startLevel = keywordLevels[token.value] || 0;\n      var stackDepth = 0;\n      var endRow = row;\n      while (token = stream.stepForward()) {\n        if (token.type !== \"storage.type\") continue;\n        var level = keywordLevels[token.value] || 0;\n        if (level >= 9) {\n          if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n          stackDepth += level == 9 ? 1 : -1;\n          if (stackDepth < 0) break;\n        } else if (level >= startLevel) break;\n      }\n      if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n      while (endRow > row && !/\\S/.test(session.getLine(endRow))) endRow--;\n      return new Range(row, session.getLine(row).length, endRow, session.getLine(endRow).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/latex_highlight_rules\", \"ace/mode/behaviour/cstyle\", \"ace/mode/folding/latex\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var LatexHighlightRules = require(\"./latex_highlight_rules\").LatexHighlightRules;\n  var CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\n  var LatexFoldMode = require(\"./folding/latex\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = new CstyleBehaviour({\n      braces: true\n    });\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.type = \"text\";\n    this.lineCommentStart = \"%\";\n    this.$id = \"ace/mode/latex\";\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) row = session.selection.lead;\n      if (typeof row == \"object\") {\n        column = row.column;\n        row = row.row;\n      }\n      var startToken = session.getTokenAt(row, column);\n      if (!startToken) return;\n      if (startToken.value == \"\\\\begin\" || startToken.value == \"\\\\end\") {\n        return this.foldingRules.latexBlock(session, row, column, true);\n      }\n    };\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/latex\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}