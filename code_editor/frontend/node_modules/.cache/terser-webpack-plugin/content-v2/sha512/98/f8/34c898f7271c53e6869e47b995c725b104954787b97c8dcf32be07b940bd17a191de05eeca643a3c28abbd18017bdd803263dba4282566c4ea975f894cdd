{"code":"ace.define(\"ace/mode/ruby_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),a=e(\"./text_highlight_rules\").TextHighlightRules,s=t.constantOtherSymbol={token:\"constant.other.symbol.ruby\",regex:\"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"};t.qString={token:\"string\",regex:\"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"},t.qqString={token:\"string\",regex:'[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'},t.tString={token:\"string\",regex:\"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"};var i=t.constantNumericHex={token:\"constant.numeric\",regex:\"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"},o=t.constantNumericBinary={token:\"constant.numeric\",regex:/\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/},l=t.constantNumericDecimal={token:\"constant.numeric\",regex:/\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/},c=t.constantNumericOctal={token:\"constant.numeric\",regex:/\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/},u=t.constantNumericRational={token:\"constant.numeric\",regex:/\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/},g=t.constantNumericComplex={token:\"constant.numeric\",regex:/\\b([\\d]i)\\b/},h=t.constantNumericFloat={token:\"constant.numeric\",regex:\"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"},d=t.instanceVariable={token:\"variable.instance\",regex:\"@{1,2}[a-zA-Z_\\\\d]+\"},_=function(){var e=this.$keywords=this.createKeywordMapper({keyword:\"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\",\"constant.language\":\"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\",\"variable.language\":\"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|$!|root_url|flash|session|cookies|params|request|response|logger|self\",\"support.function\":\"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|validates_inclusion_of|validates_numericality_of|validates_with|validates_each|authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|cache|expire_fragment|expire_cache_for|observe|cache_sweeper|has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|private_class_method|remove_method|undef_method\",\"invalid.deprecated\":\"debugger\"},\"identifier\"),t=\"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\",n={\"(\":\")\",\"[\":\"]\",\"{\":\"}\",\"<\":\">\",\"^\":\"^\",\"|\":\"|\",\"%\":\"%\"};this.$rules={start:[{token:\"comment\",regex:\"#.*$\"},{token:\"comment.multiline\",regex:\"^=begin(?=$|\\\\s.*$)\",next:\"comment\"},{token:\"string.regexp\",regex:/[/](?=.*\\/)/,next:\"regex\"},[{token:[\"constant.other.symbol.ruby\",\"string.start\"],regex:/(:)?(\")/,push:[{token:\"constant.language.escape\",regex:t},{token:\"paren.start\",regex:/#{/,push:\"start\"},{token:\"string.end\",regex:/\"/,next:\"pop\"},{defaultToken:\"string\"}]},{token:\"string.start\",regex:/`/,push:[{token:\"constant.language.escape\",regex:t},{token:\"paren.start\",regex:/#{/,push:\"start\"},{token:\"string.end\",regex:/`/,next:\"pop\"},{defaultToken:\"string\"}]},{token:[\"constant.other.symbol.ruby\",\"string.start\"],regex:/(:)?(')/,push:[{token:\"constant.language.escape\",regex:/\\\\['\\\\]/},{token:\"string.end\",regex:/'/,next:\"pop\"},{defaultToken:\"string\"}]},{token:\"string.start\",regex:/%[qwx]([(\\[<{^|%])/,onMatch:function(e,t,n){n.length&&(n=[]);var r=e[e.length-1];return n.unshift(r,t),this.next=\"qStateWithoutInterpolation\",this.token}},{token:\"string.start\",regex:/%[QWX]?([(\\[<{^|%])/,onMatch:function(e,t,n){n.length&&(n=[]);var r=e[e.length-1];return n.unshift(r,t),this.next=\"qStateWithInterpolation\",this.token}},{token:\"constant.other.symbol.ruby\",regex:/%[si]([(\\[<{^|%])/,onMatch:function(e,t,n){n.length&&(n=[]);var r=e[e.length-1];return n.unshift(r,t),this.next=\"sStateWithoutInterpolation\",this.token}},{token:\"constant.other.symbol.ruby\",regex:/%[SI]([(\\[<{^|%])/,onMatch:function(e,t,n){n.length&&(n=[]);var r=e[e.length-1];return n.unshift(r,t),this.next=\"sStateWithInterpolation\",this.token}},{token:\"string.regexp\",regex:/%[r]([(\\[<{^|%])/,onMatch:function(e,t,n){n.length&&(n=[]);var r=e[e.length-1];return n.unshift(r,t),this.next=\"rState\",this.token}}],{token:\"punctuation\",regex:\"::\"},d,{token:\"variable.global\",regex:\"[$][a-zA-Z_\\\\d]+\"},{token:\"support.class\",regex:\"[A-Z][a-zA-Z_\\\\d]*\"},{token:[\"punctuation.operator\",\"support.function\"],regex:/(\\.)([a-zA-Z_\\d]+)(?=\\()/},{token:[\"punctuation.operator\",\"identifier\"],regex:/(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/},{token:\"string.character\",regex:\"\\\\B\\\\?(?:\"+t+\"|\\\\S)\"},{token:\"punctuation.operator\",regex:/\\?(?=.+:)/},u,g,s,i,h,o,l,c,{token:\"constant.language.boolean\",regex:\"(?:true|false)\\\\b\"},{token:e,regex:\"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"},{token:\"punctuation.separator.key-value\",regex:\"=>\"},{stateName:\"heredoc\",onMatch:function(e,t,n){var r=\"-\"==e[2]||\"~\"==e[2]?\"indentedHeredoc\":\"heredoc\",a=e.split(this.splitRegex);return n.push(r,a[3]),[{type:\"constant\",value:a[1]},{type:\"string\",value:a[2]},{type:\"support.class\",value:a[3]},{type:\"string\",value:a[4]}]},regex:\"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",rules:{heredoc:[{onMatch:function(e,t,n){return e===n[1]?(n.shift(),n.shift(),this.next=n[0]||\"start\",\"support.class\"):(this.next=\"\",\"string\")},regex:\".*$\",next:\"start\"}],indentedHeredoc:[{token:\"string\",regex:\"^ +\"},{onMatch:function(e,t,n){return e===n[1]?(n.shift(),n.shift(),this.next=n[0]||\"start\",\"support.class\"):(this.next=\"\",\"string\")},regex:\".*$\",next:\"start\"}]}},{regex:\"$\",token:\"empty\",next:function(e,t){return\"heredoc\"===t[0]||\"indentedHeredoc\"===t[0]?t[0]:e}},{token:\"keyword.operator\",regex:\"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"},{token:\"paren.lparen\",regex:\"[[({]\"},{token:\"paren.rparen\",regex:\"[\\\\])}]\",onMatch:function(e,t,n){return this.next=\"\",\"}\"==e&&n.length>1&&\"start\"!=n[1]&&(n.shift(),this.next=n.shift()),this.token}},{token:\"text\",regex:\"\\\\s+\"},{token:\"punctuation.operator\",regex:/[?:,;.]/}],comment:[{token:\"comment.multiline\",regex:\"^=end(?=$|\\\\s.*$)\",next:\"start\"},{token:\"comment\",regex:\".+\"}],qStateWithInterpolation:[{token:\"string.start\",regex:/[(\\[<{]/,onMatch:function(e,t,n){return n.length&&e===n[0]?(n.unshift(e,t),this.token):\"string\"}},{token:\"constant.language.escape\",regex:t},{token:\"constant.language.escape\",regex:/\\\\./},{token:\"paren.start\",regex:/#{/,push:\"start\"},{token:\"string.end\",regex:/[)\\]>}^|%]/,onMatch:function(e,t,r){return r.length&&e===n[r[0]]?(r.shift(),this.next=r.shift(),this.token):(this.next=\"\",\"string\")}},{defaultToken:\"string\"}],qStateWithoutInterpolation:[{token:\"string.start\",regex:/[(\\[<{]/,onMatch:function(e,t,n){return n.length&&e===n[0]?(n.unshift(e,t),this.token):\"string\"}},{token:\"constant.language.escape\",regex:/\\\\['\\\\]/},{token:\"constant.language.escape\",regex:/\\\\./},{token:\"string.end\",regex:/[)\\]>}^|%]/,onMatch:function(e,t,r){return r.length&&e===n[r[0]]?(r.shift(),this.next=r.shift(),this.token):(this.next=\"\",\"string\")}},{defaultToken:\"string\"}],sStateWithoutInterpolation:[{token:\"constant.other.symbol.ruby\",regex:/[(\\[<{]/,onMatch:function(e,t,n){return n.length&&e===n[0]?(n.unshift(e,t),this.token):\"constant.other.symbol.ruby\"}},{token:\"constant.other.symbol.ruby\",regex:/[)\\]>}^|%]/,onMatch:function(e,t,r){return r.length&&e===n[r[0]]?(r.shift(),this.next=r.shift(),this.token):(this.next=\"\",\"constant.other.symbol.ruby\")}},{defaultToken:\"constant.other.symbol.ruby\"}],sStateWithInterpolation:[{token:\"constant.other.symbol.ruby\",regex:/[(\\[<{]/,onMatch:function(e,t,n){return n.length&&e===n[0]?(n.unshift(e,t),this.token):\"constant.other.symbol.ruby\"}},{token:\"constant.language.escape\",regex:t},{token:\"constant.language.escape\",regex:/\\\\./},{token:\"paren.start\",regex:/#{/,push:\"start\"},{token:\"constant.other.symbol.ruby\",regex:/[)\\]>}^|%]/,onMatch:function(e,t,r){return r.length&&e===n[r[0]]?(r.shift(),this.next=r.shift(),this.token):(this.next=\"\",\"constant.other.symbol.ruby\")}},{defaultToken:\"constant.other.symbol.ruby\"}],rState:[{token:\"string.regexp\",regex:/[(\\[<{]/,onMatch:function(e,t,n){return n.length&&e===n[0]?(n.unshift(e,t),this.token):\"constant.language.escape\"}},{token:\"paren.start\",regex:/#{/,push:\"start\"},{token:\"string.regexp\",regex:/\\//},{token:\"string.regexp\",regex:/[)\\]>}^|%][imxouesn]*/,onMatch:function(e,t,r){return r.length&&e[0]===n[r[0]]?(r.shift(),this.next=r.shift(),this.token):(this.next=\"\",\"constant.language.escape\")}},{include:\"regex\"},{defaultToken:\"string.regexp\"}],regex:[{token:\"regexp.keyword\",regex:/\\\\[wWdDhHsS]/},{token:\"constant.language.escape\",regex:/\\\\[AGbBzZ]/},{token:\"constant.language.escape\",regex:/\\\\g<[a-zA-Z0-9]*>/},{token:[\"constant.language.escape\",\"regexp.keyword\",\"constant.language.escape\"],regex:/(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/},{token:[\"constant.language.escape\",\"invalid\",\"constant.language.escape\"],regex:/(\\\\p{\\^?)([^/]*)(})/},{token:\"regexp.keyword.operator\",regex:\"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"},{token:\"string.regexp\",regex:/[/][imxouesn]*/,next:\"start\"},{token:\"invalid\",regex:/\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/},{token:\"constant.language.escape\",regex:/\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/},{token:\"constant.language.delimiter\",regex:/\\|/},{token:\"regexp.keyword\",regex:/\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/},{token:\"constant.language.escape\",regex:/\\[\\^?/,push:\"regex_character_class\"},{defaultToken:\"string.regexp\"}],regex_character_class:[{token:\"regexp.keyword\",regex:/\\\\[wWdDhHsS]/},{token:\"regexp.charclass.keyword.operator\",regex:\"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"},{token:\"constant.language.escape\",regex:/&?&?\\[\\^?/,push:\"regex_character_class\"},{token:\"constant.language.escape\",regex:\"]\",next:\"pop\"},{token:\"constant.language.escape\",regex:\"-\"},{defaultToken:\"string.regexp.characterclass\"}]},this.normalizeRules()};r.inherits(_,a),t.RubyHighlightRules=_})),ace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"],(function(e,t,n){\"use strict\";var r=e(\"../range\").Range,a=function(){};(function(){this.checkOutdent=function(e,t){return!!/^\\s+$/.test(e)&&/^\\s*\\}/.test(t)},this.autoOutdent=function(e,t){var n=e.getLine(t).match(/^(\\s*\\})/);if(!n)return 0;var a=n[1].length,s=e.findMatchingBracket({row:t,column:a});if(!s||s.row==t)return 0;var i=this.$getIndent(e.getLine(s.row));e.replace(new r(t,0,t,a-1),i)},this.$getIndent=function(e){return e.match(/^\\s*/)[0]}}).call(a.prototype),t.MatchingBraceOutdent=a})),ace.define(\"ace/mode/folding/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"],(function(e,t,n){\"use strict\";var r=e(\"../../lib/oop\"),a=e(\"./fold_mode\").FoldMode,s=e(\"../../range\").Range,i=e(\"../../token_iterator\").TokenIterator,o=t.FoldMode=function(){};r.inherits(o,a),function(){this.indentKeywords={class:1,def:1,module:1,do:1,unless:1,if:1,while:1,for:1,until:1,begin:1,else:0,elsif:0,rescue:0,ensure:0,when:0,end:-1,case:1,\"=begin\":1,\"=end\":-1},this.foldingStartMarker=/(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/,this.foldingStopMarker=/(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/,this.getFoldWidget=function(e,t,n){var r,a=e.getLine(n),s=this.foldingStartMarker.test(a),i=this.foldingStopMarker.test(a);if(s&&!i)if((r=a.match(this.foldingStartMarker))[1]){if(\"if\"==r[1]||\"else\"==r[1]||\"while\"==r[1]||\"until\"==r[1]||\"unless\"==r[1]){if(\"else\"==r[1]&&!1===/^\\s*else\\s*$/.test(a))return;if(!1===/^\\s*(?:if|else|while|until|unless)\\s*/.test(a))return}if(\"when\"==r[1]&&!0===/\\sthen\\s/.test(a))return;if(\"keyword\"===e.getTokenAt(n,r.index+2).type)return\"start\"}else{if(!r[3])return\"start\";if(\"comment.multiline\"===e.getTokenAt(n,r.index+1).type)return\"start\"}if(\"markbeginend\"!=t||!i||s&&i)return\"\";if(\"end\"===(r=a.match(this.foldingStopMarker))[3]){if(\"keyword\"===e.getTokenAt(n,r.index+1).type)return\"end\"}else{if(!r[1])return\"end\";if(\"comment.multiline\"===e.getTokenAt(n,r.index+1).type)return\"end\"}},this.getFoldWidgetRange=function(e,t,n){var r,a=e.doc.getLine(n);return(r=this.foldingStartMarker.exec(a))?r[1]||r[3]?this.rubyBlock(e,n,r.index+2):this.openingBracketBlock(e,\"{\",n,r.index):(r=this.foldingStopMarker.exec(a))?\"end\"===r[3]&&\"keyword\"===e.getTokenAt(n,r.index+1).type||\"=end\"===r[1]&&\"comment.multiline\"===e.getTokenAt(n,r.index+1).type?this.rubyBlock(e,n,r.index+1):this.closingBracketBlock(e,\"}\",n,r.index+r[0].length):void 0},this.rubyBlock=function(e,t,n,r){var a=new i(e,t,n),o=a.getCurrentToken();if(o&&(\"keyword\"==o.type||\"comment.multiline\"==o.type)){var l=o.value,c=e.getLine(t);switch(o.value){case\"if\":case\"unless\":case\"while\":case\"until\":if(!new RegExp(\"^\\\\s*\"+o.value).test(c))return;var u=this.indentKeywords[l];break;case\"when\":if(/\\sthen\\s/.test(c))return;case\"elsif\":case\"rescue\":case\"ensure\":u=1;break;case\"else\":if(!new RegExp(\"^\\\\s*\"+o.value+\"\\\\s*$\").test(c))return;u=1;break;default:u=this.indentKeywords[l]}var g=[l];if(u){var h=-1===u?e.getLine(t-1).length:e.getLine(t).length,d=t,_=[];if(_.push(a.getCurrentTokenRange()),a.step=-1===u?a.stepBackward:a.stepForward,\"comment.multiline\"==o.type){for(;o=a.step();)if(\"comment.multiline\"===o.type)if(1==u){if(h=6,\"=end\"==o.value)break}else if(\"=begin\"==o.value)break}else for(;o=a.step();){var f=!1;if(\"keyword\"===o.type){var p=u*this.indentKeywords[o.value];switch(c=e.getLine(a.getCurrentTokenRow()),o.value){case\"do\":for(var k=a.$tokenIndex-1;k>=0;k--){var x=a.$rowTokens[k];if(x&&(\"while\"==x.value||\"until\"==x.value||\"for\"==x.value)){p=0;break}}break;case\"else\":new RegExp(\"^\\\\s*\"+o.value+\"\\\\s*$\").test(c)&&\"case\"!=l||(p=0,f=!0);break;case\"if\":case\"unless\":case\"while\":case\"until\":new RegExp(\"^\\\\s*\"+o.value).test(c)||(p=0,f=!0);break;case\"when\":(/\\sthen\\s/.test(c)||\"case\"==l)&&(p=0,f=!0)}if(p>0)g.unshift(o.value);else if(p<=0&&!1===f){if(g.shift(),!g.length){if((\"while\"==l||\"until\"==l||\"for\"==l)&&\"do\"!=o.value)break;if(\"do\"==o.value&&-1==u&&0!=p)break;if(\"do\"!=o.value)break}0===p&&g.unshift(o.value)}}}if(!o)return null;if(r)return _.push(a.getCurrentTokenRange()),_;t=a.getCurrentTokenRow();if(-1===u){if(\"comment.multiline\"===o.type)var m=6;else m=e.getLine(t).length;return new s(t,m,d-1,h)}return new s(d,h,t-1,e.getLine(t-1).length)}}}}.call(o.prototype)})),ace.define(\"ace/mode/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/ruby_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/folding/ruby\"],(function(e,t,n){\"use strict\";var r=e(\"../lib/oop\"),a=e(\"./text\").Mode,s=e(\"./ruby_highlight_rules\").RubyHighlightRules,i=e(\"./matching_brace_outdent\").MatchingBraceOutdent,o=e(\"../range\").Range,l=e(\"./folding/ruby\").FoldMode,c=function(){this.HighlightRules=s,this.$outdent=new i,this.$behaviour=this.$defaultBehaviour,this.foldingRules=new l,this.indentKeywords=this.foldingRules.indentKeywords};r.inherits(c,a),function(){this.lineCommentStart=\"#\",this.getNextLineIndent=function(e,t,n){var r=this.$getIndent(t),a=this.getTokenizer().getLineTokens(t,e).tokens;if(a.length&&\"comment\"==a[a.length-1].type)return r;if(\"start\"==e){var s=t.match(/^.*[\\{\\(\\[]\\s*$/),i=t.match(/^\\s*(class|def|module)\\s.*$/),o=t.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/),l=t.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);(s||i||o||l)&&(r+=n)}return r},this.checkOutdent=function(e,t,n){return/^\\s+(end|else|rescue|ensure)$/.test(t+n)||this.$outdent.checkOutdent(t,n)},this.autoOutdent=function(e,t,n){var r=t.getLine(n);if(/}/.test(r))return this.$outdent.autoOutdent(t,n);var a=this.$getIndent(r),s=t.getLine(n-1),i=this.$getIndent(s),l=t.getTabString();i.length<=a.length&&a.slice(-l.length)==l&&t.remove(new o(n,a.length-l.length,n,a.length))},this.getMatching=function(e,t,n){if(void 0==t){var r=e.selection.lead;n=r.column,t=r.row}var a=e.getTokenAt(t,n);if(a&&a.value in this.indentKeywords)return this.foldingRules.rubyBlock(e,t,n,!0)},this.$id=\"ace/mode/ruby\",this.snippetFileId=\"ace/snippets/ruby\"}.call(c.prototype),t.Mode=c})),ace.require([\"ace/mode/ruby\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"25ad5f304c3b0d5140b77c84b7b7b7cc.js","input":"ace.define(\"ace/mode/ruby_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var constantOtherSymbol = exports.constantOtherSymbol = {\n    token: \"constant.other.symbol.ruby\",\n    // symbol\n    regex: \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n  };\n  exports.qString = {\n    token: \"string\",\n    // single line\n    regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n  };\n  exports.qqString = {\n    token: \"string\",\n    // single line\n    regex: '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n  };\n  exports.tString = {\n    token: \"string\",\n    // backtick string\n    regex: \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n  };\n  var constantNumericHex = exports.constantNumericHex = {\n    token: \"constant.numeric\",\n    // hex\n    regex: \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n  };\n  var constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n  };\n  var constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n  };\n  var constantNumericOctal = exports.constantNumericOctal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n  };\n  var constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\",\n    //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n  };\n  var constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\",\n    //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n  };\n  var constantNumericFloat = exports.constantNumericFloat = {\n    token: \"constant.numeric\",\n    // float + complex\n    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n  };\n  var instanceVariable = exports.instanceVariable = {\n    token: \"variable.instance\",\n    // instance variable\n    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n  };\n  var RubyHighlightRules = function () {\n    var builtinFunctions = \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" + \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" + \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" + \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" + \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" + \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" + \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" + \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" + \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" + \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" + \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" + \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" + \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" + \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" + \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" + \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" + \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" + \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" + \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" + \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" + \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" + \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" + \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" + \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" + \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" + \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" + \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" + \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" + \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" + \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" + \"private_class_method|remove_method|undef_method\";\n    var keywords = \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" + \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" + \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\";\n    var buildinConstants = \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" + \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\";\n    var builtinVariables = \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" + \"$!|root_url|flash|session|cookies|params|request|response|logger|self\";\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"constant.language\": buildinConstants,\n      \"variable.language\": builtinVariables,\n      \"support.function\": builtinFunctions,\n      \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n    var closeParen = {\n      \"(\": \")\",\n      \"[\": \"]\",\n      \"{\": \"}\",\n      \"<\": \">\",\n      \"^\": \"^\",\n      \"|\": \"|\",\n      \"%\": \"%\"\n    };\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"#.*$\"\n      }, {\n        token: \"comment.multiline\",\n        // multi line comment\n        regex: \"^=begin(?=$|\\\\s.*$)\",\n        next: \"comment\"\n      }, {\n        token: \"string.regexp\",\n        regex: /[/](?=.*\\/)/,\n        next: \"regex\"\n      }, [{\n        token: [\"constant.other.symbol.ruby\", \"string.start\"],\n        regex: /(:)?(\")/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: escapedChars\n        }, {\n          token: \"paren.start\",\n          regex: /#{/,\n          push: \"start\"\n        }, {\n          token: \"string.end\",\n          regex: /\"/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string.start\",\n        regex: /`/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: escapedChars\n        }, {\n          token: \"paren.start\",\n          regex: /#{/,\n          push: \"start\"\n        }, {\n          token: \"string.end\",\n          regex: /`/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: [\"constant.other.symbol.ruby\", \"string.start\"],\n        regex: /(:)?(')/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: /\\\\['\\\\]/\n        }, {\n          token: \"string.end\",\n          regex: /'/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string.start\",\n        //doesn't see any differences between strings and array of strings in highlighting\n        regex: /%[qwx]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"qStateWithoutInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"string.start\",\n        //doesn't see any differences between strings and array of strings in highlighting\n        regex: /%[QWX]?([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"qStateWithInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        //doesn't see any differences between symbols and array of symbols in highlighting\n        regex: /%[si]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"sStateWithoutInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        //doesn't see any differences between symbols and array of symbols in highlighting\n        regex: /%[SI]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"sStateWithInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"string.regexp\",\n        regex: /%[r]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"rState\";\n          return this.token;\n        }\n      }], {\n        token: \"punctuation\",\n        // namespaces aren't symbols\n        regex: \"::\"\n      }, instanceVariable, {\n        token: \"variable.global\",\n        // global variable\n        regex: \"[$][a-zA-Z_\\\\d]+\"\n      }, {\n        token: \"support.class\",\n        // class name\n        regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n      }, {\n        token: [\"punctuation.operator\", \"support.function\"],\n        regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n      }, {\n        token: [\"punctuation.operator\", \"identifier\"],\n        regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n      }, {\n        token: \"string.character\",\n        regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n      }, {\n        token: \"punctuation.operator\",\n        regex: /\\?(?=.+:)/\n      }, constantNumericRational, constantNumericComplex, constantOtherSymbol, constantNumericHex, constantNumericFloat, constantNumericBinary, constantNumericDecimal, constantNumericOctal, {\n        token: \"constant.language.boolean\",\n        regex: \"(?:true|false)\\\\b\"\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n      }, {\n        token: \"punctuation.separator.key-value\",\n        regex: \"=>\"\n      }, {\n        stateName: \"heredoc\",\n        onMatch: function (value, currentState, stack) {\n          var next = value[2] == '-' || value[2] == '~' ? \"indentedHeredoc\" : \"heredoc\";\n          var tokens = value.split(this.splitRegex);\n          stack.push(next, tokens[3]);\n          return [{\n            type: \"constant\",\n            value: tokens[1]\n          }, {\n            type: \"string\",\n            value: tokens[2]\n          }, {\n            type: \"support.class\",\n            value: tokens[3]\n          }, {\n            type: \"string\",\n            value: tokens[4]\n          }];\n        },\n        regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n        rules: {\n          heredoc: [{\n            onMatch: function (value, currentState, stack) {\n              if (value === stack[1]) {\n                stack.shift();\n                stack.shift();\n                this.next = stack[0] || \"start\";\n                return \"support.class\";\n              }\n              this.next = \"\";\n              return \"string\";\n            },\n            regex: \".*$\",\n            next: \"start\"\n          }],\n          indentedHeredoc: [{\n            token: \"string\",\n            regex: \"^ +\"\n          }, {\n            onMatch: function (value, currentState, stack) {\n              if (value === stack[1]) {\n                stack.shift();\n                stack.shift();\n                this.next = stack[0] || \"start\";\n                return \"support.class\";\n              }\n              this.next = \"\";\n              return \"string\";\n            },\n            regex: \".*$\",\n            next: \"start\"\n          }]\n        }\n      }, {\n        regex: \"$\",\n        token: \"empty\",\n        next: function (currentState, stack) {\n          if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\") return stack[0];\n          return currentState;\n        }\n      }, {\n        token: \"keyword.operator\",\n        regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\])}]\",\n        onMatch: function (value, currentState, stack) {\n          this.next = '';\n          if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n            stack.shift();\n            this.next = stack.shift();\n          }\n          return this.token;\n        }\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+\"\n      }, {\n        token: \"punctuation.operator\",\n        regex: /[?:,;.]/\n      }],\n      \"comment\": [{\n        token: \"comment.multiline\",\n        // closing comment\n        regex: \"^=end(?=$|\\\\s.*$)\",\n        next: \"start\"\n      }, {\n        token: \"comment\",\n        // comment spanning whole line\n        regex: \".+\"\n      }],\n      \"qStateWithInterpolation\": [{\n        token: \"string.start\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"string\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: escapedChars\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"string.end\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"string\";\n        }\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"qStateWithoutInterpolation\": [{\n        token: \"string.start\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"string\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\['\\\\]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"string.end\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"string\";\n        }\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"sStateWithoutInterpolation\": [{\n        token: \"constant.other.symbol.ruby\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        defaultToken: \"constant.other.symbol.ruby\"\n      }],\n      \"sStateWithInterpolation\": [{\n        token: \"constant.other.symbol.ruby\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: escapedChars\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        defaultToken: \"constant.other.symbol.ruby\"\n      }],\n      \"rState\": [{\n        token: \"string.regexp\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n          return \"constant.language.escape\";\n        }\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"string.regexp\",\n        regex: /\\//\n      }, {\n        token: \"string.regexp\",\n        regex: /[)\\]>}^|%][imxouesn]*/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val[0] === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n          this.next = '';\n          return \"constant.language.escape\";\n        }\n      }, {\n        include: \"regex\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex\": [{\n        token: \"regexp.keyword\",\n        regex: /\\\\[wWdDhHsS]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\[AGbBzZ]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\g<[a-zA-Z0-9]*>/\n      }, {\n        token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n        regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n      }, {\n        token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n        regex: /(\\\\p{\\^?)([^/]*)(})/\n      }, {\n        token: \"regexp.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"string.regexp\",\n        regex: /[/][imxouesn]*/,\n        next: \"start\"\n      }, {\n        token: \"invalid\",\n        regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n      }, {\n        token: \"constant.language.delimiter\",\n        regex: /\\|/\n      }, {\n        token: \"regexp.keyword\",\n        regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\[\\^?/,\n        push: \"regex_character_class\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex_character_class\": [{\n        token: \"regexp.keyword\",\n        regex: /\\\\[wWdDhHsS]/\n      }, {\n        token: \"regexp.charclass.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: /&?&?\\[\\^?/,\n        push: \"regex_character_class\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"]\",\n        next: \"pop\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"-\"\n      }, {\n        defaultToken: \"string.regexp.characterclass\"\n      }]\n    };\n    this.normalizeRules();\n  };\n  oop.inherits(RubyHighlightRules, TextHighlightRules);\n  exports.RubyHighlightRules = RubyHighlightRules;\n});\nace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n  var MatchingBraceOutdent = function () {};\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/folding/ruby\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var TokenIterator = require(\"../../token_iterator\").TokenIterator;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.indentKeywords = {\n      \"class\": 1,\n      \"def\": 1,\n      \"module\": 1,\n      \"do\": 1,\n      \"unless\": 1,\n      \"if\": 1,\n      \"while\": 1,\n      \"for\": 1,\n      \"until\": 1,\n      \"begin\": 1,\n      \"else\": 0,\n      \"elsif\": 0,\n      \"rescue\": 0,\n      \"ensure\": 0,\n      \"when\": 0,\n      \"end\": -1,\n      \"case\": 1,\n      \"=begin\": 1,\n      \"=end\": -1\n    };\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var isStart = this.foldingStartMarker.test(line);\n      var isEnd = this.foldingStopMarker.test(line);\n      if (isStart && !isEnd) {\n        var match = line.match(this.foldingStartMarker);\n        if (match[1]) {\n          if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n            if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n              return;\n            }\n            if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n              return;\n            }\n          }\n          if (match[1] == \"when\") {\n            if (/\\sthen\\s/.test(line) === true) {\n              return;\n            }\n          }\n          if (session.getTokenAt(row, match.index + 2).type === \"keyword\") return \"start\";\n        } else if (match[3]) {\n          if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return \"start\";\n        } else {\n          return \"start\";\n        }\n      }\n      if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd) return \"\";\n      var match = line.match(this.foldingStopMarker);\n      if (match[3] === \"end\") {\n        if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"end\";\n      } else if (match[1]) {\n        if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return \"end\";\n      } else return \"end\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n      if (match) {\n        if (match[1] || match[3]) return this.rubyBlock(session, row, match.index + 2);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n      var match = this.foldingStopMarker.exec(line);\n      if (match) {\n        if (match[3] === \"end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return this.rubyBlock(session, row, match.index + 1);\n        }\n        if (match[1] === \"=end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return this.rubyBlock(session, row, match.index + 1);\n        }\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n    this.rubyBlock = function (session, row, column, tokenRange) {\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"keyword\" && token.type != \"comment.multiline\") return;\n      var val = token.value;\n      var line = session.getLine(row);\n      switch (token.value) {\n        case \"if\":\n        case \"unless\":\n        case \"while\":\n        case \"until\":\n          var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n          if (!checkToken.test(line)) {\n            return;\n          }\n          var dir = this.indentKeywords[val];\n          break;\n        case \"when\":\n          if (/\\sthen\\s/.test(line)) {\n            return;\n          }\n        case \"elsif\":\n        case \"rescue\":\n        case \"ensure\":\n          var dir = 1;\n          break;\n        case \"else\":\n          var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n          if (!checkToken.test(line)) {\n            return;\n          }\n          var dir = 1;\n          break;\n        default:\n          var dir = this.indentKeywords[val];\n          break;\n      }\n      var stack = [val];\n      if (!dir) return;\n      var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n      var startRow = row;\n      var ranges = [];\n      ranges.push(stream.getCurrentTokenRange());\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n      if (token.type == \"comment.multiline\") {\n        while (token = stream.step()) {\n          if (token.type !== \"comment.multiline\") continue;\n          if (dir == 1) {\n            startColumn = 6;\n            if (token.value == \"=end\") {\n              break;\n            }\n          } else {\n            if (token.value == \"=begin\") {\n              break;\n            }\n          }\n        }\n      } else {\n        while (token = stream.step()) {\n          var ignore = false;\n          if (token.type !== \"keyword\") continue;\n          var level = dir * this.indentKeywords[token.value];\n          line = session.getLine(stream.getCurrentTokenRow());\n          switch (token.value) {\n            case \"do\":\n              for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                var prevToken = stream.$rowTokens[i];\n                if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                  level = 0;\n                  break;\n                }\n              }\n              break;\n            case \"else\":\n              var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n              if (!checkToken.test(line) || val == \"case\") {\n                level = 0;\n                ignore = true;\n              }\n              break;\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n              var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n              if (!checkToken.test(line)) {\n                level = 0;\n                ignore = true;\n              }\n              break;\n            case \"when\":\n              if (/\\sthen\\s/.test(line) || val == \"case\") {\n                level = 0;\n                ignore = true;\n              }\n              break;\n          }\n          if (level > 0) {\n            stack.unshift(token.value);\n          } else if (level <= 0 && ignore === false) {\n            stack.shift();\n            if (!stack.length) {\n              if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                break;\n              }\n              if (token.value == \"do\" && dir == -1 && level != 0) break;\n              if (token.value != \"do\") break;\n            }\n            if (level === 0) {\n              stack.unshift(token.value);\n            }\n          }\n        }\n      }\n      if (!token) return null;\n      if (tokenRange) {\n        ranges.push(stream.getCurrentTokenRange());\n        return ranges;\n      }\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) {\n        if (token.type === \"comment.multiline\") {\n          var endColumn = 6;\n        } else {\n          var endColumn = session.getLine(row).length;\n        }\n        return new Range(row, endColumn, startRow - 1, startColumn);\n      } else return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/ruby\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/ruby_highlight_rules\", \"ace/mode/matching_brace_outdent\", \"ace/range\", \"ace/mode/folding/ruby\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\n  var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n  var Range = require(\"../range\").Range;\n  var FoldMode = require(\"./folding/ruby\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n      var tokens = tokenizedLine.tokens;\n      if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n        return indent;\n      }\n      if (state == \"start\") {\n        var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n        var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n        var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n        var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n        if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n          indent += tab;\n        }\n      }\n      return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n      return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, session, row) {\n      var line = session.getLine(row);\n      if (/}/.test(line)) return this.$outdent.autoOutdent(session, row);\n      var indent = this.$getIndent(line);\n      var prevLine = session.getLine(row - 1);\n      var prevIndent = this.$getIndent(prevLine);\n      var tab = session.getTabString();\n      if (prevIndent.length <= indent.length) {\n        if (indent.slice(-tab.length) == tab) session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n      }\n    };\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) {\n        var pos = session.selection.lead;\n        column = pos.column;\n        row = pos.row;\n      }\n      var startToken = session.getTokenAt(row, column);\n      if (startToken && startToken.value in this.indentKeywords) return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/ruby\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}