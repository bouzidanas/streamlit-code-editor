{"code":"ace.define(\"ace/mode/elixir_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"],(function(e,i,t){\"use strict\";var n=e(\"../lib/oop\"),o=e(\"./text_highlight_rules\").TextHighlightRules,r=function(){this.$rules={start:[{token:[\"meta.module.elixir\",\"keyword.control.module.elixir\",\"meta.module.elixir\",\"entity.name.type.module.elixir\"],regex:\"^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)\"},{token:\"comment.documentation.heredoc\",regex:'@(?:module|type)?doc (?:~[a-z])?\"\"\"',push:[{token:\"comment.documentation.heredoc\",regex:'\\\\s*\"\"\"',next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"comment.documentation.heredoc\"}],comment:\"@doc with heredocs is treated as documentation\"},{token:\"comment.documentation.heredoc\",regex:'@(?:module|type)?doc ~[A-Z]\"\"\"',push:[{token:\"comment.documentation.heredoc\",regex:'\\\\s*\"\"\"',next:\"pop\"},{defaultToken:\"comment.documentation.heredoc\"}],comment:\"@doc with heredocs is treated as documentation\"},{token:\"comment.documentation.heredoc\",regex:\"@(?:module|type)?doc (?:~[a-z])?'''\",push:[{token:\"comment.documentation.heredoc\",regex:\"\\\\s*'''\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"comment.documentation.heredoc\"}],comment:\"@doc with heredocs is treated as documentation\"},{token:\"comment.documentation.heredoc\",regex:\"@(?:module|type)?doc ~[A-Z]'''\",push:[{token:\"comment.documentation.heredoc\",regex:\"\\\\s*'''\",next:\"pop\"},{defaultToken:\"comment.documentation.heredoc\"}],comment:\"@doc with heredocs is treated as documentation\"},{token:\"comment.documentation.false\",regex:\"@(?:module|type)?doc false\",comment:\"@doc false is treated as documentation\"},{token:\"comment.documentation.string\",regex:'@(?:module|type)?doc \"',push:[{token:\"comment.documentation.string\",regex:'\"',next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"comment.documentation.string\"}],comment:\"@doc with string is treated as documentation\"},{token:\"keyword.control.elixir\",regex:\"\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])\"},{token:\"keyword.operator.elixir\",regex:\"\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b\",comment:\" as above, just doesn't need a 'end' and does a logic operation\"},{token:\"constant.language.elixir\",regex:\"\\\\b(?:nil|true|false)\\\\b(?![?!])\"},{token:\"variable.language.elixir\",regex:\"\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])\"},{token:[\"punctuation.definition.variable.elixir\",\"variable.other.readwrite.module.elixir\"],regex:\"(@)([a-zA-Z_]\\\\w*)\"},{token:[\"punctuation.definition.variable.elixir\",\"variable.other.anonymous.elixir\"],regex:\"(&)(\\\\d*)\"},{token:\"variable.other.constant.elixir\",regex:\"\\\\b[A-Z]\\\\w*\\\\b\"},{token:\"constant.numeric.elixir\",regex:\"\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b\"},{token:\"punctuation.definition.constant.elixir\",regex:\":'\",push:[{token:\"punctuation.definition.constant.elixir\",regex:\"'\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"constant.other.symbol.single-quoted.elixir\"}]},{token:\"punctuation.definition.constant.elixir\",regex:':\"',push:[{token:\"punctuation.definition.constant.elixir\",regex:'\"',next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"constant.other.symbol.double-quoted.elixir\"}]},{token:\"punctuation.definition.string.begin.elixir\",regex:\"(?:''')\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"(?>''')\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"^\\\\s*'''\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"support.function.variable.quoted.single.heredoc.elixir\"}],comment:\"Single-quoted heredocs\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"'\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"'\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"support.function.variable.quoted.single.elixir\"}],comment:\"single quoted string (allows for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:'(?:\"\"\")',TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:'(?>\"\"\")',push:[{token:\"punctuation.definition.string.end.elixir\",regex:'^\\\\s*\"\"\"',next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.quoted.double.heredoc.elixir\"}],comment:\"Double-quoted heredocs\"},{token:\"punctuation.definition.string.begin.elixir\",regex:'\"',push:[{token:\"punctuation.definition.string.end.elixir\",regex:'\"',next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.quoted.double.elixir\"}],comment:\"double quoted string (allows for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:'~[a-z](?:\"\"\")',TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:'~[a-z](?>\"\"\")',push:[{token:\"punctuation.definition.string.end.elixir\",regex:'^\\\\s*\"\"\"',next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.quoted.double.heredoc.elixir\"}],comment:\"Double-quoted heredocs sigils\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[a-z]\\\\{\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\}[a-z]*\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.interpolated.elixir\"}],comment:\"sigil (allow for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[a-z]\\\\[\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\][a-z]*\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.interpolated.elixir\"}],comment:\"sigil (allow for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[a-z]\\\\<\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\>[a-z]*\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.interpolated.elixir\"}],comment:\"sigil (allow for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[a-z]\\\\(\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\)[a-z]*\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{defaultToken:\"string.interpolated.elixir\"}],comment:\"sigil (allow for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[a-z][^\\\\w]\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"[^\\\\w][a-z]*\",next:\"pop\"},{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{include:\"#escaped_char\"},{defaultToken:\"string.interpolated.elixir\"}],comment:\"sigil (allow for interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:'~[A-Z](?:\"\"\")',TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:'~[A-Z](?>\"\"\")',push:[{token:\"punctuation.definition.string.end.elixir\",regex:'^\\\\s*\"\"\"',next:\"pop\"},{defaultToken:\"string.quoted.other.literal.upper.elixir\"}],comment:\"Double-quoted heredocs sigils\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[A-Z]\\\\{\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\}[a-z]*\",next:\"pop\"},{defaultToken:\"string.quoted.other.literal.upper.elixir\"}],comment:\"sigil (without interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[A-Z]\\\\[\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\][a-z]*\",next:\"pop\"},{defaultToken:\"string.quoted.other.literal.upper.elixir\"}],comment:\"sigil (without interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[A-Z]\\\\<\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\>[a-z]*\",next:\"pop\"},{defaultToken:\"string.quoted.other.literal.upper.elixir\"}],comment:\"sigil (without interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[A-Z]\\\\(\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"\\\\)[a-z]*\",next:\"pop\"},{defaultToken:\"string.quoted.other.literal.upper.elixir\"}],comment:\"sigil (without interpolation)\"},{token:\"punctuation.definition.string.begin.elixir\",regex:\"~[A-Z][^\\\\w]\",push:[{token:\"punctuation.definition.string.end.elixir\",regex:\"[^\\\\w][a-z]*\",next:\"pop\"},{defaultToken:\"string.quoted.other.literal.upper.elixir\"}],comment:\"sigil (without interpolation)\"},{token:[\"punctuation.definition.constant.elixir\",\"constant.other.symbol.elixir\"],regex:\"(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)\",comment:\"symbols\"},{token:\"punctuation.definition.constant.elixir\",regex:\"(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)\",comment:\"symbols\"},{token:[\"punctuation.definition.comment.elixir\",\"comment.line.number-sign.elixir\"],regex:\"(#)(.*)\"},{token:\"constant.numeric.elixir\",regex:\"\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])\",TODO:\"FIXME: regexp doesn't have js equivalent\",originalRegex:\"(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])\",comment:'\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t'},{token:\"keyword.operator.assignment.augmented.elixir\",regex:\"\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&=\"},{token:\"keyword.operator.comparison.elixir\",regex:\"===?|!==?|<=?|>=?\"},{token:\"keyword.operator.bitwise.elixir\",regex:\"\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}\"},{token:\"keyword.operator.logical.elixir\",regex:\"!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b\",originalRegex:\"(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b\"},{token:\"keyword.operator.arithmetic.elixir\",regex:\"\\\\*|\\\\+|\\\\-|/\"},{token:\"keyword.operator.other.elixir\",regex:\"\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>\"},{token:\"keyword.operator.assignment.elixir\",regex:\"=\"},{token:\"punctuation.separator.other.elixir\",regex:\":\"},{token:\"punctuation.separator.statement.elixir\",regex:\"\\\\;\"},{token:\"punctuation.separator.object.elixir\",regex:\",\"},{token:\"punctuation.separator.method.elixir\",regex:\"\\\\.\"},{token:\"punctuation.section.scope.elixir\",regex:\"\\\\{|\\\\}\"},{token:\"punctuation.section.array.elixir\",regex:\"\\\\[|\\\\]\"},{token:\"punctuation.section.function.elixir\",regex:\"\\\\(|\\\\)\"}],\"#escaped_char\":[{token:\"constant.character.escape.elixir\",regex:\"\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)\"}],\"#interpolated_elixir\":[{token:[\"source.elixir.embedded.source\",\"source.elixir.embedded.source.empty\"],regex:\"(#\\\\{)(\\\\})\"},{todo:{token:\"punctuation.section.embedded.elixir\",regex:\"#\\\\{\",push:[{token:\"punctuation.section.embedded.elixir\",regex:\"\\\\}\",next:\"pop\"},{include:\"#nest_curly_and_self\"},{include:\"$self\"},{defaultToken:\"source.elixir.embedded.source\"}]}}],\"#nest_curly_and_self\":[{token:\"punctuation.section.scope.elixir\",regex:\"\\\\{\",push:[{token:\"punctuation.section.scope.elixir\",regex:\"\\\\}\",next:\"pop\"},{include:\"#nest_curly_and_self\"}]},{include:\"$self\"}],\"#regex_sub\":[{include:\"#interpolated_elixir\"},{include:\"#escaped_char\"},{token:[\"punctuation.definition.arbitrary-repitition.elixir\",\"string.regexp.arbitrary-repitition.elixir\",\"string.regexp.arbitrary-repitition.elixir\",\"punctuation.definition.arbitrary-repitition.elixir\"],regex:\"(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})\"},{token:\"punctuation.definition.character-class.elixir\",regex:\"\\\\[(?:\\\\^?\\\\])?\",push:[{token:\"punctuation.definition.character-class.elixir\",regex:\"\\\\]\",next:\"pop\"},{include:\"#escaped_char\"},{defaultToken:\"string.regexp.character-class.elixir\"}]},{token:\"punctuation.definition.group.elixir\",regex:\"\\\\(\",push:[{token:\"punctuation.definition.group.elixir\",regex:\"\\\\)\",next:\"pop\"},{include:\"#regex_sub\"},{defaultToken:\"string.regexp.group.elixir\"}]},{token:[\"punctuation.definition.comment.elixir\",\"comment.line.number-sign.elixir\"],regex:\"(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)\",originalRegex:\"(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$\",comment:\"We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.\"}]},this.normalizeRules()};r.metaData={comment:\"Textmate bundle for Elixir Programming Language.\",fileTypes:[\"ex\",\"exs\"],firstLineMatch:\"^#!/.*\\\\belixir\",foldingStartMarker:\"(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$\",foldingStopMarker:\"^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)\",keyEquivalent:\"^~E\",name:\"Elixir\",scopeName:\"source.elixir\"},n.inherits(r,o),i.ElixirHighlightRules=r})),ace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"],(function(e,i,t){\"use strict\";var n=e(\"../../lib/oop\"),o=e(\"./fold_mode\").FoldMode,r=e(\"../../range\").Range,a=i.FoldMode=function(){};n.inherits(a,o),function(){this.commentBlock=function(e,i){var t=/\\S/,n=e.getLine(i),o=n.search(t);if(-1!=o&&\"#\"==n[o]){for(var a=n.length,l=e.getLength(),d=i,c=i;++i<l;){var u=(n=e.getLine(i)).search(t);if(-1!=u){if(\"#\"!=n[u])break;c=i}}if(c>d){var s=e.getLine(c).length;return new r(d,a,c,s)}}},this.getFoldWidgetRange=function(e,i,t){var n=this.indentationBlock(e,t);return n||((n=this.commentBlock(e,t))||void 0)},this.getFoldWidget=function(e,i,t){var n=e.getLine(t),o=n.search(/\\S/),r=e.getLine(t+1),a=e.getLine(t-1),l=a.search(/\\S/),d=r.search(/\\S/);if(-1==o)return e.foldWidgets[t-1]=-1!=l&&l<d?\"start\":\"\",\"\";if(-1==l){if(o==d&&\"#\"==n[o]&&\"#\"==r[o])return e.foldWidgets[t-1]=\"\",e.foldWidgets[t+1]=\"\",\"start\"}else if(l==o&&\"#\"==n[o]&&\"#\"==a[o]&&-1==e.getLine(t-2).search(/\\S/))return e.foldWidgets[t-1]=\"start\",e.foldWidgets[t+1]=\"\",\"\";return e.foldWidgets[t-1]=-1!=l&&l<o?\"start\":\"\",o<d?\"start\":\"\"}}.call(a.prototype)})),ace.define(\"ace/mode/elixir\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/elixir_highlight_rules\",\"ace/mode/folding/coffee\"],(function(e,i,t){\"use strict\";var n=e(\"../lib/oop\"),o=e(\"./text\").Mode,r=e(\"./elixir_highlight_rules\").ElixirHighlightRules,a=e(\"./folding/coffee\").FoldMode,l=function(){this.HighlightRules=r,this.foldingRules=new a,this.$behaviour=this.$defaultBehaviour};n.inherits(l,o),function(){this.lineCommentStart=\"#\",this.$id=\"ace/mode/elixir\"}.call(l.prototype),i.Mode=l})),ace.require([\"ace/mode/elixir\"],(function(e){\"object\"==typeof module&&\"object\"==typeof exports&&module&&(module.exports=e)}));","name":"2efdced6dc9a5936110384f59df71821.js","input":"ace.define(\"ace/mode/elixir_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  /* This file was autogenerated from https://raw.githubusercontent.com/elixir-lang/elixir-tmbundle/master/Syntaxes/Elixir.tmLanguage (uuid: ) */\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var ElixirHighlightRules = function () {\n    this.$rules = {\n      start: [{\n        token: ['meta.module.elixir', 'keyword.control.module.elixir', 'meta.module.elixir', 'entity.name.type.module.elixir'],\n        regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.heredoc',\n        regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n        push: [{\n          token: 'comment.documentation.heredoc',\n          regex: '\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          defaultToken: 'comment.documentation.heredoc'\n        }],\n        comment: '@doc with heredocs is treated as documentation'\n      }, {\n        token: 'comment.documentation.false',\n        regex: '@(?:module|type)?doc false',\n        comment: '@doc false is treated as documentation'\n      }, {\n        token: 'comment.documentation.string',\n        regex: '@(?:module|type)?doc \"',\n        push: [{\n          token: 'comment.documentation.string',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'comment.documentation.string'\n        }],\n        comment: '@doc with string is treated as documentation'\n      }, {\n        token: 'keyword.control.elixir',\n        regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])'\n      }, {\n        token: 'keyword.operator.elixir',\n        regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n        comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation'\n      }, {\n        token: 'constant.language.elixir',\n        regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])'\n      }, {\n        token: 'variable.language.elixir',\n        regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.readwrite.module.elixir'],\n        regex: '(@)([a-zA-Z_]\\\\w*)'\n      }, {\n        token: ['punctuation.definition.variable.elixir', 'variable.other.anonymous.elixir'],\n        regex: '(&)(\\\\d*)'\n      }, {\n        token: 'variable.other.constant.elixir',\n        regex: '\\\\b[A-Z]\\\\w*\\\\b'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\\'',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.single-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: ':\"',\n        push: [{\n          token: 'punctuation.definition.constant.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'constant.other.symbol.double-quoted.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\\'\\'\\')',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\\'\\'\\')',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\\'\\'\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.heredoc.elixir'\n        }],\n        comment: 'Single-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\\'',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\'',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'support.function.variable.quoted.single.elixir'\n        }],\n        comment: 'single quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '(?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '\"',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.elixir'\n        }],\n        comment: 'double quoted string (allows for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[a-z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.quoted.double.heredoc.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[a-z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          include: '#interpolated_elixir'\n        }, {\n          include: '#escaped_char'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.interpolated.elixir'\n        }],\n        comment: 'sigil (allow for interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z](?:\"\"\")',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '~[A-Z](?>\"\"\")',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '^\\\\s*\"\"\"',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'Double-quoted heredocs sigils'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\{',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\}[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\[',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\<',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\>[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z]\\\\(',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '\\\\)[a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: 'punctuation.definition.string.begin.elixir',\n        regex: '~[A-Z][^\\\\w]',\n        push: [{\n          token: 'punctuation.definition.string.end.elixir',\n          regex: '[^\\\\w][a-z]*',\n          next: 'pop'\n        }, {\n          defaultToken: 'string.quoted.other.literal.upper.elixir'\n        }],\n        comment: 'sigil (without interpolation)'\n      }, {\n        token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n        regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n        comment: 'symbols'\n      }, {\n        token: 'punctuation.definition.constant.elixir',\n        regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n        comment: 'symbols'\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(#)(.*)'\n      }, {\n        token: 'constant.numeric.elixir',\n        regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n        originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n        comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t'\n      }, {\n        token: 'keyword.operator.assignment.augmented.elixir',\n        regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&='\n      }, {\n        token: 'keyword.operator.comparison.elixir',\n        regex: '===?|!==?|<=?|>=?'\n      }, {\n        token: 'keyword.operator.bitwise.elixir',\n        regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}'\n      }, {\n        token: 'keyword.operator.logical.elixir',\n        regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n        originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b'\n      }, {\n        token: 'keyword.operator.arithmetic.elixir',\n        regex: '\\\\*|\\\\+|\\\\-|/'\n      }, {\n        token: 'keyword.operator.other.elixir',\n        regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>'\n      }, {\n        token: 'keyword.operator.assignment.elixir',\n        regex: '='\n      }, {\n        token: 'punctuation.separator.other.elixir',\n        regex: ':'\n      }, {\n        token: 'punctuation.separator.statement.elixir',\n        regex: '\\\\;'\n      }, {\n        token: 'punctuation.separator.object.elixir',\n        regex: ','\n      }, {\n        token: 'punctuation.separator.method.elixir',\n        regex: '\\\\.'\n      }, {\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{|\\\\}'\n      }, {\n        token: 'punctuation.section.array.elixir',\n        regex: '\\\\[|\\\\]'\n      }, {\n        token: 'punctuation.section.function.elixir',\n        regex: '\\\\(|\\\\)'\n      }],\n      '#escaped_char': [{\n        token: 'constant.character.escape.elixir',\n        regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)'\n      }],\n      '#interpolated_elixir': [{\n        token: ['source.elixir.embedded.source', 'source.elixir.embedded.source.empty'],\n        regex: '(#\\\\{)(\\\\})'\n      }, {\n        todo: {\n          token: 'punctuation.section.embedded.elixir',\n          regex: '#\\\\{',\n          push: [{\n            token: 'punctuation.section.embedded.elixir',\n            regex: '\\\\}',\n            next: 'pop'\n          }, {\n            include: '#nest_curly_and_self'\n          }, {\n            include: '$self'\n          }, {\n            defaultToken: 'source.elixir.embedded.source'\n          }]\n        }\n      }],\n      '#nest_curly_and_self': [{\n        token: 'punctuation.section.scope.elixir',\n        regex: '\\\\{',\n        push: [{\n          token: 'punctuation.section.scope.elixir',\n          regex: '\\\\}',\n          next: 'pop'\n        }, {\n          include: '#nest_curly_and_self'\n        }]\n      }, {\n        include: '$self'\n      }],\n      '#regex_sub': [{\n        include: '#interpolated_elixir'\n      }, {\n        include: '#escaped_char'\n      }, {\n        token: ['punctuation.definition.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'string.regexp.arbitrary-repitition.elixir', 'punctuation.definition.arbitrary-repitition.elixir'],\n        regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})'\n      }, {\n        token: 'punctuation.definition.character-class.elixir',\n        regex: '\\\\[(?:\\\\^?\\\\])?',\n        push: [{\n          token: 'punctuation.definition.character-class.elixir',\n          regex: '\\\\]',\n          next: 'pop'\n        }, {\n          include: '#escaped_char'\n        }, {\n          defaultToken: 'string.regexp.character-class.elixir'\n        }]\n      }, {\n        token: 'punctuation.definition.group.elixir',\n        regex: '\\\\(',\n        push: [{\n          token: 'punctuation.definition.group.elixir',\n          regex: '\\\\)',\n          next: 'pop'\n        }, {\n          include: '#regex_sub'\n        }, {\n          defaultToken: 'string.regexp.group.elixir'\n        }]\n      }, {\n        token: ['punctuation.definition.comment.elixir', 'comment.line.number-sign.elixir'],\n        regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n        originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n        comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.'\n      }]\n    };\n    this.normalizeRules();\n  };\n  ElixirHighlightRules.metaData = {\n    comment: 'Textmate bundle for Elixir Programming Language.',\n    fileTypes: ['ex', 'exs'],\n    firstLineMatch: '^#!/.*\\\\belixir',\n    foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n    foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n    keyEquivalent: '^~E',\n    name: 'Elixir',\n    scopeName: 'source.elixir'\n  };\n  oop.inherits(ElixirHighlightRules, TextHighlightRules);\n  exports.ElixirHighlightRules = ElixirHighlightRules;\n});\nace.define(\"ace/mode/folding/coffee\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.commentBlock = function (session, row) {\n      var re = /\\S/;\n      var line = session.getLine(row);\n      var startLevel = line.search(re);\n      if (startLevel == -1 || line[startLevel] != \"#\") return;\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n      while (++row < maxRow) {\n        line = session.getLine(row);\n        var level = line.search(re);\n        if (level == -1) continue;\n        if (line[level] != \"#\") break;\n        endRow = row;\n      }\n      if (endRow > startRow) {\n        var endColumn = session.getLine(endRow).length;\n        return new Range(startRow, startColumn, endRow, endColumn);\n      }\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var range = this.indentationBlock(session, row);\n      if (range) return range;\n      range = this.commentBlock(session, row);\n      if (range) return range;\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var indent = line.search(/\\S/);\n      var next = session.getLine(row + 1);\n      var prev = session.getLine(row - 1);\n      var prevIndent = prev.search(/\\S/);\n      var nextIndent = next.search(/\\S/);\n      if (indent == -1) {\n        session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n        return \"\";\n      }\n      if (prevIndent == -1) {\n        if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n          session.foldWidgets[row - 1] = \"\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"start\";\n        }\n      } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n        if (session.getLine(row - 2).search(/\\S/) == -1) {\n          session.foldWidgets[row - 1] = \"start\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"\";\n        }\n      }\n      if (prevIndent != -1 && prevIndent < indent) session.foldWidgets[row - 1] = \"start\";else session.foldWidgets[row - 1] = \"\";\n      if (indent < nextIndent) return \"start\";else return \"\";\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/elixir\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/elixir_highlight_rules\", \"ace/mode/folding/coffee\"], function (require, exports, module) {\n  /*\n  THIS FILE WAS AUTOGENERATED BY mode.tmpl.js\n  */\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextMode = require(\"./text\").Mode;\n  var ElixirHighlightRules = require(\"./elixir_highlight_rules\").ElixirHighlightRules;\n  var FoldMode = require(\"./folding/coffee\").FoldMode;\n  var Mode = function () {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n  };\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n    this.$id = \"ace/mode/elixir\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/elixir\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();"}