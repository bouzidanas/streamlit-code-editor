{"code":"!function(t){if((\"undefined\"==typeof t.window||!t.document)&&(!t.require||!t.define)){t.console||(t.console=function(){var t=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:t})},t.console.error=t.console.warn=t.console.log=t.console.trace=t.console),t.window=t,t.ace=t,t.onerror=function(t,e,n,r,i){postMessage({type:\"error\",data:{message:t,data:i&&i.data,file:e,line:n,col:r,stack:i&&i.stack}})},t.normalizeModule=function(e,n){if(-1!==n.indexOf(\"!\")){var r=n.split(\"!\");return t.normalizeModule(e,r[0])+\"!\"+t.normalizeModule(e,r[1])}if(\".\"==n.charAt(0)){var i=e.split(\"/\").slice(0,-1).join(\"/\");for(n=(i?i+\"/\":\"\")+n;-1!==n.indexOf(\".\")&&o!=n;){var o=n;n=n.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return n},t.require=function(e,n){if(n||(n=e,e=null),!n.charAt)throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");n=t.normalizeModule(e,n);var r=t.require.modules[n];if(r)return r.initialized||(r.initialized=!0,r.exports=r.factory().exports),r.exports;if(!t.require.tlns)return console.log(\"unable to load \"+n);var i=function(t,e){var n=t,r=\"\";for(;n;){var i=e[n];if(\"string\"==typeof i)return i+r;if(i)return i.location.replace(/\\/*$/,\"/\")+(r||i.main||i.name);if(!1===i)return\"\";var o=n.lastIndexOf(\"/\");if(-1===o)break;r=n.substr(o)+r,n=n.slice(0,o)}return t}(n,t.require.tlns);return\".js\"!=i.slice(-3)&&(i+=\".js\"),t.require.id=n,t.require.modules[n]={},importScripts(i),t.require(e,n)},t.require.modules={},t.require.tlns={},t.define=function(e,n,r){if(2==arguments.length?(r=n,\"string\"!=typeof e&&(n=e,e=t.require.id)):1==arguments.length&&(r=e,n=[],e=t.require.id),\"function\"==typeof r){n.length||(n=[\"require\",\"exports\",\"module\"]);var i=function(n){return t.require(e,n)};t.require.modules[e]={exports:{},factory:function(){var t=this,e=r.apply(this,n.slice(0,r.length).map((function(e){switch(e){case\"require\":return i;case\"exports\":return t.exports;case\"module\":return t;default:return i(e)}})));return e&&(t.exports=e),t}}}else t.require.modules[e]={exports:r,initialized:!0}},t.define.amd={},t.require.tlns={},t.initBaseUrls=function(t){for(var e in t)this.require.tlns[e]=t[e]},t.initSender=function(){var e=t.require(\"ace/lib/event_emitter\").EventEmitter,n=t.require(\"ace/lib/oop\"),r=function(){};return function(){n.implement(this,e),this.callback=function(t,e){postMessage({type:\"call\",id:e,data:t})},this.emit=function(t,e){postMessage({type:\"event\",name:t,data:e})}}.call(r.prototype),new r};var e=t.main=null,n=t.sender=null;t.onmessage=function(r){var i=r.data;if(i.event&&n)n._signal(i.event,i.data);else if(i.command)if(e[i.command])e[i.command].apply(e,i.args);else{if(!t[i.command])throw new Error(\"Unknown command:\"+i.command);t[i.command].apply(t,i.args)}else if(i.init){t.initBaseUrls(i.tlns),n=t.sender=t.initSender();var o=this.require(i.module)[i.classname];e=t.main=new o(n)}}}}(this),ace.define(\"ace/lib/oop\",[],(function(t,e,n){\"use strict\";e.inherits=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})},e.mixin=function(t,e){for(var n in e)t[n]=e[n];return t},e.implement=function(t,n){e.mixin(t,n)}})),ace.define(\"ace/apply_delta\",[],(function(t,e,n){\"use strict\";e.applyDelta=function(t,e,n){var r=e.start.row,i=e.start.column,o=t[r]||\"\";switch(e.action){case\"insert\":if(1===e.lines.length)t[r]=o.substring(0,i)+e.lines[0]+o.substring(i);else{var s=[r,1].concat(e.lines);t.splice.apply(t,s),t[r]=o.substring(0,i)+t[r],t[r+e.lines.length-1]+=o.substring(i)}break;case\"remove\":var a=e.end.column,c=e.end.row;r===c?t[r]=o.substring(0,i)+o.substring(a):t.splice(r,c-r+1,o.substring(0,i)+t[c].substring(a))}}})),ace.define(\"ace/lib/event_emitter\",[],(function(t,e,n){\"use strict\";var r={},i=function(){this.propagationStopped=!0},o=function(){this.defaultPrevented=!0};r._emit=r._dispatchEvent=function(t,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var n=this._eventRegistry[t]||[],r=this._defaultHandlers[t];if(n.length||r){\"object\"==typeof e&&e||(e={}),e.type||(e.type=t),e.stopPropagation||(e.stopPropagation=i),e.preventDefault||(e.preventDefault=o),n=n.slice();for(var s=0;s<n.length&&(n[s](e,this),!e.propagationStopped);s++);return r&&!e.defaultPrevented?r(e,this):void 0}},r._signal=function(t,e){var n=(this._eventRegistry||{})[t];if(n){n=n.slice();for(var r=0;r<n.length;r++)n[r](e,this)}},r.once=function(t,e){var n=this;if(this.on(t,(function r(){n.off(t,r),e.apply(null,arguments)})),!e)return new Promise((function(t){e=t}))},r.setDefaultHandler=function(t,e){var n=this._defaultHandlers;if(n||(n=this._defaultHandlers={_disabled_:{}}),n[t]){var r=n[t],i=n._disabled_[t];i||(n._disabled_[t]=i=[]),i.push(r);var o=i.indexOf(e);-1!=o&&i.splice(o,1)}n[t]=e},r.removeDefaultHandler=function(t,e){var n=this._defaultHandlers;if(n){var r=n._disabled_[t];if(n[t]==e)r&&this.setDefaultHandler(t,r.pop());else if(r){var i=r.indexOf(e);-1!=i&&r.splice(i,1)}}},r.on=r.addEventListener=function(t,e,n){this._eventRegistry=this._eventRegistry||{};var r=this._eventRegistry[t];return r||(r=this._eventRegistry[t]=[]),-1==r.indexOf(e)&&r[n?\"unshift\":\"push\"](e),e},r.off=r.removeListener=r.removeEventListener=function(t,e){this._eventRegistry=this._eventRegistry||{};var n=this._eventRegistry[t];if(n){var r=n.indexOf(e);-1!==r&&n.splice(r,1)}},r.removeAllListeners=function(t){t||(this._eventRegistry=this._defaultHandlers=void 0),this._eventRegistry&&(this._eventRegistry[t]=void 0),this._defaultHandlers&&(this._defaultHandlers[t]=void 0)},e.EventEmitter=r})),ace.define(\"ace/range\",[],(function(t,e,n){\"use strict\";var r=function(){function t(t,e,n,r){this.start={row:t,column:e},this.end={row:n,column:r}}return t.prototype.isEqual=function(t){return this.start.row===t.start.row&&this.end.row===t.end.row&&this.start.column===t.start.column&&this.end.column===t.end.column},t.prototype.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},t.prototype.contains=function(t,e){return 0==this.compare(t,e)},t.prototype.compareRange=function(t){var e,n=t.end,r=t.start;return 1==(e=this.compare(n.row,n.column))?1==(e=this.compare(r.row,r.column))?2:0==e?1:0:-1==e?-2:-1==(e=this.compare(r.row,r.column))?-1:1==e?42:0},t.prototype.comparePoint=function(t){return this.compare(t.row,t.column)},t.prototype.containsRange=function(t){return 0==this.comparePoint(t.start)&&0==this.comparePoint(t.end)},t.prototype.intersects=function(t){var e=this.compareRange(t);return-1==e||0==e||1==e},t.prototype.isEnd=function(t,e){return this.end.row==t&&this.end.column==e},t.prototype.isStart=function(t,e){return this.start.row==t&&this.start.column==e},t.prototype.setStart=function(t,e){\"object\"==typeof t?(this.start.column=t.column,this.start.row=t.row):(this.start.row=t,this.start.column=e)},t.prototype.setEnd=function(t,e){\"object\"==typeof t?(this.end.column=t.column,this.end.row=t.row):(this.end.row=t,this.end.column=e)},t.prototype.inside=function(t,e){return 0==this.compare(t,e)&&(!this.isEnd(t,e)&&!this.isStart(t,e))},t.prototype.insideStart=function(t,e){return 0==this.compare(t,e)&&!this.isEnd(t,e)},t.prototype.insideEnd=function(t,e){return 0==this.compare(t,e)&&!this.isStart(t,e)},t.prototype.compare=function(t,e){return this.isMultiLine()||t!==this.start.row?t<this.start.row?-1:t>this.end.row?1:this.start.row===t?e>=this.start.column?0:-1:this.end.row===t?e<=this.end.column?0:1:0:e<this.start.column?-1:e>this.end.column?1:0},t.prototype.compareStart=function(t,e){return this.start.row==t&&this.start.column==e?-1:this.compare(t,e)},t.prototype.compareEnd=function(t,e){return this.end.row==t&&this.end.column==e?1:this.compare(t,e)},t.prototype.compareInside=function(t,e){return this.end.row==t&&this.end.column==e?1:this.start.row==t&&this.start.column==e?-1:this.compare(t,e)},t.prototype.clipRows=function(e,n){if(this.end.row>n)var r={row:n+1,column:0};else if(this.end.row<e)r={row:e,column:0};if(this.start.row>n)var i={row:n+1,column:0};else if(this.start.row<e)i={row:e,column:0};return t.fromPoints(i||this.start,r||this.end)},t.prototype.extend=function(e,n){var r=this.compare(e,n);if(0==r)return this;if(-1==r)var i={row:e,column:n};else var o={row:e,column:n};return t.fromPoints(i||this.start,o||this.end)},t.prototype.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},t.prototype.isMultiLine=function(){return this.start.row!==this.end.row},t.prototype.clone=function(){return t.fromPoints(this.start,this.end)},t.prototype.collapseRows=function(){return 0==this.end.column?new t(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new t(this.start.row,0,this.end.row,0)},t.prototype.toScreenRange=function(e){var n=e.documentToScreenPosition(this.start),r=e.documentToScreenPosition(this.end);return new t(n.row,n.column,r.row,r.column)},t.prototype.moveBy=function(t,e){this.start.row+=t,this.start.column+=e,this.end.row+=t,this.end.column+=e},t}();r.fromPoints=function(t,e){return new r(t.row,t.column,e.row,e.column)},r.comparePoints=function(t,e){return t.row-e.row||t.column-e.column},e.Range=r})),ace.define(\"ace/anchor\",[],(function(t,e,n){\"use strict\";var r=t(\"./lib/oop\"),i=t(\"./lib/event_emitter\").EventEmitter,o=function(){function t(t,e,n){this.$onChange=this.onChange.bind(this),this.attach(t),\"number\"!=typeof e?this.setPosition(e.row,e.column):this.setPosition(e,n)}return t.prototype.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},t.prototype.getDocument=function(){return this.document},t.prototype.onChange=function(t){if((t.start.row!=t.end.row||t.start.row==this.row)&&!(t.start.row>this.row)){var e=function(t,e,n){var r=\"insert\"==t.action,i=(r?1:-1)*(t.end.row-t.start.row),o=(r?1:-1)*(t.end.column-t.start.column),a=t.start,c=r?a:t.end;if(s(e,a,n))return{row:e.row,column:e.column};if(s(c,e,!n))return{row:e.row+i,column:e.column+(e.row==c.row?o:0)};return{row:a.row,column:a.column}}(t,{row:this.row,column:this.column},this.$insertRight);this.setPosition(e.row,e.column,!0)}},t.prototype.setPosition=function(t,e,n){var r;if(r=n?{row:t,column:e}:this.$clipPositionToDocument(t,e),this.row!=r.row||this.column!=r.column){var i={row:this.row,column:this.column};this.row=r.row,this.column=r.column,this._signal(\"change\",{old:i,value:r})}},t.prototype.detach=function(){this.document.off(\"change\",this.$onChange)},t.prototype.attach=function(t){this.document=t||this.document,this.document.on(\"change\",this.$onChange)},t.prototype.$clipPositionToDocument=function(t,e){var n={};return t>=this.document.getLength()?(n.row=Math.max(0,this.document.getLength()-1),n.column=this.document.getLine(n.row).length):t<0?(n.row=0,n.column=0):(n.row=t,n.column=Math.min(this.document.getLine(n.row).length,Math.max(0,e))),e<0&&(n.column=0),n},t}();function s(t,e,n){var r=n?t.column<=e.column:t.column<e.column;return t.row<e.row||t.row==e.row&&r}o.prototype.$insertRight=!1,r.implement(o.prototype,i),e.Anchor=o})),ace.define(\"ace/document\",[],(function(t,e,n){\"use strict\";var r=t(\"./lib/oop\"),i=t(\"./apply_delta\").applyDelta,o=t(\"./lib/event_emitter\").EventEmitter,s=t(\"./range\").Range,a=t(\"./anchor\").Anchor,c=function(){function t(t){this.$lines=[\"\"],0===t.length?this.$lines=[\"\"]:Array.isArray(t)?this.insertMergedLines({row:0,column:0},t):this.insert({row:0,column:0},t)}return t.prototype.setValue=function(t){var e=this.getLength()-1;this.remove(new s(0,0,e,this.getLine(e).length)),this.insert({row:0,column:0},t||\"\")},t.prototype.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},t.prototype.createAnchor=function(t,e){return new a(this,t,e)},t.prototype.$detectNewLine=function(t){var e=t.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=e?e[1]:\"\\n\",this._signal(\"changeNewLineMode\")},t.prototype.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},t.prototype.setNewLineMode=function(t){this.$newLineMode!==t&&(this.$newLineMode=t,this._signal(\"changeNewLineMode\"))},t.prototype.getNewLineMode=function(){return this.$newLineMode},t.prototype.isNewLine=function(t){return\"\\r\\n\"==t||\"\\r\"==t||\"\\n\"==t},t.prototype.getLine=function(t){return this.$lines[t]||\"\"},t.prototype.getLines=function(t,e){return this.$lines.slice(t,e+1)},t.prototype.getAllLines=function(){return this.getLines(0,this.getLength())},t.prototype.getLength=function(){return this.$lines.length},t.prototype.getTextRange=function(t){return this.getLinesForRange(t).join(this.getNewLineCharacter())},t.prototype.getLinesForRange=function(t){var e;if(t.start.row===t.end.row)e=[this.getLine(t.start.row).substring(t.start.column,t.end.column)];else{(e=this.getLines(t.start.row,t.end.row))[0]=(e[0]||\"\").substring(t.start.column);var n=e.length-1;t.end.row-t.start.row==n&&(e[n]=e[n].substring(0,t.end.column))}return e},t.prototype.insertLines=function(t,e){return console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\"),this.insertFullLines(t,e)},t.prototype.removeLines=function(t,e){return console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\"),this.removeFullLines(t,e)},t.prototype.insertNewLine=function(t){return console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\"),this.insertMergedLines(t,[\"\",\"\"])},t.prototype.insert=function(t,e){return this.getLength()<=1&&this.$detectNewLine(e),this.insertMergedLines(t,this.$split(e))},t.prototype.insertInLine=function(t,e){var n=this.clippedPos(t.row,t.column),r=this.pos(t.row,t.column+e.length);return this.applyDelta({start:n,end:r,action:\"insert\",lines:[e]},!0),this.clonePos(r)},t.prototype.clippedPos=function(t,e){var n=this.getLength();void 0===t?t=n:t<0?t=0:t>=n&&(t=n-1,e=void 0);var r=this.getLine(t);return void 0==e&&(e=r.length),{row:t,column:e=Math.min(Math.max(e,0),r.length)}},t.prototype.clonePos=function(t){return{row:t.row,column:t.column}},t.prototype.pos=function(t,e){return{row:t,column:e}},t.prototype.$clipPosition=function(t){var e=this.getLength();return t.row>=e?(t.row=Math.max(0,e-1),t.column=this.getLine(e-1).length):(t.row=Math.max(0,t.row),t.column=Math.min(Math.max(t.column,0),this.getLine(t.row).length)),t},t.prototype.insertFullLines=function(t,e){var n=0;(t=Math.min(Math.max(t,0),this.getLength()))<this.getLength()?(e=e.concat([\"\"]),n=0):(e=[\"\"].concat(e),t--,n=this.$lines[t].length),this.insertMergedLines({row:t,column:n},e)},t.prototype.insertMergedLines=function(t,e){var n=this.clippedPos(t.row,t.column),r={row:n.row+e.length-1,column:(1==e.length?n.column:0)+e[e.length-1].length};return this.applyDelta({start:n,end:r,action:\"insert\",lines:e}),this.clonePos(r)},t.prototype.remove=function(t){var e=this.clippedPos(t.start.row,t.start.column),n=this.clippedPos(t.end.row,t.end.column);return this.applyDelta({start:e,end:n,action:\"remove\",lines:this.getLinesForRange({start:e,end:n})}),this.clonePos(e)},t.prototype.removeInLine=function(t,e,n){var r=this.clippedPos(t,e),i=this.clippedPos(t,n);return this.applyDelta({start:r,end:i,action:\"remove\",lines:this.getLinesForRange({start:r,end:i})},!0),this.clonePos(r)},t.prototype.removeFullLines=function(t,e){t=Math.min(Math.max(0,t),this.getLength()-1);var n=(e=Math.min(Math.max(0,e),this.getLength()-1))==this.getLength()-1&&t>0,r=e<this.getLength()-1,i=n?t-1:t,o=n?this.getLine(i).length:0,a=r?e+1:e,c=r?0:this.getLine(a).length,u=new s(i,o,a,c),l=this.$lines.slice(t,e+1);return this.applyDelta({start:u.start,end:u.end,action:\"remove\",lines:this.getLinesForRange(u)}),l},t.prototype.removeNewLine=function(t){t<this.getLength()-1&&t>=0&&this.applyDelta({start:this.pos(t,this.getLine(t).length),end:this.pos(t+1,0),action:\"remove\",lines:[\"\",\"\"]})},t.prototype.replace=function(t,e){return t instanceof s||(t=s.fromPoints(t.start,t.end)),0===e.length&&t.isEmpty()?t.start:e==this.getTextRange(t)?t.end:(this.remove(t),e?this.insert(t.start,e):t.start)},t.prototype.applyDeltas=function(t){for(var e=0;e<t.length;e++)this.applyDelta(t[e])},t.prototype.revertDeltas=function(t){for(var e=t.length-1;e>=0;e--)this.revertDelta(t[e])},t.prototype.applyDelta=function(t,e){var n=\"insert\"==t.action;(n?t.lines.length<=1&&!t.lines[0]:!s.comparePoints(t.start,t.end))||(n&&t.lines.length>2e4?this.$splitAndapplyLargeDelta(t,2e4):(i(this.$lines,t,e),this._signal(\"change\",t)))},t.prototype.$safeApplyDelta=function(t){var e=this.$lines.length;(\"remove\"==t.action&&t.start.row<e&&t.end.row<e||\"insert\"==t.action&&t.start.row<=e)&&this.applyDelta(t)},t.prototype.$splitAndapplyLargeDelta=function(t,e){for(var n=t.lines,r=n.length-e+1,i=t.start.row,o=t.start.column,s=0,a=0;s<r;s=a){a+=e-1;var c=n.slice(s,a);c.push(\"\"),this.applyDelta({start:this.pos(i+s,o),end:this.pos(i+a,o=0),action:t.action,lines:c},!0)}t.lines=n.slice(s),t.start.row=i+s,t.start.column=o,this.applyDelta(t,!0)},t.prototype.revertDelta=function(t){this.$safeApplyDelta({start:this.clonePos(t.start),end:this.clonePos(t.end),action:\"insert\"==t.action?\"remove\":\"insert\",lines:t.lines.slice()})},t.prototype.indexToPosition=function(t,e){for(var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=e||0,o=n.length;i<o;i++)if((t-=n[i].length+r)<0)return{row:i,column:t+n[i].length+r};return{row:o-1,column:t+n[o-1].length+r}},t.prototype.positionToIndex=function(t,e){for(var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=0,o=Math.min(t.row,n.length),s=e||0;s<o;++s)i+=n[s].length+r;return i+t.column},t.prototype.$split=function(t){return t.split(/\\r\\n|\\r|\\n/)},t}();c.prototype.$autoNewLine=\"\",c.prototype.$newLineMode=\"auto\",r.implement(c.prototype,o),e.Document=c})),ace.define(\"ace/lib/deep_copy\",[],(function(t,e,n){e.deepCopy=function t(e){if(\"object\"!==typeof e||!e)return e;var n;if(Array.isArray(e)){n=[];for(var r=0;r<e.length;r++)n[r]=t(e[r]);return n}if(\"[object Object]\"!==Object.prototype.toString.call(e))return e;for(var r in n={},e)n[r]=t(e[r]);return n}})),ace.define(\"ace/lib/lang\",[],(function(t,e,n){\"use strict\";e.last=function(t){return t[t.length-1]},e.stringReverse=function(t){return t.split(\"\").reverse().join(\"\")},e.stringRepeat=function(t,e){for(var n=\"\";e>0;)1&e&&(n+=t),(e>>=1)&&(t+=t);return n};var r=/^\\s\\s*/,i=/\\s\\s*$/;e.stringTrimLeft=function(t){return t.replace(r,\"\")},e.stringTrimRight=function(t){return t.replace(i,\"\")},e.copyObject=function(t){var e={};for(var n in t)e[n]=t[n];return e},e.copyArray=function(t){for(var e=[],n=0,r=t.length;n<r;n++)t[n]&&\"object\"==typeof t[n]?e[n]=this.copyObject(t[n]):e[n]=t[n];return e},e.deepCopy=t(\"./deep_copy\").deepCopy,e.arrayToMap=function(t){for(var e={},n=0;n<t.length;n++)e[t[n]]=1;return e},e.createMap=function(t){var e=Object.create(null);for(var n in t)e[n]=t[n];return e},e.arrayRemove=function(t,e){for(var n=0;n<=t.length;n++)e===t[n]&&t.splice(n,1)},e.escapeRegExp=function(t){return t.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},e.escapeHTML=function(t){return(\"\"+t).replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},e.getMatchOffsets=function(t,e){var n=[];return t.replace(e,(function(t){n.push({offset:arguments[arguments.length-2],length:t.length})})),n},e.deferredCall=function(t){var e=null,n=function(){e=null,t()},r=function(t){return r.cancel(),e=setTimeout(n,t||0),r};return r.schedule=r,r.call=function(){return this.cancel(),t(),r},r.cancel=function(){return clearTimeout(e),e=null,r},r.isPending=function(){return e},r},e.delayedCall=function(t,e){var n=null,r=function(){n=null,t()},i=function(t){null==n&&(n=setTimeout(r,t||e))};return i.delay=function(t){n&&clearTimeout(n),n=setTimeout(r,t||e)},i.schedule=i,i.call=function(){this.cancel(),t()},i.cancel=function(){n&&clearTimeout(n),n=null},i.isPending=function(){return n},i},e.supportsLookbehind=function(){try{new RegExp(\"(?<=.)\")}catch(t){return!1}return!0},e.skipEmptyMatch=function(t,e,n){return n&&t.codePointAt(e)>65535?2:1}})),ace.define(\"ace/worker/mirror\",[],(function(t,e,n){\"use strict\";var r=t(\"../document\").Document,i=t(\"../lib/lang\"),o=e.Mirror=function(t){this.sender=t;var e=this.doc=new r(\"\"),n=this.deferredUpdate=i.delayedCall(this.onUpdate.bind(this)),o=this;t.on(\"change\",(function(t){var r=t.data;if(r[0].start)e.applyDeltas(r);else for(var i=0;i<r.length;i+=2){var s,a;if((\"insert\"==(s=Array.isArray(r[i+1])?{action:\"insert\",start:r[i],lines:r[i+1]}:{action:\"remove\",start:r[i],end:r[i+1]}).action?s.start:s.end).row>=e.$lines.length)throw(a=new Error(\"Invalid delta\")).data={path:o.$path,linesLength:e.$lines.length,start:s.start,end:s.end},a;e.applyDelta(s,!0)}if(o.$timeout)return n.schedule(o.$timeout);o.onUpdate()}))};(function(){this.$timeout=500,this.setTimeout=function(t){this.$timeout=t},this.setValue=function(t){this.doc.setValue(t),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(t){this.sender.callback(this.doc.getValue(),t)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(o.prototype)})),ace.define(\"ace/mode/yaml/yaml-lint\",[],(function(t,e,n){var r={require:t,exports:e,module:n};function i(e,n,i){\"function\"==typeof e&&(i=e,n=[\"require\",\"exports\",\"module\"],e=r.module.id),\"string\"!==typeof e&&(i=n,n=e,e=r.module.id),i||(i=n,n=[]);var o=\"function\"==typeof i?i.apply(r.module,n.map((function(e){return r[e]||t(e)}))):i;void 0!=o&&(r.module.exports=o)}e=void 0,n=void 0,i.amd=!0,function(t){if(\"object\"===typeof e&&\"undefined\"!==typeof n)n.exports=t();else if(i.amd)i([],t);else{(\"undefined\"!==typeof window?window:\"undefined\"!==typeof global?global:\"undefined\"!==typeof self?self:this).lint=t()}}((function(){return function e(n,r,i){function o(a,c){if(!r[a]){if(!n[a]){var u=\"function\"==typeof t&&t;if(!c&&u)return u(a,!0);if(s)return s(a,!0);var l=new Error(\"Cannot find module '\"+a+\"'\");throw l.code=\"MODULE_NOT_FOUND\",l}var p=r[a]={exports:{}};n[a][0].call(p.exports,(function(t){return o(n[a][1][t]||t)}),p,p.exports,e,n,r,i)}return r[a].exports}for(var s=\"function\"==typeof t&&t,a=0;a<i.length;a++)o(i[a]);return o}({1:[function(t,e,n){},{}],2:[function(t,e,n){t(\"fs\");var r=t(\"lodash.merge\"),i=t(\"js-yaml\"),o={schema:\"DEFAULT_SAFE_SCHEMA\"};e.exports={lint:function(t,e,n){var s=r({},o,e);try{i.safeLoad(t,{schema:i[s.schema]}),n()}catch(a){n(a)}}}},{fs:1,\"js-yaml\":3,\"lodash.merge\":33}],3:[function(t,e,n){\"use strict\";var r=t(\"./lib/js-yaml.js\");e.exports=r},{\"./lib/js-yaml.js\":4}],4:[function(t,e,n){\"use strict\";var r=t(\"./js-yaml/loader\"),i=t(\"./js-yaml/dumper\");function o(t){return function(){throw new Error(\"Function \"+t+\" is deprecated and cannot be used.\")}}e.exports.Type=t(\"./js-yaml/type\"),e.exports.Schema=t(\"./js-yaml/schema\"),e.exports.FAILSAFE_SCHEMA=t(\"./js-yaml/schema/failsafe\"),e.exports.JSON_SCHEMA=t(\"./js-yaml/schema/json\"),e.exports.CORE_SCHEMA=t(\"./js-yaml/schema/core\"),e.exports.DEFAULT_SAFE_SCHEMA=t(\"./js-yaml/schema/default_safe\"),e.exports.DEFAULT_FULL_SCHEMA=t(\"./js-yaml/schema/default_full\"),e.exports.load=r.load,e.exports.loadAll=r.loadAll,e.exports.safeLoad=r.safeLoad,e.exports.safeLoadAll=r.safeLoadAll,e.exports.dump=i.dump,e.exports.safeDump=i.safeDump,e.exports.YAMLException=t(\"./js-yaml/exception\"),e.exports.MINIMAL_SCHEMA=t(\"./js-yaml/schema/failsafe\"),e.exports.SAFE_SCHEMA=t(\"./js-yaml/schema/default_safe\"),e.exports.DEFAULT_SCHEMA=t(\"./js-yaml/schema/default_full\"),e.exports.scan=o(\"scan\"),e.exports.parse=o(\"parse\"),e.exports.compose=o(\"compose\"),e.exports.addConstructor=o(\"addConstructor\")},{\"./js-yaml/dumper\":6,\"./js-yaml/exception\":7,\"./js-yaml/loader\":8,\"./js-yaml/schema\":10,\"./js-yaml/schema/core\":11,\"./js-yaml/schema/default_full\":12,\"./js-yaml/schema/default_safe\":13,\"./js-yaml/schema/failsafe\":14,\"./js-yaml/schema/json\":15,\"./js-yaml/type\":16}],5:[function(t,e,n){\"use strict\";function r(t){return\"undefined\"===typeof t||null===t}e.exports.isNothing=r,e.exports.isObject=function(t){return\"object\"===typeof t&&null!==t},e.exports.toArray=function(t){return Array.isArray(t)?t:r(t)?[]:[t]},e.exports.repeat=function(t,e){var n,r=\"\";for(n=0;n<e;n+=1)r+=t;return r},e.exports.isNegativeZero=function(t){return 0===t&&Number.NEGATIVE_INFINITY===1/t},e.exports.extend=function(t,e){var n,r,i,o;if(e)for(n=0,r=(o=Object.keys(e)).length;n<r;n+=1)t[i=o[n]]=e[i];return t}},{}],6:[function(t,e,n){\"use strict\";var r=t(\"./common\"),i=t(\"./exception\"),o=t(\"./schema/default_full\"),s=t(\"./schema/default_safe\"),a=Object.prototype.toString,c=Object.prototype.hasOwnProperty,u=9,l=10,p=32,f=33,h=34,d=35,m=37,g=38,y=39,v=42,w=44,b=45,x=58,A=62,_=63,j=64,L=91,C=93,k=96,O=123,E=124,S=125,M={0:\"\\\\0\",7:\"\\\\a\",8:\"\\\\b\",9:\"\\\\t\",10:\"\\\\n\",11:\"\\\\v\",12:\"\\\\f\",13:\"\\\\r\",27:\"\\\\e\",34:'\\\\\"',92:\"\\\\\\\\\",133:\"\\\\N\",160:\"\\\\_\",8232:\"\\\\L\",8233:\"\\\\P\"},I=[\"y\",\"Y\",\"yes\",\"Yes\",\"YES\",\"on\",\"On\",\"ON\",\"n\",\"N\",\"no\",\"No\",\"NO\",\"off\",\"Off\",\"OFF\"];function F(t){var e,n,o;if(e=t.toString(16).toUpperCase(),t<=255)n=\"x\",o=2;else if(t<=65535)n=\"u\",o=4;else{if(!(t<=4294967295))throw new i(\"code point within a string may not be greater than 0xFFFFFFFF\");n=\"U\",o=8}return\"\\\\\"+n+r.repeat(\"0\",o-e.length)+e}function T(t){this.schema=t.schema||o,this.indent=Math.max(1,t.indent||2),this.noArrayIndent=t.noArrayIndent||!1,this.skipInvalid=t.skipInvalid||!1,this.flowLevel=r.isNothing(t.flowLevel)?-1:t.flowLevel,this.styleMap=function(t,e){var n,r,i,o,s,a,u;if(null===e)return{};for(n={},i=0,o=(r=Object.keys(e)).length;i<o;i+=1)s=r[i],a=String(e[s]),\"!!\"===s.slice(0,2)&&(s=\"tag:yaml.org,2002:\"+s.slice(2)),(u=t.compiledTypeMap.fallback[s])&&c.call(u.styleAliases,a)&&(a=u.styleAliases[a]),n[s]=a;return n}(this.schema,t.styles||null),this.sortKeys=t.sortKeys||!1,this.lineWidth=t.lineWidth||80,this.noRefs=t.noRefs||!1,this.noCompatMode=t.noCompatMode||!1,this.condenseFlow=t.condenseFlow||!1,this.implicitTypes=this.schema.compiledImplicit,this.explicitTypes=this.schema.compiledExplicit,this.tag=null,this.result=\"\",this.duplicates=[],this.usedDuplicates=null}function N(t,e){for(var n,i=r.repeat(\" \",e),o=0,s=-1,a=\"\",c=t.length;o<c;)-1===(s=t.indexOf(\"\\n\",o))?(n=t.slice(o),o=c):(n=t.slice(o,s+1),o=s+1),n.length&&\"\\n\"!==n&&(a+=i),a+=n;return a}function D(t,e){return\"\\n\"+r.repeat(\" \",t.indent*e)}function $(t){return t===p||t===u}function P(t){return t>=32&&t<=126||t>=161&&t<=55295&&8232!==t&&8233!==t||t>=57344&&t<=65533&&65279!==t||t>=65536&&t<=1114111}function R(t){return P(t)&&65279!==t&&t!==w&&t!==L&&t!==C&&t!==O&&t!==S&&t!==x&&t!==d}function U(t){return/^\\n* /.test(t)}var q=1,z=2,H=3,Y=4,B=5;function V(t,e,n,r,i){var o,s,a,c=!1,u=!1,p=-1!==r,M=-1,I=P(a=t.charCodeAt(0))&&65279!==a&&!$(a)&&a!==b&&a!==_&&a!==x&&a!==w&&a!==L&&a!==C&&a!==O&&a!==S&&a!==d&&a!==g&&a!==v&&a!==f&&a!==E&&a!==A&&a!==y&&a!==h&&a!==m&&a!==j&&a!==k&&!$(t.charCodeAt(t.length-1));if(e)for(o=0;o<t.length;o++){if(!P(s=t.charCodeAt(o)))return B;I=I&&R(s)}else{for(o=0;o<t.length;o++){if((s=t.charCodeAt(o))===l)c=!0,p&&(u=u||o-M-1>r&&\" \"!==t[M+1],M=o);else if(!P(s))return B;I=I&&R(s)}u=u||p&&o-M-1>r&&\" \"!==t[M+1]}return c||u?n>9&&U(t)?B:u?Y:H:I&&!i(t)?q:z}function W(t,e,n,r){t.dump=function(){if(0===e.length)return\"''\";if(!t.noCompatMode&&-1!==I.indexOf(e))return\"'\"+e+\"'\";var o=t.indent*Math.max(1,n),s=-1===t.lineWidth?-1:Math.max(Math.min(t.lineWidth,40),t.lineWidth-o),a=r||t.flowLevel>-1&&n>=t.flowLevel;switch(V(e,a,t.indent,s,(function(e){return function(t,e){var n,r;for(n=0,r=t.implicitTypes.length;n<r;n+=1)if(t.implicitTypes[n].resolve(e))return!0;return!1}(t,e)}))){case q:return e;case z:return\"'\"+e.replace(/'/g,\"''\")+\"'\";case H:return\"|\"+K(e,t.indent)+G(N(e,o));case Y:return\">\"+K(e,t.indent)+G(N(function(t,e){var n,r,i=/(\\n+)([^\\n]*)/g,o=function(){var n=t.indexOf(\"\\n\");return n=-1!==n?n:t.length,i.lastIndex=n,Z(t.slice(0,n),e)}(),s=\"\\n\"===t[0]||\" \"===t[0];for(;r=i.exec(t);){var a=r[1],c=r[2];n=\" \"===c[0],o+=a+(s||n||\"\"===c?\"\":\"\\n\")+Z(c,e),s=n}return o}(e,s),o));case B:return'\"'+function(t){for(var e,n,r,i=\"\",o=0;o<t.length;o++)(e=t.charCodeAt(o))>=55296&&e<=56319&&(n=t.charCodeAt(o+1))>=56320&&n<=57343?(i+=F(1024*(e-55296)+n-56320+65536),o++):i+=!(r=M[e])&&P(e)?t[o]:r||F(e);return i}(e)+'\"';default:throw new i(\"impossible error: invalid scalar style\")}}()}function K(t,e){var n=U(t)?String(e):\"\",r=\"\\n\"===t[t.length-1];return n+(r&&(\"\\n\"===t[t.length-2]||\"\\n\"===t)?\"+\":r?\"\":\"-\")+\"\\n\"}function G(t){return\"\\n\"===t[t.length-1]?t.slice(0,-1):t}function Z(t,e){if(\"\"===t||\" \"===t[0])return t;for(var n,r,i=/ [^ ]/g,o=0,s=0,a=0,c=\"\";n=i.exec(t);)(a=n.index)-o>e&&(r=s>o?s:a,c+=\"\\n\"+t.slice(o,r),o=r+1),s=a;return c+=\"\\n\",t.length-o>e&&s>o?c+=t.slice(o,s)+\"\\n\"+t.slice(s+1):c+=t.slice(o),c.slice(1)}function J(t,e,n){var r,o,s,u,l,p;for(s=0,u=(o=n?t.explicitTypes:t.implicitTypes).length;s<u;s+=1)if(((l=o[s]).instanceOf||l.predicate)&&(!l.instanceOf||\"object\"===typeof e&&e instanceof l.instanceOf)&&(!l.predicate||l.predicate(e))){if(t.tag=n?l.tag:\"?\",l.represent){if(p=t.styleMap[l.tag]||l.defaultStyle,\"[object Function]\"===a.call(l.represent))r=l.represent(e,p);else{if(!c.call(l.represent,p))throw new i(\"!<\"+l.tag+'> tag resolver accepts not \"'+p+'\" style');r=l.represent[p](e,p)}t.dump=r}return!0}return!1}function Q(t,e,n,r,o,s){t.tag=null,t.dump=n,J(t,n,!1)||J(t,n,!0);var c=a.call(t.dump);r&&(r=t.flowLevel<0||t.flowLevel>e);var u,p,f=\"[object Object]\"===c||\"[object Array]\"===c;if(f&&(p=-1!==(u=t.duplicates.indexOf(n))),(null!==t.tag&&\"?\"!==t.tag||p||2!==t.indent&&e>0)&&(o=!1),p&&t.usedDuplicates[u])t.dump=\"*ref_\"+u;else{if(f&&p&&!t.usedDuplicates[u]&&(t.usedDuplicates[u]=!0),\"[object Object]\"===c)r&&0!==Object.keys(t.dump).length?(!function(t,e,n,r){var o,s,a,c,u,p,f=\"\",h=t.tag,d=Object.keys(n);if(!0===t.sortKeys)d.sort();else if(\"function\"===typeof t.sortKeys)d.sort(t.sortKeys);else if(t.sortKeys)throw new i(\"sortKeys must be a boolean or a function\");for(o=0,s=d.length;o<s;o+=1)p=\"\",r&&0===o||(p+=D(t,e)),c=n[a=d[o]],Q(t,e+1,a,!0,!0,!0)&&((u=null!==t.tag&&\"?\"!==t.tag||t.dump&&t.dump.length>1024)&&(t.dump&&l===t.dump.charCodeAt(0)?p+=\"?\":p+=\"? \"),p+=t.dump,u&&(p+=D(t,e)),Q(t,e+1,c,!0,u)&&(t.dump&&l===t.dump.charCodeAt(0)?p+=\":\":p+=\": \",f+=p+=t.dump));t.tag=h,t.dump=f||\"{}\"}(t,e,t.dump,o),p&&(t.dump=\"&ref_\"+u+t.dump)):(!function(t,e,n){var r,i,o,s,a,c=\"\",u=t.tag,l=Object.keys(n);for(r=0,i=l.length;r<i;r+=1)a=t.condenseFlow?'\"':\"\",0!==r&&(a+=\", \"),s=n[o=l[r]],Q(t,e,o,!1,!1)&&(t.dump.length>1024&&(a+=\"? \"),a+=t.dump+(t.condenseFlow?'\"':\"\")+\":\"+(t.condenseFlow?\"\":\" \"),Q(t,e,s,!1,!1)&&(c+=a+=t.dump));t.tag=u,t.dump=\"{\"+c+\"}\"}(t,e,t.dump),p&&(t.dump=\"&ref_\"+u+\" \"+t.dump));else if(\"[object Array]\"===c){var h=t.noArrayIndent&&e>0?e-1:e;r&&0!==t.dump.length?(!function(t,e,n,r){var i,o,s=\"\",a=t.tag;for(i=0,o=n.length;i<o;i+=1)Q(t,e+1,n[i],!0,!0)&&(r&&0===i||(s+=D(t,e)),t.dump&&l===t.dump.charCodeAt(0)?s+=\"-\":s+=\"- \",s+=t.dump);t.tag=a,t.dump=s||\"[]\"}(t,h,t.dump,o),p&&(t.dump=\"&ref_\"+u+t.dump)):(!function(t,e,n){var r,i,o=\"\",s=t.tag;for(r=0,i=n.length;r<i;r+=1)Q(t,e,n[r],!1,!1)&&(0!==r&&(o+=\",\"+(t.condenseFlow?\"\":\" \")),o+=t.dump);t.tag=s,t.dump=\"[\"+o+\"]\"}(t,h,t.dump),p&&(t.dump=\"&ref_\"+u+\" \"+t.dump))}else{if(\"[object String]\"!==c){if(t.skipInvalid)return!1;throw new i(\"unacceptable kind of an object to dump \"+c)}\"?\"!==t.tag&&W(t,t.dump,e,s)}null!==t.tag&&\"?\"!==t.tag&&(t.dump=\"!<\"+t.tag+\"> \"+t.dump)}return!0}function X(t,e){var n,r,i=[],o=[];for(tt(t,i,o),n=0,r=o.length;n<r;n+=1)e.duplicates.push(i[o[n]]);e.usedDuplicates=new Array(r)}function tt(t,e,n){var r,i,o;if(null!==t&&\"object\"===typeof t)if(-1!==(i=e.indexOf(t)))-1===n.indexOf(i)&&n.push(i);else if(e.push(t),Array.isArray(t))for(i=0,o=t.length;i<o;i+=1)tt(t[i],e,n);else for(i=0,o=(r=Object.keys(t)).length;i<o;i+=1)tt(t[r[i]],e,n)}function et(t,e){var n=new T(e=e||{});return n.noRefs||X(t,n),Q(n,0,t,!0,!0)?n.dump+\"\\n\":\"\"}e.exports.dump=et,e.exports.safeDump=function(t,e){return et(t,r.extend({schema:s},e))}},{\"./common\":5,\"./exception\":7,\"./schema/default_full\":12,\"./schema/default_safe\":13}],7:[function(t,e,n){\"use strict\";function r(t,e){Error.call(this),this.name=\"YAMLException\",this.reason=t,this.mark=e,this.message=(this.reason||\"(unknown reason)\")+(this.mark?\" \"+this.mark.toString():\"\"),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack||\"\"}r.prototype=Object.create(Error.prototype),r.prototype.constructor=r,r.prototype.toString=function(t){var e=this.name+\": \";return e+=this.reason||\"(unknown reason)\",!t&&this.mark&&(e+=\" \"+this.mark.toString()),e},e.exports=r},{}],8:[function(t,e,n){\"use strict\";var r=t(\"./common\"),i=t(\"./exception\"),o=t(\"./mark\"),s=t(\"./schema/default_safe\"),a=t(\"./schema/default_full\"),c=Object.prototype.hasOwnProperty,u=1,l=2,p=3,f=4,h=1,d=2,m=3,g=/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/,y=/[\\x85\\u2028\\u2029]/,v=/[,\\[\\]\\{\\}]/,w=/^(?:!|!!|![a-z\\-]+!)$/i,b=/^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;function x(t){return 10===t||13===t}function A(t){return 9===t||32===t}function _(t){return 9===t||32===t||10===t||13===t}function j(t){return 44===t||91===t||93===t||123===t||125===t}function L(t){var e;return t>=48&&t<=57?t-48:(e=32|t)>=97&&e<=102?e-97+10:-1}function C(t){return 48===t?\"\\0\":97===t?\"\\x07\":98===t?\"\\b\":116===t||9===t?\"\\t\":110===t?\"\\n\":118===t?\"\\v\":102===t?\"\\f\":114===t?\"\\r\":101===t?\"\\x1b\":32===t?\" \":34===t?'\"':47===t?\"/\":92===t?\"\\\\\":78===t?\"\\x85\":95===t?\"\\xa0\":76===t?\"\\u2028\":80===t?\"\\u2029\":\"\"}function k(t){return t<=65535?String.fromCharCode(t):String.fromCharCode(55296+(t-65536>>10),56320+(t-65536&1023))}for(var O=new Array(256),E=new Array(256),S=0;S<256;S++)O[S]=C(S)?1:0,E[S]=C(S);function M(t,e){this.input=t,this.filename=e.filename||null,this.schema=e.schema||a,this.onWarning=e.onWarning||null,this.legacy=e.legacy||!1,this.json=e.json||!1,this.listener=e.listener||null,this.implicitTypes=this.schema.compiledImplicit,this.typeMap=this.schema.compiledTypeMap,this.length=t.length,this.position=0,this.line=0,this.lineStart=0,this.lineIndent=0,this.documents=[]}function I(t,e){return new i(e,new o(t.filename,t.input,t.position,t.line,t.position-t.lineStart))}function F(t,e){throw I(t,e)}function T(t,e){t.onWarning&&t.onWarning.call(null,I(t,e))}var N={YAML:function(t,e,n){var r,i,o;null!==t.version&&F(t,\"duplication of %YAML directive\"),1!==n.length&&F(t,\"YAML directive accepts exactly one argument\"),null===(r=/^([0-9]+)\\.([0-9]+)$/.exec(n[0]))&&F(t,\"ill-formed argument of the YAML directive\"),i=parseInt(r[1],10),o=parseInt(r[2],10),1!==i&&F(t,\"unacceptable YAML version of the document\"),t.version=n[0],t.checkLineBreaks=o<2,1!==o&&2!==o&&T(t,\"unsupported YAML version of the document\")},TAG:function(t,e,n){var r,i;2!==n.length&&F(t,\"TAG directive accepts exactly two arguments\"),r=n[0],i=n[1],w.test(r)||F(t,\"ill-formed tag handle (first argument) of the TAG directive\"),c.call(t.tagMap,r)&&F(t,'there is a previously declared suffix for \"'+r+'\" tag handle'),b.test(i)||F(t,\"ill-formed tag prefix (second argument) of the TAG directive\"),t.tagMap[r]=i}};function D(t,e,n,r){var i,o,s,a;if(e<n){if(a=t.input.slice(e,n),r)for(i=0,o=a.length;i<o;i+=1)9===(s=a.charCodeAt(i))||s>=32&&s<=1114111||F(t,\"expected valid JSON character\");else g.test(a)&&F(t,\"the stream contains non-printable characters\");t.result+=a}}function $(t,e,n,i){var o,s,a,u;for(r.isObject(n)||F(t,\"cannot merge mappings; the provided source object is unacceptable\"),a=0,u=(o=Object.keys(n)).length;a<u;a+=1)s=o[a],c.call(e,s)||(e[s]=n[s],i[s]=!0)}function P(t,e,n,r,i,o,s,a){var u,l;if(i=String(i),null===e&&(e={}),\"tag:yaml.org,2002:merge\"===r)if(Array.isArray(o))for(u=0,l=o.length;u<l;u+=1)$(t,e,o[u],n);else $(t,e,o,n);else t.json||c.call(n,i)||!c.call(e,i)||(t.line=s||t.line,t.position=a||t.position,F(t,\"duplicated mapping key\")),e[i]=o,delete n[i];return e}function R(t){var e;10===(e=t.input.charCodeAt(t.position))?t.position++:13===e?(t.position++,10===t.input.charCodeAt(t.position)&&t.position++):F(t,\"a line break is expected\"),t.line+=1,t.lineStart=t.position}function U(t,e,n){for(var r=0,i=t.input.charCodeAt(t.position);0!==i;){for(;A(i);)i=t.input.charCodeAt(++t.position);if(e&&35===i)do{i=t.input.charCodeAt(++t.position)}while(10!==i&&13!==i&&0!==i);if(!x(i))break;for(R(t),i=t.input.charCodeAt(t.position),r++,t.lineIndent=0;32===i;)t.lineIndent++,i=t.input.charCodeAt(++t.position)}return-1!==n&&0!==r&&t.lineIndent<n&&T(t,\"deficient indentation\"),r}function q(t){var e,n=t.position;return!(45!==(e=t.input.charCodeAt(n))&&46!==e||e!==t.input.charCodeAt(n+1)||e!==t.input.charCodeAt(n+2)||(n+=3,0!==(e=t.input.charCodeAt(n))&&!_(e)))}function z(t,e){1===e?t.result+=\" \":e>1&&(t.result+=r.repeat(\"\\n\",e-1))}function H(t,e){var n,r,i=t.tag,o=t.anchor,s=[],a=!1;for(null!==t.anchor&&(t.anchorMap[t.anchor]=s),r=t.input.charCodeAt(t.position);0!==r&&45===r&&_(t.input.charCodeAt(t.position+1));)if(a=!0,t.position++,U(t,!0,-1)&&t.lineIndent<=e)s.push(null),r=t.input.charCodeAt(t.position);else if(n=t.line,V(t,e,p,!1,!0),s.push(t.result),U(t,!0,-1),r=t.input.charCodeAt(t.position),(t.line===n||t.lineIndent>e)&&0!==r)F(t,\"bad indentation of a sequence entry\");else if(t.lineIndent<e)break;return!!a&&(t.tag=i,t.anchor=o,t.kind=\"sequence\",t.result=s,!0)}function Y(t){var e,n,r,i,o=!1,s=!1;if(33!==(i=t.input.charCodeAt(t.position)))return!1;if(null!==t.tag&&F(t,\"duplication of a tag property\"),60===(i=t.input.charCodeAt(++t.position))?(o=!0,i=t.input.charCodeAt(++t.position)):33===i?(s=!0,n=\"!!\",i=t.input.charCodeAt(++t.position)):n=\"!\",e=t.position,o){do{i=t.input.charCodeAt(++t.position)}while(0!==i&&62!==i);t.position<t.length?(r=t.input.slice(e,t.position),i=t.input.charCodeAt(++t.position)):F(t,\"unexpected end of the stream within a verbatim tag\")}else{for(;0!==i&&!_(i);)33===i&&(s?F(t,\"tag suffix cannot contain exclamation marks\"):(n=t.input.slice(e-1,t.position+1),w.test(n)||F(t,\"named tag handle cannot contain such characters\"),s=!0,e=t.position+1)),i=t.input.charCodeAt(++t.position);r=t.input.slice(e,t.position),v.test(r)&&F(t,\"tag suffix cannot contain flow indicator characters\")}return r&&!b.test(r)&&F(t,\"tag name cannot contain such characters: \"+r),o?t.tag=r:c.call(t.tagMap,n)?t.tag=t.tagMap[n]+r:\"!\"===n?t.tag=\"!\"+r:\"!!\"===n?t.tag=\"tag:yaml.org,2002:\"+r:F(t,'undeclared tag handle \"'+n+'\"'),!0}function B(t){var e,n;if(38!==(n=t.input.charCodeAt(t.position)))return!1;for(null!==t.anchor&&F(t,\"duplication of an anchor property\"),n=t.input.charCodeAt(++t.position),e=t.position;0!==n&&!_(n)&&!j(n);)n=t.input.charCodeAt(++t.position);return t.position===e&&F(t,\"name of an anchor node must contain at least one character\"),t.anchor=t.input.slice(e,t.position),!0}function V(t,e,n,i,o){var s,a,g,y,v,w,b,C,S=1,M=!1,I=!1;if(null!==t.listener&&t.listener(\"open\",t),t.tag=null,t.anchor=null,t.kind=null,t.result=null,s=a=g=f===n||p===n,i&&U(t,!0,-1)&&(M=!0,t.lineIndent>e?S=1:t.lineIndent===e?S=0:t.lineIndent<e&&(S=-1)),1===S)for(;Y(t)||B(t);)U(t,!0,-1)?(M=!0,g=s,t.lineIndent>e?S=1:t.lineIndent===e?S=0:t.lineIndent<e&&(S=-1)):g=!1;if(g&&(g=M||o),1!==S&&f!==n||(b=u===n||l===n?e:e+1,C=t.position-t.lineStart,1===S?g&&(H(t,C)||function(t,e,n){var r,i,o,s,a,c=t.tag,u=t.anchor,p={},h={},d=null,m=null,g=null,y=!1,v=!1;for(null!==t.anchor&&(t.anchorMap[t.anchor]=p),a=t.input.charCodeAt(t.position);0!==a;){if(r=t.input.charCodeAt(t.position+1),o=t.line,s=t.position,63!==a&&58!==a||!_(r)){if(!V(t,n,l,!1,!0))break;if(t.line===o){for(a=t.input.charCodeAt(t.position);A(a);)a=t.input.charCodeAt(++t.position);if(58===a)_(a=t.input.charCodeAt(++t.position))||F(t,\"a whitespace character is expected after the key-value separator within a block mapping\"),y&&(P(t,p,h,d,m,null),d=m=g=null),v=!0,y=!1,i=!1,d=t.tag,m=t.result;else{if(!v)return t.tag=c,t.anchor=u,!0;F(t,\"can not read an implicit mapping pair; a colon is missed\")}}else{if(!v)return t.tag=c,t.anchor=u,!0;F(t,\"can not read a block mapping entry; a multiline key may not be an implicit key\")}}else 63===a?(y&&(P(t,p,h,d,m,null),d=m=g=null),v=!0,y=!0,i=!0):y?(y=!1,i=!0):F(t,\"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line\"),t.position+=1,a=r;if((t.line===o||t.lineIndent>e)&&(V(t,e,f,!0,i)&&(y?m=t.result:g=t.result),y||(P(t,p,h,d,m,g,o,s),d=m=g=null),U(t,!0,-1),a=t.input.charCodeAt(t.position)),t.lineIndent>e&&0!==a)F(t,\"bad indentation of a mapping entry\");else if(t.lineIndent<e)break}return y&&P(t,p,h,d,m,null),v&&(t.tag=c,t.anchor=u,t.kind=\"mapping\",t.result=p),v}(t,C,b))||function(t,e){var n,r,i,o,s,a,c,l,p,f,h=!0,d=t.tag,m=t.anchor,g={};if(91===(f=t.input.charCodeAt(t.position)))i=93,a=!1,r=[];else{if(123!==f)return!1;i=125,a=!0,r={}}for(null!==t.anchor&&(t.anchorMap[t.anchor]=r),f=t.input.charCodeAt(++t.position);0!==f;){if(U(t,!0,e),(f=t.input.charCodeAt(t.position))===i)return t.position++,t.tag=d,t.anchor=m,t.kind=a?\"mapping\":\"sequence\",t.result=r,!0;h||F(t,\"missed comma between flow collection entries\"),p=null,o=s=!1,63===f&&_(t.input.charCodeAt(t.position+1))&&(o=s=!0,t.position++,U(t,!0,e)),n=t.line,V(t,e,u,!1,!0),l=t.tag,c=t.result,U(t,!0,e),f=t.input.charCodeAt(t.position),!s&&t.line!==n||58!==f||(o=!0,f=t.input.charCodeAt(++t.position),U(t,!0,e),V(t,e,u,!1,!0),p=t.result),a?P(t,r,g,l,c,p):o?r.push(P(t,null,g,l,c,p)):r.push(c),U(t,!0,e),44===(f=t.input.charCodeAt(t.position))?(h=!0,f=t.input.charCodeAt(++t.position)):h=!1}F(t,\"unexpected end of the stream within a flow collection\")}(t,b)?I=!0:(a&&function(t,e){var n,i,o,s,a,c=h,u=!1,l=!1,p=e,f=0,g=!1;if(124===(s=t.input.charCodeAt(t.position)))i=!1;else{if(62!==s)return!1;i=!0}for(t.kind=\"scalar\",t.result=\"\";0!==s;)if(43===(s=t.input.charCodeAt(++t.position))||45===s)h===c?c=43===s?m:d:F(t,\"repeat of a chomping mode identifier\");else{if(!((o=(a=s)>=48&&a<=57?a-48:-1)>=0))break;0===o?F(t,\"bad explicit indentation width of a block scalar; it cannot be less than one\"):l?F(t,\"repeat of an indentation width identifier\"):(p=e+o-1,l=!0)}if(A(s)){do{s=t.input.charCodeAt(++t.position)}while(A(s));if(35===s)do{s=t.input.charCodeAt(++t.position)}while(!x(s)&&0!==s)}for(;0!==s;){for(R(t),t.lineIndent=0,s=t.input.charCodeAt(t.position);(!l||t.lineIndent<p)&&32===s;)t.lineIndent++,s=t.input.charCodeAt(++t.position);if(!l&&t.lineIndent>p&&(p=t.lineIndent),x(s))f++;else{if(t.lineIndent<p){c===m?t.result+=r.repeat(\"\\n\",u?1+f:f):c===h&&u&&(t.result+=\"\\n\");break}for(i?A(s)?(g=!0,t.result+=r.repeat(\"\\n\",u?1+f:f)):g?(g=!1,t.result+=r.repeat(\"\\n\",f+1)):0===f?u&&(t.result+=\" \"):t.result+=r.repeat(\"\\n\",f):t.result+=r.repeat(\"\\n\",u?1+f:f),u=!0,l=!0,f=0,n=t.position;!x(s)&&0!==s;)s=t.input.charCodeAt(++t.position);D(t,n,t.position,!1)}}return!0}(t,b)||function(t,e){var n,r,i;if(39!==(n=t.input.charCodeAt(t.position)))return!1;for(t.kind=\"scalar\",t.result=\"\",t.position++,r=i=t.position;0!==(n=t.input.charCodeAt(t.position));)if(39===n){if(D(t,r,t.position,!0),39!==(n=t.input.charCodeAt(++t.position)))return!0;r=t.position,t.position++,i=t.position}else x(n)?(D(t,r,i,!0),z(t,U(t,!1,e)),r=i=t.position):t.position===t.lineStart&&q(t)?F(t,\"unexpected end of the document within a single quoted scalar\"):(t.position++,i=t.position);F(t,\"unexpected end of the stream within a single quoted scalar\")}(t,b)||function(t,e){var n,r,i,o,s,a,c;if(34!==(a=t.input.charCodeAt(t.position)))return!1;for(t.kind=\"scalar\",t.result=\"\",t.position++,n=r=t.position;0!==(a=t.input.charCodeAt(t.position));){if(34===a)return D(t,n,t.position,!0),t.position++,!0;if(92===a){if(D(t,n,t.position,!0),x(a=t.input.charCodeAt(++t.position)))U(t,!1,e);else if(a<256&&O[a])t.result+=E[a],t.position++;else if((s=120===(c=a)?2:117===c?4:85===c?8:0)>0){for(i=s,o=0;i>0;i--)(s=L(a=t.input.charCodeAt(++t.position)))>=0?o=(o<<4)+s:F(t,\"expected hexadecimal character\");t.result+=k(o),t.position++}else F(t,\"unknown escape sequence\");n=r=t.position}else x(a)?(D(t,n,r,!0),z(t,U(t,!1,e)),n=r=t.position):t.position===t.lineStart&&q(t)?F(t,\"unexpected end of the document within a double quoted scalar\"):(t.position++,r=t.position)}F(t,\"unexpected end of the stream within a double quoted scalar\")}(t,b)?I=!0:!function(t){var e,n,r;if(42!==(r=t.input.charCodeAt(t.position)))return!1;for(r=t.input.charCodeAt(++t.position),e=t.position;0!==r&&!_(r)&&!j(r);)r=t.input.charCodeAt(++t.position);return t.position===e&&F(t,\"name of an alias node must contain at least one character\"),n=t.input.slice(e,t.position),t.anchorMap.hasOwnProperty(n)||F(t,'unidentified alias \"'+n+'\"'),t.result=t.anchorMap[n],U(t,!0,-1),!0}(t)?function(t,e,n){var r,i,o,s,a,c,u,l,p=t.kind,f=t.result;if(_(l=t.input.charCodeAt(t.position))||j(l)||35===l||38===l||42===l||33===l||124===l||62===l||39===l||34===l||37===l||64===l||96===l)return!1;if((63===l||45===l)&&(_(r=t.input.charCodeAt(t.position+1))||n&&j(r)))return!1;for(t.kind=\"scalar\",t.result=\"\",i=o=t.position,s=!1;0!==l;){if(58===l){if(_(r=t.input.charCodeAt(t.position+1))||n&&j(r))break}else if(35===l){if(_(t.input.charCodeAt(t.position-1)))break}else{if(t.position===t.lineStart&&q(t)||n&&j(l))break;if(x(l)){if(a=t.line,c=t.lineStart,u=t.lineIndent,U(t,!1,-1),t.lineIndent>=e){s=!0,l=t.input.charCodeAt(t.position);continue}t.position=o,t.line=a,t.lineStart=c,t.lineIndent=u;break}}s&&(D(t,i,o,!1),z(t,t.line-a),i=o=t.position,s=!1),A(l)||(o=t.position+1),l=t.input.charCodeAt(++t.position)}return D(t,i,o,!1),!!t.result||(t.kind=p,t.result=f,!1)}(t,b,u===n)&&(I=!0,null===t.tag&&(t.tag=\"?\")):(I=!0,null===t.tag&&null===t.anchor||F(t,\"alias node should not have any properties\")),null!==t.anchor&&(t.anchorMap[t.anchor]=t.result)):0===S&&(I=g&&H(t,C))),null!==t.tag&&\"!\"!==t.tag)if(\"?\"===t.tag){for(y=0,v=t.implicitTypes.length;y<v;y+=1)if((w=t.implicitTypes[y]).resolve(t.result)){t.result=w.construct(t.result),t.tag=w.tag,null!==t.anchor&&(t.anchorMap[t.anchor]=t.result);break}}else c.call(t.typeMap[t.kind||\"fallback\"],t.tag)?(w=t.typeMap[t.kind||\"fallback\"][t.tag],null!==t.result&&w.kind!==t.kind&&F(t,\"unacceptable node kind for !<\"+t.tag+'> tag; it should be \"'+w.kind+'\", not \"'+t.kind+'\"'),w.resolve(t.result)?(t.result=w.construct(t.result),null!==t.anchor&&(t.anchorMap[t.anchor]=t.result)):F(t,\"cannot resolve a node with !<\"+t.tag+\"> explicit tag\")):F(t,\"unknown tag !<\"+t.tag+\">\");return null!==t.listener&&t.listener(\"close\",t),null!==t.tag||null!==t.anchor||I}function W(t){var e,n,r,i,o=t.position,s=!1;for(t.version=null,t.checkLineBreaks=t.legacy,t.tagMap={},t.anchorMap={};0!==(i=t.input.charCodeAt(t.position))&&(U(t,!0,-1),i=t.input.charCodeAt(t.position),!(t.lineIndent>0||37!==i));){for(s=!0,i=t.input.charCodeAt(++t.position),e=t.position;0!==i&&!_(i);)i=t.input.charCodeAt(++t.position);for(r=[],(n=t.input.slice(e,t.position)).length<1&&F(t,\"directive name must not be less than one character in length\");0!==i;){for(;A(i);)i=t.input.charCodeAt(++t.position);if(35===i){do{i=t.input.charCodeAt(++t.position)}while(0!==i&&!x(i));break}if(x(i))break;for(e=t.position;0!==i&&!_(i);)i=t.input.charCodeAt(++t.position);r.push(t.input.slice(e,t.position))}0!==i&&R(t),c.call(N,n)?N[n](t,n,r):T(t,'unknown document directive \"'+n+'\"')}U(t,!0,-1),0===t.lineIndent&&45===t.input.charCodeAt(t.position)&&45===t.input.charCodeAt(t.position+1)&&45===t.input.charCodeAt(t.position+2)?(t.position+=3,U(t,!0,-1)):s&&F(t,\"directives end mark is expected\"),V(t,t.lineIndent-1,f,!1,!0),U(t,!0,-1),t.checkLineBreaks&&y.test(t.input.slice(o,t.position))&&T(t,\"non-ASCII line breaks are interpreted as content\"),t.documents.push(t.result),t.position===t.lineStart&&q(t)?46===t.input.charCodeAt(t.position)&&(t.position+=3,U(t,!0,-1)):t.position<t.length-1&&F(t,\"end of the stream or a document separator is expected\")}function K(t,e){e=e||{},0!==(t=String(t)).length&&(10!==t.charCodeAt(t.length-1)&&13!==t.charCodeAt(t.length-1)&&(t+=\"\\n\"),65279===t.charCodeAt(0)&&(t=t.slice(1)));var n=new M(t,e);for(n.input+=\"\\0\";32===n.input.charCodeAt(n.position);)n.lineIndent+=1,n.position+=1;for(;n.position<n.length-1;)W(n);return n.documents}function G(t,e,n){var r,i,o=K(t,n);if(\"function\"!==typeof e)return o;for(r=0,i=o.length;r<i;r+=1)e(o[r])}function Z(t,e){var n=K(t,e);if(0!==n.length){if(1===n.length)return n[0];throw new i(\"expected a single document in the stream, but found more\")}}e.exports.loadAll=G,e.exports.load=Z,e.exports.safeLoadAll=function(t,e,n){if(\"function\"!==typeof e)return G(t,r.extend({schema:s},n));G(t,e,r.extend({schema:s},n))},e.exports.safeLoad=function(t,e){return Z(t,r.extend({schema:s},e))}},{\"./common\":5,\"./exception\":7,\"./mark\":9,\"./schema/default_full\":12,\"./schema/default_safe\":13}],9:[function(t,e,n){\"use strict\";var r=t(\"./common\");function i(t,e,n,r,i){this.name=t,this.buffer=e,this.position=n,this.line=r,this.column=i}i.prototype.getSnippet=function(t,e){var n,i,o,s,a;if(!this.buffer)return null;for(t=t||4,e=e||75,n=\"\",i=this.position;i>0&&-1===\"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(i-1));)if(i-=1,this.position-i>e/2-1){n=\" ... \",i+=5;break}for(o=\"\",s=this.position;s<this.buffer.length&&-1===\"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(s));)if((s+=1)-this.position>e/2-1){o=\" ... \",s-=5;break}return a=this.buffer.slice(i,s),r.repeat(\" \",t)+n+a+o+\"\\n\"+r.repeat(\" \",t+this.position-i+n.length)+\"^\"},i.prototype.toString=function(t){var e,n=\"\";return this.name&&(n+='in \"'+this.name+'\" '),n+=\"at line \"+(this.line+1)+\", column \"+(this.column+1),t||(e=this.getSnippet())&&(n+=\":\\n\"+e),n},e.exports=i},{\"./common\":5}],10:[function(t,e,n){\"use strict\";var r=t(\"./common\"),i=t(\"./exception\"),o=t(\"./type\");function s(t,e,n){var r=[];return t.include.forEach((function(t){n=s(t,e,n)})),t[e].forEach((function(t){n.forEach((function(e,n){e.tag===t.tag&&e.kind===t.kind&&r.push(n)})),n.push(t)})),n.filter((function(t,e){return-1===r.indexOf(e)}))}function a(t){this.include=t.include||[],this.implicit=t.implicit||[],this.explicit=t.explicit||[],this.implicit.forEach((function(t){if(t.loadKind&&\"scalar\"!==t.loadKind)throw new i(\"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.\")})),this.compiledImplicit=s(this,\"implicit\",[]),this.compiledExplicit=s(this,\"explicit\",[]),this.compiledTypeMap=function(){var t,e,n={scalar:{},sequence:{},mapping:{},fallback:{}};function r(t){n[t.kind][t.tag]=n.fallback[t.tag]=t}for(t=0,e=arguments.length;t<e;t+=1)arguments[t].forEach(r);return n}(this.compiledImplicit,this.compiledExplicit)}a.DEFAULT=null,a.create=function(){var t,e;switch(arguments.length){case 1:t=a.DEFAULT,e=arguments[0];break;case 2:t=arguments[0],e=arguments[1];break;default:throw new i(\"Wrong number of arguments for Schema.create function\")}if(t=r.toArray(t),e=r.toArray(e),!t.every((function(t){return t instanceof a})))throw new i(\"Specified list of super schemas (or a single Schema object) contains a non-Schema object.\");if(!e.every((function(t){return t instanceof o})))throw new i(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");return new a({include:t,explicit:e})},e.exports=a},{\"./common\":5,\"./exception\":7,\"./type\":16}],11:[function(t,e,n){\"use strict\";var r=t(\"../schema\");e.exports=new r({include:[t(\"./json\")]})},{\"../schema\":10,\"./json\":15}],12:[function(t,e,n){\"use strict\";var r=t(\"../schema\");e.exports=r.DEFAULT=new r({include:[t(\"./default_safe\")],explicit:[t(\"../type/js/undefined\"),t(\"../type/js/regexp\"),t(\"../type/js/function\")]})},{\"../schema\":10,\"../type/js/function\":21,\"../type/js/regexp\":22,\"../type/js/undefined\":23,\"./default_safe\":13}],13:[function(t,e,n){\"use strict\";var r=t(\"../schema\");e.exports=new r({include:[t(\"./core\")],implicit:[t(\"../type/timestamp\"),t(\"../type/merge\")],explicit:[t(\"../type/binary\"),t(\"../type/omap\"),t(\"../type/pairs\"),t(\"../type/set\")]})},{\"../schema\":10,\"../type/binary\":17,\"../type/merge\":25,\"../type/omap\":27,\"../type/pairs\":28,\"../type/set\":30,\"../type/timestamp\":32,\"./core\":11}],14:[function(t,e,n){\"use strict\";var r=t(\"../schema\");e.exports=new r({explicit:[t(\"../type/str\"),t(\"../type/seq\"),t(\"../type/map\")]})},{\"../schema\":10,\"../type/map\":24,\"../type/seq\":29,\"../type/str\":31}],15:[function(t,e,n){\"use strict\";var r=t(\"../schema\");e.exports=new r({include:[t(\"./failsafe\")],implicit:[t(\"../type/null\"),t(\"../type/bool\"),t(\"../type/int\"),t(\"../type/float\")]})},{\"../schema\":10,\"../type/bool\":18,\"../type/float\":19,\"../type/int\":20,\"../type/null\":26,\"./failsafe\":14}],16:[function(t,e,n){\"use strict\";var r=t(\"./exception\"),i=[\"kind\",\"resolve\",\"construct\",\"instanceOf\",\"predicate\",\"represent\",\"defaultStyle\",\"styleAliases\"],o=[\"scalar\",\"sequence\",\"mapping\"];e.exports=function(t,e){if(e=e||{},Object.keys(e).forEach((function(e){if(-1===i.indexOf(e))throw new r('Unknown option \"'+e+'\" is met in definition of \"'+t+'\" YAML type.')})),this.tag=t,this.kind=e.kind||null,this.resolve=e.resolve||function(){return!0},this.construct=e.construct||function(t){return t},this.instanceOf=e.instanceOf||null,this.predicate=e.predicate||null,this.represent=e.represent||null,this.defaultStyle=e.defaultStyle||null,this.styleAliases=function(t){var e={};return null!==t&&Object.keys(t).forEach((function(n){t[n].forEach((function(t){e[String(t)]=n}))})),e}(e.styleAliases||null),-1===o.indexOf(this.kind))throw new r('Unknown kind \"'+this.kind+'\" is specified for \"'+t+'\" YAML type.')}},{\"./exception\":7}],17:[function(t,e,n){\"use strict\";var r;try{r=t(\"buffer\").Buffer}catch(s){}var i=t(\"../type\"),o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r\";e.exports=new i(\"tag:yaml.org,2002:binary\",{kind:\"scalar\",resolve:function(t){if(null===t)return!1;var e,n,r=0,i=t.length,s=o;for(n=0;n<i;n++)if(!((e=s.indexOf(t.charAt(n)))>64)){if(e<0)return!1;r+=6}return r%8===0},construct:function(t){var e,n,i=t.replace(/[\\r\\n=]/g,\"\"),s=i.length,a=o,c=0,u=[];for(e=0;e<s;e++)e%4===0&&e&&(u.push(c>>16&255),u.push(c>>8&255),u.push(255&c)),c=c<<6|a.indexOf(i.charAt(e));return 0===(n=s%4*6)?(u.push(c>>16&255),u.push(c>>8&255),u.push(255&c)):18===n?(u.push(c>>10&255),u.push(c>>2&255)):12===n&&u.push(c>>4&255),r?r.from?r.from(u):new r(u):u},predicate:function(t){return r&&r.isBuffer(t)},represent:function(t){var e,n,r=\"\",i=0,s=t.length,a=o;for(e=0;e<s;e++)e%3===0&&e&&(r+=a[i>>18&63],r+=a[i>>12&63],r+=a[i>>6&63],r+=a[63&i]),i=(i<<8)+t[e];return 0===(n=s%3)?(r+=a[i>>18&63],r+=a[i>>12&63],r+=a[i>>6&63],r+=a[63&i]):2===n?(r+=a[i>>10&63],r+=a[i>>4&63],r+=a[i<<2&63],r+=a[64]):1===n&&(r+=a[i>>2&63],r+=a[i<<4&63],r+=a[64],r+=a[64]),r}})},{\"../type\":16}],18:[function(t,e,n){\"use strict\";var r=t(\"../type\");e.exports=new r(\"tag:yaml.org,2002:bool\",{kind:\"scalar\",resolve:function(t){if(null===t)return!1;var e=t.length;return 4===e&&(\"true\"===t||\"True\"===t||\"TRUE\"===t)||5===e&&(\"false\"===t||\"False\"===t||\"FALSE\"===t)},construct:function(t){return\"true\"===t||\"True\"===t||\"TRUE\"===t},predicate:function(t){return\"[object Boolean]\"===Object.prototype.toString.call(t)},represent:{lowercase:function(t){return t?\"true\":\"false\"},uppercase:function(t){return t?\"TRUE\":\"FALSE\"},camelcase:function(t){return t?\"True\":\"False\"}},defaultStyle:\"lowercase\"})},{\"../type\":16}],19:[function(t,e,n){\"use strict\";var r=t(\"../common\"),i=t(\"../type\"),o=new RegExp(\"^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*|[-+]?\\\\.(?:inf|Inf|INF)|\\\\.(?:nan|NaN|NAN))$\");var s=/^[-+]?[0-9]+e/;e.exports=new i(\"tag:yaml.org,2002:float\",{kind:\"scalar\",resolve:function(t){return null!==t&&!(!o.test(t)||\"_\"===t[t.length-1])},construct:function(t){var e,n,r,i;return n=\"-\"===(e=t.replace(/_/g,\"\").toLowerCase())[0]?-1:1,i=[],\"+-\".indexOf(e[0])>=0&&(e=e.slice(1)),\".inf\"===e?1===n?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:\".nan\"===e?NaN:e.indexOf(\":\")>=0?(e.split(\":\").forEach((function(t){i.unshift(parseFloat(t,10))})),e=0,r=1,i.forEach((function(t){e+=t*r,r*=60})),n*e):n*parseFloat(e,10)},predicate:function(t){return\"[object Number]\"===Object.prototype.toString.call(t)&&(t%1!==0||r.isNegativeZero(t))},represent:function(t,e){var n;if(isNaN(t))switch(e){case\"lowercase\":return\".nan\";case\"uppercase\":return\".NAN\";case\"camelcase\":return\".NaN\"}else if(Number.POSITIVE_INFINITY===t)switch(e){case\"lowercase\":return\".inf\";case\"uppercase\":return\".INF\";case\"camelcase\":return\".Inf\"}else if(Number.NEGATIVE_INFINITY===t)switch(e){case\"lowercase\":return\"-.inf\";case\"uppercase\":return\"-.INF\";case\"camelcase\":return\"-.Inf\"}else if(r.isNegativeZero(t))return\"-0.0\";return n=t.toString(10),s.test(n)?n.replace(\"e\",\".e\"):n},defaultStyle:\"lowercase\"})},{\"../common\":5,\"../type\":16}],20:[function(t,e,n){\"use strict\";var r=t(\"../common\"),i=t(\"../type\");function o(t){return t>=48&&t<=55}function s(t){return t>=48&&t<=57}e.exports=new i(\"tag:yaml.org,2002:int\",{kind:\"scalar\",resolve:function(t){if(null===t)return!1;var e,n,r=t.length,i=0,a=!1;if(!r)return!1;if(\"-\"!==(e=t[i])&&\"+\"!==e||(e=t[++i]),\"0\"===e){if(i+1===r)return!0;if(\"b\"===(e=t[++i])){for(i++;i<r;i++)if(\"_\"!==(e=t[i])){if(\"0\"!==e&&\"1\"!==e)return!1;a=!0}return a&&\"_\"!==e}if(\"x\"===e){for(i++;i<r;i++)if(\"_\"!==(e=t[i])){if(!((n=t.charCodeAt(i))>=48&&n<=57||n>=65&&n<=70||n>=97&&n<=102))return!1;a=!0}return a&&\"_\"!==e}for(;i<r;i++)if(\"_\"!==(e=t[i])){if(!o(t.charCodeAt(i)))return!1;a=!0}return a&&\"_\"!==e}if(\"_\"===e)return!1;for(;i<r;i++)if(\"_\"!==(e=t[i])){if(\":\"===e)break;if(!s(t.charCodeAt(i)))return!1;a=!0}return!(!a||\"_\"===e)&&(\":\"!==e||/^(:[0-5]?[0-9])+$/.test(t.slice(i)))},construct:function(t){var e,n,r=t,i=1,o=[];return-1!==r.indexOf(\"_\")&&(r=r.replace(/_/g,\"\")),\"-\"!==(e=r[0])&&\"+\"!==e||(\"-\"===e&&(i=-1),e=(r=r.slice(1))[0]),\"0\"===r?0:\"0\"===e?\"b\"===r[1]?i*parseInt(r.slice(2),2):\"x\"===r[1]?i*parseInt(r,16):i*parseInt(r,8):-1!==r.indexOf(\":\")?(r.split(\":\").forEach((function(t){o.unshift(parseInt(t,10))})),r=0,n=1,o.forEach((function(t){r+=t*n,n*=60})),i*r):i*parseInt(r,10)},predicate:function(t){return\"[object Number]\"===Object.prototype.toString.call(t)&&t%1===0&&!r.isNegativeZero(t)},represent:{binary:function(t){return t>=0?\"0b\"+t.toString(2):\"-0b\"+t.toString(2).slice(1)},octal:function(t){return t>=0?\"0\"+t.toString(8):\"-0\"+t.toString(8).slice(1)},decimal:function(t){return t.toString(10)},hexadecimal:function(t){return t>=0?\"0x\"+t.toString(16).toUpperCase():\"-0x\"+t.toString(16).toUpperCase().slice(1)}},defaultStyle:\"decimal\",styleAliases:{binary:[2,\"bin\"],octal:[8,\"oct\"],decimal:[10,\"dec\"],hexadecimal:[16,\"hex\"]}})},{\"../common\":5,\"../type\":16}],21:[function(t,e,n){\"use strict\";var r;try{r=t(\"esprima\")}catch(o){\"undefined\"!==typeof window&&(r=window.esprima)}var i=t(\"../../type\");e.exports=new i(\"tag:yaml.org,2002:js/function\",{kind:\"scalar\",resolve:function(t){if(null===t)return!1;try{var e=\"(\"+t+\")\",n=r.parse(e,{range:!0});return\"Program\"===n.type&&1===n.body.length&&\"ExpressionStatement\"===n.body[0].type&&(\"ArrowFunctionExpression\"===n.body[0].expression.type||\"FunctionExpression\"===n.body[0].expression.type)}catch(i){return!1}},construct:function(t){var e,n=\"(\"+t+\")\",i=r.parse(n,{range:!0}),o=[];if(\"Program\"!==i.type||1!==i.body.length||\"ExpressionStatement\"!==i.body[0].type||\"ArrowFunctionExpression\"!==i.body[0].expression.type&&\"FunctionExpression\"!==i.body[0].expression.type)throw new Error(\"Failed to resolve function\");return i.body[0].expression.params.forEach((function(t){o.push(t.name)})),e=i.body[0].expression.body.range,\"BlockStatement\"===i.body[0].expression.body.type?new Function(o,n.slice(e[0]+1,e[1]-1)):new Function(o,\"return \"+n.slice(e[0],e[1]))},predicate:function(t){return\"[object Function]\"===Object.prototype.toString.call(t)},represent:function(t){return t.toString()}})},{\"../../type\":16}],22:[function(t,e,n){\"use strict\";var r=t(\"../../type\");e.exports=new r(\"tag:yaml.org,2002:js/regexp\",{kind:\"scalar\",resolve:function(t){if(null===t)return!1;if(0===t.length)return!1;var e=t,n=/\\/([gim]*)$/.exec(t),r=\"\";if(\"/\"===e[0]){if(n&&(r=n[1]),r.length>3)return!1;if(\"/\"!==e[e.length-r.length-1])return!1}return!0},construct:function(t){var e=t,n=/\\/([gim]*)$/.exec(t),r=\"\";return\"/\"===e[0]&&(n&&(r=n[1]),e=e.slice(1,e.length-r.length-1)),new RegExp(e,r)},predicate:function(t){return\"[object RegExp]\"===Object.prototype.toString.call(t)},represent:function(t){var e=\"/\"+t.source+\"/\";return t.global&&(e+=\"g\"),t.multiline&&(e+=\"m\"),t.ignoreCase&&(e+=\"i\"),e}})},{\"../../type\":16}],23:[function(t,e,n){\"use strict\";var r=t(\"../../type\");e.exports=new r(\"tag:yaml.org,2002:js/undefined\",{kind:\"scalar\",resolve:function(){return!0},construct:function(){},predicate:function(t){return\"undefined\"===typeof t},represent:function(){return\"\"}})},{\"../../type\":16}],24:[function(t,e,n){\"use strict\";var r=t(\"../type\");e.exports=new r(\"tag:yaml.org,2002:map\",{kind:\"mapping\",construct:function(t){return null!==t?t:{}}})},{\"../type\":16}],25:[function(t,e,n){\"use strict\";var r=t(\"../type\");e.exports=new r(\"tag:yaml.org,2002:merge\",{kind:\"scalar\",resolve:function(t){return\"<<\"===t||null===t}})},{\"../type\":16}],26:[function(t,e,n){\"use strict\";var r=t(\"../type\");e.exports=new r(\"tag:yaml.org,2002:null\",{kind:\"scalar\",resolve:function(t){if(null===t)return!0;var e=t.length;return 1===e&&\"~\"===t||4===e&&(\"null\"===t||\"Null\"===t||\"NULL\"===t)},construct:function(){return null},predicate:function(t){return null===t},represent:{canonical:function(){return\"~\"},lowercase:function(){return\"null\"},uppercase:function(){return\"NULL\"},camelcase:function(){return\"Null\"}},defaultStyle:\"lowercase\"})},{\"../type\":16}],27:[function(t,e,n){\"use strict\";var r=t(\"../type\"),i=Object.prototype.hasOwnProperty,o=Object.prototype.toString;e.exports=new r(\"tag:yaml.org,2002:omap\",{kind:\"sequence\",resolve:function(t){if(null===t)return!0;var e,n,r,s,a,c=[],u=t;for(e=0,n=u.length;e<n;e+=1){if(r=u[e],a=!1,\"[object Object]\"!==o.call(r))return!1;for(s in r)if(i.call(r,s)){if(a)return!1;a=!0}if(!a)return!1;if(-1!==c.indexOf(s))return!1;c.push(s)}return!0},construct:function(t){return null!==t?t:[]}})},{\"../type\":16}],28:[function(t,e,n){\"use strict\";var r=t(\"../type\"),i=Object.prototype.toString;e.exports=new r(\"tag:yaml.org,2002:pairs\",{kind:\"sequence\",resolve:function(t){if(null===t)return!0;var e,n,r,o,s,a=t;for(s=new Array(a.length),e=0,n=a.length;e<n;e+=1){if(r=a[e],\"[object Object]\"!==i.call(r))return!1;if(1!==(o=Object.keys(r)).length)return!1;s[e]=[o[0],r[o[0]]]}return!0},construct:function(t){if(null===t)return[];var e,n,r,i,o,s=t;for(o=new Array(s.length),e=0,n=s.length;e<n;e+=1)r=s[e],i=Object.keys(r),o[e]=[i[0],r[i[0]]];return o}})},{\"../type\":16}],29:[function(t,e,n){\"use strict\";var r=t(\"../type\");e.exports=new r(\"tag:yaml.org,2002:seq\",{kind:\"sequence\",construct:function(t){return null!==t?t:[]}})},{\"../type\":16}],30:[function(t,e,n){\"use strict\";var r=t(\"../type\"),i=Object.prototype.hasOwnProperty;e.exports=new r(\"tag:yaml.org,2002:set\",{kind:\"mapping\",resolve:function(t){if(null===t)return!0;var e,n=t;for(e in n)if(i.call(n,e)&&null!==n[e])return!1;return!0},construct:function(t){return null!==t?t:{}}})},{\"../type\":16}],31:[function(t,e,n){\"use strict\";var r=t(\"../type\");e.exports=new r(\"tag:yaml.org,2002:str\",{kind:\"scalar\",construct:function(t){return null!==t?t:\"\"}})},{\"../type\":16}],32:[function(t,e,n){\"use strict\";var r=t(\"../type\"),i=new RegExp(\"^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$\"),o=new RegExp(\"^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\\\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\\\.([0-9]*))?(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$\");e.exports=new r(\"tag:yaml.org,2002:timestamp\",{kind:\"scalar\",resolve:function(t){return null!==t&&(null!==i.exec(t)||null!==o.exec(t))},construct:function(t){var e,n,r,s,a,c,u,l,p=0,f=null;if(null===(e=i.exec(t))&&(e=o.exec(t)),null===e)throw new Error(\"Date resolve error\");if(n=+e[1],r=+e[2]-1,s=+e[3],!e[4])return new Date(Date.UTC(n,r,s));if(a=+e[4],c=+e[5],u=+e[6],e[7]){for(p=e[7].slice(0,3);p.length<3;)p+=\"0\";p=+p}return e[9]&&(f=6e4*(60*+e[10]+ +(e[11]||0)),\"-\"===e[9]&&(f=-f)),l=new Date(Date.UTC(n,r,s,a,c,u,p)),f&&l.setTime(l.getTime()-f),l},instanceOf:Date,represent:function(t){return t.toISOString()}})},{\"../type\":16}],33:[function(t,e,n){(function(t){var r=\"__lodash_hash_undefined__\",i=9007199254740991,o=\"[object Arguments]\",s=\"[object AsyncFunction]\",a=\"[object Function]\",c=\"[object GeneratorFunction]\",u=\"[object Null]\",l=\"[object Object]\",p=\"[object Proxy]\",f=\"[object Undefined]\",h=/^\\[object .+?Constructor\\]$/,d=/^(?:0|[1-9]\\d*)$/,m={};m[\"[object Float32Array]\"]=m[\"[object Float64Array]\"]=m[\"[object Int8Array]\"]=m[\"[object Int16Array]\"]=m[\"[object Int32Array]\"]=m[\"[object Uint8Array]\"]=m[\"[object Uint8ClampedArray]\"]=m[\"[object Uint16Array]\"]=m[\"[object Uint32Array]\"]=!0,m[o]=m[\"[object Array]\"]=m[\"[object ArrayBuffer]\"]=m[\"[object Boolean]\"]=m[\"[object DataView]\"]=m[\"[object Date]\"]=m[\"[object Error]\"]=m[a]=m[\"[object Map]\"]=m[\"[object Number]\"]=m[l]=m[\"[object RegExp]\"]=m[\"[object Set]\"]=m[\"[object String]\"]=m[\"[object WeakMap]\"]=!1;var g=\"object\"==typeof t&&t&&t.Object===Object&&t,y=\"object\"==typeof self&&self&&self.Object===Object&&self,v=g||y||Function(\"return this\")(),w=\"object\"==typeof n&&n&&!n.nodeType&&n,b=w&&\"object\"==typeof e&&e&&!e.nodeType&&e,x=b&&b.exports===w,A=x&&g.process,_=function(){try{return A&&A.binding&&A.binding(\"util\")}catch(t){}}(),j=_&&_.isTypedArray;function L(t,e){return\"__proto__\"==e?void 0:t[e]}var C,k,O=Array.prototype,E=Function.prototype,S=Object.prototype,M=v[\"__core-js_shared__\"],I=E.toString,F=S.hasOwnProperty,T=function(){var t=/[^.]+$/.exec(M&&M.keys&&M.keys.IE_PROTO||\"\");return t?\"Symbol(src)_1.\"+t:\"\"}(),N=S.toString,D=I.call(Object),$=RegExp(\"^\"+I.call(F).replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),P=x?v.Buffer:void 0,R=v.Symbol,U=v.Uint8Array,q=P?P.allocUnsafe:void 0,z=(C=Object.getPrototypeOf,k=Object,function(t){return C(k(t))}),H=Object.create,Y=S.propertyIsEnumerable,B=O.splice,V=R?R.toStringTag:void 0,W=function(){try{var t=wt(Object,\"defineProperty\");return t({},\"\",{}),t}catch(e){}}(),K=P?P.isBuffer:void 0,G=Math.max,Z=Date.now,J=wt(v,\"Map\"),Q=wt(Object,\"create\"),X=function(){function t(){}return function(e){if(!St(e))return{};if(H)return H(e);t.prototype=e;var n=new t;return t.prototype=void 0,n}}();function tt(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function et(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function nt(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function rt(t){var e=this.__data__=new et(t);this.size=e.size}function it(t,e){var n=Lt(t),r=!n&&jt(t),i=!n&&!r&&kt(t),o=!n&&!r&&!i&&It(t),s=n||r||i||o,a=s?function(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}(t.length,String):[],c=a.length;for(var u in t)!e&&!F.call(t,u)||s&&(\"length\"==u||i&&(\"offset\"==u||\"parent\"==u)||o&&(\"buffer\"==u||\"byteLength\"==u||\"byteOffset\"==u)||bt(u,c))||a.push(u);return a}function ot(t,e,n){(void 0!==n&&!_t(t[e],n)||void 0===n&&!(e in t))&&ct(t,e,n)}function st(t,e,n){var r=t[e];F.call(t,e)&&_t(r,n)&&(void 0!==n||e in t)||ct(t,e,n)}function at(t,e){for(var n=t.length;n--;)if(_t(t[n][0],e))return n;return-1}function ct(t,e,n){\"__proto__\"==e&&W?W(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}tt.prototype.clear=function(){this.__data__=Q?Q(null):{},this.size=0},tt.prototype.delete=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e},tt.prototype.get=function(t){var e=this.__data__;if(Q){var n=e[t];return n===r?void 0:n}return F.call(e,t)?e[t]:void 0},tt.prototype.has=function(t){var e=this.__data__;return Q?void 0!==e[t]:F.call(e,t)},tt.prototype.set=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=Q&&void 0===e?r:e,this},et.prototype.clear=function(){this.__data__=[],this.size=0},et.prototype.delete=function(t){var e=this.__data__,n=at(e,t);return!(n<0)&&(n==e.length-1?e.pop():B.call(e,n,1),--this.size,!0)},et.prototype.get=function(t){var e=this.__data__,n=at(e,t);return n<0?void 0:e[n][1]},et.prototype.has=function(t){return at(this.__data__,t)>-1},et.prototype.set=function(t,e){var n=this.__data__,r=at(n,t);return r<0?(++this.size,n.push([t,e])):n[r][1]=e,this},nt.prototype.clear=function(){this.size=0,this.__data__={hash:new tt,map:new(J||et),string:new tt}},nt.prototype.delete=function(t){var e=vt(this,t).delete(t);return this.size-=e?1:0,e},nt.prototype.get=function(t){return vt(this,t).get(t)},nt.prototype.has=function(t){return vt(this,t).has(t)},nt.prototype.set=function(t,e){var n=vt(this,t),r=n.size;return n.set(t,e),this.size+=n.size==r?0:1,this},rt.prototype.clear=function(){this.__data__=new et,this.size=0},rt.prototype.delete=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n},rt.prototype.get=function(t){return this.__data__.get(t)},rt.prototype.has=function(t){return this.__data__.has(t)},rt.prototype.set=function(t,e){var n=this.__data__;if(n instanceof et){var r=n.__data__;if(!J||r.length<199)return r.push([t,e]),this.size=++n.size,this;n=this.__data__=new nt(r)}return n.set(t,e),this.size=n.size,this};var ut,lt=function(t,e,n){for(var r=-1,i=Object(t),o=n(t),s=o.length;s--;){var a=o[ut?s:++r];if(!1===e(i[a],a,i))break}return t};function pt(t){return null==t?void 0===t?f:u:V&&V in Object(t)?function(t){var e=F.call(t,V),n=t[V];try{t[V]=void 0;var r=!0}catch(o){}var i=N.call(t);r&&(e?t[V]=n:delete t[V]);return i}(t):function(t){return N.call(t)}(t)}function ft(t){return Mt(t)&&pt(t)==o}function ht(t){return!(!St(t)||function(t){return!!T&&T in t}(t))&&(Ot(t)?$:h).test(function(t){if(null!=t){try{return I.call(t)}catch(e){}try{return t+\"\"}catch(e){}}return\"\"}(t))}function dt(t){if(!St(t))return function(t){var e=[];if(null!=t)for(var n in Object(t))e.push(n);return e}(t);var e=xt(t),n=[];for(var r in t)(\"constructor\"!=r||!e&&F.call(t,r))&&n.push(r);return n}function mt(t,e,n,r,i){t!==e&&lt(e,(function(o,s){if(St(o))i||(i=new rt),function(t,e,n,r,i,o,s){var a=L(t,n),c=L(e,n),u=s.get(c);if(u)return void ot(t,n,u);var p=o?o(a,c,n+\"\",t,e,s):void 0,f=void 0===p;if(f){var h=Lt(c),d=!h&&kt(c),m=!h&&!d&&It(c);p=c,h||d||m?Lt(a)?p=a:Mt(g=a)&&Ct(g)?p=function(t,e){var n=-1,r=t.length;e||(e=Array(r));for(;++n<r;)e[n]=t[n];return e}(a):d?(f=!1,p=function(t,e){if(e)return t.slice();var n=t.length,r=q?q(n):new t.constructor(n);return t.copy(r),r}(c,!0)):m?(f=!1,p=function(t,e){var n=e?function(t){var e=new t.constructor(t.byteLength);return new U(e).set(new U(t)),e}(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}(c,!0)):p=[]:function(t){if(!Mt(t)||pt(t)!=l)return!1;var e=z(t);if(null===e)return!0;var n=F.call(e,\"constructor\")&&e.constructor;return\"function\"==typeof n&&n instanceof n&&I.call(n)==D}(c)||jt(c)?(p=a,jt(a)?p=function(t){return function(t,e,n,r){var i=!n;n||(n={});var o=-1,s=e.length;for(;++o<s;){var a=e[o],c=r?r(n[a],t[a],a,n,t):void 0;void 0===c&&(c=t[a]),i?ct(n,a,c):st(n,a,c)}return n}(t,Ft(t))}(a):(!St(a)||r&&Ot(a))&&(p=function(t){return\"function\"!=typeof t.constructor||xt(t)?{}:X(z(t))}(c))):f=!1}var g;f&&(s.set(c,p),i(p,c,r,o,s),s.delete(c));ot(t,n,p)}(t,e,s,n,mt,r,i);else{var a=r?r(L(t,s),o,s+\"\",t,e,i):void 0;void 0===a&&(a=o),ot(t,s,a)}}),Ft)}function gt(t,e){return At(function(t,e,n){return e=G(void 0===e?t.length-1:e,0),function(){for(var r=arguments,i=-1,o=G(r.length-e,0),s=Array(o);++i<o;)s[i]=r[e+i];i=-1;for(var a=Array(e+1);++i<e;)a[i]=r[i];return a[e]=n(s),function(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}(t,this,a)}}(t,e,Dt),t+\"\")}var yt=W?function(t,e){return W(t,\"toString\",{configurable:!0,enumerable:!1,value:(n=e,function(){return n}),writable:!0});var n}:Dt;function vt(t,e){var n=t.__data__;return function(t){var e=typeof t;return\"string\"==e||\"number\"==e||\"symbol\"==e||\"boolean\"==e?\"__proto__\"!==t:null===t}(e)?n[\"string\"==typeof e?\"string\":\"hash\"]:n.map}function wt(t,e){var n=function(t,e){return null==t?void 0:t[e]}(t,e);return ht(n)?n:void 0}function bt(t,e){var n=typeof t;return!!(e=null==e?i:e)&&(\"number\"==n||\"symbol\"!=n&&d.test(t))&&t>-1&&t%1==0&&t<e}function xt(t){var e=t&&t.constructor;return t===(\"function\"==typeof e&&e.prototype||S)}var At=function(t){var e=0,n=0;return function(){var r=Z(),i=16-(r-n);if(n=r,i>0){if(++e>=800)return arguments[0]}else e=0;return t.apply(void 0,arguments)}}(yt);function _t(t,e){return t===e||t!==t&&e!==e}var jt=ft(function(){return arguments}())?ft:function(t){return Mt(t)&&F.call(t,\"callee\")&&!Y.call(t,\"callee\")},Lt=Array.isArray;function Ct(t){return null!=t&&Et(t.length)&&!Ot(t)}var kt=K||function(){return!1};function Ot(t){if(!St(t))return!1;var e=pt(t);return e==a||e==c||e==s||e==p}function Et(t){return\"number\"==typeof t&&t>-1&&t%1==0&&t<=i}function St(t){var e=typeof t;return null!=t&&(\"object\"==e||\"function\"==e)}function Mt(t){return null!=t&&\"object\"==typeof t}var It=j?function(t){return function(e){return t(e)}}(j):function(t){return Mt(t)&&Et(t.length)&&!!m[pt(t)]};function Ft(t){return Ct(t)?it(t,!0):dt(t)}var Tt,Nt=(Tt=function(t,e,n){mt(t,e,n)},gt((function(t,e){var n=-1,r=e.length,i=r>1?e[r-1]:void 0,o=r>2?e[2]:void 0;for(i=Tt.length>3&&\"function\"==typeof i?(r--,i):void 0,o&&function(t,e,n){if(!St(n))return!1;var r=typeof e;return!!(\"number\"==r?Ct(n)&&bt(e,n.length):\"string\"==r&&e in n)&&_t(n[e],t)}(e[0],e[1],o)&&(i=r<3?void 0:i,r=1),t=Object(t);++n<r;){var s=e[n];s&&Tt(t,s,n,i)}return t})));function Dt(t){return t}e.exports=Nt}).call(this,\"undefined\"!==typeof global?global:\"undefined\"!==typeof self?self:\"undefined\"!==typeof window?window:{})},{}]},{},[2])(2)}))})),ace.define(\"ace/mode/yaml_worker\",[],(function(t,e){\"use strict\";var n=t(\"../lib/oop\"),r=t(\"../worker/mirror\").Mirror,i=t(\"./yaml/yaml-lint\").lint,o=e.YamlWorker=function(t){r.call(this,t),this.setTimeout(500),this.setOptions()};n.inherits(o,r),function(){this.setOptions=function(){this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.changeOptions=function(t){n.mixin(this.options,t),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.onUpdate=function(){var t=this,e=this.doc.getValue(),n=[];i(e,{},(function(e){if(e){var r=!!e.mark;n.push({row:r?e.mark.line:0,column:r?e.mark.column:0,text:e.reason,type:\"error\",raw:e}),t.sender.emit(\"annotate\",n)}else t.sender.emit(\"annotate\",n)}))}}.call(o.prototype)}));","name":"de25440f4097f128f6d9869c385401ca.js","input":"\"no use strict\";\n\n!function (window) {\n  if (typeof window.window != \"undefined\" && window.document) return;\n  if (window.require && window.define) return;\n  if (!window.console) {\n    window.console = function () {\n      var msgs = Array.prototype.slice.call(arguments, 0);\n      postMessage({\n        type: \"log\",\n        data: msgs\n      });\n    };\n    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;\n  }\n  window.window = window;\n  window.ace = window;\n  window.onerror = function (message, file, line, col, err) {\n    postMessage({\n      type: \"error\",\n      data: {\n        message: message,\n        data: err && err.data,\n        file: file,\n        line: line,\n        col: col,\n        stack: err && err.stack\n      }\n    });\n  };\n  window.normalizeModule = function (parentId, moduleName) {\n    // normalize plugin requires\n    if (moduleName.indexOf(\"!\") !== -1) {\n      var chunks = moduleName.split(\"!\");\n      return window.normalizeModule(parentId, chunks[0]) + \"!\" + window.normalizeModule(parentId, chunks[1]);\n    }\n    // normalize relative requires\n    if (moduleName.charAt(0) == \".\") {\n      var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n      moduleName = (base ? base + \"/\" : \"\") + moduleName;\n      while (moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n        var previous = moduleName;\n        moduleName = moduleName.replace(/^\\.\\//, \"\").replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n      }\n    }\n    return moduleName;\n  };\n  window.require = function require(parentId, id) {\n    if (!id) {\n      id = parentId;\n      parentId = null;\n    }\n    if (!id.charAt) throw new Error(\"worker.js require() accepts only (parentId, id) as arguments\");\n    id = window.normalizeModule(parentId, id);\n    var module = window.require.modules[id];\n    if (module) {\n      if (!module.initialized) {\n        module.initialized = true;\n        module.exports = module.factory().exports;\n      }\n      return module.exports;\n    }\n    if (!window.require.tlns) return console.log(\"unable to load \" + id);\n    var path = resolveModuleId(id, window.require.tlns);\n    if (path.slice(-3) != \".js\") path += \".js\";\n    window.require.id = id;\n    window.require.modules[id] = {}; // prevent infinite loop on broken modules\n    importScripts(path);\n    return window.require(parentId, id);\n  };\n  function resolveModuleId(id, paths) {\n    var testPath = id,\n      tail = \"\";\n    while (testPath) {\n      var alias = paths[testPath];\n      if (typeof alias == \"string\") {\n        return alias + tail;\n      } else if (alias) {\n        return alias.location.replace(/\\/*$/, \"/\") + (tail || alias.main || alias.name);\n      } else if (alias === false) {\n        return \"\";\n      }\n      var i = testPath.lastIndexOf(\"/\");\n      if (i === -1) break;\n      tail = testPath.substr(i) + tail;\n      testPath = testPath.slice(0, i);\n    }\n    return id;\n  }\n  window.require.modules = {};\n  window.require.tlns = {};\n  window.define = function (id, deps, factory) {\n    if (arguments.length == 2) {\n      factory = deps;\n      if (typeof id != \"string\") {\n        deps = id;\n        id = window.require.id;\n      }\n    } else if (arguments.length == 1) {\n      factory = id;\n      deps = [];\n      id = window.require.id;\n    }\n    if (typeof factory != \"function\") {\n      window.require.modules[id] = {\n        exports: factory,\n        initialized: true\n      };\n      return;\n    }\n    if (!deps.length)\n      // If there is no dependencies, we inject \"require\", \"exports\" and\n      // \"module\" as dependencies, to provide CommonJS compatibility.\n      deps = [\"require\", \"exports\", \"module\"];\n    var req = function (childId) {\n      return window.require(id, childId);\n    };\n    window.require.modules[id] = {\n      exports: {},\n      factory: function () {\n        var module = this;\n        var returnExports = factory.apply(this, deps.slice(0, factory.length).map(function (dep) {\n          switch (dep) {\n            // Because \"require\", \"exports\" and \"module\" aren't actual\n            // dependencies, we must handle them seperately.\n            case \"require\":\n              return req;\n            case \"exports\":\n              return module.exports;\n            case \"module\":\n              return module;\n            // But for all other dependencies, we can just go ahead and\n            // require them.\n            default:\n              return req(dep);\n          }\n        }));\n        if (returnExports) module.exports = returnExports;\n        return module;\n      }\n    };\n  };\n  window.define.amd = {};\n  window.require.tlns = {};\n  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {\n    for (var i in topLevelNamespaces) this.require.tlns[i] = topLevelNamespaces[i];\n  };\n  window.initSender = function initSender() {\n    var EventEmitter = window.require(\"ace/lib/event_emitter\").EventEmitter;\n    var oop = window.require(\"ace/lib/oop\");\n    var Sender = function () {};\n    (function () {\n      oop.implement(this, EventEmitter);\n      this.callback = function (data, callbackId) {\n        postMessage({\n          type: \"call\",\n          id: callbackId,\n          data: data\n        });\n      };\n      this.emit = function (name, data) {\n        postMessage({\n          type: \"event\",\n          name: name,\n          data: data\n        });\n      };\n    }).call(Sender.prototype);\n    return new Sender();\n  };\n  var main = window.main = null;\n  var sender = window.sender = null;\n  window.onmessage = function (e) {\n    var msg = e.data;\n    if (msg.event && sender) {\n      sender._signal(msg.event, msg.data);\n    } else if (msg.command) {\n      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error(\"Unknown command:\" + msg.command);\n    } else if (msg.init) {\n      window.initBaseUrls(msg.tlns);\n      sender = window.sender = window.initSender();\n      var clazz = this.require(msg.module)[msg.classname];\n      main = window.main = new clazz(sender);\n    }\n  };\n}(this);\nace.define(\"ace/lib/oop\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.inherits = function (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n  exports.mixin = function (obj, mixin) {\n    for (var key in mixin) {\n      obj[key] = mixin[key];\n    }\n    return obj;\n  };\n  exports.implement = function (proto, mixin) {\n    exports.mixin(proto, mixin);\n  };\n});\nace.define(\"ace/apply_delta\", [], function (require, exports, module) {\n  \"use strict\";\n\n  function throwDeltaError(delta, errorText) {\n    console.log(\"Invalid Delta:\", delta);\n    throw \"Invalid Delta: \" + errorText;\n  }\n  function positionInDocument(docLines, position) {\n    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;\n  }\n  function validateDelta(docLines, delta) {\n    if (delta.action != \"insert\" && delta.action != \"remove\") throwDeltaError(delta, \"delta.action must be 'insert' or 'remove'\");\n    if (!(delta.lines instanceof Array)) throwDeltaError(delta, \"delta.lines must be an Array\");\n    if (!delta.start || !delta.end) throwDeltaError(delta, \"delta.start/end must be an present\");\n    var start = delta.start;\n    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, \"delta.start must be contained in document\");\n    var end = delta.end;\n    if (delta.action == \"remove\" && !positionInDocument(docLines, end)) throwDeltaError(delta, \"delta.end must contained in document for 'remove' actions\");\n    var numRangeRows = end.row - start.row;\n    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);\n    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, \"delta.range must match delta lines\");\n  }\n  exports.applyDelta = function (docLines, delta, doNotValidate) {\n    var row = delta.start.row;\n    var startColumn = delta.start.column;\n    var line = docLines[row] || \"\";\n    switch (delta.action) {\n      case \"insert\":\n        var lines = delta.lines;\n        if (lines.length === 1) {\n          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);\n        } else {\n          var args = [row, 1].concat(delta.lines);\n          docLines.splice.apply(docLines, args);\n          docLines[row] = line.substring(0, startColumn) + docLines[row];\n          docLines[row + delta.lines.length - 1] += line.substring(startColumn);\n        }\n        break;\n      case \"remove\":\n        var endColumn = delta.end.column;\n        var endRow = delta.end.row;\n        if (row === endRow) {\n          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);\n        } else {\n          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));\n        }\n        break;\n    }\n  };\n});\nace.define(\"ace/lib/event_emitter\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var EventEmitter = {};\n  var stopPropagation = function () {\n    this.propagationStopped = true;\n  };\n  var preventDefault = function () {\n    this.defaultPrevented = true;\n  };\n  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {\n    this._eventRegistry || (this._eventRegistry = {});\n    this._defaultHandlers || (this._defaultHandlers = {});\n    var listeners = this._eventRegistry[eventName] || [];\n    var defaultHandler = this._defaultHandlers[eventName];\n    if (!listeners.length && !defaultHandler) return;\n    if (typeof e != \"object\" || !e) e = {};\n    if (!e.type) e.type = eventName;\n    if (!e.stopPropagation) e.stopPropagation = stopPropagation;\n    if (!e.preventDefault) e.preventDefault = preventDefault;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i](e, this);\n      if (e.propagationStopped) break;\n    }\n    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);\n  };\n  EventEmitter._signal = function (eventName, e) {\n    var listeners = (this._eventRegistry || {})[eventName];\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0; i < listeners.length; i++) listeners[i](e, this);\n  };\n  EventEmitter.once = function (eventName, callback) {\n    var _self = this;\n    this.on(eventName, function newCallback() {\n      _self.off(eventName, newCallback);\n      callback.apply(null, arguments);\n    });\n    if (!callback) {\n      return new Promise(function (resolve) {\n        callback = resolve;\n      });\n    }\n  };\n  EventEmitter.setDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) handlers = this._defaultHandlers = {\n      _disabled_: {}\n    };\n    if (handlers[eventName]) {\n      var old = handlers[eventName];\n      var disabled = handlers._disabled_[eventName];\n      if (!disabled) handlers._disabled_[eventName] = disabled = [];\n      disabled.push(old);\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n    handlers[eventName] = callback;\n  };\n  EventEmitter.removeDefaultHandler = function (eventName, callback) {\n    var handlers = this._defaultHandlers;\n    if (!handlers) return;\n    var disabled = handlers._disabled_[eventName];\n    if (handlers[eventName] == callback) {\n      if (disabled) this.setDefaultHandler(eventName, disabled.pop());\n    } else if (disabled) {\n      var i = disabled.indexOf(callback);\n      if (i != -1) disabled.splice(i, 1);\n    }\n  };\n  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) listeners = this._eventRegistry[eventName] = [];\n    if (listeners.indexOf(callback) == -1) listeners[capturing ? \"unshift\" : \"push\"](callback);\n    return callback;\n  };\n  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {\n    this._eventRegistry = this._eventRegistry || {};\n    var listeners = this._eventRegistry[eventName];\n    if (!listeners) return;\n    var index = listeners.indexOf(callback);\n    if (index !== -1) listeners.splice(index, 1);\n  };\n  EventEmitter.removeAllListeners = function (eventName) {\n    if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;\n    if (this._eventRegistry) this._eventRegistry[eventName] = undefined;\n    if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;\n  };\n  exports.EventEmitter = EventEmitter;\n});\nace.define(\"ace/range\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = /** @class */function () {\n    function Range(startRow, startColumn, endRow, endColumn) {\n      this.start = {\n        row: startRow,\n        column: startColumn\n      };\n      this.end = {\n        row: endRow,\n        column: endColumn\n      };\n    }\n    Range.prototype.isEqual = function (range) {\n      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;\n    };\n    Range.prototype.toString = function () {\n      return \"Range: [\" + this.start.row + \"/\" + this.start.column + \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\";\n    };\n    Range.prototype.contains = function (row, column) {\n      return this.compare(row, column) == 0;\n    };\n    Range.prototype.compareRange = function (range) {\n      var cmp,\n        end = range.end,\n        start = range.start;\n      cmp = this.compare(end.row, end.column);\n      if (cmp == 1) {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == 1) {\n          return 2;\n        } else if (cmp == 0) {\n          return 1;\n        } else {\n          return 0;\n        }\n      } else if (cmp == -1) {\n        return -2;\n      } else {\n        cmp = this.compare(start.row, start.column);\n        if (cmp == -1) {\n          return -1;\n        } else if (cmp == 1) {\n          return 42;\n        } else {\n          return 0;\n        }\n      }\n    };\n    Range.prototype.comparePoint = function (p) {\n      return this.compare(p.row, p.column);\n    };\n    Range.prototype.containsRange = function (range) {\n      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n    };\n    Range.prototype.intersects = function (range) {\n      var cmp = this.compareRange(range);\n      return cmp == -1 || cmp == 0 || cmp == 1;\n    };\n    Range.prototype.isEnd = function (row, column) {\n      return this.end.row == row && this.end.column == column;\n    };\n    Range.prototype.isStart = function (row, column) {\n      return this.start.row == row && this.start.column == column;\n    };\n    Range.prototype.setStart = function (row, column) {\n      if (typeof row == \"object\") {\n        this.start.column = row.column;\n        this.start.row = row.row;\n      } else {\n        this.start.row = row;\n        this.start.column = column;\n      }\n    };\n    Range.prototype.setEnd = function (row, column) {\n      if (typeof row == \"object\") {\n        this.end.column = row.column;\n        this.end.row = row.row;\n      } else {\n        this.end.row = row;\n        this.end.column = column;\n      }\n    };\n    Range.prototype.inside = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column) || this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    Range.prototype.insideStart = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isEnd(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    Range.prototype.insideEnd = function (row, column) {\n      if (this.compare(row, column) == 0) {\n        if (this.isStart(row, column)) {\n          return false;\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    Range.prototype.compare = function (row, column) {\n      if (!this.isMultiLine()) {\n        if (row === this.start.row) {\n          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;\n        }\n      }\n      if (row < this.start.row) return -1;\n      if (row > this.end.row) return 1;\n      if (this.start.row === row) return column >= this.start.column ? 0 : -1;\n      if (this.end.row === row) return column <= this.end.column ? 0 : 1;\n      return 0;\n    };\n    Range.prototype.compareStart = function (row, column) {\n      if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    Range.prototype.compareEnd = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    Range.prototype.compareInside = function (row, column) {\n      if (this.end.row == row && this.end.column == column) {\n        return 1;\n      } else if (this.start.row == row && this.start.column == column) {\n        return -1;\n      } else {\n        return this.compare(row, column);\n      }\n    };\n    Range.prototype.clipRows = function (firstRow, lastRow) {\n      if (this.end.row > lastRow) var end = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.end.row < firstRow) var end = {\n        row: firstRow,\n        column: 0\n      };\n      if (this.start.row > lastRow) var start = {\n        row: lastRow + 1,\n        column: 0\n      };else if (this.start.row < firstRow) var start = {\n        row: firstRow,\n        column: 0\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    Range.prototype.extend = function (row, column) {\n      var cmp = this.compare(row, column);\n      if (cmp == 0) return this;else if (cmp == -1) var start = {\n        row: row,\n        column: column\n      };else var end = {\n        row: row,\n        column: column\n      };\n      return Range.fromPoints(start || this.start, end || this.end);\n    };\n    Range.prototype.isEmpty = function () {\n      return this.start.row === this.end.row && this.start.column === this.end.column;\n    };\n    Range.prototype.isMultiLine = function () {\n      return this.start.row !== this.end.row;\n    };\n    Range.prototype.clone = function () {\n      return Range.fromPoints(this.start, this.end);\n    };\n    Range.prototype.collapseRows = function () {\n      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);\n    };\n    Range.prototype.toScreenRange = function (session) {\n      var screenPosStart = session.documentToScreenPosition(this.start);\n      var screenPosEnd = session.documentToScreenPosition(this.end);\n      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);\n    };\n    Range.prototype.moveBy = function (row, column) {\n      this.start.row += row;\n      this.start.column += column;\n      this.end.row += row;\n      this.end.column += column;\n    };\n    return Range;\n  }();\n  Range.fromPoints = function (start, end) {\n    return new Range(start.row, start.column, end.row, end.column);\n  };\n  Range.comparePoints = function (p1, p2) {\n    return p1.row - p2.row || p1.column - p2.column;\n  };\n  exports.Range = Range;\n});\nace.define(\"ace/anchor\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Anchor = /** @class */function () {\n    function Anchor(doc, row, column) {\n      this.$onChange = this.onChange.bind(this);\n      this.attach(doc);\n      if (typeof row != \"number\") this.setPosition(row.row, row.column);else this.setPosition(row, column);\n    }\n    Anchor.prototype.getPosition = function () {\n      return this.$clipPositionToDocument(this.row, this.column);\n    };\n    Anchor.prototype.getDocument = function () {\n      return this.document;\n    };\n    Anchor.prototype.onChange = function (delta) {\n      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;\n      if (delta.start.row > this.row) return;\n      var point = $getTransformedPoint(delta, {\n        row: this.row,\n        column: this.column\n      }, this.$insertRight);\n      this.setPosition(point.row, point.column, true);\n    };\n    Anchor.prototype.setPosition = function (row, column, noClip) {\n      var pos;\n      if (noClip) {\n        pos = {\n          row: row,\n          column: column\n        };\n      } else {\n        pos = this.$clipPositionToDocument(row, column);\n      }\n      if (this.row == pos.row && this.column == pos.column) return;\n      var old = {\n        row: this.row,\n        column: this.column\n      };\n      this.row = pos.row;\n      this.column = pos.column;\n      this._signal(\"change\", {\n        old: old,\n        value: pos\n      });\n    };\n    Anchor.prototype.detach = function () {\n      this.document.off(\"change\", this.$onChange);\n    };\n    Anchor.prototype.attach = function (doc) {\n      this.document = doc || this.document;\n      this.document.on(\"change\", this.$onChange);\n    };\n    Anchor.prototype.$clipPositionToDocument = function (row, column) {\n      var pos = {};\n      if (row >= this.document.getLength()) {\n        pos.row = Math.max(0, this.document.getLength() - 1);\n        pos.column = this.document.getLine(pos.row).length;\n      } else if (row < 0) {\n        pos.row = 0;\n        pos.column = 0;\n      } else {\n        pos.row = row;\n        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n      }\n      if (column < 0) pos.column = 0;\n      return pos;\n    };\n    return Anchor;\n  }();\n  Anchor.prototype.$insertRight = false;\n  oop.implement(Anchor.prototype, EventEmitter);\n  function $pointsInOrder(point1, point2, equalPointsInOrder) {\n    var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;\n    return point1.row < point2.row || point1.row == point2.row && bColIsAfter;\n  }\n  function $getTransformedPoint(delta, point, moveIfEqual) {\n    var deltaIsInsert = delta.action == \"insert\";\n    var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);\n    var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);\n    var deltaStart = delta.start;\n    var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.\n    if ($pointsInOrder(point, deltaStart, moveIfEqual)) {\n      return {\n        row: point.row,\n        column: point.column\n      };\n    }\n    if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {\n      return {\n        row: point.row + deltaRowShift,\n        column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)\n      };\n    }\n    return {\n      row: deltaStart.row,\n      column: deltaStart.column\n    };\n  }\n  exports.Anchor = Anchor;\n});\nace.define(\"ace/document\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"./lib/oop\");\n  var applyDelta = require(\"./apply_delta\").applyDelta;\n  var EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\n  var Range = require(\"./range\").Range;\n  var Anchor = require(\"./anchor\").Anchor;\n  var Document = /** @class */function () {\n    function Document(textOrLines) {\n      this.$lines = [\"\"];\n      if (textOrLines.length === 0) {\n        this.$lines = [\"\"];\n      } else if (Array.isArray(textOrLines)) {\n        this.insertMergedLines({\n          row: 0,\n          column: 0\n        }, textOrLines);\n      } else {\n        this.insert({\n          row: 0,\n          column: 0\n        }, textOrLines);\n      }\n    }\n    Document.prototype.setValue = function (text) {\n      var len = this.getLength() - 1;\n      this.remove(new Range(0, 0, len, this.getLine(len).length));\n      this.insert({\n        row: 0,\n        column: 0\n      }, text || \"\");\n    };\n    Document.prototype.getValue = function () {\n      return this.getAllLines().join(this.getNewLineCharacter());\n    };\n    Document.prototype.createAnchor = function (row, column) {\n      return new Anchor(this, row, column);\n    };\n    Document.prototype.$detectNewLine = function (text) {\n      var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n      this.$autoNewLine = match ? match[1] : \"\\n\";\n      this._signal(\"changeNewLineMode\");\n    };\n    Document.prototype.getNewLineCharacter = function () {\n      switch (this.$newLineMode) {\n        case \"windows\":\n          return \"\\r\\n\";\n        case \"unix\":\n          return \"\\n\";\n        default:\n          return this.$autoNewLine || \"\\n\";\n      }\n    };\n    Document.prototype.setNewLineMode = function (newLineMode) {\n      if (this.$newLineMode === newLineMode) return;\n      this.$newLineMode = newLineMode;\n      this._signal(\"changeNewLineMode\");\n    };\n    Document.prototype.getNewLineMode = function () {\n      return this.$newLineMode;\n    };\n    Document.prototype.isNewLine = function (text) {\n      return text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\";\n    };\n    Document.prototype.getLine = function (row) {\n      return this.$lines[row] || \"\";\n    };\n    Document.prototype.getLines = function (firstRow, lastRow) {\n      return this.$lines.slice(firstRow, lastRow + 1);\n    };\n    Document.prototype.getAllLines = function () {\n      return this.getLines(0, this.getLength());\n    };\n    Document.prototype.getLength = function () {\n      return this.$lines.length;\n    };\n    Document.prototype.getTextRange = function (range) {\n      return this.getLinesForRange(range).join(this.getNewLineCharacter());\n    };\n    Document.prototype.getLinesForRange = function (range) {\n      var lines;\n      if (range.start.row === range.end.row) {\n        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\n      } else {\n        lines = this.getLines(range.start.row, range.end.row);\n        lines[0] = (lines[0] || \"\").substring(range.start.column);\n        var l = lines.length - 1;\n        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);\n      }\n      return lines;\n    };\n    Document.prototype.insertLines = function (row, lines) {\n      console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\n      return this.insertFullLines(row, lines);\n    };\n    Document.prototype.removeLines = function (firstRow, lastRow) {\n      console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\n      return this.removeFullLines(firstRow, lastRow);\n    };\n    Document.prototype.insertNewLine = function (position) {\n      console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\n      return this.insertMergedLines(position, [\"\", \"\"]);\n    };\n    Document.prototype.insert = function (position, text) {\n      if (this.getLength() <= 1) this.$detectNewLine(text);\n      return this.insertMergedLines(position, this.$split(text));\n    };\n    Document.prototype.insertInLine = function (position, text) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = this.pos(position.row, position.column + text.length);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: [text]\n      }, true);\n      return this.clonePos(end);\n    };\n    Document.prototype.clippedPos = function (row, column) {\n      var length = this.getLength();\n      if (row === undefined) {\n        row = length;\n      } else if (row < 0) {\n        row = 0;\n      } else if (row >= length) {\n        row = length - 1;\n        column = undefined;\n      }\n      var line = this.getLine(row);\n      if (column == undefined) column = line.length;\n      column = Math.min(Math.max(column, 0), line.length);\n      return {\n        row: row,\n        column: column\n      };\n    };\n    Document.prototype.clonePos = function (pos) {\n      return {\n        row: pos.row,\n        column: pos.column\n      };\n    };\n    Document.prototype.pos = function (row, column) {\n      return {\n        row: row,\n        column: column\n      };\n    };\n    Document.prototype.$clipPosition = function (position) {\n      var length = this.getLength();\n      if (position.row >= length) {\n        position.row = Math.max(0, length - 1);\n        position.column = this.getLine(length - 1).length;\n      } else {\n        position.row = Math.max(0, position.row);\n        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\n      }\n      return position;\n    };\n    Document.prototype.insertFullLines = function (row, lines) {\n      row = Math.min(Math.max(row, 0), this.getLength());\n      var column = 0;\n      if (row < this.getLength()) {\n        lines = lines.concat([\"\"]);\n        column = 0;\n      } else {\n        lines = [\"\"].concat(lines);\n        row--;\n        column = this.$lines[row].length;\n      }\n      this.insertMergedLines({\n        row: row,\n        column: column\n      }, lines);\n    };\n    Document.prototype.insertMergedLines = function (position, lines) {\n      var start = this.clippedPos(position.row, position.column);\n      var end = {\n        row: start.row + lines.length - 1,\n        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\n      };\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"insert\",\n        lines: lines\n      });\n      return this.clonePos(end);\n    };\n    Document.prototype.remove = function (range) {\n      var start = this.clippedPos(range.start.row, range.start.column);\n      var end = this.clippedPos(range.end.row, range.end.column);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      });\n      return this.clonePos(start);\n    };\n    Document.prototype.removeInLine = function (row, startColumn, endColumn) {\n      var start = this.clippedPos(row, startColumn);\n      var end = this.clippedPos(row, endColumn);\n      this.applyDelta({\n        start: start,\n        end: end,\n        action: \"remove\",\n        lines: this.getLinesForRange({\n          start: start,\n          end: end\n        })\n      }, true);\n      return this.clonePos(start);\n    };\n    Document.prototype.removeFullLines = function (firstRow, lastRow) {\n      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\n      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);\n      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\n      var deleteLastNewLine = lastRow < this.getLength() - 1;\n      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;\n      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;\n      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;\n      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;\n      var range = new Range(startRow, startCol, endRow, endCol);\n      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\n      this.applyDelta({\n        start: range.start,\n        end: range.end,\n        action: \"remove\",\n        lines: this.getLinesForRange(range)\n      });\n      return deletedLines;\n    };\n    Document.prototype.removeNewLine = function (row) {\n      if (row < this.getLength() - 1 && row >= 0) {\n        this.applyDelta({\n          start: this.pos(row, this.getLine(row).length),\n          end: this.pos(row + 1, 0),\n          action: \"remove\",\n          lines: [\"\", \"\"]\n        });\n      }\n    };\n    Document.prototype.replace = function (range, text) {\n      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);\n      if (text.length === 0 && range.isEmpty()) return range.start;\n      if (text == this.getTextRange(range)) return range.end;\n      this.remove(range);\n      var end;\n      if (text) {\n        end = this.insert(range.start, text);\n      } else {\n        end = range.start;\n      }\n      return end;\n    };\n    Document.prototype.applyDeltas = function (deltas) {\n      for (var i = 0; i < deltas.length; i++) {\n        this.applyDelta(deltas[i]);\n      }\n    };\n    Document.prototype.revertDeltas = function (deltas) {\n      for (var i = deltas.length - 1; i >= 0; i--) {\n        this.revertDelta(deltas[i]);\n      }\n    };\n    Document.prototype.applyDelta = function (delta, doNotValidate) {\n      var isInsert = delta.action == \"insert\";\n      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {\n        return;\n      }\n      if (isInsert && delta.lines.length > 20000) {\n        this.$splitAndapplyLargeDelta(delta, 20000);\n      } else {\n        applyDelta(this.$lines, delta, doNotValidate);\n        this._signal(\"change\", delta);\n      }\n    };\n    Document.prototype.$safeApplyDelta = function (delta) {\n      var docLength = this.$lines.length;\n      if (delta.action == \"remove\" && delta.start.row < docLength && delta.end.row < docLength || delta.action == \"insert\" && delta.start.row <= docLength) {\n        this.applyDelta(delta);\n      }\n    };\n    Document.prototype.$splitAndapplyLargeDelta = function (delta, MAX) {\n      var lines = delta.lines;\n      var l = lines.length - MAX + 1;\n      var row = delta.start.row;\n      var column = delta.start.column;\n      for (var from = 0, to = 0; from < l; from = to) {\n        to += MAX - 1;\n        var chunk = lines.slice(from, to);\n        chunk.push(\"\");\n        this.applyDelta({\n          start: this.pos(row + from, column),\n          end: this.pos(row + to, column = 0),\n          action: delta.action,\n          lines: chunk\n        }, true);\n      }\n      delta.lines = lines.slice(from);\n      delta.start.row = row + from;\n      delta.start.column = column;\n      this.applyDelta(delta, true);\n    };\n    Document.prototype.revertDelta = function (delta) {\n      this.$safeApplyDelta({\n        start: this.clonePos(delta.start),\n        end: this.clonePos(delta.end),\n        action: delta.action == \"insert\" ? \"remove\" : \"insert\",\n        lines: delta.lines.slice()\n      });\n    };\n    Document.prototype.indexToPosition = function (index, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      for (var i = startRow || 0, l = lines.length; i < l; i++) {\n        index -= lines[i].length + newlineLength;\n        if (index < 0) return {\n          row: i,\n          column: index + lines[i].length + newlineLength\n        };\n      }\n      return {\n        row: l - 1,\n        column: index + lines[l - 1].length + newlineLength\n      };\n    };\n    Document.prototype.positionToIndex = function (pos, startRow) {\n      var lines = this.$lines || this.getAllLines();\n      var newlineLength = this.getNewLineCharacter().length;\n      var index = 0;\n      var row = Math.min(pos.row, lines.length);\n      for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;\n      return index + pos.column;\n    };\n    Document.prototype.$split = function (text) {\n      return text.split(/\\r\\n|\\r|\\n/);\n    };\n    return Document;\n  }();\n  Document.prototype.$autoNewLine = \"\";\n  Document.prototype.$newLineMode = \"auto\";\n  oop.implement(Document.prototype, EventEmitter);\n  exports.Document = Document;\n});\nace.define(\"ace/lib/deep_copy\", [], function (require, exports, module) {\n  exports.deepCopy = function deepCopy(obj) {\n    if (typeof obj !== \"object\" || !obj) return obj;\n    var copy;\n    if (Array.isArray(obj)) {\n      copy = [];\n      for (var key = 0; key < obj.length; key++) {\n        copy[key] = deepCopy(obj[key]);\n      }\n      return copy;\n    }\n    if (Object.prototype.toString.call(obj) !== \"[object Object]\") return obj;\n    copy = {};\n    for (var key in obj) copy[key] = deepCopy(obj[key]);\n    return copy;\n  };\n});\nace.define(\"ace/lib/lang\", [], function (require, exports, module) {\n  \"use strict\";\n\n  exports.last = function (a) {\n    return a[a.length - 1];\n  };\n  exports.stringReverse = function (string) {\n    return string.split(\"\").reverse().join(\"\");\n  };\n  exports.stringRepeat = function (string, count) {\n    var result = '';\n    while (count > 0) {\n      if (count & 1) result += string;\n      if (count >>= 1) string += string;\n    }\n    return result;\n  };\n  var trimBeginRegexp = /^\\s\\s*/;\n  var trimEndRegexp = /\\s\\s*$/;\n  exports.stringTrimLeft = function (string) {\n    return string.replace(trimBeginRegexp, '');\n  };\n  exports.stringTrimRight = function (string) {\n    return string.replace(trimEndRegexp, '');\n  };\n  exports.copyObject = function (obj) {\n    var copy = {};\n    for (var key in obj) {\n      copy[key] = obj[key];\n    }\n    return copy;\n  };\n  exports.copyArray = function (array) {\n    var copy = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n      if (array[i] && typeof array[i] == \"object\") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];\n    }\n    return copy;\n  };\n  exports.deepCopy = require(\"./deep_copy\").deepCopy;\n  exports.arrayToMap = function (arr) {\n    var map = {};\n    for (var i = 0; i < arr.length; i++) {\n      map[arr[i]] = 1;\n    }\n    return map;\n  };\n  exports.createMap = function (props) {\n    var map = Object.create(null);\n    for (var i in props) {\n      map[i] = props[i];\n    }\n    return map;\n  };\n  exports.arrayRemove = function (array, value) {\n    for (var i = 0; i <= array.length; i++) {\n      if (value === array[i]) {\n        array.splice(i, 1);\n      }\n    }\n  };\n  exports.escapeRegExp = function (str) {\n    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  };\n  exports.escapeHTML = function (str) {\n    return (\"\" + str).replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n  };\n  exports.getMatchOffsets = function (string, regExp) {\n    var matches = [];\n    string.replace(regExp, function (str) {\n      matches.push({\n        offset: arguments[arguments.length - 2],\n        length: str.length\n      });\n    });\n    return matches;\n  };\n  exports.deferredCall = function (fcn) {\n    var timer = null;\n    var callback = function () {\n      timer = null;\n      fcn();\n    };\n    var deferred = function (timeout) {\n      deferred.cancel();\n      timer = setTimeout(callback, timeout || 0);\n      return deferred;\n    };\n    deferred.schedule = deferred;\n    deferred.call = function () {\n      this.cancel();\n      fcn();\n      return deferred;\n    };\n    deferred.cancel = function () {\n      clearTimeout(timer);\n      timer = null;\n      return deferred;\n    };\n    deferred.isPending = function () {\n      return timer;\n    };\n    return deferred;\n  };\n  exports.delayedCall = function (fcn, defaultTimeout) {\n    var timer = null;\n    var callback = function () {\n      timer = null;\n      fcn();\n    };\n    var _self = function (timeout) {\n      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.delay = function (timeout) {\n      timer && clearTimeout(timer);\n      timer = setTimeout(callback, timeout || defaultTimeout);\n    };\n    _self.schedule = _self;\n    _self.call = function () {\n      this.cancel();\n      fcn();\n    };\n    _self.cancel = function () {\n      timer && clearTimeout(timer);\n      timer = null;\n    };\n    _self.isPending = function () {\n      return timer;\n    };\n    return _self;\n  };\n  exports.supportsLookbehind = function () {\n    try {\n      new RegExp('(?<=.)');\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n  exports.skipEmptyMatch = function (line, last, supportsUnicodeFlag) {\n    return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;\n  };\n});\nace.define(\"ace/worker/mirror\", [], function (require, exports, module) {\n  \"use strict\";\n\n  var Document = require(\"../document\").Document;\n  var lang = require(\"../lib/lang\");\n  var Mirror = exports.Mirror = function (sender) {\n    this.sender = sender;\n    var doc = this.doc = new Document(\"\");\n    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));\n    var _self = this;\n    sender.on(\"change\", function (e) {\n      var data = e.data;\n      if (data[0].start) {\n        doc.applyDeltas(data);\n      } else {\n        for (var i = 0; i < data.length; i += 2) {\n          var d, err;\n          if (Array.isArray(data[i + 1])) {\n            d = {\n              action: \"insert\",\n              start: data[i],\n              lines: data[i + 1]\n            };\n          } else {\n            d = {\n              action: \"remove\",\n              start: data[i],\n              end: data[i + 1]\n            };\n          }\n          if ((d.action == \"insert\" ? d.start : d.end).row >= doc.$lines.length) {\n            err = new Error(\"Invalid delta\");\n            err.data = {\n              path: _self.$path,\n              linesLength: doc.$lines.length,\n              start: d.start,\n              end: d.end\n            };\n            throw err;\n          }\n          doc.applyDelta(d, true);\n        }\n      }\n      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);\n      _self.onUpdate();\n    });\n  };\n  (function () {\n    this.$timeout = 500;\n    this.setTimeout = function (timeout) {\n      this.$timeout = timeout;\n    };\n    this.setValue = function (value) {\n      this.doc.setValue(value);\n      this.deferredUpdate.schedule(this.$timeout);\n    };\n    this.getValue = function (callbackId) {\n      this.sender.callback(this.doc.getValue(), callbackId);\n    };\n    this.onUpdate = function () {};\n    this.isPending = function () {\n      return this.deferredUpdate.isPending();\n    };\n  }).call(Mirror.prototype);\n});\nace.define(\"ace/mode/yaml/yaml-lint\", [], function (require, exports, module) {\n  var $build_deps$ = {\n    require: require,\n    exports: exports,\n    module: module\n  };\n  exports = undefined;\n  module = undefined;\n  function define(name, deps, m) {\n    if (typeof name == \"function\") {\n      m = name;\n      deps = [\"require\", \"exports\", \"module\"];\n      name = $build_deps$.module.id;\n    }\n    if (typeof name !== \"string\") {\n      m = deps;\n      deps = name;\n      name = $build_deps$.module.id;\n    }\n    if (!m) {\n      m = deps;\n      deps = [];\n    }\n    var ret = typeof m == \"function\" ? m.apply($build_deps$.module, deps.map(function (n) {\n      return $build_deps$[n] || require(n);\n    })) : m;\n    if (ret != undefined) $build_deps$.module.exports = ret;\n  }\n  define.amd = true;\n  (function (f) {\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n      module.exports = f();\n    } else if (typeof define === \"function\" && define.amd) {\n      define([], f);\n    } else {\n      var g;\n      if (typeof window !== \"undefined\") {\n        g = window;\n      } else if (typeof global !== \"undefined\") {\n        g = global;\n      } else if (typeof self !== \"undefined\") {\n        g = self;\n      } else {\n        g = this;\n      }\n      g.lint = f();\n    }\n  })(function () {\n    var define, module, exports;\n    return function () {\n      function r(e, n, t) {\n        function o(i, f) {\n          if (!n[i]) {\n            if (!e[i]) {\n              var c = typeof require == \"function\" && require;\n              if (!f && c) return c(i, !0);\n              if (u) return u(i, !0);\n              var a = new Error(\"Cannot find module '\" + i + \"'\");\n              throw a.code = \"MODULE_NOT_FOUND\", a;\n            }\n            var p = n[i] = {\n              exports: {}\n            };\n            e[i][0].call(p.exports, function (r) {\n              var n = e[i][1][r];\n              return o(n || r);\n            }, p, p.exports, r, e, n, t);\n          }\n          return n[i].exports;\n        }\n        for (var u = typeof require == \"function\" && require, i = 0; i < t.length; i++) o(t[i]);\n        return o;\n      }\n      return r;\n    }()({\n      1: [function (require, module, exports) {}, {}],\n      2: [function (require, module, exports) {\n        var fs = require('fs');\n        var merge = require('lodash.merge');\n        var yaml = require('js-yaml');\n        var DEFAULT_LINT_OPTION = {\n          schema: 'DEFAULT_SAFE_SCHEMA'\n        };\n        function lint(content, opts, cb) {\n          var options = merge({}, DEFAULT_LINT_OPTION, opts);\n          try {\n            yaml.safeLoad(content, {\n              schema: yaml[options.schema]\n            });\n            cb();\n          } catch (e) {\n            cb(e);\n          }\n        }\n        module.exports = {\n          lint: lint\n        };\n      }, {\n        \"fs\": 1,\n        \"js-yaml\": 3,\n        \"lodash.merge\": 33\n      }],\n      3: [function (require, module, exports) {\n        'use strict';\n\n        var yaml = require('./lib/js-yaml.js');\n        module.exports = yaml;\n      }, {\n        \"./lib/js-yaml.js\": 4\n      }],\n      4: [function (require, module, exports) {\n        'use strict';\n\n        var loader = require('./js-yaml/loader');\n        var dumper = require('./js-yaml/dumper');\n        function deprecated(name) {\n          return function () {\n            throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n          };\n        }\n        module.exports.Type = require('./js-yaml/type');\n        module.exports.Schema = require('./js-yaml/schema');\n        module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');\n        module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');\n        module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');\n        module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n        module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\n        module.exports.load = loader.load;\n        module.exports.loadAll = loader.loadAll;\n        module.exports.safeLoad = loader.safeLoad;\n        module.exports.safeLoadAll = loader.safeLoadAll;\n        module.exports.dump = dumper.dump;\n        module.exports.safeDump = dumper.safeDump;\n        module.exports.YAMLException = require('./js-yaml/exception');\n        module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\n        module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n        module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n        module.exports.scan = deprecated('scan');\n        module.exports.parse = deprecated('parse');\n        module.exports.compose = deprecated('compose');\n        module.exports.addConstructor = deprecated('addConstructor');\n      }, {\n        \"./js-yaml/dumper\": 6,\n        \"./js-yaml/exception\": 7,\n        \"./js-yaml/loader\": 8,\n        \"./js-yaml/schema\": 10,\n        \"./js-yaml/schema/core\": 11,\n        \"./js-yaml/schema/default_full\": 12,\n        \"./js-yaml/schema/default_safe\": 13,\n        \"./js-yaml/schema/failsafe\": 14,\n        \"./js-yaml/schema/json\": 15,\n        \"./js-yaml/type\": 16\n      }],\n      5: [function (require, module, exports) {\n        'use strict';\n\n        function isNothing(subject) {\n          return typeof subject === 'undefined' || subject === null;\n        }\n        function isObject(subject) {\n          return typeof subject === 'object' && subject !== null;\n        }\n        function toArray(sequence) {\n          if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n          return [sequence];\n        }\n        function extend(target, source) {\n          var index, length, key, sourceKeys;\n          if (source) {\n            sourceKeys = Object.keys(source);\n            for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n              key = sourceKeys[index];\n              target[key] = source[key];\n            }\n          }\n          return target;\n        }\n        function repeat(string, count) {\n          var result = '',\n            cycle;\n          for (cycle = 0; cycle < count; cycle += 1) {\n            result += string;\n          }\n          return result;\n        }\n        function isNegativeZero(number) {\n          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n        }\n        module.exports.isNothing = isNothing;\n        module.exports.isObject = isObject;\n        module.exports.toArray = toArray;\n        module.exports.repeat = repeat;\n        module.exports.isNegativeZero = isNegativeZero;\n        module.exports.extend = extend;\n      }, {}],\n      6: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        var YAMLException = require('./exception');\n        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n        var _toString = Object.prototype.toString;\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        var CHAR_TAB = 0x09;\n        var CHAR_LINE_FEED = 0x0A;\n        var CHAR_SPACE = 0x20;\n        var CHAR_EXCLAMATION = 0x21;\n        var CHAR_DOUBLE_QUOTE = 0x22;\n        var CHAR_SHARP = 0x23;\n        var CHAR_PERCENT = 0x25;\n        var CHAR_AMPERSAND = 0x26;\n        var CHAR_SINGLE_QUOTE = 0x27;\n        var CHAR_ASTERISK = 0x2A;\n        var CHAR_COMMA = 0x2C;\n        var CHAR_MINUS = 0x2D;\n        var CHAR_COLON = 0x3A;\n        var CHAR_GREATER_THAN = 0x3E;\n        var CHAR_QUESTION = 0x3F;\n        var CHAR_COMMERCIAL_AT = 0x40;\n        var CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n        var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n        var CHAR_GRAVE_ACCENT = 0x60;\n        var CHAR_LEFT_CURLY_BRACKET = 0x7B;\n        var CHAR_VERTICAL_LINE = 0x7C;\n        var CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n        var ESCAPE_SEQUENCES = {};\n        ESCAPE_SEQUENCES[0x00] = '\\\\0';\n        ESCAPE_SEQUENCES[0x07] = '\\\\a';\n        ESCAPE_SEQUENCES[0x08] = '\\\\b';\n        ESCAPE_SEQUENCES[0x09] = '\\\\t';\n        ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n        ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n        ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n        ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n        ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n        ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n        ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n        ESCAPE_SEQUENCES[0x85] = '\\\\N';\n        ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n        ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n        ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n        var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n        function compileStyleMap(schema, map) {\n          var result, keys, index, length, tag, style, type;\n          if (map === null) return {};\n          result = {};\n          keys = Object.keys(map);\n          for (index = 0, length = keys.length; index < length; index += 1) {\n            tag = keys[index];\n            style = String(map[tag]);\n            if (tag.slice(0, 2) === '!!') {\n              tag = 'tag:yaml.org,2002:' + tag.slice(2);\n            }\n            type = schema.compiledTypeMap['fallback'][tag];\n            if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n              style = type.styleAliases[style];\n            }\n            result[tag] = style;\n          }\n          return result;\n        }\n        function encodeHex(character) {\n          var string, handle, length;\n          string = character.toString(16).toUpperCase();\n          if (character <= 0xFF) {\n            handle = 'x';\n            length = 2;\n          } else if (character <= 0xFFFF) {\n            handle = 'u';\n            length = 4;\n          } else if (character <= 0xFFFFFFFF) {\n            handle = 'U';\n            length = 8;\n          } else {\n            throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n          }\n          return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n        }\n        function State(options) {\n          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n          this.indent = Math.max(1, options['indent'] || 2);\n          this.noArrayIndent = options['noArrayIndent'] || false;\n          this.skipInvalid = options['skipInvalid'] || false;\n          this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n          this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n          this.sortKeys = options['sortKeys'] || false;\n          this.lineWidth = options['lineWidth'] || 80;\n          this.noRefs = options['noRefs'] || false;\n          this.noCompatMode = options['noCompatMode'] || false;\n          this.condenseFlow = options['condenseFlow'] || false;\n          this.implicitTypes = this.schema.compiledImplicit;\n          this.explicitTypes = this.schema.compiledExplicit;\n          this.tag = null;\n          this.result = '';\n          this.duplicates = [];\n          this.usedDuplicates = null;\n        }\n        function indentString(string, spaces) {\n          var ind = common.repeat(' ', spaces),\n            position = 0,\n            next = -1,\n            result = '',\n            line,\n            length = string.length;\n          while (position < length) {\n            next = string.indexOf('\\n', position);\n            if (next === -1) {\n              line = string.slice(position);\n              position = length;\n            } else {\n              line = string.slice(position, next + 1);\n              position = next + 1;\n            }\n            if (line.length && line !== '\\n') result += ind;\n            result += line;\n          }\n          return result;\n        }\n        function generateNextLine(state, level) {\n          return '\\n' + common.repeat(' ', state.indent * level);\n        }\n        function testImplicitResolving(state, str) {\n          var index, length, type;\n          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n            type = state.implicitTypes[index];\n            if (type.resolve(str)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function isWhitespace(c) {\n          return c === CHAR_SPACE || c === CHAR_TAB;\n        }\n        function isPrintable(c) {\n          return c >= 0x00020 && c <= 0x00007E || c >= 0x000A1 && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || c >= 0x0E000 && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || c >= 0x10000 && c <= 0x10FFFF;\n        }\n        function isPlainSafe(c) {\n          return isPrintable(c) && c !== 0xFEFF && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;\n        }\n        function isPlainSafeFirst(c) {\n          return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n          && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n        }\n        function needIndentIndicator(string) {\n          var leadingSpaceRe = /^\\n* /;\n          return leadingSpaceRe.test(string);\n        }\n        var STYLE_PLAIN = 1,\n          STYLE_SINGLE = 2,\n          STYLE_LITERAL = 3,\n          STYLE_FOLDED = 4,\n          STYLE_DOUBLE = 5;\n        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n          var i;\n          var char;\n          var hasLineBreak = false;\n          var hasFoldableLine = false; // only checked if shouldTrackWidth\n          var shouldTrackWidth = lineWidth !== -1;\n          var previousLineBreak = -1; // count the first line correctly\n          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n          if (singleLineOnly) {\n            for (i = 0; i < string.length; i++) {\n              char = string.charCodeAt(i);\n              if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n              }\n              plain = plain && isPlainSafe(char);\n            }\n          } else {\n            for (i = 0; i < string.length; i++) {\n              char = string.charCodeAt(i);\n              if (char === CHAR_LINE_FEED) {\n                hasLineBreak = true;\n                if (shouldTrackWidth) {\n                  hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n                  previousLineBreak = i;\n                }\n              } else if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n              }\n              plain = plain && isPlainSafe(char);\n            }\n            hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          }\n          if (!hasLineBreak && !hasFoldableLine) {\n            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n          }\n          if (indentPerLevel > 9 && needIndentIndicator(string)) {\n            return STYLE_DOUBLE;\n          }\n          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n        }\n        function writeScalar(state, string, level, iskey) {\n          state.dump = function () {\n            if (string.length === 0) {\n              return \"''\";\n            }\n            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n              return \"'\" + string + \"'\";\n            }\n            var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n            var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;\n            function testAmbiguity(string) {\n              return testImplicitResolving(state, string);\n            }\n            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n              case STYLE_PLAIN:\n                return string;\n              case STYLE_SINGLE:\n                return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n              case STYLE_LITERAL:\n                return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n              case STYLE_FOLDED:\n                return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n              case STYLE_DOUBLE:\n                return '\"' + escapeString(string, lineWidth) + '\"';\n              default:\n                throw new YAMLException('impossible error: invalid scalar style');\n            }\n          }();\n        }\n        function blockHeader(string, indentPerLevel) {\n          var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n          var clip = string[string.length - 1] === '\\n';\n          var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n          var chomp = keep ? '+' : clip ? '' : '-';\n          return indentIndicator + chomp + '\\n';\n        }\n        function dropEndingNewline(string) {\n          return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n        }\n        function foldString(string, width) {\n          var lineRe = /(\\n+)([^\\n]*)/g;\n          var result = function () {\n            var nextLF = string.indexOf('\\n');\n            nextLF = nextLF !== -1 ? nextLF : string.length;\n            lineRe.lastIndex = nextLF;\n            return foldLine(string.slice(0, nextLF), width);\n          }();\n          var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n          var moreIndented;\n          var match;\n          while (match = lineRe.exec(string)) {\n            var prefix = match[1],\n              line = match[2];\n            moreIndented = line[0] === ' ';\n            result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n            prevMoreIndented = moreIndented;\n          }\n          return result;\n        }\n        function foldLine(line, width) {\n          if (line === '' || line[0] === ' ') return line;\n          var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n          var match;\n          var start = 0,\n            end,\n            curr = 0,\n            next = 0;\n          var result = '';\n          while (match = breakRe.exec(line)) {\n            next = match.index;\n            if (next - start > width) {\n              end = curr > start ? curr : next; // derive end <= length-2\n              result += '\\n' + line.slice(start, end);\n              start = end + 1; // derive start <= length-1\n            }\n            curr = next;\n          }\n          result += '\\n';\n          if (line.length - start > width && curr > start) {\n            result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n          } else {\n            result += line.slice(start);\n          }\n          return result.slice(1); // drop extra \\n joiner\n        }\n        function escapeString(string) {\n          var result = '';\n          var char, nextChar;\n          var escapeSeq;\n          for (var i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n            if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {\n              nextChar = string.charCodeAt(i + 1);\n              if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {\n                result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n                i++;\n                continue;\n              }\n            }\n            escapeSeq = ESCAPE_SEQUENCES[char];\n            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n          }\n          return result;\n        }\n        function writeFlowSequence(state, level, object) {\n          var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n          for (index = 0, length = object.length; index < length; index += 1) {\n            if (writeNode(state, level, object[index], false, false)) {\n              if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n              _result += state.dump;\n            }\n          }\n          state.tag = _tag;\n          state.dump = '[' + _result + ']';\n        }\n        function writeBlockSequence(state, level, object, compact) {\n          var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n          for (index = 0, length = object.length; index < length; index += 1) {\n            if (writeNode(state, level + 1, object[index], true, true)) {\n              if (!compact || index !== 0) {\n                _result += generateNextLine(state, level);\n              }\n              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                _result += '-';\n              } else {\n                _result += '- ';\n              }\n              _result += state.dump;\n            }\n          }\n          state.tag = _tag;\n          state.dump = _result || '[]'; // Empty sequence if no valid values.\n        }\n        function writeFlowMapping(state, level, object) {\n          var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            pairBuffer;\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            pairBuffer = state.condenseFlow ? '\"' : '';\n            if (index !== 0) pairBuffer += ', ';\n            objectKey = objectKeyList[index];\n            objectValue = object[objectKey];\n            if (!writeNode(state, level, objectKey, false, false)) {\n              continue; // Skip this pair because of invalid key;\n            }\n            if (state.dump.length > 1024) pairBuffer += '? ';\n            pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n            if (!writeNode(state, level, objectValue, false, false)) {\n              continue; // Skip this pair because of invalid value.\n            }\n            pairBuffer += state.dump;\n            _result += pairBuffer;\n          }\n          state.tag = _tag;\n          state.dump = '{' + _result + '}';\n        }\n        function writeBlockMapping(state, level, object, compact) {\n          var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            explicitPair,\n            pairBuffer;\n          if (state.sortKeys === true) {\n            objectKeyList.sort();\n          } else if (typeof state.sortKeys === 'function') {\n            objectKeyList.sort(state.sortKeys);\n          } else if (state.sortKeys) {\n            throw new YAMLException('sortKeys must be a boolean or a function');\n          }\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            pairBuffer = '';\n            if (!compact || index !== 0) {\n              pairBuffer += generateNextLine(state, level);\n            }\n            objectKey = objectKeyList[index];\n            objectValue = object[objectKey];\n            if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n              continue; // Skip this pair because of invalid key.\n            }\n            explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n            if (explicitPair) {\n              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                pairBuffer += '?';\n              } else {\n                pairBuffer += '? ';\n              }\n            }\n            pairBuffer += state.dump;\n            if (explicitPair) {\n              pairBuffer += generateNextLine(state, level);\n            }\n            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n              continue; // Skip this pair because of invalid value.\n            }\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              pairBuffer += ':';\n            } else {\n              pairBuffer += ': ';\n            }\n            pairBuffer += state.dump;\n            _result += pairBuffer;\n          }\n          state.tag = _tag;\n          state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n        }\n        function detectType(state, object, explicit) {\n          var _result, typeList, index, length, type, style;\n          typeList = explicit ? state.explicitTypes : state.implicitTypes;\n          for (index = 0, length = typeList.length; index < length; index += 1) {\n            type = typeList[index];\n            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n              state.tag = explicit ? type.tag : '?';\n              if (type.represent) {\n                style = state.styleMap[type.tag] || type.defaultStyle;\n                if (_toString.call(type.represent) === '[object Function]') {\n                  _result = type.represent(object, style);\n                } else if (_hasOwnProperty.call(type.represent, style)) {\n                  _result = type.represent[style](object, style);\n                } else {\n                  throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n                }\n                state.dump = _result;\n              }\n              return true;\n            }\n          }\n          return false;\n        }\n        function writeNode(state, level, object, block, compact, iskey) {\n          state.tag = null;\n          state.dump = object;\n          if (!detectType(state, object, false)) {\n            detectType(state, object, true);\n          }\n          var type = _toString.call(state.dump);\n          if (block) {\n            block = state.flowLevel < 0 || state.flowLevel > level;\n          }\n          var objectOrArray = type === '[object Object]' || type === '[object Array]',\n            duplicateIndex,\n            duplicate;\n          if (objectOrArray) {\n            duplicateIndex = state.duplicates.indexOf(object);\n            duplicate = duplicateIndex !== -1;\n          }\n          if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n            compact = false;\n          }\n          if (duplicate && state.usedDuplicates[duplicateIndex]) {\n            state.dump = '*ref_' + duplicateIndex;\n          } else {\n            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n              state.usedDuplicates[duplicateIndex] = true;\n            }\n            if (type === '[object Object]') {\n              if (block && Object.keys(state.dump).length !== 0) {\n                writeBlockMapping(state, level, state.dump, compact);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + state.dump;\n                }\n              } else {\n                writeFlowMapping(state, level, state.dump);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n                }\n              }\n            } else if (type === '[object Array]') {\n              var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n              if (block && state.dump.length !== 0) {\n                writeBlockSequence(state, arrayLevel, state.dump, compact);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + state.dump;\n                }\n              } else {\n                writeFlowSequence(state, arrayLevel, state.dump);\n                if (duplicate) {\n                  state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n                }\n              }\n            } else if (type === '[object String]') {\n              if (state.tag !== '?') {\n                writeScalar(state, state.dump, level, iskey);\n              }\n            } else {\n              if (state.skipInvalid) return false;\n              throw new YAMLException('unacceptable kind of an object to dump ' + type);\n            }\n            if (state.tag !== null && state.tag !== '?') {\n              state.dump = '!<' + state.tag + '> ' + state.dump;\n            }\n          }\n          return true;\n        }\n        function getDuplicateReferences(object, state) {\n          var objects = [],\n            duplicatesIndexes = [],\n            index,\n            length;\n          inspectNode(object, objects, duplicatesIndexes);\n          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n            state.duplicates.push(objects[duplicatesIndexes[index]]);\n          }\n          state.usedDuplicates = new Array(length);\n        }\n        function inspectNode(object, objects, duplicatesIndexes) {\n          var objectKeyList, index, length;\n          if (object !== null && typeof object === 'object') {\n            index = objects.indexOf(object);\n            if (index !== -1) {\n              if (duplicatesIndexes.indexOf(index) === -1) {\n                duplicatesIndexes.push(index);\n              }\n            } else {\n              objects.push(object);\n              if (Array.isArray(object)) {\n                for (index = 0, length = object.length; index < length; index += 1) {\n                  inspectNode(object[index], objects, duplicatesIndexes);\n                }\n              } else {\n                objectKeyList = Object.keys(object);\n                for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n                }\n              }\n            }\n          }\n        }\n        function dump(input, options) {\n          options = options || {};\n          var state = new State(options);\n          if (!state.noRefs) getDuplicateReferences(input, state);\n          if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n          return '';\n        }\n        function safeDump(input, options) {\n          return dump(input, common.extend({\n            schema: DEFAULT_SAFE_SCHEMA\n          }, options));\n        }\n        module.exports.dump = dump;\n        module.exports.safeDump = safeDump;\n      }, {\n        \"./common\": 5,\n        \"./exception\": 7,\n        \"./schema/default_full\": 12,\n        \"./schema/default_safe\": 13\n      }],\n      7: [function (require, module, exports) {\n        'use strict';\n\n        function YAMLException(reason, mark) {\n          Error.call(this);\n          this.name = 'YAMLException';\n          this.reason = reason;\n          this.mark = mark;\n          this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n          } else {\n            this.stack = new Error().stack || '';\n          }\n        }\n        YAMLException.prototype = Object.create(Error.prototype);\n        YAMLException.prototype.constructor = YAMLException;\n        YAMLException.prototype.toString = function toString(compact) {\n          var result = this.name + ': ';\n          result += this.reason || '(unknown reason)';\n          if (!compact && this.mark) {\n            result += ' ' + this.mark.toString();\n          }\n          return result;\n        };\n        module.exports = YAMLException;\n      }, {}],\n      8: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        var YAMLException = require('./exception');\n        var Mark = require('./mark');\n        var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n        var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        var CONTEXT_FLOW_IN = 1;\n        var CONTEXT_FLOW_OUT = 2;\n        var CONTEXT_BLOCK_IN = 3;\n        var CONTEXT_BLOCK_OUT = 4;\n        var CHOMPING_CLIP = 1;\n        var CHOMPING_STRIP = 2;\n        var CHOMPING_KEEP = 3;\n        var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n        var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n        var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n        var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n        function is_EOL(c) {\n          return c === 0x0A /* LF */ || c === 0x0D /* CR */;\n        }\n        function is_WHITE_SPACE(c) {\n          return c === 0x09 /* Tab */ || c === 0x20 /* Space */;\n        }\n        function is_WS_OR_EOL(c) {\n          return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;\n        }\n        function is_FLOW_INDICATOR(c) {\n          return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;\n        }\n        function fromHexCode(c) {\n          var lc;\n          if (c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */) {\n            return c - 0x30;\n          }\n          lc = c | 0x20;\n          if (lc /* a */ >= 0x61 && lc <= 0x66 /* f */) {\n            return lc - 0x61 + 10;\n          }\n          return -1;\n        }\n        function escapedHexLen(c) {\n          if (c === 0x78 /* x */) {\n            return 2;\n          }\n          if (c === 0x75 /* u */) {\n            return 4;\n          }\n          if (c === 0x55 /* U */) {\n            return 8;\n          }\n          return 0;\n        }\n        function fromDecimalCode(c) {\n          if (c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */) {\n            return c - 0x30;\n          }\n          return -1;\n        }\n        function simpleEscapeSequence(c) {\n          return c === 0x30 /* 0 */ ? '\\x00' : c === 0x61 /* a */ ? '\\x07' : c === 0x62 /* b */ ? '\\x08' : c === 0x74 /* t */ ? '\\x09' : c === 0x09 /* Tab */ ? '\\x09' : c === 0x6E /* n */ ? '\\x0A' : c === 0x76 /* v */ ? '\\x0B' : c === 0x66 /* f */ ? '\\x0C' : c === 0x72 /* r */ ? '\\x0D' : c === 0x65 /* e */ ? '\\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* \" */ ? '\\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \\ */ ? '\\x5C' : c === 0x4E /* N */ ? '\\x85' : c === 0x5F /* _ */ ? '\\xA0' : c === 0x4C /* L */ ? '\\u2028' : c === 0x50 /* P */ ? '\\u2029' : '';\n        }\n        function charFromCodepoint(c) {\n          if (c <= 0xFFFF) {\n            return String.fromCharCode(c);\n          }\n          return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n        }\n        var simpleEscapeCheck = new Array(256); // integer, for fast access\n        var simpleEscapeMap = new Array(256);\n        for (var i = 0; i < 256; i++) {\n          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n          simpleEscapeMap[i] = simpleEscapeSequence(i);\n        }\n        function State(input, options) {\n          this.input = input;\n          this.filename = options['filename'] || null;\n          this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n          this.onWarning = options['onWarning'] || null;\n          this.legacy = options['legacy'] || false;\n          this.json = options['json'] || false;\n          this.listener = options['listener'] || null;\n          this.implicitTypes = this.schema.compiledImplicit;\n          this.typeMap = this.schema.compiledTypeMap;\n          this.length = input.length;\n          this.position = 0;\n          this.line = 0;\n          this.lineStart = 0;\n          this.lineIndent = 0;\n          this.documents = [];\n        }\n        function generateError(state, message) {\n          return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));\n        }\n        function throwError(state, message) {\n          throw generateError(state, message);\n        }\n        function throwWarning(state, message) {\n          if (state.onWarning) {\n            state.onWarning.call(null, generateError(state, message));\n          }\n        }\n        var directiveHandlers = {\n          YAML: function handleYamlDirective(state, name, args) {\n            var match, major, minor;\n            if (state.version !== null) {\n              throwError(state, 'duplication of %YAML directive');\n            }\n            if (args.length !== 1) {\n              throwError(state, 'YAML directive accepts exactly one argument');\n            }\n            match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n            if (match === null) {\n              throwError(state, 'ill-formed argument of the YAML directive');\n            }\n            major = parseInt(match[1], 10);\n            minor = parseInt(match[2], 10);\n            if (major !== 1) {\n              throwError(state, 'unacceptable YAML version of the document');\n            }\n            state.version = args[0];\n            state.checkLineBreaks = minor < 2;\n            if (minor !== 1 && minor !== 2) {\n              throwWarning(state, 'unsupported YAML version of the document');\n            }\n          },\n          TAG: function handleTagDirective(state, name, args) {\n            var handle, prefix;\n            if (args.length !== 2) {\n              throwError(state, 'TAG directive accepts exactly two arguments');\n            }\n            handle = args[0];\n            prefix = args[1];\n            if (!PATTERN_TAG_HANDLE.test(handle)) {\n              throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n            }\n            if (_hasOwnProperty.call(state.tagMap, handle)) {\n              throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n            }\n            if (!PATTERN_TAG_URI.test(prefix)) {\n              throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n            }\n            state.tagMap[handle] = prefix;\n          }\n        };\n        function captureSegment(state, start, end, checkJson) {\n          var _position, _length, _character, _result;\n          if (start < end) {\n            _result = state.input.slice(start, end);\n            if (checkJson) {\n              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n                _character = _result.charCodeAt(_position);\n                if (!(_character === 0x09 || _character >= 0x20 && _character <= 0x10FFFF)) {\n                  throwError(state, 'expected valid JSON character');\n                }\n              }\n            } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n              throwError(state, 'the stream contains non-printable characters');\n            }\n            state.result += _result;\n          }\n        }\n        function mergeMappings(state, destination, source, overridableKeys) {\n          var sourceKeys, key, index, quantity;\n          if (!common.isObject(source)) {\n            throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n          }\n          sourceKeys = Object.keys(source);\n          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n            key = sourceKeys[index];\n            if (!_hasOwnProperty.call(destination, key)) {\n              destination[key] = source[key];\n              overridableKeys[key] = true;\n            }\n          }\n        }\n        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n          var index, quantity;\n          keyNode = String(keyNode);\n          if (_result === null) {\n            _result = {};\n          }\n          if (keyTag === 'tag:yaml.org,2002:merge') {\n            if (Array.isArray(valueNode)) {\n              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n                mergeMappings(state, _result, valueNode[index], overridableKeys);\n              }\n            } else {\n              mergeMappings(state, _result, valueNode, overridableKeys);\n            }\n          } else {\n            if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {\n              state.line = startLine || state.line;\n              state.position = startPos || state.position;\n              throwError(state, 'duplicated mapping key');\n            }\n            _result[keyNode] = valueNode;\n            delete overridableKeys[keyNode];\n          }\n          return _result;\n        }\n        function readLineBreak(state) {\n          var ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch === 0x0A /* LF */) {\n            state.position++;\n          } else if (ch === 0x0D /* CR */) {\n            state.position++;\n            if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {\n              state.position++;\n            }\n          } else {\n            throwError(state, 'a line break is expected');\n          }\n          state.line += 1;\n          state.lineStart = state.position;\n        }\n        function skipSeparationSpace(state, allowComments, checkIndent) {\n          var lineBreaks = 0,\n            ch = state.input.charCodeAt(state.position);\n          while (ch !== 0) {\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            if (allowComments && ch === 0x23 /* # */) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);\n            }\n            if (is_EOL(ch)) {\n              readLineBreak(state);\n              ch = state.input.charCodeAt(state.position);\n              lineBreaks++;\n              state.lineIndent = 0;\n              while (ch === 0x20 /* Space */) {\n                state.lineIndent++;\n                ch = state.input.charCodeAt(++state.position);\n              }\n            } else {\n              break;\n            }\n          }\n          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n            throwWarning(state, 'deficient indentation');\n          }\n          return lineBreaks;\n        }\n        function testDocumentSeparator(state) {\n          var _position = state.position,\n            ch;\n          ch = state.input.charCodeAt(_position);\n          if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n            _position += 3;\n            ch = state.input.charCodeAt(_position);\n            if (ch === 0 || is_WS_OR_EOL(ch)) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function writeFoldedLines(state, count) {\n          if (count === 1) {\n            state.result += ' ';\n          } else if (count > 1) {\n            state.result += common.repeat('\\n', count - 1);\n          }\n        }\n        function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n          var preceding,\n            following,\n            captureStart,\n            captureEnd,\n            hasPendingContent,\n            _line,\n            _lineStart,\n            _lineIndent,\n            _kind = state.kind,\n            _result = state.result,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* \" */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {\n            return false;\n          }\n          if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {\n            following = state.input.charCodeAt(state.position + 1);\n            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n              return false;\n            }\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          captureStart = captureEnd = state.position;\n          hasPendingContent = false;\n          while (ch !== 0) {\n            if (ch === 0x3A /* : */) {\n              following = state.input.charCodeAt(state.position + 1);\n              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n                break;\n              }\n            } else if (ch === 0x23 /* # */) {\n              preceding = state.input.charCodeAt(state.position - 1);\n              if (is_WS_OR_EOL(preceding)) {\n                break;\n              }\n            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n              break;\n            } else if (is_EOL(ch)) {\n              _line = state.line;\n              _lineStart = state.lineStart;\n              _lineIndent = state.lineIndent;\n              skipSeparationSpace(state, false, -1);\n              if (state.lineIndent >= nodeIndent) {\n                hasPendingContent = true;\n                ch = state.input.charCodeAt(state.position);\n                continue;\n              } else {\n                state.position = captureEnd;\n                state.line = _line;\n                state.lineStart = _lineStart;\n                state.lineIndent = _lineIndent;\n                break;\n              }\n            }\n            if (hasPendingContent) {\n              captureSegment(state, captureStart, captureEnd, false);\n              writeFoldedLines(state, state.line - _line);\n              captureStart = captureEnd = state.position;\n              hasPendingContent = false;\n            }\n            if (!is_WHITE_SPACE(ch)) {\n              captureEnd = state.position + 1;\n            }\n            ch = state.input.charCodeAt(++state.position);\n          }\n          captureSegment(state, captureStart, captureEnd, false);\n          if (state.result) {\n            return true;\n          }\n          state.kind = _kind;\n          state.result = _result;\n          return false;\n        }\n        function readSingleQuotedScalar(state, nodeIndent) {\n          var ch, captureStart, captureEnd;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x27 /* ' */) {\n            return false;\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          state.position++;\n          captureStart = captureEnd = state.position;\n          while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n            if (ch === 0x27 /* ' */) {\n              captureSegment(state, captureStart, state.position, true);\n              ch = state.input.charCodeAt(++state.position);\n              if (ch === 0x27 /* ' */) {\n                captureStart = state.position;\n                state.position++;\n                captureEnd = state.position;\n              } else {\n                return true;\n              }\n            } else if (is_EOL(ch)) {\n              captureSegment(state, captureStart, captureEnd, true);\n              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n              captureStart = captureEnd = state.position;\n            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n              throwError(state, 'unexpected end of the document within a single quoted scalar');\n            } else {\n              state.position++;\n              captureEnd = state.position;\n            }\n          }\n          throwError(state, 'unexpected end of the stream within a single quoted scalar');\n        }\n        function readDoubleQuotedScalar(state, nodeIndent) {\n          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x22 /* \" */) {\n            return false;\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          state.position++;\n          captureStart = captureEnd = state.position;\n          while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n            if (ch === 0x22 /* \" */) {\n              captureSegment(state, captureStart, state.position, true);\n              state.position++;\n              return true;\n            } else if (ch === 0x5C /* \\ */) {\n              captureSegment(state, captureStart, state.position, true);\n              ch = state.input.charCodeAt(++state.position);\n              if (is_EOL(ch)) {\n                skipSeparationSpace(state, false, nodeIndent);\n              } else if (ch < 256 && simpleEscapeCheck[ch]) {\n                state.result += simpleEscapeMap[ch];\n                state.position++;\n              } else if ((tmp = escapedHexLen(ch)) > 0) {\n                hexLength = tmp;\n                hexResult = 0;\n                for (; hexLength > 0; hexLength--) {\n                  ch = state.input.charCodeAt(++state.position);\n                  if ((tmp = fromHexCode(ch)) >= 0) {\n                    hexResult = (hexResult << 4) + tmp;\n                  } else {\n                    throwError(state, 'expected hexadecimal character');\n                  }\n                }\n                state.result += charFromCodepoint(hexResult);\n                state.position++;\n              } else {\n                throwError(state, 'unknown escape sequence');\n              }\n              captureStart = captureEnd = state.position;\n            } else if (is_EOL(ch)) {\n              captureSegment(state, captureStart, captureEnd, true);\n              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n              captureStart = captureEnd = state.position;\n            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n              throwError(state, 'unexpected end of the document within a double quoted scalar');\n            } else {\n              state.position++;\n              captureEnd = state.position;\n            }\n          }\n          throwError(state, 'unexpected end of the stream within a double quoted scalar');\n        }\n        function readFlowCollection(state, nodeIndent) {\n          var readNext = true,\n            _line,\n            _tag = state.tag,\n            _result,\n            _anchor = state.anchor,\n            following,\n            terminator,\n            isPair,\n            isExplicitPair,\n            isMapping,\n            overridableKeys = {},\n            keyNode,\n            keyTag,\n            valueNode,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch === 0x5B /* [ */) {\n            terminator = 0x5D;\n            isMapping = false;\n            _result = [];\n          } else if (ch === 0x7B /* { */) {\n            terminator = 0x7D;\n            isMapping = true;\n            _result = {};\n          } else {\n            return false;\n          }\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = _result;\n          }\n          ch = state.input.charCodeAt(++state.position);\n          while (ch !== 0) {\n            skipSeparationSpace(state, true, nodeIndent);\n            ch = state.input.charCodeAt(state.position);\n            if (ch === terminator) {\n              state.position++;\n              state.tag = _tag;\n              state.anchor = _anchor;\n              state.kind = isMapping ? 'mapping' : 'sequence';\n              state.result = _result;\n              return true;\n            } else if (!readNext) {\n              throwError(state, 'missed comma between flow collection entries');\n            }\n            keyTag = keyNode = valueNode = null;\n            isPair = isExplicitPair = false;\n            if (ch === 0x3F /* ? */) {\n              following = state.input.charCodeAt(state.position + 1);\n              if (is_WS_OR_EOL(following)) {\n                isPair = isExplicitPair = true;\n                state.position++;\n                skipSeparationSpace(state, true, nodeIndent);\n              }\n            }\n            _line = state.line;\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            keyTag = state.tag;\n            keyNode = state.result;\n            skipSeparationSpace(state, true, nodeIndent);\n            ch = state.input.charCodeAt(state.position);\n            if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {\n              isPair = true;\n              ch = state.input.charCodeAt(++state.position);\n              skipSeparationSpace(state, true, nodeIndent);\n              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n              valueNode = state.result;\n            }\n            if (isMapping) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n            } else if (isPair) {\n              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n            } else {\n              _result.push(keyNode);\n            }\n            skipSeparationSpace(state, true, nodeIndent);\n            ch = state.input.charCodeAt(state.position);\n            if (ch === 0x2C /* , */) {\n              readNext = true;\n              ch = state.input.charCodeAt(++state.position);\n            } else {\n              readNext = false;\n            }\n          }\n          throwError(state, 'unexpected end of the stream within a flow collection');\n        }\n        function readBlockScalar(state, nodeIndent) {\n          var captureStart,\n            folding,\n            chomping = CHOMPING_CLIP,\n            didReadContent = false,\n            detectedIndent = false,\n            textIndent = nodeIndent,\n            emptyLines = 0,\n            atMoreIndented = false,\n            tmp,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch === 0x7C /* | */) {\n            folding = false;\n          } else if (ch === 0x3E /* > */) {\n            folding = true;\n          } else {\n            return false;\n          }\n          state.kind = 'scalar';\n          state.result = '';\n          while (ch !== 0) {\n            ch = state.input.charCodeAt(++state.position);\n            if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {\n              if (CHOMPING_CLIP === chomping) {\n                chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;\n              } else {\n                throwError(state, 'repeat of a chomping mode identifier');\n              }\n            } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n              if (tmp === 0) {\n                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n              } else if (!detectedIndent) {\n                textIndent = nodeIndent + tmp - 1;\n                detectedIndent = true;\n              } else {\n                throwError(state, 'repeat of an indentation width identifier');\n              }\n            } else {\n              break;\n            }\n          }\n          if (is_WHITE_SPACE(ch)) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (is_WHITE_SPACE(ch));\n            if (ch === 0x23 /* # */) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (!is_EOL(ch) && ch !== 0);\n            }\n          }\n          while (ch !== 0) {\n            readLineBreak(state);\n            state.lineIndent = 0;\n            ch = state.input.charCodeAt(state.position);\n            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {\n              state.lineIndent++;\n              ch = state.input.charCodeAt(++state.position);\n            }\n            if (!detectedIndent && state.lineIndent > textIndent) {\n              textIndent = state.lineIndent;\n            }\n            if (is_EOL(ch)) {\n              emptyLines++;\n              continue;\n            }\n            if (state.lineIndent < textIndent) {\n              if (chomping === CHOMPING_KEEP) {\n                state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n              } else if (chomping === CHOMPING_CLIP) {\n                if (didReadContent) {\n                  // i.e. only if the scalar is not empty.\n                  state.result += '\\n';\n                }\n              }\n              break;\n            }\n            if (folding) {\n              if (is_WHITE_SPACE(ch)) {\n                atMoreIndented = true;\n                state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n              } else if (atMoreIndented) {\n                atMoreIndented = false;\n                state.result += common.repeat('\\n', emptyLines + 1);\n              } else if (emptyLines === 0) {\n                if (didReadContent) {\n                  // i.e. only if we have already read some scalar content.\n                  state.result += ' ';\n                }\n              } else {\n                state.result += common.repeat('\\n', emptyLines);\n              }\n            } else {\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n            }\n            didReadContent = true;\n            detectedIndent = true;\n            emptyLines = 0;\n            captureStart = state.position;\n            while (!is_EOL(ch) && ch !== 0) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            captureSegment(state, captureStart, state.position, false);\n          }\n          return true;\n        }\n        function readBlockSequence(state, nodeIndent) {\n          var _line,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = [],\n            following,\n            detected = false,\n            ch;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = _result;\n          }\n          ch = state.input.charCodeAt(state.position);\n          while (ch !== 0) {\n            if (ch !== 0x2D /* - */) {\n              break;\n            }\n            following = state.input.charCodeAt(state.position + 1);\n            if (!is_WS_OR_EOL(following)) {\n              break;\n            }\n            detected = true;\n            state.position++;\n            if (skipSeparationSpace(state, true, -1)) {\n              if (state.lineIndent <= nodeIndent) {\n                _result.push(null);\n                ch = state.input.charCodeAt(state.position);\n                continue;\n              }\n            }\n            _line = state.line;\n            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n            _result.push(state.result);\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n              throwError(state, 'bad indentation of a sequence entry');\n            } else if (state.lineIndent < nodeIndent) {\n              break;\n            }\n          }\n          if (detected) {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = 'sequence';\n            state.result = _result;\n            return true;\n          }\n          return false;\n        }\n        function readBlockMapping(state, nodeIndent, flowIndent) {\n          var following,\n            allowCompact,\n            _line,\n            _pos,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = {},\n            overridableKeys = {},\n            keyTag = null,\n            keyNode = null,\n            valueNode = null,\n            atExplicitKey = false,\n            detected = false,\n            ch;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = _result;\n          }\n          ch = state.input.charCodeAt(state.position);\n          while (ch !== 0) {\n            following = state.input.charCodeAt(state.position + 1);\n            _line = state.line; // Save the current line.\n            _pos = state.position;\n            if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {\n              if (ch === 0x3F /* ? */) {\n                if (atExplicitKey) {\n                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                  keyTag = keyNode = valueNode = null;\n                }\n                detected = true;\n                atExplicitKey = true;\n                allowCompact = true;\n              } else if (atExplicitKey) {\n                atExplicitKey = false;\n                allowCompact = true;\n              } else {\n                throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n              }\n              state.position += 1;\n              ch = following;\n            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n              if (state.line === _line) {\n                ch = state.input.charCodeAt(state.position);\n                while (is_WHITE_SPACE(ch)) {\n                  ch = state.input.charCodeAt(++state.position);\n                }\n                if (ch === 0x3A /* : */) {\n                  ch = state.input.charCodeAt(++state.position);\n                  if (!is_WS_OR_EOL(ch)) {\n                    throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n                  }\n                  if (atExplicitKey) {\n                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                    keyTag = keyNode = valueNode = null;\n                  }\n                  detected = true;\n                  atExplicitKey = false;\n                  allowCompact = false;\n                  keyTag = state.tag;\n                  keyNode = state.result;\n                } else if (detected) {\n                  throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n                } else {\n                  state.tag = _tag;\n                  state.anchor = _anchor;\n                  return true; // Keep the result of `composeNode`.\n                }\n              } else if (detected) {\n                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n              } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n              }\n            } else {\n              break; // Reading is done. Go to the epilogue.\n            }\n            if (state.line === _line || state.lineIndent > nodeIndent) {\n              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n                if (atExplicitKey) {\n                  keyNode = state.result;\n                } else {\n                  valueNode = state.result;\n                }\n              }\n              if (!atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n                keyTag = keyNode = valueNode = null;\n              }\n              skipSeparationSpace(state, true, -1);\n              ch = state.input.charCodeAt(state.position);\n            }\n            if (state.lineIndent > nodeIndent && ch !== 0) {\n              throwError(state, 'bad indentation of a mapping entry');\n            } else if (state.lineIndent < nodeIndent) {\n              break;\n            }\n          }\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          }\n          if (detected) {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = 'mapping';\n            state.result = _result;\n          }\n          return detected;\n        }\n        function readTagProperty(state) {\n          var _position,\n            isVerbatim = false,\n            isNamed = false,\n            tagHandle,\n            tagName,\n            ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x21 /* ! */) return false;\n          if (state.tag !== null) {\n            throwError(state, 'duplication of a tag property');\n          }\n          ch = state.input.charCodeAt(++state.position);\n          if (ch === 0x3C /* < */) {\n            isVerbatim = true;\n            ch = state.input.charCodeAt(++state.position);\n          } else if (ch === 0x21 /* ! */) {\n            isNamed = true;\n            tagHandle = '!!';\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            tagHandle = '!';\n          }\n          _position = state.position;\n          if (isVerbatim) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0 && ch !== 0x3E /* > */);\n            if (state.position < state.length) {\n              tagName = state.input.slice(_position, state.position);\n              ch = state.input.charCodeAt(++state.position);\n            } else {\n              throwError(state, 'unexpected end of the stream within a verbatim tag');\n            }\n          } else {\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              if (ch === 0x21 /* ! */) {\n                if (!isNamed) {\n                  tagHandle = state.input.slice(_position - 1, state.position + 1);\n                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                    throwError(state, 'named tag handle cannot contain such characters');\n                  }\n                  isNamed = true;\n                  _position = state.position + 1;\n                } else {\n                  throwError(state, 'tag suffix cannot contain exclamation marks');\n                }\n              }\n              ch = state.input.charCodeAt(++state.position);\n            }\n            tagName = state.input.slice(_position, state.position);\n            if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n              throwError(state, 'tag suffix cannot contain flow indicator characters');\n            }\n          }\n          if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n            throwError(state, 'tag name cannot contain such characters: ' + tagName);\n          }\n          if (isVerbatim) {\n            state.tag = tagName;\n          } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n            state.tag = state.tagMap[tagHandle] + tagName;\n          } else if (tagHandle === '!') {\n            state.tag = '!' + tagName;\n          } else if (tagHandle === '!!') {\n            state.tag = 'tag:yaml.org,2002:' + tagName;\n          } else {\n            throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n          }\n          return true;\n        }\n        function readAnchorProperty(state) {\n          var _position, ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x26 /* & */) return false;\n          if (state.anchor !== null) {\n            throwError(state, 'duplication of an anchor property');\n          }\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (state.position === _position) {\n            throwError(state, 'name of an anchor node must contain at least one character');\n          }\n          state.anchor = state.input.slice(_position, state.position);\n          return true;\n        }\n        function readAlias(state) {\n          var _position, alias, ch;\n          ch = state.input.charCodeAt(state.position);\n          if (ch !== 0x2A /* * */) return false;\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n          if (state.position === _position) {\n            throwError(state, 'name of an alias node must contain at least one character');\n          }\n          alias = state.input.slice(_position, state.position);\n          if (!state.anchorMap.hasOwnProperty(alias)) {\n            throwError(state, 'unidentified alias \"' + alias + '\"');\n          }\n          state.result = state.anchorMap[alias];\n          skipSeparationSpace(state, true, -1);\n          return true;\n        }\n        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n          var allowBlockStyles,\n            allowBlockScalars,\n            allowBlockCollections,\n            indentStatus = 1,\n            // 1: this>parent, 0: this=parent, -1: this<parent\n            atNewLine = false,\n            hasContent = false,\n            typeIndex,\n            typeQuantity,\n            type,\n            flowIndent,\n            blockIndent;\n          if (state.listener !== null) {\n            state.listener('open', state);\n          }\n          state.tag = null;\n          state.anchor = null;\n          state.kind = null;\n          state.result = null;\n          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n          if (allowToSeek) {\n            if (skipSeparationSpace(state, true, -1)) {\n              atNewLine = true;\n              if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n              } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n              } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n              }\n            }\n          }\n          if (indentStatus === 1) {\n            while (readTagProperty(state) || readAnchorProperty(state)) {\n              if (skipSeparationSpace(state, true, -1)) {\n                atNewLine = true;\n                allowBlockCollections = allowBlockStyles;\n                if (state.lineIndent > parentIndent) {\n                  indentStatus = 1;\n                } else if (state.lineIndent === parentIndent) {\n                  indentStatus = 0;\n                } else if (state.lineIndent < parentIndent) {\n                  indentStatus = -1;\n                }\n              } else {\n                allowBlockCollections = false;\n              }\n            }\n          }\n          if (allowBlockCollections) {\n            allowBlockCollections = atNewLine || allowCompact;\n          }\n          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n              flowIndent = parentIndent;\n            } else {\n              flowIndent = parentIndent + 1;\n            }\n            blockIndent = state.position - state.lineStart;\n            if (indentStatus === 1) {\n              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n                hasContent = true;\n              } else {\n                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n                  hasContent = true;\n                } else if (readAlias(state)) {\n                  hasContent = true;\n                  if (state.tag !== null || state.anchor !== null) {\n                    throwError(state, 'alias node should not have any properties');\n                  }\n                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                  hasContent = true;\n                  if (state.tag === null) {\n                    state.tag = '?';\n                  }\n                }\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n              }\n            } else if (indentStatus === 0) {\n              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n            }\n          }\n          if (state.tag !== null && state.tag !== '!') {\n            if (state.tag === '?') {\n              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n                type = state.implicitTypes[typeIndex];\n                if (type.resolve(state.result)) {\n                  // `state.result` updated in resolver if matched\n                  state.result = type.construct(state.result);\n                  state.tag = type.tag;\n                  if (state.anchor !== null) {\n                    state.anchorMap[state.anchor] = state.result;\n                  }\n                  break;\n                }\n              }\n            } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n              type = state.typeMap[state.kind || 'fallback'][state.tag];\n              if (state.result !== null && type.kind !== state.kind) {\n                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n              }\n              if (!type.resolve(state.result)) {\n                // `state.result` updated in resolver if matched\n                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n              } else {\n                state.result = type.construct(state.result);\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n              }\n            } else {\n              throwError(state, 'unknown tag !<' + state.tag + '>');\n            }\n          }\n          if (state.listener !== null) {\n            state.listener('close', state);\n          }\n          return state.tag !== null || state.anchor !== null || hasContent;\n        }\n        function readDocument(state) {\n          var documentStart = state.position,\n            _position,\n            directiveName,\n            directiveArgs,\n            hasDirectives = false,\n            ch;\n          state.version = null;\n          state.checkLineBreaks = state.legacy;\n          state.tagMap = {};\n          state.anchorMap = {};\n          while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n            if (state.lineIndent > 0 || ch !== 0x25 /* % */) {\n              break;\n            }\n            hasDirectives = true;\n            ch = state.input.charCodeAt(++state.position);\n            _position = state.position;\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n            directiveName = state.input.slice(_position, state.position);\n            directiveArgs = [];\n            if (directiveName.length < 1) {\n              throwError(state, 'directive name must not be less than one character in length');\n            }\n            while (ch !== 0) {\n              while (is_WHITE_SPACE(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n              if (ch === 0x23 /* # */) {\n                do {\n                  ch = state.input.charCodeAt(++state.position);\n                } while (ch !== 0 && !is_EOL(ch));\n                break;\n              }\n              if (is_EOL(ch)) break;\n              _position = state.position;\n              while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n              directiveArgs.push(state.input.slice(_position, state.position));\n            }\n            if (ch !== 0) readLineBreak(state);\n            if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n              directiveHandlers[directiveName](state, directiveName, directiveArgs);\n            } else {\n              throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n            }\n          }\n          skipSeparationSpace(state, true, -1);\n          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n          } else if (hasDirectives) {\n            throwError(state, 'directives end mark is expected');\n          }\n          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n          skipSeparationSpace(state, true, -1);\n          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n            throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n          }\n          state.documents.push(state.result);\n          if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            if (state.input.charCodeAt(state.position) === 0x2E /* . */) {\n              state.position += 3;\n              skipSeparationSpace(state, true, -1);\n            }\n            return;\n          }\n          if (state.position < state.length - 1) {\n            throwError(state, 'end of the stream or a document separator is expected');\n          } else {\n            return;\n          }\n        }\n        function loadDocuments(input, options) {\n          input = String(input);\n          options = options || {};\n          if (input.length !== 0) {\n            if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {\n              input += '\\n';\n            }\n            if (input.charCodeAt(0) === 0xFEFF) {\n              input = input.slice(1);\n            }\n          }\n          var state = new State(input, options);\n          state.input += '\\0';\n          while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {\n            state.lineIndent += 1;\n            state.position += 1;\n          }\n          while (state.position < state.length - 1) {\n            readDocument(state);\n          }\n          return state.documents;\n        }\n        function loadAll(input, iterator, options) {\n          var documents = loadDocuments(input, options),\n            index,\n            length;\n          if (typeof iterator !== 'function') {\n            return documents;\n          }\n          for (index = 0, length = documents.length; index < length; index += 1) {\n            iterator(documents[index]);\n          }\n        }\n        function load(input, options) {\n          var documents = loadDocuments(input, options);\n          if (documents.length === 0) {\n            return undefined;\n          } else if (documents.length === 1) {\n            return documents[0];\n          }\n          throw new YAMLException('expected a single document in the stream, but found more');\n        }\n        function safeLoadAll(input, output, options) {\n          if (typeof output === 'function') {\n            loadAll(input, output, common.extend({\n              schema: DEFAULT_SAFE_SCHEMA\n            }, options));\n          } else {\n            return loadAll(input, common.extend({\n              schema: DEFAULT_SAFE_SCHEMA\n            }, options));\n          }\n        }\n        function safeLoad(input, options) {\n          return load(input, common.extend({\n            schema: DEFAULT_SAFE_SCHEMA\n          }, options));\n        }\n        module.exports.loadAll = loadAll;\n        module.exports.load = load;\n        module.exports.safeLoadAll = safeLoadAll;\n        module.exports.safeLoad = safeLoad;\n      }, {\n        \"./common\": 5,\n        \"./exception\": 7,\n        \"./mark\": 9,\n        \"./schema/default_full\": 12,\n        \"./schema/default_safe\": 13\n      }],\n      9: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        function Mark(name, buffer, position, line, column) {\n          this.name = name;\n          this.buffer = buffer;\n          this.position = position;\n          this.line = line;\n          this.column = column;\n        }\n        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n          var head, start, tail, end, snippet;\n          if (!this.buffer) return null;\n          indent = indent || 4;\n          maxLength = maxLength || 75;\n          head = '';\n          start = this.position;\n          while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n            start -= 1;\n            if (this.position - start > maxLength / 2 - 1) {\n              head = ' ... ';\n              start += 5;\n              break;\n            }\n          }\n          tail = '';\n          end = this.position;\n          while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n            end += 1;\n            if (end - this.position > maxLength / 2 - 1) {\n              tail = ' ... ';\n              end -= 5;\n              break;\n            }\n          }\n          snippet = this.buffer.slice(start, end);\n          return common.repeat(' ', indent) + head + snippet + tail + '\\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';\n        };\n        Mark.prototype.toString = function toString(compact) {\n          var snippet,\n            where = '';\n          if (this.name) {\n            where += 'in \"' + this.name + '\" ';\n          }\n          where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n          if (!compact) {\n            snippet = this.getSnippet();\n            if (snippet) {\n              where += ':\\n' + snippet;\n            }\n          }\n          return where;\n        };\n        module.exports = Mark;\n      }, {\n        \"./common\": 5\n      }],\n      10: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('./common');\n        var YAMLException = require('./exception');\n        var Type = require('./type');\n        function compileList(schema, name, result) {\n          var exclude = [];\n          schema.include.forEach(function (includedSchema) {\n            result = compileList(includedSchema, name, result);\n          });\n          schema[name].forEach(function (currentType) {\n            result.forEach(function (previousType, previousIndex) {\n              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n                exclude.push(previousIndex);\n              }\n            });\n            result.push(currentType);\n          });\n          return result.filter(function (type, index) {\n            return exclude.indexOf(index) === -1;\n          });\n        }\n        function compileMap( /* lists... */\n        ) {\n          var result = {\n              scalar: {},\n              sequence: {},\n              mapping: {},\n              fallback: {}\n            },\n            index,\n            length;\n          function collectType(type) {\n            result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n          }\n          for (index = 0, length = arguments.length; index < length; index += 1) {\n            arguments[index].forEach(collectType);\n          }\n          return result;\n        }\n        function Schema(definition) {\n          this.include = definition.include || [];\n          this.implicit = definition.implicit || [];\n          this.explicit = definition.explicit || [];\n          this.implicit.forEach(function (type) {\n            if (type.loadKind && type.loadKind !== 'scalar') {\n              throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n            }\n          });\n          this.compiledImplicit = compileList(this, 'implicit', []);\n          this.compiledExplicit = compileList(this, 'explicit', []);\n          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n        }\n        Schema.DEFAULT = null;\n        Schema.create = function createSchema() {\n          var schemas, types;\n          switch (arguments.length) {\n            case 1:\n              schemas = Schema.DEFAULT;\n              types = arguments[0];\n              break;\n            case 2:\n              schemas = arguments[0];\n              types = arguments[1];\n              break;\n            default:\n              throw new YAMLException('Wrong number of arguments for Schema.create function');\n          }\n          schemas = common.toArray(schemas);\n          types = common.toArray(types);\n          if (!schemas.every(function (schema) {\n            return schema instanceof Schema;\n          })) {\n            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n          }\n          if (!types.every(function (type) {\n            return type instanceof Type;\n          })) {\n            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n          }\n          return new Schema({\n            include: schemas,\n            explicit: types\n          });\n        };\n        module.exports = Schema;\n      }, {\n        \"./common\": 5,\n        \"./exception\": 7,\n        \"./type\": 16\n      }],\n      11: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          include: [require('./json')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"./json\": 15\n      }],\n      12: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = Schema.DEFAULT = new Schema({\n          include: [require('./default_safe')],\n          explicit: [require('../type/js/undefined'), require('../type/js/regexp'), require('../type/js/function')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/js/function\": 21,\n        \"../type/js/regexp\": 22,\n        \"../type/js/undefined\": 23,\n        \"./default_safe\": 13\n      }],\n      13: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          include: [require('./core')],\n          implicit: [require('../type/timestamp'), require('../type/merge')],\n          explicit: [require('../type/binary'), require('../type/omap'), require('../type/pairs'), require('../type/set')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/binary\": 17,\n        \"../type/merge\": 25,\n        \"../type/omap\": 27,\n        \"../type/pairs\": 28,\n        \"../type/set\": 30,\n        \"../type/timestamp\": 32,\n        \"./core\": 11\n      }],\n      14: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          explicit: [require('../type/str'), require('../type/seq'), require('../type/map')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/map\": 24,\n        \"../type/seq\": 29,\n        \"../type/str\": 31\n      }],\n      15: [function (require, module, exports) {\n        'use strict';\n\n        var Schema = require('../schema');\n        module.exports = new Schema({\n          include: [require('./failsafe')],\n          implicit: [require('../type/null'), require('../type/bool'), require('../type/int'), require('../type/float')]\n        });\n      }, {\n        \"../schema\": 10,\n        \"../type/bool\": 18,\n        \"../type/float\": 19,\n        \"../type/int\": 20,\n        \"../type/null\": 26,\n        \"./failsafe\": 14\n      }],\n      16: [function (require, module, exports) {\n        'use strict';\n\n        var YAMLException = require('./exception');\n        var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];\n        var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n        function compileStyleAliases(map) {\n          var result = {};\n          if (map !== null) {\n            Object.keys(map).forEach(function (style) {\n              map[style].forEach(function (alias) {\n                result[String(alias)] = style;\n              });\n            });\n          }\n          return result;\n        }\n        function Type(tag, options) {\n          options = options || {};\n          Object.keys(options).forEach(function (name) {\n            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n              throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n            }\n          });\n          this.tag = tag;\n          this.kind = options['kind'] || null;\n          this.resolve = options['resolve'] || function () {\n            return true;\n          };\n          this.construct = options['construct'] || function (data) {\n            return data;\n          };\n          this.instanceOf = options['instanceOf'] || null;\n          this.predicate = options['predicate'] || null;\n          this.represent = options['represent'] || null;\n          this.defaultStyle = options['defaultStyle'] || null;\n          this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n            throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n          }\n        }\n        module.exports = Type;\n      }, {\n        \"./exception\": 7\n      }],\n      17: [function (require, module, exports) {\n        'use strict';\n\n        var NodeBuffer;\n        try {\n          var _require = require;\n          NodeBuffer = _require('buffer').Buffer;\n        } catch (__) {}\n        var Type = require('../type');\n        var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n        function resolveYamlBinary(data) {\n          if (data === null) return false;\n          var code,\n            idx,\n            bitlen = 0,\n            max = data.length,\n            map = BASE64_MAP;\n          for (idx = 0; idx < max; idx++) {\n            code = map.indexOf(data.charAt(idx));\n            if (code > 64) continue;\n            if (code < 0) return false;\n            bitlen += 6;\n          }\n          return bitlen % 8 === 0;\n        }\n        function constructYamlBinary(data) {\n          var idx,\n            tailbits,\n            input = data.replace(/[\\r\\n=]/g, ''),\n            // remove CR/LF & padding to simplify scan\n            max = input.length,\n            map = BASE64_MAP,\n            bits = 0,\n            result = [];\n          for (idx = 0; idx < max; idx++) {\n            if (idx % 4 === 0 && idx) {\n              result.push(bits >> 16 & 0xFF);\n              result.push(bits >> 8 & 0xFF);\n              result.push(bits & 0xFF);\n            }\n            bits = bits << 6 | map.indexOf(input.charAt(idx));\n          }\n          tailbits = max % 4 * 6;\n          if (tailbits === 0) {\n            result.push(bits >> 16 & 0xFF);\n            result.push(bits >> 8 & 0xFF);\n            result.push(bits & 0xFF);\n          } else if (tailbits === 18) {\n            result.push(bits >> 10 & 0xFF);\n            result.push(bits >> 2 & 0xFF);\n          } else if (tailbits === 12) {\n            result.push(bits >> 4 & 0xFF);\n          }\n          if (NodeBuffer) {\n            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n          }\n          return result;\n        }\n        function representYamlBinary(object /*, style*/) {\n          var result = '',\n            bits = 0,\n            idx,\n            tail,\n            max = object.length,\n            map = BASE64_MAP;\n          for (idx = 0; idx < max; idx++) {\n            if (idx % 3 === 0 && idx) {\n              result += map[bits >> 18 & 0x3F];\n              result += map[bits >> 12 & 0x3F];\n              result += map[bits >> 6 & 0x3F];\n              result += map[bits & 0x3F];\n            }\n            bits = (bits << 8) + object[idx];\n          }\n          tail = max % 3;\n          if (tail === 0) {\n            result += map[bits >> 18 & 0x3F];\n            result += map[bits >> 12 & 0x3F];\n            result += map[bits >> 6 & 0x3F];\n            result += map[bits & 0x3F];\n          } else if (tail === 2) {\n            result += map[bits >> 10 & 0x3F];\n            result += map[bits >> 4 & 0x3F];\n            result += map[bits << 2 & 0x3F];\n            result += map[64];\n          } else if (tail === 1) {\n            result += map[bits >> 2 & 0x3F];\n            result += map[bits << 4 & 0x3F];\n            result += map[64];\n            result += map[64];\n          }\n          return result;\n        }\n        function isBinary(object) {\n          return NodeBuffer && NodeBuffer.isBuffer(object);\n        }\n        module.exports = new Type('tag:yaml.org,2002:binary', {\n          kind: 'scalar',\n          resolve: resolveYamlBinary,\n          construct: constructYamlBinary,\n          predicate: isBinary,\n          represent: representYamlBinary\n        });\n      }, {\n        \"../type\": 16\n      }],\n      18: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        function resolveYamlBoolean(data) {\n          if (data === null) return false;\n          var max = data.length;\n          return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n        }\n        function constructYamlBoolean(data) {\n          return data === 'true' || data === 'True' || data === 'TRUE';\n        }\n        function isBoolean(object) {\n          return Object.prototype.toString.call(object) === '[object Boolean]';\n        }\n        module.exports = new Type('tag:yaml.org,2002:bool', {\n          kind: 'scalar',\n          resolve: resolveYamlBoolean,\n          construct: constructYamlBoolean,\n          predicate: isBoolean,\n          represent: {\n            lowercase: function (object) {\n              return object ? 'true' : 'false';\n            },\n            uppercase: function (object) {\n              return object ? 'TRUE' : 'FALSE';\n            },\n            camelcase: function (object) {\n              return object ? 'True' : 'False';\n            }\n          },\n          defaultStyle: 'lowercase'\n        });\n      }, {\n        \"../type\": 16\n      }],\n      19: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('../common');\n        var Type = require('../type');\n        var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' + '|[-+]?\\\\.(?:inf|Inf|INF)' + '|\\\\.(?:nan|NaN|NAN))$');\n        function resolveYamlFloat(data) {\n          if (data === null) return false;\n          if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === '_') {\n            return false;\n          }\n          return true;\n        }\n        function constructYamlFloat(data) {\n          var value, sign, base, digits;\n          value = data.replace(/_/g, '').toLowerCase();\n          sign = value[0] === '-' ? -1 : 1;\n          digits = [];\n          if ('+-'.indexOf(value[0]) >= 0) {\n            value = value.slice(1);\n          }\n          if (value === '.inf') {\n            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n          } else if (value === '.nan') {\n            return NaN;\n          } else if (value.indexOf(':') >= 0) {\n            value.split(':').forEach(function (v) {\n              digits.unshift(parseFloat(v, 10));\n            });\n            value = 0.0;\n            base = 1;\n            digits.forEach(function (d) {\n              value += d * base;\n              base *= 60;\n            });\n            return sign * value;\n          }\n          return sign * parseFloat(value, 10);\n        }\n        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n        function representYamlFloat(object, style) {\n          var res;\n          if (isNaN(object)) {\n            switch (style) {\n              case 'lowercase':\n                return '.nan';\n              case 'uppercase':\n                return '.NAN';\n              case 'camelcase':\n                return '.NaN';\n            }\n          } else if (Number.POSITIVE_INFINITY === object) {\n            switch (style) {\n              case 'lowercase':\n                return '.inf';\n              case 'uppercase':\n                return '.INF';\n              case 'camelcase':\n                return '.Inf';\n            }\n          } else if (Number.NEGATIVE_INFINITY === object) {\n            switch (style) {\n              case 'lowercase':\n                return '-.inf';\n              case 'uppercase':\n                return '-.INF';\n              case 'camelcase':\n                return '-.Inf';\n            }\n          } else if (common.isNegativeZero(object)) {\n            return '-0.0';\n          }\n          res = object.toString(10);\n          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n        }\n        function isFloat(object) {\n          return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n        }\n        module.exports = new Type('tag:yaml.org,2002:float', {\n          kind: 'scalar',\n          resolve: resolveYamlFloat,\n          construct: constructYamlFloat,\n          predicate: isFloat,\n          represent: representYamlFloat,\n          defaultStyle: 'lowercase'\n        });\n      }, {\n        \"../common\": 5,\n        \"../type\": 16\n      }],\n      20: [function (require, module, exports) {\n        'use strict';\n\n        var common = require('../common');\n        var Type = require('../type');\n        function isHexCode(c) {\n          return c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */ || c /* A */ >= 0x41 && c <= 0x46 /* F */ || c /* a */ >= 0x61 && c <= 0x66 /* f */;\n        }\n        function isOctCode(c) {\n          return c /* 0 */ >= 0x30 && c <= 0x37 /* 7 */;\n        }\n        function isDecCode(c) {\n          return c /* 0 */ >= 0x30 && c <= 0x39 /* 9 */;\n        }\n        function resolveYamlInteger(data) {\n          if (data === null) return false;\n          var max = data.length,\n            index = 0,\n            hasDigits = false,\n            ch;\n          if (!max) return false;\n          ch = data[index];\n          if (ch === '-' || ch === '+') {\n            ch = data[++index];\n          }\n          if (ch === '0') {\n            if (index + 1 === max) return true;\n            ch = data[++index];\n            if (ch === 'b') {\n              index++;\n              for (; index < max; index++) {\n                ch = data[index];\n                if (ch === '_') continue;\n                if (ch !== '0' && ch !== '1') return false;\n                hasDigits = true;\n              }\n              return hasDigits && ch !== '_';\n            }\n            if (ch === 'x') {\n              index++;\n              for (; index < max; index++) {\n                ch = data[index];\n                if (ch === '_') continue;\n                if (!isHexCode(data.charCodeAt(index))) return false;\n                hasDigits = true;\n              }\n              return hasDigits && ch !== '_';\n            }\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (!isOctCode(data.charCodeAt(index))) return false;\n              hasDigits = true;\n            }\n            return hasDigits && ch !== '_';\n          }\n          if (ch === '_') return false;\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === '_') continue;\n            if (ch === ':') break;\n            if (!isDecCode(data.charCodeAt(index))) {\n              return false;\n            }\n            hasDigits = true;\n          }\n          if (!hasDigits || ch === '_') return false;\n          if (ch !== ':') return true;\n          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n        }\n        function constructYamlInteger(data) {\n          var value = data,\n            sign = 1,\n            ch,\n            base,\n            digits = [];\n          if (value.indexOf('_') !== -1) {\n            value = value.replace(/_/g, '');\n          }\n          ch = value[0];\n          if (ch === '-' || ch === '+') {\n            if (ch === '-') sign = -1;\n            value = value.slice(1);\n            ch = value[0];\n          }\n          if (value === '0') return 0;\n          if (ch === '0') {\n            if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n            if (value[1] === 'x') return sign * parseInt(value, 16);\n            return sign * parseInt(value, 8);\n          }\n          if (value.indexOf(':') !== -1) {\n            value.split(':').forEach(function (v) {\n              digits.unshift(parseInt(v, 10));\n            });\n            value = 0;\n            base = 1;\n            digits.forEach(function (d) {\n              value += d * base;\n              base *= 60;\n            });\n            return sign * value;\n          }\n          return sign * parseInt(value, 10);\n        }\n        function isInteger(object) {\n          return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n        }\n        module.exports = new Type('tag:yaml.org,2002:int', {\n          kind: 'scalar',\n          resolve: resolveYamlInteger,\n          construct: constructYamlInteger,\n          predicate: isInteger,\n          represent: {\n            binary: function (obj) {\n              return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n            },\n            octal: function (obj) {\n              return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);\n            },\n            decimal: function (obj) {\n              return obj.toString(10);\n            },\n            hexadecimal: function (obj) {\n              return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n            }\n          },\n          defaultStyle: 'decimal',\n          styleAliases: {\n            binary: [2, 'bin'],\n            octal: [8, 'oct'],\n            decimal: [10, 'dec'],\n            hexadecimal: [16, 'hex']\n          }\n        });\n      }, {\n        \"../common\": 5,\n        \"../type\": 16\n      }],\n      21: [function (require, module, exports) {\n        'use strict';\n\n        var esprima;\n        try {\n          var _require = require;\n          esprima = _require('esprima');\n        } catch (_) {\n          if (typeof window !== 'undefined') esprima = window.esprima;\n        }\n        var Type = require('../../type');\n        function resolveJavascriptFunction(data) {\n          if (data === null) return false;\n          try {\n            var source = '(' + data + ')',\n              ast = esprima.parse(source, {\n                range: true\n              });\n            if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n              return false;\n            }\n            return true;\n          } catch (err) {\n            return false;\n          }\n        }\n        function constructJavascriptFunction(data) {\n          var source = '(' + data + ')',\n            ast = esprima.parse(source, {\n              range: true\n            }),\n            params = [],\n            body;\n          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n            throw new Error('Failed to resolve function');\n          }\n          ast.body[0].expression.params.forEach(function (param) {\n            params.push(param.name);\n          });\n          body = ast.body[0].expression.body.range;\n          if (ast.body[0].expression.body.type === 'BlockStatement') {\n            return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n          }\n          return new Function(params, 'return ' + source.slice(body[0], body[1]));\n        }\n        function representJavascriptFunction(object /*, style*/) {\n          return object.toString();\n        }\n        function isFunction(object) {\n          return Object.prototype.toString.call(object) === '[object Function]';\n        }\n        module.exports = new Type('tag:yaml.org,2002:js/function', {\n          kind: 'scalar',\n          resolve: resolveJavascriptFunction,\n          construct: constructJavascriptFunction,\n          predicate: isFunction,\n          represent: representJavascriptFunction\n        });\n      }, {\n        \"../../type\": 16\n      }],\n      22: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../../type');\n        function resolveJavascriptRegExp(data) {\n          if (data === null) return false;\n          if (data.length === 0) return false;\n          var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = '';\n          if (regexp[0] === '/') {\n            if (tail) modifiers = tail[1];\n            if (modifiers.length > 3) return false;\n            if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n          }\n          return true;\n        }\n        function constructJavascriptRegExp(data) {\n          var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = '';\n          if (regexp[0] === '/') {\n            if (tail) modifiers = tail[1];\n            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n          }\n          return new RegExp(regexp, modifiers);\n        }\n        function representJavascriptRegExp(object /*, style*/) {\n          var result = '/' + object.source + '/';\n          if (object.global) result += 'g';\n          if (object.multiline) result += 'm';\n          if (object.ignoreCase) result += 'i';\n          return result;\n        }\n        function isRegExp(object) {\n          return Object.prototype.toString.call(object) === '[object RegExp]';\n        }\n        module.exports = new Type('tag:yaml.org,2002:js/regexp', {\n          kind: 'scalar',\n          resolve: resolveJavascriptRegExp,\n          construct: constructJavascriptRegExp,\n          predicate: isRegExp,\n          represent: representJavascriptRegExp\n        });\n      }, {\n        \"../../type\": 16\n      }],\n      23: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../../type');\n        function resolveJavascriptUndefined() {\n          return true;\n        }\n        function constructJavascriptUndefined() {\n          return undefined;\n        }\n        function representJavascriptUndefined() {\n          return '';\n        }\n        function isUndefined(object) {\n          return typeof object === 'undefined';\n        }\n        module.exports = new Type('tag:yaml.org,2002:js/undefined', {\n          kind: 'scalar',\n          resolve: resolveJavascriptUndefined,\n          construct: constructJavascriptUndefined,\n          predicate: isUndefined,\n          represent: representJavascriptUndefined\n        });\n      }, {\n        \"../../type\": 16\n      }],\n      24: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        module.exports = new Type('tag:yaml.org,2002:map', {\n          kind: 'mapping',\n          construct: function (data) {\n            return data !== null ? data : {};\n          }\n        });\n      }, {\n        \"../type\": 16\n      }],\n      25: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        function resolveYamlMerge(data) {\n          return data === '<<' || data === null;\n        }\n        module.exports = new Type('tag:yaml.org,2002:merge', {\n          kind: 'scalar',\n          resolve: resolveYamlMerge\n        });\n      }, {\n        \"../type\": 16\n      }],\n      26: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        function resolveYamlNull(data) {\n          if (data === null) return true;\n          var max = data.length;\n          return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n        }\n        function constructYamlNull() {\n          return null;\n        }\n        function isNull(object) {\n          return object === null;\n        }\n        module.exports = new Type('tag:yaml.org,2002:null', {\n          kind: 'scalar',\n          resolve: resolveYamlNull,\n          construct: constructYamlNull,\n          predicate: isNull,\n          represent: {\n            canonical: function () {\n              return '~';\n            },\n            lowercase: function () {\n              return 'null';\n            },\n            uppercase: function () {\n              return 'NULL';\n            },\n            camelcase: function () {\n              return 'Null';\n            }\n          },\n          defaultStyle: 'lowercase'\n        });\n      }, {\n        \"../type\": 16\n      }],\n      27: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        var _toString = Object.prototype.toString;\n        function resolveYamlOmap(data) {\n          if (data === null) return true;\n          var objectKeys = [],\n            index,\n            length,\n            pair,\n            pairKey,\n            pairHasKey,\n            object = data;\n          for (index = 0, length = object.length; index < length; index += 1) {\n            pair = object[index];\n            pairHasKey = false;\n            if (_toString.call(pair) !== '[object Object]') return false;\n            for (pairKey in pair) {\n              if (_hasOwnProperty.call(pair, pairKey)) {\n                if (!pairHasKey) pairHasKey = true;else return false;\n              }\n            }\n            if (!pairHasKey) return false;\n            if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n          }\n          return true;\n        }\n        function constructYamlOmap(data) {\n          return data !== null ? data : [];\n        }\n        module.exports = new Type('tag:yaml.org,2002:omap', {\n          kind: 'sequence',\n          resolve: resolveYamlOmap,\n          construct: constructYamlOmap\n        });\n      }, {\n        \"../type\": 16\n      }],\n      28: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var _toString = Object.prototype.toString;\n        function resolveYamlPairs(data) {\n          if (data === null) return true;\n          var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n          result = new Array(object.length);\n          for (index = 0, length = object.length; index < length; index += 1) {\n            pair = object[index];\n            if (_toString.call(pair) !== '[object Object]') return false;\n            keys = Object.keys(pair);\n            if (keys.length !== 1) return false;\n            result[index] = [keys[0], pair[keys[0]]];\n          }\n          return true;\n        }\n        function constructYamlPairs(data) {\n          if (data === null) return [];\n          var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n          result = new Array(object.length);\n          for (index = 0, length = object.length; index < length; index += 1) {\n            pair = object[index];\n            keys = Object.keys(pair);\n            result[index] = [keys[0], pair[keys[0]]];\n          }\n          return result;\n        }\n        module.exports = new Type('tag:yaml.org,2002:pairs', {\n          kind: 'sequence',\n          resolve: resolveYamlPairs,\n          construct: constructYamlPairs\n        });\n      }, {\n        \"../type\": 16\n      }],\n      29: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        module.exports = new Type('tag:yaml.org,2002:seq', {\n          kind: 'sequence',\n          construct: function (data) {\n            return data !== null ? data : [];\n          }\n        });\n      }, {\n        \"../type\": 16\n      }],\n      30: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var _hasOwnProperty = Object.prototype.hasOwnProperty;\n        function resolveYamlSet(data) {\n          if (data === null) return true;\n          var key,\n            object = data;\n          for (key in object) {\n            if (_hasOwnProperty.call(object, key)) {\n              if (object[key] !== null) return false;\n            }\n          }\n          return true;\n        }\n        function constructYamlSet(data) {\n          return data !== null ? data : {};\n        }\n        module.exports = new Type('tag:yaml.org,2002:set', {\n          kind: 'mapping',\n          resolve: resolveYamlSet,\n          construct: constructYamlSet\n        });\n      }, {\n        \"../type\": 16\n      }],\n      31: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        module.exports = new Type('tag:yaml.org,2002:str', {\n          kind: 'scalar',\n          construct: function (data) {\n            return data !== null ? data : '';\n          }\n        });\n      }, {\n        \"../type\": 16\n      }],\n      32: [function (require, module, exports) {\n        'use strict';\n\n        var Type = require('../type');\n        var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +\n        // [1] year\n        '-([0-9][0-9])' +\n        // [2] month\n        '-([0-9][0-9])$'); // [3] day\n\n        var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +\n        // [1] year\n        '-([0-9][0-9]?)' +\n        // [2] month\n        '-([0-9][0-9]?)' +\n        // [3] day\n        '(?:[Tt]|[ \\\\t]+)' +\n        // ...\n        '([0-9][0-9]?)' +\n        // [4] hour\n        ':([0-9][0-9])' +\n        // [5] minute\n        ':([0-9][0-9])' +\n        // [6] second\n        '(?:\\\\.([0-9]*))?' +\n        // [7] fraction\n        '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' +\n        // [8] tz [9] tz_sign [10] tz_hour\n        '(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\n        function resolveYamlTimestamp(data) {\n          if (data === null) return false;\n          if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n          return false;\n        }\n        function constructYamlTimestamp(data) {\n          var match,\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            fraction = 0,\n            delta = null,\n            tz_hour,\n            tz_minute,\n            date;\n          match = YAML_DATE_REGEXP.exec(data);\n          if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n          if (match === null) throw new Error('Date resolve error');\n          year = +match[1];\n          month = +match[2] - 1; // JS month starts with 0\n          day = +match[3];\n          if (!match[4]) {\n            // no hour\n            return new Date(Date.UTC(year, month, day));\n          }\n          hour = +match[4];\n          minute = +match[5];\n          second = +match[6];\n          if (match[7]) {\n            fraction = match[7].slice(0, 3);\n            while (fraction.length < 3) {\n              // milli-seconds\n              fraction += '0';\n            }\n            fraction = +fraction;\n          }\n          if (match[9]) {\n            tz_hour = +match[10];\n            tz_minute = +(match[11] || 0);\n            delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n            if (match[9] === '-') delta = -delta;\n          }\n          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n          if (delta) date.setTime(date.getTime() - delta);\n          return date;\n        }\n        function representYamlTimestamp(object /*, style*/) {\n          return object.toISOString();\n        }\n        module.exports = new Type('tag:yaml.org,2002:timestamp', {\n          kind: 'scalar',\n          resolve: resolveYamlTimestamp,\n          construct: constructYamlTimestamp,\n          instanceOf: Date,\n          represent: representYamlTimestamp\n        });\n      }, {\n        \"../type\": 16\n      }],\n      33: [function (require, module, exports) {\n        (function (global) {\n          var LARGE_ARRAY_SIZE = 200;\n          var HASH_UNDEFINED = '__lodash_hash_undefined__';\n          var HOT_COUNT = 800,\n            HOT_SPAN = 16;\n          var MAX_SAFE_INTEGER = 9007199254740991;\n          var argsTag = '[object Arguments]',\n            arrayTag = '[object Array]',\n            asyncTag = '[object AsyncFunction]',\n            boolTag = '[object Boolean]',\n            dateTag = '[object Date]',\n            errorTag = '[object Error]',\n            funcTag = '[object Function]',\n            genTag = '[object GeneratorFunction]',\n            mapTag = '[object Map]',\n            numberTag = '[object Number]',\n            nullTag = '[object Null]',\n            objectTag = '[object Object]',\n            proxyTag = '[object Proxy]',\n            regexpTag = '[object RegExp]',\n            setTag = '[object Set]',\n            stringTag = '[object String]',\n            undefinedTag = '[object Undefined]',\n            weakMapTag = '[object WeakMap]';\n          var arrayBufferTag = '[object ArrayBuffer]',\n            dataViewTag = '[object DataView]',\n            float32Tag = '[object Float32Array]',\n            float64Tag = '[object Float64Array]',\n            int8Tag = '[object Int8Array]',\n            int16Tag = '[object Int16Array]',\n            int32Tag = '[object Int32Array]',\n            uint8Tag = '[object Uint8Array]',\n            uint8ClampedTag = '[object Uint8ClampedArray]',\n            uint16Tag = '[object Uint16Array]',\n            uint32Tag = '[object Uint32Array]';\n          var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n          var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n          var reIsUint = /^(?:0|[1-9]\\d*)$/;\n          var typedArrayTags = {};\n          typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n          typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n          var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n          var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n          var root = freeGlobal || freeSelf || Function('return this')();\n          var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n          var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n          var moduleExports = freeModule && freeModule.exports === freeExports;\n          var freeProcess = moduleExports && freeGlobal.process;\n          var nodeUtil = function () {\n            try {\n              return freeProcess && freeProcess.binding && freeProcess.binding('util');\n            } catch (e) {}\n          }();\n          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n          function apply(func, thisArg, args) {\n            switch (args.length) {\n              case 0:\n                return func.call(thisArg);\n              case 1:\n                return func.call(thisArg, args[0]);\n              case 2:\n                return func.call(thisArg, args[0], args[1]);\n              case 3:\n                return func.call(thisArg, args[0], args[1], args[2]);\n            }\n            return func.apply(thisArg, args);\n          }\n          function baseTimes(n, iteratee) {\n            var index = -1,\n              result = Array(n);\n            while (++index < n) {\n              result[index] = iteratee(index);\n            }\n            return result;\n          }\n          function baseUnary(func) {\n            return function (value) {\n              return func(value);\n            };\n          }\n          function getValue(object, key) {\n            return object == null ? undefined : object[key];\n          }\n          function overArg(func, transform) {\n            return function (arg) {\n              return func(transform(arg));\n            };\n          }\n          function safeGet(object, key) {\n            return key == '__proto__' ? undefined : object[key];\n          }\n          var arrayProto = Array.prototype,\n            funcProto = Function.prototype,\n            objectProto = Object.prototype;\n          var coreJsData = root['__core-js_shared__'];\n          var funcToString = funcProto.toString;\n          var hasOwnProperty = objectProto.hasOwnProperty;\n          var maskSrcKey = function () {\n            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n            return uid ? 'Symbol(src)_1.' + uid : '';\n          }();\n          var nativeObjectToString = objectProto.toString;\n          var objectCtorString = funcToString.call(Object);\n          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n          var Buffer = moduleExports ? root.Buffer : undefined,\n            Symbol = root.Symbol,\n            Uint8Array = root.Uint8Array,\n            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n            getPrototype = overArg(Object.getPrototypeOf, Object),\n            objectCreate = Object.create,\n            propertyIsEnumerable = objectProto.propertyIsEnumerable,\n            splice = arrayProto.splice,\n            symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n          var defineProperty = function () {\n            try {\n              var func = getNative(Object, 'defineProperty');\n              func({}, '', {});\n              return func;\n            } catch (e) {}\n          }();\n          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n            nativeMax = Math.max,\n            nativeNow = Date.now;\n          var Map = getNative(root, 'Map'),\n            nativeCreate = getNative(Object, 'create');\n          var baseCreate = function () {\n            function object() {}\n            return function (proto) {\n              if (!isObject(proto)) {\n                return {};\n              }\n              if (objectCreate) {\n                return objectCreate(proto);\n              }\n              object.prototype = proto;\n              var result = new object();\n              object.prototype = undefined;\n              return result;\n            };\n          }();\n          function Hash(entries) {\n            var index = -1,\n              length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n              var entry = entries[index];\n              this.set(entry[0], entry[1]);\n            }\n          }\n          function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {};\n            this.size = 0;\n          }\n          function hashDelete(key) {\n            var result = this.has(key) && delete this.__data__[key];\n            this.size -= result ? 1 : 0;\n            return result;\n          }\n          function hashGet(key) {\n            var data = this.__data__;\n            if (nativeCreate) {\n              var result = data[key];\n              return result === HASH_UNDEFINED ? undefined : result;\n            }\n            return hasOwnProperty.call(data, key) ? data[key] : undefined;\n          }\n          function hashHas(key) {\n            var data = this.__data__;\n            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n          }\n          function hashSet(key, value) {\n            var data = this.__data__;\n            this.size += this.has(key) ? 0 : 1;\n            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n            return this;\n          }\n          Hash.prototype.clear = hashClear;\n          Hash.prototype['delete'] = hashDelete;\n          Hash.prototype.get = hashGet;\n          Hash.prototype.has = hashHas;\n          Hash.prototype.set = hashSet;\n          function ListCache(entries) {\n            var index = -1,\n              length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n              var entry = entries[index];\n              this.set(entry[0], entry[1]);\n            }\n          }\n          function listCacheClear() {\n            this.__data__ = [];\n            this.size = 0;\n          }\n          function listCacheDelete(key) {\n            var data = this.__data__,\n              index = assocIndexOf(data, key);\n            if (index < 0) {\n              return false;\n            }\n            var lastIndex = data.length - 1;\n            if (index == lastIndex) {\n              data.pop();\n            } else {\n              splice.call(data, index, 1);\n            }\n            --this.size;\n            return true;\n          }\n          function listCacheGet(key) {\n            var data = this.__data__,\n              index = assocIndexOf(data, key);\n            return index < 0 ? undefined : data[index][1];\n          }\n          function listCacheHas(key) {\n            return assocIndexOf(this.__data__, key) > -1;\n          }\n          function listCacheSet(key, value) {\n            var data = this.__data__,\n              index = assocIndexOf(data, key);\n            if (index < 0) {\n              ++this.size;\n              data.push([key, value]);\n            } else {\n              data[index][1] = value;\n            }\n            return this;\n          }\n          ListCache.prototype.clear = listCacheClear;\n          ListCache.prototype['delete'] = listCacheDelete;\n          ListCache.prototype.get = listCacheGet;\n          ListCache.prototype.has = listCacheHas;\n          ListCache.prototype.set = listCacheSet;\n          function MapCache(entries) {\n            var index = -1,\n              length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n              var entry = entries[index];\n              this.set(entry[0], entry[1]);\n            }\n          }\n          function mapCacheClear() {\n            this.size = 0;\n            this.__data__ = {\n              'hash': new Hash(),\n              'map': new (Map || ListCache)(),\n              'string': new Hash()\n            };\n          }\n          function mapCacheDelete(key) {\n            var result = getMapData(this, key)['delete'](key);\n            this.size -= result ? 1 : 0;\n            return result;\n          }\n          function mapCacheGet(key) {\n            return getMapData(this, key).get(key);\n          }\n          function mapCacheHas(key) {\n            return getMapData(this, key).has(key);\n          }\n          function mapCacheSet(key, value) {\n            var data = getMapData(this, key),\n              size = data.size;\n            data.set(key, value);\n            this.size += data.size == size ? 0 : 1;\n            return this;\n          }\n          MapCache.prototype.clear = mapCacheClear;\n          MapCache.prototype['delete'] = mapCacheDelete;\n          MapCache.prototype.get = mapCacheGet;\n          MapCache.prototype.has = mapCacheHas;\n          MapCache.prototype.set = mapCacheSet;\n          function Stack(entries) {\n            var data = this.__data__ = new ListCache(entries);\n            this.size = data.size;\n          }\n          function stackClear() {\n            this.__data__ = new ListCache();\n            this.size = 0;\n          }\n          function stackDelete(key) {\n            var data = this.__data__,\n              result = data['delete'](key);\n            this.size = data.size;\n            return result;\n          }\n          function stackGet(key) {\n            return this.__data__.get(key);\n          }\n          function stackHas(key) {\n            return this.__data__.has(key);\n          }\n          function stackSet(key, value) {\n            var data = this.__data__;\n            if (data instanceof ListCache) {\n              var pairs = data.__data__;\n              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([key, value]);\n                this.size = ++data.size;\n                return this;\n              }\n              data = this.__data__ = new MapCache(pairs);\n            }\n            data.set(key, value);\n            this.size = data.size;\n            return this;\n          }\n          Stack.prototype.clear = stackClear;\n          Stack.prototype['delete'] = stackDelete;\n          Stack.prototype.get = stackGet;\n          Stack.prototype.has = stackHas;\n          Stack.prototype.set = stackSet;\n          function arrayLikeKeys(value, inherited) {\n            var isArr = isArray(value),\n              isArg = !isArr && isArguments(value),\n              isBuff = !isArr && !isArg && isBuffer(value),\n              isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n              skipIndexes = isArr || isArg || isBuff || isType,\n              result = skipIndexes ? baseTimes(value.length, String) : [],\n              length = result.length;\n            for (var key in value) {\n              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {\n                result.push(key);\n              }\n            }\n            return result;\n          }\n          function assignMergeValue(object, key, value) {\n            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\n              baseAssignValue(object, key, value);\n            }\n          }\n          function assignValue(object, key, value) {\n            var objValue = object[key];\n            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n              baseAssignValue(object, key, value);\n            }\n          }\n          function assocIndexOf(array, key) {\n            var length = array.length;\n            while (length--) {\n              if (eq(array[length][0], key)) {\n                return length;\n              }\n            }\n            return -1;\n          }\n          function baseAssignValue(object, key, value) {\n            if (key == '__proto__' && defineProperty) {\n              defineProperty(object, key, {\n                'configurable': true,\n                'enumerable': true,\n                'value': value,\n                'writable': true\n              });\n            } else {\n              object[key] = value;\n            }\n          }\n          var baseFor = createBaseFor();\n          function baseGetTag(value) {\n            if (value == null) {\n              return value === undefined ? undefinedTag : nullTag;\n            }\n            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n          }\n          function baseIsArguments(value) {\n            return isObjectLike(value) && baseGetTag(value) == argsTag;\n          }\n          function baseIsNative(value) {\n            if (!isObject(value) || isMasked(value)) {\n              return false;\n            }\n            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n            return pattern.test(toSource(value));\n          }\n          function baseIsTypedArray(value) {\n            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n          }\n          function baseKeysIn(object) {\n            if (!isObject(object)) {\n              return nativeKeysIn(object);\n            }\n            var isProto = isPrototype(object),\n              result = [];\n            for (var key in object) {\n              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n                result.push(key);\n              }\n            }\n            return result;\n          }\n          function baseMerge(object, source, srcIndex, customizer, stack) {\n            if (object === source) {\n              return;\n            }\n            baseFor(source, function (srcValue, key) {\n              if (isObject(srcValue)) {\n                stack || (stack = new Stack());\n                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n              } else {\n                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;\n                if (newValue === undefined) {\n                  newValue = srcValue;\n                }\n                assignMergeValue(object, key, newValue);\n              }\n            }, keysIn);\n          }\n          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n            var objValue = safeGet(object, key),\n              srcValue = safeGet(source, key),\n              stacked = stack.get(srcValue);\n            if (stacked) {\n              assignMergeValue(object, key, stacked);\n              return;\n            }\n            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;\n            var isCommon = newValue === undefined;\n            if (isCommon) {\n              var isArr = isArray(srcValue),\n                isBuff = !isArr && isBuffer(srcValue),\n                isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n              newValue = srcValue;\n              if (isArr || isBuff || isTyped) {\n                if (isArray(objValue)) {\n                  newValue = objValue;\n                } else if (isArrayLikeObject(objValue)) {\n                  newValue = copyArray(objValue);\n                } else if (isBuff) {\n                  isCommon = false;\n                  newValue = cloneBuffer(srcValue, true);\n                } else if (isTyped) {\n                  isCommon = false;\n                  newValue = cloneTypedArray(srcValue, true);\n                } else {\n                  newValue = [];\n                }\n              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                newValue = objValue;\n                if (isArguments(objValue)) {\n                  newValue = toPlainObject(objValue);\n                } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {\n                  newValue = initCloneObject(srcValue);\n                }\n              } else {\n                isCommon = false;\n              }\n            }\n            if (isCommon) {\n              stack.set(srcValue, newValue);\n              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n              stack['delete'](srcValue);\n            }\n            assignMergeValue(object, key, newValue);\n          }\n          function baseRest(func, start) {\n            return setToString(overRest(func, start, identity), func + '');\n          }\n          var baseSetToString = !defineProperty ? identity : function (func, string) {\n            return defineProperty(func, 'toString', {\n              'configurable': true,\n              'enumerable': false,\n              'value': constant(string),\n              'writable': true\n            });\n          };\n          function cloneBuffer(buffer, isDeep) {\n            if (isDeep) {\n              return buffer.slice();\n            }\n            var length = buffer.length,\n              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n            buffer.copy(result);\n            return result;\n          }\n          function cloneArrayBuffer(arrayBuffer) {\n            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n            new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n            return result;\n          }\n          function cloneTypedArray(typedArray, isDeep) {\n            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n          }\n          function copyArray(source, array) {\n            var index = -1,\n              length = source.length;\n            array || (array = Array(length));\n            while (++index < length) {\n              array[index] = source[index];\n            }\n            return array;\n          }\n          function copyObject(source, props, object, customizer) {\n            var isNew = !object;\n            object || (object = {});\n            var index = -1,\n              length = props.length;\n            while (++index < length) {\n              var key = props[index];\n              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n              if (newValue === undefined) {\n                newValue = source[key];\n              }\n              if (isNew) {\n                baseAssignValue(object, key, newValue);\n              } else {\n                assignValue(object, key, newValue);\n              }\n            }\n            return object;\n          }\n          function createAssigner(assigner) {\n            return baseRest(function (object, sources) {\n              var index = -1,\n                length = sources.length,\n                customizer = length > 1 ? sources[length - 1] : undefined,\n                guard = length > 2 ? sources[2] : undefined;\n              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;\n              if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                customizer = length < 3 ? undefined : customizer;\n                length = 1;\n              }\n              object = Object(object);\n              while (++index < length) {\n                var source = sources[index];\n                if (source) {\n                  assigner(object, source, index, customizer);\n                }\n              }\n              return object;\n            });\n          }\n          function createBaseFor(fromRight) {\n            return function (object, iteratee, keysFunc) {\n              var index = -1,\n                iterable = Object(object),\n                props = keysFunc(object),\n                length = props.length;\n              while (length--) {\n                var key = props[fromRight ? length : ++index];\n                if (iteratee(iterable[key], key, iterable) === false) {\n                  break;\n                }\n              }\n              return object;\n            };\n          }\n          function getMapData(map, key) {\n            var data = map.__data__;\n            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n          }\n          function getNative(object, key) {\n            var value = getValue(object, key);\n            return baseIsNative(value) ? value : undefined;\n          }\n          function getRawTag(value) {\n            var isOwn = hasOwnProperty.call(value, symToStringTag),\n              tag = value[symToStringTag];\n            try {\n              value[symToStringTag] = undefined;\n              var unmasked = true;\n            } catch (e) {}\n            var result = nativeObjectToString.call(value);\n            if (unmasked) {\n              if (isOwn) {\n                value[symToStringTag] = tag;\n              } else {\n                delete value[symToStringTag];\n              }\n            }\n            return result;\n          }\n          function initCloneObject(object) {\n            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\n          }\n          function isIndex(value, length) {\n            var type = typeof value;\n            length = length == null ? MAX_SAFE_INTEGER : length;\n            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n          }\n          function isIterateeCall(value, index, object) {\n            if (!isObject(object)) {\n              return false;\n            }\n            var type = typeof index;\n            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n              return eq(object[index], value);\n            }\n            return false;\n          }\n          function isKeyable(value) {\n            var type = typeof value;\n            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n          }\n          function isMasked(func) {\n            return !!maskSrcKey && maskSrcKey in func;\n          }\n          function isPrototype(value) {\n            var Ctor = value && value.constructor,\n              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n            return value === proto;\n          }\n          function nativeKeysIn(object) {\n            var result = [];\n            if (object != null) {\n              for (var key in Object(object)) {\n                result.push(key);\n              }\n            }\n            return result;\n          }\n          function objectToString(value) {\n            return nativeObjectToString.call(value);\n          }\n          function overRest(func, start, transform) {\n            start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n            return function () {\n              var args = arguments,\n                index = -1,\n                length = nativeMax(args.length - start, 0),\n                array = Array(length);\n              while (++index < length) {\n                array[index] = args[start + index];\n              }\n              index = -1;\n              var otherArgs = Array(start + 1);\n              while (++index < start) {\n                otherArgs[index] = args[index];\n              }\n              otherArgs[start] = transform(array);\n              return apply(func, this, otherArgs);\n            };\n          }\n          var setToString = shortOut(baseSetToString);\n          function shortOut(func) {\n            var count = 0,\n              lastCalled = 0;\n            return function () {\n              var stamp = nativeNow(),\n                remaining = HOT_SPAN - (stamp - lastCalled);\n              lastCalled = stamp;\n              if (remaining > 0) {\n                if (++count >= HOT_COUNT) {\n                  return arguments[0];\n                }\n              } else {\n                count = 0;\n              }\n              return func.apply(undefined, arguments);\n            };\n          }\n          function toSource(func) {\n            if (func != null) {\n              try {\n                return funcToString.call(func);\n              } catch (e) {}\n              try {\n                return func + '';\n              } catch (e) {}\n            }\n            return '';\n          }\n          function eq(value, other) {\n            return value === other || value !== value && other !== other;\n          }\n          var isArguments = baseIsArguments(function () {\n            return arguments;\n          }()) ? baseIsArguments : function (value) {\n            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n          };\n          var isArray = Array.isArray;\n          function isArrayLike(value) {\n            return value != null && isLength(value.length) && !isFunction(value);\n          }\n          function isArrayLikeObject(value) {\n            return isObjectLike(value) && isArrayLike(value);\n          }\n          var isBuffer = nativeIsBuffer || stubFalse;\n          function isFunction(value) {\n            if (!isObject(value)) {\n              return false;\n            }\n            var tag = baseGetTag(value);\n            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n          }\n          function isLength(value) {\n            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n          }\n          function isObject(value) {\n            var type = typeof value;\n            return value != null && (type == 'object' || type == 'function');\n          }\n          function isObjectLike(value) {\n            return value != null && typeof value == 'object';\n          }\n          function isPlainObject(value) {\n            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n              return false;\n            }\n            var proto = getPrototype(value);\n            if (proto === null) {\n              return true;\n            }\n            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n          }\n          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n          function toPlainObject(value) {\n            return copyObject(value, keysIn(value));\n          }\n          function keysIn(object) {\n            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n          }\n          var merge = createAssigner(function (object, source, srcIndex) {\n            baseMerge(object, source, srcIndex);\n          });\n          function constant(value) {\n            return function () {\n              return value;\n            };\n          }\n          function identity(value) {\n            return value;\n          }\n          function stubFalse() {\n            return false;\n          }\n          module.exports = merge;\n        }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n      }, {}]\n    }, {}, [2])(2);\n  });\n});\nace.define(\"ace/mode/yaml_worker\", [], function (require, exports) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var Mirror = require(\"../worker/mirror\").Mirror;\n  var lint = require(\"./yaml/yaml-lint\").lint;\n  var YamlWorker = exports.YamlWorker = function (sender) {\n    Mirror.call(this, sender);\n    this.setTimeout(500);\n    this.setOptions();\n  };\n  oop.inherits(YamlWorker, Mirror);\n  (function () {\n    this.setOptions = function () {\n      this.doc.getValue() && this.deferredUpdate.schedule(100);\n    };\n    this.changeOptions = function (newOptions) {\n      oop.mixin(this.options, newOptions);\n      this.doc.getValue() && this.deferredUpdate.schedule(100);\n    };\n    this.onUpdate = function () {\n      var _this = this;\n      var value = this.doc.getValue();\n      var errors = [];\n      lint(value, {}, function (error) {\n        if (!error) {\n          _this.sender.emit(\"annotate\", errors);\n          return;\n        }\n        var markDefined = !!error.mark;\n        errors.push({\n          row: markDefined ? error.mark.line : 0,\n          column: markDefined ? error.mark.column : 0,\n          text: error.reason,\n          type: 'error',\n          raw: error\n        });\n        _this.sender.emit(\"annotate\", errors);\n      });\n    };\n  }).call(YamlWorker.prototype);\n});"}